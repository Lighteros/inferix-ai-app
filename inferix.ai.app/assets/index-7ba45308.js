true &&
  (function polyfill() {
    const relList = document.createElement("link").relList;
    if (relList && relList.supports && relList.supports("modulepreload")) {
      return;
    }
    for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
      processPreload(link);
    }
    new MutationObserver((mutations) => {
      for (const mutation of mutations) {
        if (mutation.type !== "childList") {
          continue;
        }
        for (const node of mutation.addedNodes) {
          if (node.tagName === "LINK" && node.rel === "modulepreload")
            processPreload(node);
        }
      }
    }).observe(document, { childList: true, subtree: true });
    function getFetchOpts(link) {
      const fetchOpts = {};
      if (link.integrity) fetchOpts.integrity = link.integrity;
      if (link.referrerPolicy) fetchOpts.referrerPolicy = link.referrerPolicy;
      if (link.crossOrigin === "use-credentials")
        fetchOpts.credentials = "include";
      else if (link.crossOrigin === "anonymous") fetchOpts.credentials = "omit";
      else fetchOpts.credentials = "same-origin";
      return fetchOpts;
    }
    function processPreload(link) {
      if (link.ep)
        // ep marker = processed
        return;
      link.ep = true;
      // prepopulate the load record
      const fetchOpts = getFetchOpts(link);
      fetch(link.href, fetchOpts);
    }
  })();

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x) =>
  typeof require !== "undefined"
    ? require
    : typeof Proxy !== "undefined"
    ? new Proxy(x, {
        get: (a, b) => (typeof require !== "undefined" ? require : a)[b],
      })
    : x)(function (x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __esm = (fn, res) =>
  function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])((fn = 0))), res;
  };
var __commonJS = (cb, mod) =>
  function __require2() {
    return (
      mod ||
        (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod),
      mod.exports
    );
  };
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if ((from && typeof from === "object") || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, {
          get: () => from[key],
          enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable,
        });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (
  (target = mod != null ? __create(__getProtoOf(mod)) : {}),
  __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule
      ? __defProp(target, "default", { value: mod, enumerable: true })
      : target,
    mod
  )
);
var __toCommonJS = (mod) =>
  __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/@vue/shared/dist/shared.esm-bundler.js
var shared_esm_bundler_exports = {};
__export(shared_esm_bundler_exports, {
  EMPTY_ARR: () => EMPTY_ARR,
  EMPTY_OBJ: () => EMPTY_OBJ,
  NO: () => NO,
  NOOP: () => NOOP,
  PatchFlagNames: () => PatchFlagNames,
  camelize: () => camelize,
  capitalize: () => capitalize,
  def: () => def,
  escapeHtml: () => escapeHtml,
  escapeHtmlComment: () => escapeHtmlComment,
  extend: () => extend,
  generateCodeFrame: () => generateCodeFrame,
  getGlobalThis: () => getGlobalThis,
  hasChanged: () => hasChanged,
  hasOwn: () => hasOwn,
  hyphenate: () => hyphenate,
  includeBooleanAttr: () => includeBooleanAttr,
  invokeArrayFns: () => invokeArrayFns,
  isArray: () => isArray,
  isBooleanAttr: () => isBooleanAttr,
  isBuiltInDirective: () => isBuiltInDirective,
  isDate: () => isDate$1,
  isFunction: () => isFunction$1,
  isGloballyWhitelisted: () => isGloballyWhitelisted,
  isHTMLTag: () => isHTMLTag,
  isIntegerKey: () => isIntegerKey,
  isKnownHtmlAttr: () => isKnownHtmlAttr,
  isKnownSvgAttr: () => isKnownSvgAttr,
  isMap: () => isMap,
  isModelListener: () => isModelListener,
  isNoUnitNumericStyleProp: () => isNoUnitNumericStyleProp,
  isObject: () => isObject$f,
  isOn: () => isOn,
  isPlainObject: () => isPlainObject$1,
  isPromise: () => isPromise,
  isReservedProp: () => isReservedProp,
  isSSRSafeAttrName: () => isSSRSafeAttrName,
  isSVGTag: () => isSVGTag,
  isSet: () => isSet,
  isSpecialBooleanAttr: () => isSpecialBooleanAttr,
  isString: () => isString$1,
  isSymbol: () => isSymbol$6,
  isVoidTag: () => isVoidTag,
  looseEqual: () => looseEqual,
  looseIndexOf: () => looseIndexOf,
  makeMap: () => makeMap,
  normalizeClass: () => normalizeClass,
  normalizeProps: () => normalizeProps,
  normalizeStyle: () => normalizeStyle,
  objectToString: () => objectToString,
  parseStringStyle: () => parseStringStyle,
  propsToAttrMap: () => propsToAttrMap,
  remove: () => remove,
  slotFlagsText: () => slotFlagsText,
  stringifyStyle: () => stringifyStyle,
  toDisplayString: () => toDisplayString,
  toHandlerKey: () => toHandlerKey,
  toNumber: () => toNumber,
  toRawType: () => toRawType,
  toTypeString: () => toTypeString,
});
function makeMap(str, expectsLowerCase) {
  const map2 = /* @__PURE__ */ Object.create(null);
  const list = str.split(",");
  for (let i = 0; i < list.length; i++) {
    map2[list[i]] = true;
  }
  return expectsLowerCase
    ? (val) => !!map2[val.toLowerCase()]
    : (val) => !!map2[val];
}
function generateCodeFrame(source, start = 0, end = source.length) {
  let lines = source.split(/(\r?\n)/);
  const newlineSequences = lines.filter((_, idx) => idx % 2 === 1);
  lines = lines.filter((_, idx) => idx % 2 === 0);
  let count = 0;
  const res = [];
  for (let i = 0; i < lines.length; i++) {
    count +=
      lines[i].length +
      ((newlineSequences[i] && newlineSequences[i].length) || 0);
    if (count >= start) {
      for (let j = i - range; j <= i + range || end > count; j++) {
        if (j < 0 || j >= lines.length) continue;
        const line = j + 1;
        res.push(
          `${line}${" ".repeat(Math.max(3 - String(line).length, 0))}|  ${
            lines[j]
          }`
        );
        const lineLength = lines[j].length;
        const newLineSeqLength =
          (newlineSequences[j] && newlineSequences[j].length) || 0;
        if (j === i) {
          const pad = start - (count - (lineLength + newLineSeqLength));
          const length = Math.max(
            1,
            end > count ? lineLength - pad : end - start
          );
          res.push(`   |  ` + " ".repeat(pad) + "^".repeat(length));
        } else if (j > i) {
          if (end > count) {
            const length = Math.max(Math.min(end - count, lineLength), 1);
            res.push(`   |  ` + "^".repeat(length));
          }
          count += lineLength + newLineSeqLength;
        }
      }
      break;
    }
  }
  return res.join("\n");
}
function includeBooleanAttr(value) {
  return !!value || value === "";
}
function isSSRSafeAttrName(name) {
  if (attrValidationCache.hasOwnProperty(name)) {
    return attrValidationCache[name];
  }
  const isUnsafe = unsafeAttrCharRE.test(name);
  if (isUnsafe) {
    console.error(`unsafe attribute name: ${name}`);
  }
  return (attrValidationCache[name] = !isUnsafe);
}
function normalizeStyle(value) {
  if (isArray(value)) {
    const res = {};
    for (let i = 0; i < value.length; i++) {
      const item = value[i];
      const normalized = isString$1(item)
        ? parseStringStyle(item)
        : normalizeStyle(item);
      if (normalized) {
        for (const key in normalized) {
          res[key] = normalized[key];
        }
      }
    }
    return res;
  } else if (isString$1(value)) {
    return value;
  } else if (isObject$f(value)) {
    return value;
  }
}
function parseStringStyle(cssText) {
  const ret = {};
  cssText.split(listDelimiterRE).forEach((item) => {
    if (item) {
      const tmp = item.split(propertyDelimiterRE);
      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return ret;
}
function stringifyStyle(styles) {
  let ret = "";
  if (!styles || isString$1(styles)) {
    return ret;
  }
  for (const key in styles) {
    const value = styles[key];
    const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key);
    if (
      isString$1(value) ||
      (typeof value === "number" && isNoUnitNumericStyleProp(normalizedKey))
    ) {
      ret += `${normalizedKey}:${value};`;
    }
  }
  return ret;
}
function normalizeClass(value) {
  let res = "";
  if (isString$1(value)) {
    res = value;
  } else if (isArray(value)) {
    for (let i = 0; i < value.length; i++) {
      const normalized = normalizeClass(value[i]);
      if (normalized) {
        res += normalized + " ";
      }
    }
  } else if (isObject$f(value)) {
    for (const name in value) {
      if (value[name]) {
        res += name + " ";
      }
    }
  }
  return res.trim();
}
function normalizeProps(props) {
  if (!props) return null;
  let { class: klass, style } = props;
  if (klass && !isString$1(klass)) {
    props.class = normalizeClass(klass);
  }
  if (style) {
    props.style = normalizeStyle(style);
  }
  return props;
}
function escapeHtml(string) {
  const str = "" + string;
  const match = escapeRE.exec(str);
  if (!match) {
    return str;
  }
  let html = "";
  let escaped;
  let index;
  let lastIndex = 0;
  for (index = match.index; index < str.length; index++) {
    switch (str.charCodeAt(index)) {
      case 34:
        escaped = "&quot;";
        break;
      case 38:
        escaped = "&amp;";
        break;
      case 39:
        escaped = "&#39;";
        break;
      case 60:
        escaped = "&lt;";
        break;
      case 62:
        escaped = "&gt;";
        break;
      default:
        continue;
    }
    if (lastIndex !== index) {
      html += str.slice(lastIndex, index);
    }
    lastIndex = index + 1;
    html += escaped;
  }
  return lastIndex !== index ? html + str.slice(lastIndex, index) : html;
}
function escapeHtmlComment(src) {
  return src.replace(commentStripRE, "");
}
function looseCompareArrays(a, b) {
  if (a.length !== b.length) return false;
  let equal = true;
  for (let i = 0; equal && i < a.length; i++) {
    equal = looseEqual(a[i], b[i]);
  }
  return equal;
}
function looseEqual(a, b) {
  if (a === b) return true;
  let aValidType = isDate$1(a);
  let bValidType = isDate$1(b);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? a.getTime() === b.getTime() : false;
  }
  aValidType = isArray(a);
  bValidType = isArray(b);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? looseCompareArrays(a, b) : false;
  }
  aValidType = isObject$f(a);
  bValidType = isObject$f(b);
  if (aValidType || bValidType) {
    if (!aValidType || !bValidType) {
      return false;
    }
    const aKeysCount = Object.keys(a).length;
    const bKeysCount = Object.keys(b).length;
    if (aKeysCount !== bKeysCount) {
      return false;
    }
    for (const key in a) {
      const aHasKey = a.hasOwnProperty(key);
      const bHasKey = b.hasOwnProperty(key);
      if (
        (aHasKey && !bHasKey) ||
        (!aHasKey && bHasKey) ||
        !looseEqual(a[key], b[key])
      ) {
        return false;
      }
    }
  }
  return String(a) === String(b);
}
function looseIndexOf(arr, val) {
  return arr.findIndex((item) => looseEqual(item, val));
}
var PatchFlagNames,
  slotFlagsText,
  GLOBALS_WHITE_LISTED,
  isGloballyWhitelisted,
  range,
  specialBooleanAttrs,
  isSpecialBooleanAttr,
  isBooleanAttr,
  unsafeAttrCharRE,
  attrValidationCache,
  propsToAttrMap,
  isNoUnitNumericStyleProp,
  isKnownHtmlAttr,
  isKnownSvgAttr,
  listDelimiterRE,
  propertyDelimiterRE,
  HTML_TAGS,
  SVG_TAGS,
  VOID_TAGS,
  isHTMLTag,
  isSVGTag,
  isVoidTag,
  escapeRE,
  commentStripRE,
  toDisplayString,
  replacer,
  EMPTY_OBJ,
  EMPTY_ARR,
  NOOP,
  NO,
  onRE,
  isOn,
  isModelListener,
  extend,
  remove,
  hasOwnProperty$5,
  hasOwn,
  isArray,
  isMap,
  isSet,
  isDate$1,
  isFunction$1,
  isString$1,
  isSymbol$6,
  isObject$f,
  isPromise,
  objectToString,
  toTypeString,
  toRawType,
  isPlainObject$1,
  isIntegerKey,
  isReservedProp,
  isBuiltInDirective,
  cacheStringFunction$1,
  camelizeRE$1,
  camelize,
  hyphenateRE,
  hyphenate,
  capitalize,
  toHandlerKey,
  hasChanged,
  invokeArrayFns,
  def,
  toNumber,
  _globalThis,
  getGlobalThis;
var init_shared_esm_bundler = __esm({
  "node_modules/@vue/shared/dist/shared.esm-bundler.js"() {
    PatchFlagNames = {
      [1]:
        /* TEXT */
        `TEXT`,
      [2]:
        /* CLASS */
        `CLASS`,
      [4]:
        /* STYLE */
        `STYLE`,
      [8]:
        /* PROPS */
        `PROPS`,
      [16]:
        /* FULL_PROPS */
        `FULL_PROPS`,
      [32]:
        /* HYDRATE_EVENTS */
        `HYDRATE_EVENTS`,
      [64]:
        /* STABLE_FRAGMENT */
        `STABLE_FRAGMENT`,
      [128]:
        /* KEYED_FRAGMENT */
        `KEYED_FRAGMENT`,
      [256]:
        /* UNKEYED_FRAGMENT */
        `UNKEYED_FRAGMENT`,
      [512]:
        /* NEED_PATCH */
        `NEED_PATCH`,
      [1024]:
        /* DYNAMIC_SLOTS */
        `DYNAMIC_SLOTS`,
      [2048]:
        /* DEV_ROOT_FRAGMENT */
        `DEV_ROOT_FRAGMENT`,
      [-1]:
        /* HOISTED */
        `HOISTED`,
      [-2]:
        /* BAIL */
        `BAIL`,
    };
    slotFlagsText = {
      [1]:
        /* STABLE */
        "STABLE",
      [2]:
        /* DYNAMIC */
        "DYNAMIC",
      [3]:
        /* FORWARDED */
        "FORWARDED",
    };
    GLOBALS_WHITE_LISTED =
      "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt";
    isGloballyWhitelisted = /* @__PURE__ */ makeMap(GLOBALS_WHITE_LISTED);
    range = 2;
    specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
    isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
    isBooleanAttr = /* @__PURE__ */ makeMap(
      specialBooleanAttrs +
        `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected`
    );
    unsafeAttrCharRE = /[>/="'\u0009\u000a\u000c\u0020]/;
    attrValidationCache = {};
    propsToAttrMap = {
      acceptCharset: "accept-charset",
      className: "class",
      htmlFor: "for",
      httpEquiv: "http-equiv",
    };
    isNoUnitNumericStyleProp = /* @__PURE__ */ makeMap(
      `animation-iteration-count,border-image-outset,border-image-slice,border-image-width,box-flex,box-flex-group,box-ordinal-group,column-count,columns,flex,flex-grow,flex-positive,flex-shrink,flex-negative,flex-order,grid-row,grid-row-end,grid-row-span,grid-row-start,grid-column,grid-column-end,grid-column-span,grid-column-start,font-weight,line-clamp,line-height,opacity,order,orphans,tab-size,widows,z-index,zoom,fill-opacity,flood-opacity,stop-opacity,stroke-dasharray,stroke-dashoffset,stroke-miterlimit,stroke-opacity,stroke-width`
    );
    isKnownHtmlAttr = /* @__PURE__ */ makeMap(
      `accept,accept-charset,accesskey,action,align,allow,alt,async,autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,border,buffered,capture,challenge,charset,checked,cite,class,code,codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,formaction,formenctype,formmethod,formnovalidate,formtarget,headers,height,hidden,high,href,hreflang,http-equiv,icon,id,importance,integrity,ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,target,title,translate,type,usemap,value,width,wrap`
    );
    isKnownSvgAttr = /* @__PURE__ */ makeMap(
      `xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,color-interpolation-filters,color-profile,color-rendering,contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,font-family,font-size,font-size-adjust,font-stretch,font-style,font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,overflow,overline-position,overline-thickness,panose-1,paint-order,path,pathLength,patternContentUnits,patternTransform,patternUnits,ping,pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,specularConstant,specularExponent,speed,spreadMethod,startOffset,stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,string,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,text-decoration,text-rendering,textLength,to,transform,transform-origin,type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xml:base,xml:lang,xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`
    );
    listDelimiterRE = /;(?![^(]*\))/g;
    propertyDelimiterRE = /:(.+)/;
    HTML_TAGS =
      "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot";
    SVG_TAGS =
      "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view";
    VOID_TAGS =
      "area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr";
    isHTMLTag = /* @__PURE__ */ makeMap(HTML_TAGS);
    isSVGTag = /* @__PURE__ */ makeMap(SVG_TAGS);
    isVoidTag = /* @__PURE__ */ makeMap(VOID_TAGS);
    escapeRE = /["'&<>]/;
    commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;
    toDisplayString = (val) => {
      return isString$1(val)
        ? val
        : val == null
        ? ""
        : isArray(val) ||
          (isObject$f(val) &&
            (val.toString === objectToString || !isFunction$1(val.toString)))
        ? JSON.stringify(val, replacer, 2)
        : String(val);
    };
    replacer = (_key, val) => {
      if (val && val.__v_isRef) {
        return replacer(_key, val.value);
      } else if (isMap(val)) {
        return {
          [`Map(${val.size})`]: [...val.entries()].reduce(
            (entries, [key, val2]) => {
              entries[`${key} =>`] = val2;
              return entries;
            },
            {}
          ),
        };
      } else if (isSet(val)) {
        return {
          [`Set(${val.size})`]: [...val.values()],
        };
      } else if (isObject$f(val) && !isArray(val) && !isPlainObject$1(val)) {
        return String(val);
      }
      return val;
    };
    EMPTY_OBJ = {};
    EMPTY_ARR = [];
    NOOP = () => {};
    NO = () => false;
    onRE = /^on[^a-z]/;
    isOn = (key) => onRE.test(key);
    isModelListener = (key) => key.startsWith("onUpdate:");
    extend = Object.assign;
    remove = (arr, el) => {
      const i = arr.indexOf(el);
      if (i > -1) {
        arr.splice(i, 1);
      }
    };
    hasOwnProperty$5 = Object.prototype.hasOwnProperty;
    hasOwn = (val, key) => hasOwnProperty$5.call(val, key);
    isArray = Array.isArray;
    isMap = (val) => toTypeString(val) === "[object Map]";
    isSet = (val) => toTypeString(val) === "[object Set]";
    isDate$1 = (val) => val instanceof Date;
    isFunction$1 = (val) => typeof val === "function";
    isString$1 = (val) => typeof val === "string";
    isSymbol$6 = (val) => typeof val === "symbol";
    isObject$f = (val) => val !== null && typeof val === "object";
    isPromise = (val) => {
      return (
        isObject$f(val) && isFunction$1(val.then) && isFunction$1(val.catch)
      );
    };
    objectToString = Object.prototype.toString;
    toTypeString = (value) => objectToString.call(value);
    toRawType = (value) => {
      return toTypeString(value).slice(8, -1);
    };
    isPlainObject$1 = (val) => toTypeString(val) === "[object Object]";
    isIntegerKey = (key) =>
      isString$1(key) &&
      key !== "NaN" &&
      key[0] !== "-" &&
      "" + parseInt(key, 10) === key;
    isReservedProp = /* @__PURE__ */ makeMap(
      // the leading comma is intentional so empty string "" is also included
      ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
    );
    isBuiltInDirective = /* @__PURE__ */ makeMap(
      "bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo"
    );
    cacheStringFunction$1 = (fn) => {
      const cache = /* @__PURE__ */ Object.create(null);
      return (str) => {
        const hit = cache[str];
        return hit || (cache[str] = fn(str));
      };
    };
    camelizeRE$1 = /-(\w)/g;
    camelize = cacheStringFunction$1((str) => {
      return str.replace(camelizeRE$1, (_, c) => (c ? c.toUpperCase() : ""));
    });
    hyphenateRE = /\B([A-Z])/g;
    hyphenate = cacheStringFunction$1((str) =>
      str.replace(hyphenateRE, "-$1").toLowerCase()
    );
    capitalize = cacheStringFunction$1(
      (str) => str.charAt(0).toUpperCase() + str.slice(1)
    );
    toHandlerKey = cacheStringFunction$1((str) =>
      str ? `on${capitalize(str)}` : ``
    );
    hasChanged = (value, oldValue) => !Object.is(value, oldValue);
    invokeArrayFns = (fns, arg) => {
      for (let i = 0; i < fns.length; i++) {
        fns[i](arg);
      }
    };
    def = (obj, key, value) => {
      Object.defineProperty(obj, key, {
        configurable: true,
        enumerable: false,
        value,
      });
    };
    toNumber = (val) => {
      const n = parseFloat(val);
      return isNaN(n) ? val : n;
    };
    getGlobalThis = () => {
      return (
        _globalThis ||
        (_globalThis =
          typeof globalThis !== "undefined"
            ? globalThis
            : typeof self !== "undefined"
            ? self
            : typeof window !== "undefined"
            ? window
            : typeof global !== "undefined"
            ? global
            : {})
      );
    };
  },
});
function effectScope(detached) {
  return new EffectScope(detached);
}
function recordEffectScope(effect2, scope = activeEffectScope) {
  if (scope && scope.active) {
    scope.effects.push(effect2);
  }
}
function getCurrentScope() {
  return activeEffectScope;
}
function onScopeDispose(fn) {
  if (activeEffectScope) {
    activeEffectScope.cleanups.push(fn);
  }
}
function cleanupEffect(effect2) {
  const { deps } = effect2;
  if (deps.length) {
    for (let i = 0; i < deps.length; i++) {
      deps[i].delete(effect2);
    }
    deps.length = 0;
  }
}
function effect$3(fn, options) {
  if (fn.effect) {
    fn = fn.effect.fn;
  }
  const _effect = new ReactiveEffect(fn);
  if (options) {
    extend(_effect, options);
    if (options.scope) recordEffectScope(_effect, options.scope);
  }
  if (!options || !options.lazy) {
    _effect.run();
  }
  const runner = _effect.run.bind(_effect);
  runner.effect = _effect;
  return runner;
}
function stop(runner) {
  runner.effect.stop();
}
function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}
function resetTracking() {
  const last = trackStack.pop();
  shouldTrack = last === void 0 ? true : last;
}
function track(target, type, key) {
  if (shouldTrack && activeEffect) {
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      targetMap.set(target, (depsMap = /* @__PURE__ */ new Map()));
    }
    let dep = depsMap.get(key);
    if (!dep) {
      depsMap.set(key, (dep = createDep()));
    }
    trackEffects(dep);
  }
}
function trackEffects(dep, debuggerEventExtraInfo) {
  let shouldTrack2 = false;
  if (effectTrackDepth <= maxMarkerBits) {
    if (!newTracked(dep)) {
      dep.n |= trackOpBit;
      shouldTrack2 = !wasTracked(dep);
    }
  } else {
    shouldTrack2 = !dep.has(activeEffect);
  }
  if (shouldTrack2) {
    dep.add(activeEffect);
    activeEffect.deps.push(dep);
  }
}
function trigger(target, type, key, newValue, oldValue, oldTarget) {
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    return;
  }
  let deps = [];
  if (type === "clear") {
    deps = [...depsMap.values()];
  } else if (key === "length" && isArray(target)) {
    depsMap.forEach((dep, key2) => {
      if (key2 === "length" || key2 >= newValue) {
        deps.push(dep);
      }
    });
  } else {
    if (key !== void 0) {
      deps.push(depsMap.get(key));
    }
    switch (type) {
      case "add":
        if (!isArray(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        } else if (isIntegerKey(key)) {
          deps.push(depsMap.get("length"));
        }
        break;
      case "delete":
        if (!isArray(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        }
        break;
      case "set":
        if (isMap(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
        }
        break;
    }
  }
  if (deps.length === 1) {
    if (deps[0]) {
      {
        triggerEffects(deps[0]);
      }
    }
  } else {
    const effects = [];
    for (const dep of deps) {
      if (dep) {
        effects.push(...dep);
      }
    }
    {
      triggerEffects(createDep(effects));
    }
  }
}
function triggerEffects(dep, debuggerEventExtraInfo) {
  for (const effect2 of isArray(dep) ? dep : [...dep]) {
    if (effect2 !== activeEffect || effect2.allowRecurse) {
      if (effect2.scheduler) {
        effect2.scheduler();
      } else {
        effect2.run();
      }
    }
  }
}
function createArrayInstrumentations() {
  const instrumentations = {};
  ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
    instrumentations[key] = function (...args) {
      const arr = toRaw(this);
      for (let i = 0, l = this.length; i < l; i++) {
        track(arr, "get", i + "");
      }
      const res = arr[key](...args);
      if (res === -1 || res === false) {
        return arr[key](...args.map(toRaw));
      } else {
        return res;
      }
    };
  });
  ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
    instrumentations[key] = function (...args) {
      pauseTracking();
      const res = toRaw(this)[key].apply(this, args);
      resetTracking();
      return res;
    };
  });
  return instrumentations;
}
function createGetter(isReadonly2 = false, shallow = false) {
  return function get2(target, key, receiver) {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_isShallow") {
      return shallow;
    } else if (
      key === "__v_raw" &&
      receiver ===
        (isReadonly2
          ? shallow
            ? shallowReadonlyMap
            : readonlyMap
          : shallow
          ? shallowReactiveMap
          : reactiveMap
        ).get(target)
    ) {
      return target;
    }
    const targetIsArray = isArray(target);
    if (!isReadonly2 && targetIsArray && hasOwn(arrayInstrumentations, key)) {
      return Reflect.get(arrayInstrumentations, key, receiver);
    }
    const res = Reflect.get(target, key, receiver);
    if (isSymbol$6(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
      return res;
    }
    if (!isReadonly2) {
      track(target, "get", key);
    }
    if (shallow) {
      return res;
    }
    if (isRef(res)) {
      const shouldUnwrap = !targetIsArray || !isIntegerKey(key);
      return shouldUnwrap ? res.value : res;
    }
    if (isObject$f(res)) {
      return isReadonly2 ? readonly(res) : reactive(res);
    }
    return res;
  };
}
function createSetter(shallow = false) {
  return function set2(target, key, value, receiver) {
    let oldValue = target[key];
    if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) {
      return false;
    }
    if (!shallow && !isReadonly(value)) {
      if (!isShallow(value)) {
        value = toRaw(value);
        oldValue = toRaw(oldValue);
      }
      if (!isArray(target) && isRef(oldValue) && !isRef(value)) {
        oldValue.value = value;
        return true;
      }
    }
    const hadKey =
      isArray(target) && isIntegerKey(key)
        ? Number(key) < target.length
        : hasOwn(target, key);
    const result = Reflect.set(target, key, value, receiver);
    if (target === toRaw(receiver)) {
      if (!hadKey) {
        trigger(target, "add", key, value);
      } else if (hasChanged(value, oldValue)) {
        trigger(target, "set", key, value);
      }
    }
    return result;
  };
}
function deleteProperty(target, key) {
  const hadKey = hasOwn(target, key);
  target[key];
  const result = Reflect.deleteProperty(target, key);
  if (result && hadKey) {
    trigger(target, "delete", key, void 0);
  }
  return result;
}
function has$4(target, key) {
  const result = Reflect.has(target, key);
  if (!isSymbol$6(key) || !builtInSymbols.has(key)) {
    track(target, "has", key);
  }
  return result;
}
function ownKeys(target) {
  track(target, "iterate", isArray(target) ? "length" : ITERATE_KEY);
  return Reflect.ownKeys(target);
}
function get$1$2(target, key, isReadonly2 = false, isShallow3 = false) {
  target =
    target[
      "__v_raw"
      /* RAW */
    ];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (key !== rawKey) {
    !isReadonly2 && track(rawTarget, "get", key);
  }
  !isReadonly2 && track(rawTarget, "get", rawKey);
  const { has: has2 } = getProto(rawTarget);
  const wrap = isShallow3 ? toShallow : isReadonly2 ? toReadonly : toReactive;
  if (has2.call(rawTarget, key)) {
    return wrap(target.get(key));
  } else if (has2.call(rawTarget, rawKey)) {
    return wrap(target.get(rawKey));
  } else if (target !== rawTarget) {
    target.get(key);
  }
}
function has$1$1(key, isReadonly2 = false) {
  const target =
    this[
      "__v_raw"
      /* RAW */
    ];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (key !== rawKey) {
    !isReadonly2 && track(rawTarget, "has", key);
  }
  !isReadonly2 && track(rawTarget, "has", rawKey);
  return key === rawKey
    ? target.has(key)
    : target.has(key) || target.has(rawKey);
}
function size(target, isReadonly2 = false) {
  target =
    target[
      "__v_raw"
      /* RAW */
    ];
  !isReadonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
  return Reflect.get(target, "size", target);
}
function add(value) {
  value = toRaw(value);
  const target = toRaw(this);
  const proto = getProto(target);
  const hadKey = proto.has.call(target, value);
  if (!hadKey) {
    target.add(value);
    trigger(target, "add", value, value);
  }
  return this;
}
function set$1$3(key, value) {
  value = toRaw(value);
  const target = toRaw(this);
  const { has: has2, get: get2 } = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  }
  const oldValue = get2.call(target, key);
  target.set(key, value);
  if (!hadKey) {
    trigger(target, "add", key, value);
  } else if (hasChanged(value, oldValue)) {
    trigger(target, "set", key, value);
  }
  return this;
}
function deleteEntry(key) {
  const target = toRaw(this);
  const { has: has2, get: get2 } = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  }
  get2 ? get2.call(target, key) : void 0;
  const result = target.delete(key);
  if (hadKey) {
    trigger(target, "delete", key, void 0);
  }
  return result;
}
function clear$3() {
  const target = toRaw(this);
  const hadItems = target.size !== 0;
  const result = target.clear();
  if (hadItems) {
    trigger(target, "clear", void 0, void 0);
  }
  return result;
}
function createForEach(isReadonly2, isShallow3) {
  return function forEach(callback, thisArg) {
    const observed = this;
    const target =
      observed[
        "__v_raw"
        /* RAW */
      ];
    const rawTarget = toRaw(target);
    const wrap = isShallow3 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
    return target.forEach((value, key) => {
      return callback.call(thisArg, wrap(value), wrap(key), observed);
    });
  };
}
function createIterableMethod(method, isReadonly2, isShallow3) {
  return function (...args) {
    const target =
      this[
        "__v_raw"
        /* RAW */
      ];
    const rawTarget = toRaw(target);
    const targetIsMap = isMap(rawTarget);
    const isPair =
      method === "entries" || (method === Symbol.iterator && targetIsMap);
    const isKeyOnly = method === "keys" && targetIsMap;
    const innerIterator = target[method](...args);
    const wrap = isShallow3 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 &&
      track(
        rawTarget,
        "iterate",
        isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
      );
    return {
      // iterator protocol
      next() {
        const { value, done } = innerIterator.next();
        return done
          ? { value, done }
          : {
              value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
              done,
            };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      },
    };
  };
}
function createReadonlyMethod(type) {
  return function (...args) {
    return type === "delete" ? false : this;
  };
}
function createInstrumentations() {
  const mutableInstrumentations2 = {
    get(key) {
      return get$1$2(this, key);
    },
    get size() {
      return size(this);
    },
    has: has$1$1,
    add,
    set: set$1$3,
    delete: deleteEntry,
    clear: clear$3,
    forEach: createForEach(false, false),
  };
  const shallowInstrumentations2 = {
    get(key) {
      return get$1$2(this, key, false, true);
    },
    get size() {
      return size(this);
    },
    has: has$1$1,
    add,
    set: set$1$3,
    delete: deleteEntry,
    clear: clear$3,
    forEach: createForEach(false, true),
  };
  const readonlyInstrumentations2 = {
    get(key) {
      return get$1$2(this, key, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has$1$1.call(this, key, true);
    },
    add: createReadonlyMethod(
      "add"
      /* ADD */
    ),
    set: createReadonlyMethod(
      "set"
      /* SET */
    ),
    delete: createReadonlyMethod(
      "delete"
      /* DELETE */
    ),
    clear: createReadonlyMethod(
      "clear"
      /* CLEAR */
    ),
    forEach: createForEach(true, false),
  };
  const shallowReadonlyInstrumentations2 = {
    get(key) {
      return get$1$2(this, key, true, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has$1$1.call(this, key, true);
    },
    add: createReadonlyMethod(
      "add"
      /* ADD */
    ),
    set: createReadonlyMethod(
      "set"
      /* SET */
    ),
    delete: createReadonlyMethod(
      "delete"
      /* DELETE */
    ),
    clear: createReadonlyMethod(
      "clear"
      /* CLEAR */
    ),
    forEach: createForEach(true, true),
  };
  const iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
  iteratorMethods.forEach((method) => {
    mutableInstrumentations2[method] = createIterableMethod(
      method,
      false,
      false
    );
    readonlyInstrumentations2[method] = createIterableMethod(
      method,
      true,
      false
    );
    shallowInstrumentations2[method] = createIterableMethod(
      method,
      false,
      true
    );
    shallowReadonlyInstrumentations2[method] = createIterableMethod(
      method,
      true,
      true
    );
  });
  return [
    mutableInstrumentations2,
    readonlyInstrumentations2,
    shallowInstrumentations2,
    shallowReadonlyInstrumentations2,
  ];
}
function createInstrumentationGetter(isReadonly2, shallow) {
  const instrumentations = shallow
    ? isReadonly2
      ? shallowReadonlyInstrumentations
      : shallowInstrumentations
    : isReadonly2
    ? readonlyInstrumentations
    : mutableInstrumentations;
  return (target, key, receiver) => {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_raw") {
      return target;
    }
    return Reflect.get(
      hasOwn(instrumentations, key) && key in target
        ? instrumentations
        : target,
      key,
      receiver
    );
  };
}
function targetTypeMap(rawType) {
  switch (rawType) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function getTargetType(value) {
  return value[
    "__v_skip"
    /* SKIP */
  ] || !Object.isExtensible(value)
    ? 0
    : targetTypeMap(toRawType(value));
}
function reactive(target) {
  if (isReadonly(target)) {
    return target;
  }
  return createReactiveObject(
    target,
    false,
    mutableHandlers,
    mutableCollectionHandlers,
    reactiveMap
  );
}
function shallowReactive(target) {
  return createReactiveObject(
    target,
    false,
    shallowReactiveHandlers,
    shallowCollectionHandlers,
    shallowReactiveMap
  );
}
function readonly(target) {
  return createReactiveObject(
    target,
    true,
    readonlyHandlers,
    readonlyCollectionHandlers,
    readonlyMap
  );
}
function shallowReadonly(target) {
  return createReactiveObject(
    target,
    true,
    shallowReadonlyHandlers,
    shallowReadonlyCollectionHandlers,
    shallowReadonlyMap
  );
}
function createReactiveObject(
  target,
  isReadonly2,
  baseHandlers,
  collectionHandlers,
  proxyMap
) {
  if (!isObject$f(target)) {
    return target;
  }
  if (
    target[
      "__v_raw"
      /* RAW */
    ] &&
    !(
      isReadonly2 &&
      target[
        "__v_isReactive"
        /* IS_REACTIVE */
      ]
    )
  ) {
    return target;
  }
  const existingProxy = proxyMap.get(target);
  if (existingProxy) {
    return existingProxy;
  }
  const targetType = getTargetType(target);
  if (targetType === 0) {
    return target;
  }
  const proxy = new Proxy(
    target,
    targetType === 2 ? collectionHandlers : baseHandlers
  );
  proxyMap.set(target, proxy);
  return proxy;
}
function isReactive(value) {
  if (isReadonly(value)) {
    return isReactive(
      value[
        "__v_raw"
        /* RAW */
      ]
    );
  }
  return !!(
    value &&
    value[
      "__v_isReactive"
      /* IS_REACTIVE */
    ]
  );
}
function isReadonly(value) {
  return !!(
    value &&
    value[
      "__v_isReadonly"
      /* IS_READONLY */
    ]
  );
}
function isShallow(value) {
  return !!(
    value &&
    value[
      "__v_isShallow"
      /* IS_SHALLOW */
    ]
  );
}
function isProxy(value) {
  return isReactive(value) || isReadonly(value);
}
function toRaw(observed) {
  const raw =
    observed &&
    observed[
      "__v_raw"
      /* RAW */
    ];
  return raw ? toRaw(raw) : observed;
}
function markRaw(value) {
  def(value, "__v_skip", true);
  return value;
}
function trackRefValue(ref2) {
  if (shouldTrack && activeEffect) {
    ref2 = toRaw(ref2);
    {
      trackEffects(ref2.dep || (ref2.dep = createDep()));
    }
  }
}
function triggerRefValue(ref2, newVal) {
  ref2 = toRaw(ref2);
  if (ref2.dep) {
    {
      triggerEffects(ref2.dep);
    }
  }
}
function isRef(r) {
  return !!(r && r.__v_isRef === true);
}
function ref(value) {
  return createRef(value, false);
}
function shallowRef(value) {
  return createRef(value, true);
}
function createRef(rawValue, shallow) {
  if (isRef(rawValue)) {
    return rawValue;
  }
  return new RefImpl(rawValue, shallow);
}
function triggerRef(ref2) {
  triggerRefValue(ref2);
}
function unref(ref2) {
  return isRef(ref2) ? ref2.value : ref2;
}
function proxyRefs(objectWithRefs) {
  return isReactive(objectWithRefs)
    ? objectWithRefs
    : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}
function customRef(factory) {
  return new CustomRefImpl(factory);
}
function toRefs(object) {
  const ret = isArray(object) ? new Array(object.length) : {};
  for (const key in object) {
    ret[key] = toRef(object, key);
  }
  return ret;
}
function toRef(object, key, defaultValue) {
  const val = object[key];
  return isRef(val) ? val : new ObjectRefImpl(object, key, defaultValue);
}
function computed(getterOrOptions, debugOptions, isSSR = false) {
  let getter;
  let setter;
  const onlyGetter = isFunction$1(getterOrOptions);
  if (onlyGetter) {
    getter = getterOrOptions;
    setter = NOOP;
  } else {
    getter = getterOrOptions.get;
    setter = getterOrOptions.set;
  }
  const cRef = new ComputedRefImpl(
    getter,
    setter,
    onlyGetter || !setter,
    isSSR
  );
  return cRef;
}
var activeEffectScope,
  EffectScope,
  createDep,
  wasTracked,
  newTracked,
  initDepMarkers,
  finalizeDepMarkers,
  targetMap,
  effectTrackDepth,
  trackOpBit,
  maxMarkerBits,
  activeEffect,
  ITERATE_KEY,
  MAP_KEY_ITERATE_KEY,
  ReactiveEffect,
  shouldTrack,
  trackStack,
  isNonTrackableKeys,
  builtInSymbols,
  get$4,
  shallowGet,
  readonlyGet,
  shallowReadonlyGet,
  arrayInstrumentations,
  set$5,
  shallowSet,
  mutableHandlers,
  readonlyHandlers,
  shallowReactiveHandlers,
  shallowReadonlyHandlers,
  toShallow,
  getProto,
  mutableInstrumentations,
  readonlyInstrumentations,
  shallowInstrumentations,
  shallowReadonlyInstrumentations,
  mutableCollectionHandlers,
  shallowCollectionHandlers,
  readonlyCollectionHandlers,
  shallowReadonlyCollectionHandlers,
  reactiveMap,
  shallowReactiveMap,
  readonlyMap,
  shallowReadonlyMap,
  toReactive,
  toReadonly,
  RefImpl,
  shallowUnwrapHandlers,
  CustomRefImpl,
  ObjectRefImpl,
  ComputedRefImpl;
var init_reactivity_esm_bundler = __esm({
  "node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js"() {
    init_shared_esm_bundler();
    EffectScope = class {
      constructor(detached = false) {
        this.active = true;
        this.effects = [];
        this.cleanups = [];
        if (!detached && activeEffectScope) {
          this.parent = activeEffectScope;
          this.index =
            (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
              this
            ) - 1;
        }
      }
      run(fn) {
        if (this.active) {
          const currentEffectScope = activeEffectScope;
          try {
            activeEffectScope = this;
            return fn();
          } finally {
            activeEffectScope = currentEffectScope;
          }
        }
      }
      /**
       * This should only be called on non-detached scopes
       * @internal
       */
      on() {
        activeEffectScope = this;
      }
      /**
       * This should only be called on non-detached scopes
       * @internal
       */
      off() {
        activeEffectScope = this.parent;
      }
      stop(fromParent) {
        if (this.active) {
          let i, l;
          for (i = 0, l = this.effects.length; i < l; i++) {
            this.effects[i].stop();
          }
          for (i = 0, l = this.cleanups.length; i < l; i++) {
            this.cleanups[i]();
          }
          if (this.scopes) {
            for (i = 0, l = this.scopes.length; i < l; i++) {
              this.scopes[i].stop(true);
            }
          }
          if (this.parent && !fromParent) {
            const last = this.parent.scopes.pop();
            if (last && last !== this) {
              this.parent.scopes[this.index] = last;
              last.index = this.index;
            }
          }
          this.active = false;
        }
      }
    };
    createDep = (effects) => {
      const dep = new Set(effects);
      dep.w = 0;
      dep.n = 0;
      return dep;
    };
    wasTracked = (dep) => (dep.w & trackOpBit) > 0;
    newTracked = (dep) => (dep.n & trackOpBit) > 0;
    initDepMarkers = ({ deps }) => {
      if (deps.length) {
        for (let i = 0; i < deps.length; i++) {
          deps[i].w |= trackOpBit;
        }
      }
    };
    finalizeDepMarkers = (effect2) => {
      const { deps } = effect2;
      if (deps.length) {
        let ptr = 0;
        for (let i = 0; i < deps.length; i++) {
          const dep = deps[i];
          if (wasTracked(dep) && !newTracked(dep)) {
            dep.delete(effect2);
          } else {
            deps[ptr++] = dep;
          }
          dep.w &= ~trackOpBit;
          dep.n &= ~trackOpBit;
        }
        deps.length = ptr;
      }
    };
    targetMap = /* @__PURE__ */ new WeakMap();
    effectTrackDepth = 0;
    trackOpBit = 1;
    maxMarkerBits = 30;
    ITERATE_KEY = Symbol("");
    MAP_KEY_ITERATE_KEY = Symbol("");
    ReactiveEffect = class {
      constructor(fn, scheduler = null, scope) {
        this.fn = fn;
        this.scheduler = scheduler;
        this.active = true;
        this.deps = [];
        this.parent = void 0;
        recordEffectScope(this, scope);
      }
      run() {
        if (!this.active) {
          return this.fn();
        }
        let parent = activeEffect;
        let lastShouldTrack = shouldTrack;
        while (parent) {
          if (parent === this) {
            return;
          }
          parent = parent.parent;
        }
        try {
          this.parent = activeEffect;
          activeEffect = this;
          shouldTrack = true;
          trackOpBit = 1 << ++effectTrackDepth;
          if (effectTrackDepth <= maxMarkerBits) {
            initDepMarkers(this);
          } else {
            cleanupEffect(this);
          }
          return this.fn();
        } finally {
          if (effectTrackDepth <= maxMarkerBits) {
            finalizeDepMarkers(this);
          }
          trackOpBit = 1 << --effectTrackDepth;
          activeEffect = this.parent;
          shouldTrack = lastShouldTrack;
          this.parent = void 0;
        }
      }
      stop() {
        if (this.active) {
          cleanupEffect(this);
          if (this.onStop) {
            this.onStop();
          }
          this.active = false;
        }
      }
    };
    shouldTrack = true;
    trackStack = [];
    isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
    builtInSymbols = new Set(
      Object.getOwnPropertyNames(Symbol)
        .map((key) => Symbol[key])
        .filter(isSymbol$6)
    );
    get$4 = /* @__PURE__ */ createGetter();
    shallowGet = /* @__PURE__ */ createGetter(false, true);
    readonlyGet = /* @__PURE__ */ createGetter(true);
    shallowReadonlyGet = /* @__PURE__ */ createGetter(true, true);
    arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
    set$5 = /* @__PURE__ */ createSetter();
    shallowSet = /* @__PURE__ */ createSetter(true);
    mutableHandlers = {
      get: get$4,
      set: set$5,
      deleteProperty,
      has: has$4,
      ownKeys,
    };
    readonlyHandlers = {
      get: readonlyGet,
      set(target, key) {
        return true;
      },
      deleteProperty(target, key) {
        return true;
      },
    };
    shallowReactiveHandlers = /* @__PURE__ */ extend({}, mutableHandlers, {
      get: shallowGet,
      set: shallowSet,
    });
    shallowReadonlyHandlers = /* @__PURE__ */ extend({}, readonlyHandlers, {
      get: shallowReadonlyGet,
    });
    toShallow = (value) => value;
    getProto = (v) => Reflect.getPrototypeOf(v);
    [
      mutableInstrumentations,
      readonlyInstrumentations,
      shallowInstrumentations,
      shallowReadonlyInstrumentations,
    ] = /* @__PURE__ */ createInstrumentations();
    mutableCollectionHandlers = {
      get: /* @__PURE__ */ createInstrumentationGetter(false, false),
    };
    shallowCollectionHandlers = {
      get: /* @__PURE__ */ createInstrumentationGetter(false, true),
    };
    readonlyCollectionHandlers = {
      get: /* @__PURE__ */ createInstrumentationGetter(true, false),
    };
    shallowReadonlyCollectionHandlers = {
      get: /* @__PURE__ */ createInstrumentationGetter(true, true),
    };
    reactiveMap = /* @__PURE__ */ new WeakMap();
    shallowReactiveMap = /* @__PURE__ */ new WeakMap();
    readonlyMap = /* @__PURE__ */ new WeakMap();
    shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
    toReactive = (value) => (isObject$f(value) ? reactive(value) : value);
    toReadonly = (value) => (isObject$f(value) ? readonly(value) : value);
    RefImpl = class {
      constructor(value, __v_isShallow) {
        this.__v_isShallow = __v_isShallow;
        this.dep = void 0;
        this.__v_isRef = true;
        this._rawValue = __v_isShallow ? value : toRaw(value);
        this._value = __v_isShallow ? value : toReactive(value);
      }
      get value() {
        trackRefValue(this);
        return this._value;
      }
      set value(newVal) {
        newVal = this.__v_isShallow ? newVal : toRaw(newVal);
        if (hasChanged(newVal, this._rawValue)) {
          this._rawValue = newVal;
          this._value = this.__v_isShallow ? newVal : toReactive(newVal);
          triggerRefValue(this);
        }
      }
    };
    shallowUnwrapHandlers = {
      get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),
      set: (target, key, value, receiver) => {
        const oldValue = target[key];
        if (isRef(oldValue) && !isRef(value)) {
          oldValue.value = value;
          return true;
        } else {
          return Reflect.set(target, key, value, receiver);
        }
      },
    };
    CustomRefImpl = class {
      constructor(factory) {
        this.dep = void 0;
        this.__v_isRef = true;
        const { get: get2, set: set2 } = factory(
          () => trackRefValue(this),
          () => triggerRefValue(this)
        );
        this._get = get2;
        this._set = set2;
      }
      get value() {
        return this._get();
      }
      set value(newVal) {
        this._set(newVal);
      }
    };
    ObjectRefImpl = class {
      constructor(_object, _key, _defaultValue) {
        this._object = _object;
        this._key = _key;
        this._defaultValue = _defaultValue;
        this.__v_isRef = true;
      }
      get value() {
        const val = this._object[this._key];
        return val === void 0 ? this._defaultValue : val;
      }
      set value(newVal) {
        this._object[this._key] = newVal;
      }
    };
    ComputedRefImpl = class {
      constructor(getter, _setter, isReadonly2, isSSR) {
        this._setter = _setter;
        this.dep = void 0;
        this.__v_isRef = true;
        this._dirty = true;
        this.effect = new ReactiveEffect(getter, () => {
          if (!this._dirty) {
            this._dirty = true;
            triggerRefValue(this);
          }
        });
        this.effect.computed = this;
        this.effect.active = this._cacheable = !isSSR;
        this[
          "__v_isReadonly"
          /* IS_READONLY */
        ] = isReadonly2;
      }
      get value() {
        const self2 = toRaw(this);
        trackRefValue(self2);
        if (self2._dirty || !self2._cacheable) {
          self2._dirty = false;
          self2._value = self2.effect.run();
        }
        return self2._value;
      }
      set value(newValue) {
        this._setter(newValue);
      }
    };
    Promise.resolve();
  },
});
function warn2(msg, ...args) {
  pauseTracking();
  const instance = stack.length ? stack[stack.length - 1].component : null;
  const appWarnHandler = instance && instance.appContext.config.warnHandler;
  const trace = getComponentTrace();
  if (appWarnHandler) {
    callWithErrorHandling(appWarnHandler, instance, 11, [
      msg + args.join(""),
      instance && instance.proxy,
      trace
        .map(({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`)
        .join("\n"),
      trace,
    ]);
  } else {
    const warnArgs = [`[Vue warn]: ${msg}`, ...args];
    if (
      trace.length && // avoid spamming console during tests
      true
    ) {
      warnArgs.push(
        `
`,
        ...formatTrace(trace)
      );
    }
    console.warn(...warnArgs);
  }
  resetTracking();
}
function getComponentTrace() {
  let currentVNode = stack[stack.length - 1];
  if (!currentVNode) {
    return [];
  }
  const normalizedStack = [];
  while (currentVNode) {
    const last = normalizedStack[0];
    if (last && last.vnode === currentVNode) {
      last.recurseCount++;
    } else {
      normalizedStack.push({
        vnode: currentVNode,
        recurseCount: 0,
      });
    }
    const parentInstance =
      currentVNode.component && currentVNode.component.parent;
    currentVNode = parentInstance && parentInstance.vnode;
  }
  return normalizedStack;
}
function formatTrace(trace) {
  const logs = [];
  trace.forEach((entry, i) => {
    logs.push(
      ...(i === 0
        ? []
        : [
            `
`,
          ]),
      ...formatTraceEntry(entry)
    );
  });
  return logs;
}
function formatTraceEntry({ vnode, recurseCount }) {
  const postfix =
    recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
  const isRoot = vnode.component ? vnode.component.parent == null : false;
  const open = ` at <${formatComponentName(
    vnode.component,
    vnode.type,
    isRoot
  )}`;
  const close = `>` + postfix;
  return vnode.props
    ? [open, ...formatProps(vnode.props), close]
    : [open + close];
}
function formatProps(props) {
  const res = [];
  const keys = Object.keys(props);
  keys.slice(0, 3).forEach((key) => {
    res.push(...formatProp(key, props[key]));
  });
  if (keys.length > 3) {
    res.push(` ...`);
  }
  return res;
}
function formatProp(key, value, raw) {
  if (isString$1(value)) {
    value = JSON.stringify(value);
    return raw ? value : [`${key}=${value}`];
  } else if (
    typeof value === "number" ||
    typeof value === "boolean" ||
    value == null
  ) {
    return raw ? value : [`${key}=${value}`];
  } else if (isRef(value)) {
    value = formatProp(key, toRaw(value.value), true);
    return raw ? value : [`${key}=Ref<`, value, `>`];
  } else if (isFunction$1(value)) {
    return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
  } else {
    value = toRaw(value);
    return raw ? value : [`${key}=`, value];
  }
}
function callWithErrorHandling(fn, instance, type, args) {
  let res;
  try {
    res = args ? fn(...args) : fn();
  } catch (err) {
    handleError(err, instance, type);
  }
  return res;
}
function callWithAsyncErrorHandling(fn, instance, type, args) {
  if (isFunction$1(fn)) {
    const res = callWithErrorHandling(fn, instance, type, args);
    if (res && isPromise(res)) {
      res.catch((err) => {
        handleError(err, instance, type);
      });
    }
    return res;
  }
  const values = [];
  for (let i = 0; i < fn.length; i++) {
    values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));
  }
  return values;
}
function handleError(err, instance, type, throwInDev = true) {
  const contextVNode = instance ? instance.vnode : null;
  if (instance) {
    let cur = instance.parent;
    const exposedInstance = instance.proxy;
    const errorInfo = type;
    while (cur) {
      const errorCapturedHooks = cur.ec;
      if (errorCapturedHooks) {
        for (let i = 0; i < errorCapturedHooks.length; i++) {
          if (
            errorCapturedHooks[i](err, exposedInstance, errorInfo) === false
          ) {
            return;
          }
        }
      }
      cur = cur.parent;
    }
    const appErrorHandler = instance.appContext.config.errorHandler;
    if (appErrorHandler) {
      callWithErrorHandling(appErrorHandler, null, 10, [
        err,
        exposedInstance,
        errorInfo,
      ]);
      return;
    }
  }
  logError(err, type, contextVNode, throwInDev);
}
function logError(err, type, contextVNode, throwInDev = true) {
  {
    console.error(err);
  }
}
function nextTick(fn) {
  const p2 = currentFlushPromise || resolvedPromise;
  return fn ? p2.then(this ? fn.bind(this) : fn) : p2;
}
function findInsertionIndex(id) {
  let start = flushIndex + 1;
  let end = queue$4.length;
  while (start < end) {
    const middle = (start + end) >>> 1;
    const middleJobId = getId(queue$4[middle]);
    middleJobId < id ? (start = middle + 1) : (end = middle);
  }
  return start;
}
function queueJob(job) {
  if (
    (!queue$4.length ||
      !queue$4.includes(
        job,
        isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex
      )) &&
    job !== currentPreFlushParentJob
  ) {
    if (job.id == null) {
      queue$4.push(job);
    } else {
      queue$4.splice(findInsertionIndex(job.id), 0, job);
    }
    queueFlush();
  }
}
function queueFlush() {
  if (!isFlushing && !isFlushPending) {
    isFlushPending = true;
    currentFlushPromise = resolvedPromise.then(flushJobs);
  }
}
function invalidateJob(job) {
  const i = queue$4.indexOf(job);
  if (i > flushIndex) {
    queue$4.splice(i, 1);
  }
}
function queueCb(cb, activeQueue, pendingQueue, index) {
  if (!isArray(cb)) {
    if (
      !activeQueue ||
      !activeQueue.includes(cb, cb.allowRecurse ? index + 1 : index)
    ) {
      pendingQueue.push(cb);
    }
  } else {
    pendingQueue.push(...cb);
  }
  queueFlush();
}
function queuePreFlushCb(cb) {
  queueCb(cb, activePreFlushCbs, pendingPreFlushCbs, preFlushIndex);
}
function queuePostFlushCb(cb) {
  queueCb(cb, activePostFlushCbs, pendingPostFlushCbs, postFlushIndex);
}
function flushPreFlushCbs(seen, parentJob = null) {
  if (pendingPreFlushCbs.length) {
    currentPreFlushParentJob = parentJob;
    activePreFlushCbs = [...new Set(pendingPreFlushCbs)];
    pendingPreFlushCbs.length = 0;
    for (
      preFlushIndex = 0;
      preFlushIndex < activePreFlushCbs.length;
      preFlushIndex++
    ) {
      activePreFlushCbs[preFlushIndex]();
    }
    activePreFlushCbs = null;
    preFlushIndex = 0;
    currentPreFlushParentJob = null;
    flushPreFlushCbs(seen, parentJob);
  }
}
function flushPostFlushCbs(seen) {
  if (pendingPostFlushCbs.length) {
    const deduped = [...new Set(pendingPostFlushCbs)];
    pendingPostFlushCbs.length = 0;
    if (activePostFlushCbs) {
      activePostFlushCbs.push(...deduped);
      return;
    }
    activePostFlushCbs = deduped;
    activePostFlushCbs.sort((a, b) => getId(a) - getId(b));
    for (
      postFlushIndex = 0;
      postFlushIndex < activePostFlushCbs.length;
      postFlushIndex++
    ) {
      activePostFlushCbs[postFlushIndex]();
    }
    activePostFlushCbs = null;
    postFlushIndex = 0;
  }
}
function flushJobs(seen) {
  isFlushPending = false;
  isFlushing = true;
  flushPreFlushCbs(seen);
  queue$4.sort((a, b) => getId(a) - getId(b));
  const check = NOOP;
  try {
    for (flushIndex = 0; flushIndex < queue$4.length; flushIndex++) {
      const job = queue$4[flushIndex];
      if (job && job.active !== false) {
        if ("production" !== "production" && check(job));
        callWithErrorHandling(
          job,
          null,
          14
          /* SCHEDULER */
        );
      }
    }
  } finally {
    flushIndex = 0;
    queue$4.length = 0;
    flushPostFlushCbs();
    isFlushing = false;
    currentFlushPromise = null;
    if (
      queue$4.length ||
      pendingPreFlushCbs.length ||
      pendingPostFlushCbs.length
    ) {
      flushJobs(seen);
    }
  }
}
function setDevtoolsHook(hook, target) {
  var _a2, _b;
  devtools = hook;
  if (devtools) {
    devtools.enabled = true;
    buffer.forEach(({ event, args }) => devtools.emit(event, ...args));
    buffer = [];
  } else if (
    // handle late devtools injection - only do this if we are in an actual
    // browser environment to avoid the timer handle stalling test runner exit
    // (#4815)
    // eslint-disable-next-line no-restricted-globals
    typeof window !== "undefined" && // some envs mock window but not fully
    window.HTMLElement && // also exclude jsdom
    !((_b =
      (_a2 = window.navigator) === null || _a2 === void 0
        ? void 0
        : _a2.userAgent) === null || _b === void 0
      ? void 0
      : _b.includes("jsdom"))
  ) {
    const replay = (target.__VUE_DEVTOOLS_HOOK_REPLAY__ =
      target.__VUE_DEVTOOLS_HOOK_REPLAY__ || []);
    replay.push((newHook) => {
      setDevtoolsHook(newHook, target);
    });
    setTimeout(() => {
      if (!devtools) {
        target.__VUE_DEVTOOLS_HOOK_REPLAY__ = null;
        buffer = [];
      }
    }, 3e3);
  } else {
    buffer = [];
  }
}
function emit$1(instance, event, ...rawArgs) {
  const props = instance.vnode.props || EMPTY_OBJ;
  let args = rawArgs;
  const isModelListener2 = event.startsWith("update:");
  const modelArg = isModelListener2 && event.slice(7);
  if (modelArg && modelArg in props) {
    const modifiersKey = `${
      modelArg === "modelValue" ? "model" : modelArg
    }Modifiers`;
    const { number, trim } = props[modifiersKey] || EMPTY_OBJ;
    if (trim) {
      args = rawArgs.map((a) => a.trim());
    } else if (number) {
      args = rawArgs.map(toNumber);
    }
  }
  let handlerName;
  let handler =
    props[(handlerName = toHandlerKey(event))] || // also try camelCase event handler (#2249)
    props[(handlerName = toHandlerKey(camelize(event)))];
  if (!handler && isModelListener2) {
    handler = props[(handlerName = toHandlerKey(hyphenate(event)))];
  }
  if (handler) {
    callWithAsyncErrorHandling(handler, instance, 6, args);
  }
  const onceHandler = props[handlerName + `Once`];
  if (onceHandler) {
    if (!instance.emitted) {
      instance.emitted = {};
    } else if (instance.emitted[handlerName]) {
      return;
    }
    instance.emitted[handlerName] = true;
    callWithAsyncErrorHandling(onceHandler, instance, 6, args);
  }
}
function normalizeEmitsOptions(comp, appContext, asMixin = false) {
  const cache = appContext.emitsCache;
  const cached = cache.get(comp);
  if (cached !== void 0) {
    return cached;
  }
  const raw = comp.emits;
  let normalized = {};
  let hasExtends = false;
  if (!isFunction$1(comp)) {
    const extendEmits = (raw2) => {
      const normalizedFromExtend = normalizeEmitsOptions(
        raw2,
        appContext,
        true
      );
      if (normalizedFromExtend) {
        hasExtends = true;
        extend(normalized, normalizedFromExtend);
      }
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendEmits);
    }
    if (comp.extends) {
      extendEmits(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendEmits);
    }
  }
  if (!raw && !hasExtends) {
    cache.set(comp, null);
    return null;
  }
  if (isArray(raw)) {
    raw.forEach((key) => (normalized[key] = null));
  } else {
    extend(normalized, raw);
  }
  cache.set(comp, normalized);
  return normalized;
}
function isEmitListener(options, key) {
  if (!options || !isOn(key)) {
    return false;
  }
  key = key.slice(2).replace(/Once$/, "");
  return (
    hasOwn(options, key[0].toLowerCase() + key.slice(1)) ||
    hasOwn(options, hyphenate(key)) ||
    hasOwn(options, key)
  );
}
function setCurrentRenderingInstance(instance) {
  const prev = currentRenderingInstance;
  currentRenderingInstance = instance;
  currentScopeId = (instance && instance.type.__scopeId) || null;
  return prev;
}
function pushScopeId(id) {
  currentScopeId = id;
}
function popScopeId() {
  currentScopeId = null;
}
function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
  if (!ctx) return fn;
  if (fn._n) {
    return fn;
  }
  const renderFnWithContext = (...args) => {
    if (renderFnWithContext._d) {
      setBlockTracking(-1);
    }
    const prevInstance = setCurrentRenderingInstance(ctx);
    const res = fn(...args);
    setCurrentRenderingInstance(prevInstance);
    if (renderFnWithContext._d) {
      setBlockTracking(1);
    }
    return res;
  };
  renderFnWithContext._n = true;
  renderFnWithContext._c = true;
  renderFnWithContext._d = true;
  return renderFnWithContext;
}
function markAttrsAccessed() {}
function renderComponentRoot(instance) {
  const {
    type: Component,
    vnode,
    proxy,
    withProxy,
    props,
    propsOptions: [propsOptions],
    slots,
    attrs,
    emit: emit2,
    render: render2,
    renderCache,
    data,
    setupState,
    ctx,
    inheritAttrs,
  } = instance;
  let result;
  let fallthroughAttrs;
  const prev = setCurrentRenderingInstance(instance);
  try {
    if (vnode.shapeFlag & 4) {
      const proxyToUse = withProxy || proxy;
      result = normalizeVNode(
        render2.call(
          proxyToUse,
          proxyToUse,
          renderCache,
          props,
          setupState,
          data,
          ctx
        )
      );
      fallthroughAttrs = attrs;
    } else {
      const render3 = Component;
      if ("production" !== "production" && attrs === props);
      result = normalizeVNode(
        render3.length > 1
          ? render3(
              props,
              "production" !== "production"
                ? {
                    get attrs() {
                      markAttrsAccessed();
                      return attrs;
                    },
                    slots,
                    emit: emit2,
                  }
                : { attrs, slots, emit: emit2 }
            )
          : render3(
              props,
              null
              /* we know it doesn't need it */
            )
      );
      fallthroughAttrs = Component.props
        ? attrs
        : getFunctionalFallthrough(attrs);
    }
  } catch (err) {
    blockStack.length = 0;
    handleError(
      err,
      instance,
      1
      /* RENDER_FUNCTION */
    );
    result = createVNode(Comment);
  }
  let root = result;
  if (fallthroughAttrs && inheritAttrs !== false) {
    const keys = Object.keys(fallthroughAttrs);
    const { shapeFlag } = root;
    if (keys.length) {
      if (shapeFlag & (1 | 6)) {
        if (propsOptions && keys.some(isModelListener)) {
          fallthroughAttrs = filterModelListeners(
            fallthroughAttrs,
            propsOptions
          );
        }
        root = cloneVNode(root, fallthroughAttrs);
      }
    }
  }
  if (vnode.dirs) {
    root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
  }
  if (vnode.transition) {
    root.transition = vnode.transition;
  }
  {
    result = root;
  }
  setCurrentRenderingInstance(prev);
  return result;
}
function filterSingleRoot(children) {
  let singleRoot;
  for (let i = 0; i < children.length; i++) {
    const child = children[i];
    if (isVNode(child)) {
      if (child.type !== Comment || child.children === "v-if") {
        if (singleRoot) {
          return;
        } else {
          singleRoot = child;
        }
      }
    } else {
      return;
    }
  }
  return singleRoot;
}
function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
  const { props: prevProps, children: prevChildren, component } = prevVNode;
  const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
  const emits = component.emitsOptions;
  if (nextVNode.dirs || nextVNode.transition) {
    return true;
  }
  if (optimized && patchFlag >= 0) {
    if (patchFlag & 1024) {
      return true;
    }
    if (patchFlag & 16) {
      if (!prevProps) {
        return !!nextProps;
      }
      return hasPropsChanged(prevProps, nextProps, emits);
    } else if (patchFlag & 8) {
      const dynamicProps = nextVNode.dynamicProps;
      for (let i = 0; i < dynamicProps.length; i++) {
        const key = dynamicProps[i];
        if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
          return true;
        }
      }
    }
  } else {
    if (prevChildren || nextChildren) {
      if (!nextChildren || !nextChildren.$stable) {
        return true;
      }
    }
    if (prevProps === nextProps) {
      return false;
    }
    if (!prevProps) {
      return !!nextProps;
    }
    if (!nextProps) {
      return true;
    }
    return hasPropsChanged(prevProps, nextProps, emits);
  }
  return false;
}
function hasPropsChanged(prevProps, nextProps, emitsOptions) {
  const nextKeys = Object.keys(nextProps);
  if (nextKeys.length !== Object.keys(prevProps).length) {
    return true;
  }
  for (let i = 0; i < nextKeys.length; i++) {
    const key = nextKeys[i];
    if (
      nextProps[key] !== prevProps[key] &&
      !isEmitListener(emitsOptions, key)
    ) {
      return true;
    }
  }
  return false;
}
function updateHOCHostEl({ vnode, parent }, el) {
  while (parent && parent.subTree === vnode) {
    (vnode = parent.vnode).el = el;
    parent = parent.parent;
  }
}
function triggerEvent(vnode, name) {
  const eventListener = vnode.props && vnode.props[name];
  if (isFunction$1(eventListener)) {
    eventListener();
  }
}
function mountSuspense(
  vnode,
  container,
  anchor,
  parentComponent,
  parentSuspense,
  isSVG,
  slotScopeIds,
  optimized,
  rendererInternals
) {
  const {
    p: patch,
    o: { createElement },
  } = rendererInternals;
  const hiddenContainer = createElement("div");
  const suspense = (vnode.suspense = createSuspenseBoundary(
    vnode,
    parentSuspense,
    parentComponent,
    container,
    hiddenContainer,
    anchor,
    isSVG,
    slotScopeIds,
    optimized,
    rendererInternals
  ));
  patch(
    null,
    (suspense.pendingBranch = vnode.ssContent),
    hiddenContainer,
    null,
    parentComponent,
    suspense,
    isSVG,
    slotScopeIds
  );
  if (suspense.deps > 0) {
    triggerEvent(vnode, "onPending");
    triggerEvent(vnode, "onFallback");
    patch(
      null,
      vnode.ssFallback,
      container,
      anchor,
      parentComponent,
      null,
      // fallback tree will not have suspense context
      isSVG,
      slotScopeIds
    );
    setActiveBranch(suspense, vnode.ssFallback);
  } else {
    suspense.resolve();
  }
}
function patchSuspense(
  n1,
  n2,
  container,
  anchor,
  parentComponent,
  isSVG,
  slotScopeIds,
  optimized,
  { p: patch, um: unmount, o: { createElement } }
) {
  const suspense = (n2.suspense = n1.suspense);
  suspense.vnode = n2;
  n2.el = n1.el;
  const newBranch = n2.ssContent;
  const newFallback = n2.ssFallback;
  const { activeBranch, pendingBranch, isInFallback, isHydrating } = suspense;
  if (pendingBranch) {
    suspense.pendingBranch = newBranch;
    if (isSameVNodeType(newBranch, pendingBranch)) {
      patch(
        pendingBranch,
        newBranch,
        suspense.hiddenContainer,
        null,
        parentComponent,
        suspense,
        isSVG,
        slotScopeIds,
        optimized
      );
      if (suspense.deps <= 0) {
        suspense.resolve();
      } else if (isInFallback) {
        patch(
          activeBranch,
          newFallback,
          container,
          anchor,
          parentComponent,
          null,
          // fallback tree will not have suspense context
          isSVG,
          slotScopeIds,
          optimized
        );
        setActiveBranch(suspense, newFallback);
      }
    } else {
      suspense.pendingId++;
      if (isHydrating) {
        suspense.isHydrating = false;
        suspense.activeBranch = pendingBranch;
      } else {
        unmount(pendingBranch, parentComponent, suspense);
      }
      suspense.deps = 0;
      suspense.effects.length = 0;
      suspense.hiddenContainer = createElement("div");
      if (isInFallback) {
        patch(
          null,
          newBranch,
          suspense.hiddenContainer,
          null,
          parentComponent,
          suspense,
          isSVG,
          slotScopeIds,
          optimized
        );
        if (suspense.deps <= 0) {
          suspense.resolve();
        } else {
          patch(
            activeBranch,
            newFallback,
            container,
            anchor,
            parentComponent,
            null,
            // fallback tree will not have suspense context
            isSVG,
            slotScopeIds,
            optimized
          );
          setActiveBranch(suspense, newFallback);
        }
      } else if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
        patch(
          activeBranch,
          newBranch,
          container,
          anchor,
          parentComponent,
          suspense,
          isSVG,
          slotScopeIds,
          optimized
        );
        suspense.resolve(true);
      } else {
        patch(
          null,
          newBranch,
          suspense.hiddenContainer,
          null,
          parentComponent,
          suspense,
          isSVG,
          slotScopeIds,
          optimized
        );
        if (suspense.deps <= 0) {
          suspense.resolve();
        }
      }
    }
  } else {
    if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
      patch(
        activeBranch,
        newBranch,
        container,
        anchor,
        parentComponent,
        suspense,
        isSVG,
        slotScopeIds,
        optimized
      );
      setActiveBranch(suspense, newBranch);
    } else {
      triggerEvent(n2, "onPending");
      suspense.pendingBranch = newBranch;
      suspense.pendingId++;
      patch(
        null,
        newBranch,
        suspense.hiddenContainer,
        null,
        parentComponent,
        suspense,
        isSVG,
        slotScopeIds,
        optimized
      );
      if (suspense.deps <= 0) {
        suspense.resolve();
      } else {
        const { timeout, pendingId } = suspense;
        if (timeout > 0) {
          setTimeout(() => {
            if (suspense.pendingId === pendingId) {
              suspense.fallback(newFallback);
            }
          }, timeout);
        } else if (timeout === 0) {
          suspense.fallback(newFallback);
        }
      }
    }
  }
}
function createSuspenseBoundary(
  vnode,
  parent,
  parentComponent,
  container,
  hiddenContainer,
  anchor,
  isSVG,
  slotScopeIds,
  optimized,
  rendererInternals,
  isHydrating = false
) {
  const {
    p: patch,
    m: move,
    um: unmount,
    n: next,
    o: { parentNode, remove: remove2 },
  } = rendererInternals;
  const timeout = toNumber(vnode.props && vnode.props.timeout);
  const suspense = {
    vnode,
    parent,
    parentComponent,
    isSVG,
    container,
    hiddenContainer,
    anchor,
    deps: 0,
    pendingId: 0,
    timeout: typeof timeout === "number" ? timeout : -1,
    activeBranch: null,
    pendingBranch: null,
    isInFallback: true,
    isHydrating,
    isUnmounted: false,
    effects: [],
    resolve(resume = false) {
      const {
        vnode: vnode2,
        activeBranch,
        pendingBranch,
        pendingId,
        effects,
        parentComponent: parentComponent2,
        container: container2,
      } = suspense;
      if (suspense.isHydrating) {
        suspense.isHydrating = false;
      } else if (!resume) {
        const delayEnter =
          activeBranch &&
          pendingBranch.transition &&
          pendingBranch.transition.mode === "out-in";
        if (delayEnter) {
          activeBranch.transition.afterLeave = () => {
            if (pendingId === suspense.pendingId) {
              move(
                pendingBranch,
                container2,
                anchor2,
                0
                /* ENTER */
              );
            }
          };
        }
        let { anchor: anchor2 } = suspense;
        if (activeBranch) {
          anchor2 = next(activeBranch);
          unmount(activeBranch, parentComponent2, suspense, true);
        }
        if (!delayEnter) {
          move(
            pendingBranch,
            container2,
            anchor2,
            0
            /* ENTER */
          );
        }
      }
      setActiveBranch(suspense, pendingBranch);
      suspense.pendingBranch = null;
      suspense.isInFallback = false;
      let parent2 = suspense.parent;
      let hasUnresolvedAncestor = false;
      while (parent2) {
        if (parent2.pendingBranch) {
          parent2.effects.push(...effects);
          hasUnresolvedAncestor = true;
          break;
        }
        parent2 = parent2.parent;
      }
      if (!hasUnresolvedAncestor) {
        queuePostFlushCb(effects);
      }
      suspense.effects = [];
      triggerEvent(vnode2, "onResolve");
    },
    fallback(fallbackVNode) {
      if (!suspense.pendingBranch) {
        return;
      }
      const {
        vnode: vnode2,
        activeBranch,
        parentComponent: parentComponent2,
        container: container2,
        isSVG: isSVG2,
      } = suspense;
      triggerEvent(vnode2, "onFallback");
      const anchor2 = next(activeBranch);
      const mountFallback = () => {
        if (!suspense.isInFallback) {
          return;
        }
        patch(
          null,
          fallbackVNode,
          container2,
          anchor2,
          parentComponent2,
          null,
          // fallback tree will not have suspense context
          isSVG2,
          slotScopeIds,
          optimized
        );
        setActiveBranch(suspense, fallbackVNode);
      };
      const delayEnter =
        fallbackVNode.transition && fallbackVNode.transition.mode === "out-in";
      if (delayEnter) {
        activeBranch.transition.afterLeave = mountFallback;
      }
      suspense.isInFallback = true;
      unmount(
        activeBranch,
        parentComponent2,
        null,
        // no suspense so unmount hooks fire now
        true
        // shouldRemove
      );
      if (!delayEnter) {
        mountFallback();
      }
    },
    move(container2, anchor2, type) {
      suspense.activeBranch &&
        move(suspense.activeBranch, container2, anchor2, type);
      suspense.container = container2;
    },
    next() {
      return suspense.activeBranch && next(suspense.activeBranch);
    },
    registerDep(instance, setupRenderEffect) {
      const isInPendingSuspense = !!suspense.pendingBranch;
      if (isInPendingSuspense) {
        suspense.deps++;
      }
      const hydratedEl = instance.vnode.el;
      instance.asyncDep
        .catch((err) => {
          handleError(
            err,
            instance,
            0
            /* SETUP_FUNCTION */
          );
        })
        .then((asyncSetupResult) => {
          if (
            instance.isUnmounted ||
            suspense.isUnmounted ||
            suspense.pendingId !== instance.suspenseId
          ) {
            return;
          }
          instance.asyncResolved = true;
          const { vnode: vnode2 } = instance;
          handleSetupResult(instance, asyncSetupResult, false);
          if (hydratedEl) {
            vnode2.el = hydratedEl;
          }
          const placeholder = !hydratedEl && instance.subTree.el;
          setupRenderEffect(
            instance,
            vnode2,
            // component may have been moved before resolve.
            // if this is not a hydration, instance.subTree will be the comment
            // placeholder.
            parentNode(hydratedEl || instance.subTree.el),
            // anchor will not be used if this is hydration, so only need to
            // consider the comment placeholder case.
            hydratedEl ? null : next(instance.subTree),
            suspense,
            isSVG,
            optimized
          );
          if (placeholder) {
            remove2(placeholder);
          }
          updateHOCHostEl(instance, vnode2.el);
          if (isInPendingSuspense && --suspense.deps === 0) {
            suspense.resolve();
          }
        });
    },
    unmount(parentSuspense, doRemove) {
      suspense.isUnmounted = true;
      if (suspense.activeBranch) {
        unmount(
          suspense.activeBranch,
          parentComponent,
          parentSuspense,
          doRemove
        );
      }
      if (suspense.pendingBranch) {
        unmount(
          suspense.pendingBranch,
          parentComponent,
          parentSuspense,
          doRemove
        );
      }
    },
  };
  return suspense;
}
function hydrateSuspense(
  node,
  vnode,
  parentComponent,
  parentSuspense,
  isSVG,
  slotScopeIds,
  optimized,
  rendererInternals,
  hydrateNode
) {
  const suspense = (vnode.suspense = createSuspenseBoundary(
    vnode,
    parentSuspense,
    parentComponent,
    node.parentNode,
    document.createElement("div"),
    null,
    isSVG,
    slotScopeIds,
    optimized,
    rendererInternals,
    true
    /* hydrating */
  ));
  const result = hydrateNode(
    node,
    (suspense.pendingBranch = vnode.ssContent),
    parentComponent,
    suspense,
    slotScopeIds,
    optimized
  );
  if (suspense.deps === 0) {
    suspense.resolve();
  }
  return result;
}
function normalizeSuspenseChildren(vnode) {
  const { shapeFlag, children } = vnode;
  const isSlotChildren = shapeFlag & 32;
  vnode.ssContent = normalizeSuspenseSlot(
    isSlotChildren ? children.default : children
  );
  vnode.ssFallback = isSlotChildren
    ? normalizeSuspenseSlot(children.fallback)
    : createVNode(Comment);
}
function normalizeSuspenseSlot(s) {
  let block;
  if (isFunction$1(s)) {
    const trackBlock = isBlockTreeEnabled && s._c;
    if (trackBlock) {
      s._d = false;
      openBlock();
    }
    s = s();
    if (trackBlock) {
      s._d = true;
      block = currentBlock;
      closeBlock();
    }
  }
  if (isArray(s)) {
    const singleChild = filterSingleRoot(s);
    s = singleChild;
  }
  s = normalizeVNode(s);
  if (block && !s.dynamicChildren) {
    s.dynamicChildren = block.filter((c) => c !== s);
  }
  return s;
}
function queueEffectWithSuspense(fn, suspense) {
  if (suspense && suspense.pendingBranch) {
    if (isArray(fn)) {
      suspense.effects.push(...fn);
    } else {
      suspense.effects.push(fn);
    }
  } else {
    queuePostFlushCb(fn);
  }
}
function setActiveBranch(suspense, branch) {
  suspense.activeBranch = branch;
  const { vnode, parentComponent } = suspense;
  const el = (vnode.el = branch.el);
  if (parentComponent && parentComponent.subTree === vnode) {
    parentComponent.vnode.el = el;
    updateHOCHostEl(parentComponent, el);
  }
}
function provide(key, value) {
  if (!currentInstance);
  else {
    let provides = currentInstance.provides;
    const parentProvides =
      currentInstance.parent && currentInstance.parent.provides;
    if (parentProvides === provides) {
      provides = currentInstance.provides = Object.create(parentProvides);
    }
    provides[key] = value;
  }
}
function inject(key, defaultValue, treatDefaultAsFactory = false) {
  const instance = currentInstance || currentRenderingInstance;
  if (instance) {
    const provides =
      instance.parent == null
        ? instance.vnode.appContext && instance.vnode.appContext.provides
        : instance.parent.provides;
    if (provides && key in provides) {
      return provides[key];
    } else if (arguments.length > 1) {
      return treatDefaultAsFactory && isFunction$1(defaultValue)
        ? defaultValue.call(instance.proxy)
        : defaultValue;
    } else;
  }
}
function watchEffect(effect2, options) {
  return doWatch(effect2, null, options);
}
function watchPostEffect(effect2, options) {
  return doWatch(effect2, null, { flush: "post" });
}
function watchSyncEffect(effect2, options) {
  return doWatch(effect2, null, { flush: "sync" });
}
function watch(source, cb, options) {
  return doWatch(source, cb, options);
}
function doWatch(
  source,
  cb,
  { immediate, deep, flush, onTrack, onTrigger } = EMPTY_OBJ
) {
  const instance = currentInstance;
  let getter;
  let forceTrigger = false;
  let isMultiSource = false;
  if (isRef(source)) {
    getter = () => source.value;
    forceTrigger = isShallow(source);
  } else if (isReactive(source)) {
    getter = () => source;
    deep = true;
  } else if (isArray(source)) {
    isMultiSource = true;
    forceTrigger = source.some(isReactive);
    getter = () =>
      source.map((s) => {
        if (isRef(s)) {
          return s.value;
        } else if (isReactive(s)) {
          return traverse(s);
        } else if (isFunction$1(s)) {
          return callWithErrorHandling(
            s,
            instance,
            2
            /* WATCH_GETTER */
          );
        } else;
      });
  } else if (isFunction$1(source)) {
    if (cb) {
      getter = () =>
        callWithErrorHandling(
          source,
          instance,
          2
          /* WATCH_GETTER */
        );
    } else {
      getter = () => {
        if (instance && instance.isUnmounted) {
          return;
        }
        if (cleanup) {
          cleanup();
        }
        return callWithAsyncErrorHandling(source, instance, 3, [onCleanup]);
      };
    }
  } else {
    getter = NOOP;
  }
  if (cb && deep) {
    const baseGetter = getter;
    getter = () => traverse(baseGetter());
  }
  let cleanup;
  let onCleanup = (fn) => {
    cleanup = effect2.onStop = () => {
      callWithErrorHandling(
        fn,
        instance,
        4
        /* WATCH_CLEANUP */
      );
    };
  };
  if (isInSSRComponentSetup) {
    onCleanup = NOOP;
    if (!cb) {
      getter();
    } else if (immediate) {
      callWithAsyncErrorHandling(cb, instance, 3, [
        getter(),
        isMultiSource ? [] : void 0,
        onCleanup,
      ]);
    }
    return NOOP;
  }
  let oldValue = isMultiSource ? [] : INITIAL_WATCHER_VALUE;
  const job = () => {
    if (!effect2.active) {
      return;
    }
    if (cb) {
      const newValue = effect2.run();
      if (
        deep ||
        forceTrigger ||
        (isMultiSource
          ? newValue.some((v, i) => hasChanged(v, oldValue[i]))
          : hasChanged(newValue, oldValue)) ||
        false
      ) {
        if (cleanup) {
          cleanup();
        }
        callWithAsyncErrorHandling(cb, instance, 3, [
          newValue,
          // pass undefined as the old value when it's changed for the first time
          oldValue === INITIAL_WATCHER_VALUE ? void 0 : oldValue,
          onCleanup,
        ]);
        oldValue = newValue;
      }
    } else {
      effect2.run();
    }
  };
  job.allowRecurse = !!cb;
  let scheduler;
  if (flush === "sync") {
    scheduler = job;
  } else if (flush === "post") {
    scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);
  } else {
    scheduler = () => {
      if (!instance || instance.isMounted) {
        queuePreFlushCb(job);
      } else {
        job();
      }
    };
  }
  const effect2 = new ReactiveEffect(getter, scheduler);
  if (cb) {
    if (immediate) {
      job();
    } else {
      oldValue = effect2.run();
    }
  } else if (flush === "post") {
    queuePostRenderEffect(
      effect2.run.bind(effect2),
      instance && instance.suspense
    );
  } else {
    effect2.run();
  }
  return () => {
    effect2.stop();
    if (instance && instance.scope) {
      remove(instance.scope.effects, effect2);
    }
  };
}
function instanceWatch(source, value, options) {
  const publicThis = this.proxy;
  const getter = isString$1(source)
    ? source.includes(".")
      ? createPathGetter(publicThis, source)
      : () => publicThis[source]
    : source.bind(publicThis, publicThis);
  let cb;
  if (isFunction$1(value)) {
    cb = value;
  } else {
    cb = value.handler;
    options = value;
  }
  const cur = currentInstance;
  setCurrentInstance(this);
  const res = doWatch(getter, cb.bind(publicThis), options);
  if (cur) {
    setCurrentInstance(cur);
  } else {
    unsetCurrentInstance();
  }
  return res;
}
function createPathGetter(ctx, path) {
  const segments = path.split(".");
  return () => {
    let cur = ctx;
    for (let i = 0; i < segments.length && cur; i++) {
      cur = cur[segments[i]];
    }
    return cur;
  };
}
function traverse(value, seen) {
  if (
    !isObject$f(value) ||
    value[
      "__v_skip"
      /* SKIP */
    ]
  ) {
    return value;
  }
  seen = seen || /* @__PURE__ */ new Set();
  if (seen.has(value)) {
    return value;
  }
  seen.add(value);
  if (isRef(value)) {
    traverse(value.value, seen);
  } else if (isArray(value)) {
    for (let i = 0; i < value.length; i++) {
      traverse(value[i], seen);
    }
  } else if (isSet(value) || isMap(value)) {
    value.forEach((v) => {
      traverse(v, seen);
    });
  } else if (isPlainObject$1(value)) {
    for (const key in value) {
      traverse(value[key], seen);
    }
  }
  return value;
}
function useTransitionState() {
  const state = {
    isMounted: false,
    isLeaving: false,
    isUnmounting: false,
    leavingVNodes: /* @__PURE__ */ new Map(),
  };
  onMounted$1(() => {
    state.isMounted = true;
  });
  onBeforeUnmount(() => {
    state.isUnmounting = true;
  });
  return state;
}
function getLeavingNodesForType(state, vnode) {
  const { leavingVNodes } = state;
  let leavingVNodesCache = leavingVNodes.get(vnode.type);
  if (!leavingVNodesCache) {
    leavingVNodesCache = /* @__PURE__ */ Object.create(null);
    leavingVNodes.set(vnode.type, leavingVNodesCache);
  }
  return leavingVNodesCache;
}
function resolveTransitionHooks(vnode, props, state, instance) {
  const {
    appear,
    mode,
    persisted = false,
    onBeforeEnter,
    onEnter,
    onAfterEnter,
    onEnterCancelled,
    onBeforeLeave,
    onLeave,
    onAfterLeave,
    onLeaveCancelled,
    onBeforeAppear,
    onAppear,
    onAfterAppear,
    onAppearCancelled,
  } = props;
  const key = String(vnode.key);
  const leavingVNodesCache = getLeavingNodesForType(state, vnode);
  const callHook3 = (hook, args) => {
    hook && callWithAsyncErrorHandling(hook, instance, 9, args);
  };
  const hooks = {
    mode,
    persisted,
    beforeEnter(el) {
      let hook = onBeforeEnter;
      if (!state.isMounted) {
        if (appear) {
          hook = onBeforeAppear || onBeforeEnter;
        } else {
          return;
        }
      }
      if (el._leaveCb) {
        el._leaveCb(
          true
          /* cancelled */
        );
      }
      const leavingVNode = leavingVNodesCache[key];
      if (
        leavingVNode &&
        isSameVNodeType(vnode, leavingVNode) &&
        leavingVNode.el._leaveCb
      ) {
        leavingVNode.el._leaveCb();
      }
      callHook3(hook, [el]);
    },
    enter(el) {
      let hook = onEnter;
      let afterHook = onAfterEnter;
      let cancelHook = onEnterCancelled;
      if (!state.isMounted) {
        if (appear) {
          hook = onAppear || onEnter;
          afterHook = onAfterAppear || onAfterEnter;
          cancelHook = onAppearCancelled || onEnterCancelled;
        } else {
          return;
        }
      }
      let called = false;
      const done = (el._enterCb = (cancelled) => {
        if (called) return;
        called = true;
        if (cancelled) {
          callHook3(cancelHook, [el]);
        } else {
          callHook3(afterHook, [el]);
        }
        if (hooks.delayedLeave) {
          hooks.delayedLeave();
        }
        el._enterCb = void 0;
      });
      if (hook) {
        hook(el, done);
        if (hook.length <= 1) {
          done();
        }
      } else {
        done();
      }
    },
    leave(el, remove2) {
      const key2 = String(vnode.key);
      if (el._enterCb) {
        el._enterCb(
          true
          /* cancelled */
        );
      }
      if (state.isUnmounting) {
        return remove2();
      }
      callHook3(onBeforeLeave, [el]);
      let called = false;
      const done = (el._leaveCb = (cancelled) => {
        if (called) return;
        called = true;
        remove2();
        if (cancelled) {
          callHook3(onLeaveCancelled, [el]);
        } else {
          callHook3(onAfterLeave, [el]);
        }
        el._leaveCb = void 0;
        if (leavingVNodesCache[key2] === vnode) {
          delete leavingVNodesCache[key2];
        }
      });
      leavingVNodesCache[key2] = vnode;
      if (onLeave) {
        onLeave(el, done);
        if (onLeave.length <= 1) {
          done();
        }
      } else {
        done();
      }
    },
    clone(vnode2) {
      return resolveTransitionHooks(vnode2, props, state, instance);
    },
  };
  return hooks;
}
function emptyPlaceholder(vnode) {
  if (isKeepAlive(vnode)) {
    vnode = cloneVNode(vnode);
    vnode.children = null;
    return vnode;
  }
}
function getKeepAliveChild(vnode) {
  return isKeepAlive(vnode)
    ? vnode.children
      ? vnode.children[0]
      : void 0
    : vnode;
}
function setTransitionHooks(vnode, hooks) {
  if (vnode.shapeFlag & 6 && vnode.component) {
    setTransitionHooks(vnode.component.subTree, hooks);
  } else if (vnode.shapeFlag & 128) {
    vnode.ssContent.transition = hooks.clone(vnode.ssContent);
    vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
  } else {
    vnode.transition = hooks;
  }
}
function getTransitionRawChildren(children, keepComment = false, parentKey) {
  let ret = [];
  let keyedFragmentCount = 0;
  for (let i = 0; i < children.length; i++) {
    let child = children[i];
    const key =
      parentKey == null
        ? child.key
        : String(parentKey) + String(child.key != null ? child.key : i);
    if (child.type === Fragment) {
      if (child.patchFlag & 128) keyedFragmentCount++;
      ret = ret.concat(
        getTransitionRawChildren(child.children, keepComment, key)
      );
    } else if (keepComment || child.type !== Comment) {
      ret.push(key != null ? cloneVNode(child, { key }) : child);
    }
  }
  if (keyedFragmentCount > 1) {
    for (let i = 0; i < ret.length; i++) {
      ret[i].patchFlag = -2;
    }
  }
  return ret;
}
function defineComponent(options) {
  return isFunction$1(options)
    ? { setup: options, name: options.name }
    : options;
}
function defineAsyncComponent(source) {
  if (isFunction$1(source)) {
    source = { loader: source };
  }
  const {
    loader,
    loadingComponent,
    errorComponent,
    delay = 200,
    timeout,
    // undefined = never times out
    suspensible = true,
    onError: userOnError,
  } = source;
  let pendingRequest = null;
  let resolvedComp;
  let retries = 0;
  const retry = () => {
    retries++;
    pendingRequest = null;
    return load();
  };
  const load = () => {
    let thisRequest;
    return (
      pendingRequest ||
      (thisRequest = pendingRequest =
        loader()
          .catch((err) => {
            err = err instanceof Error ? err : new Error(String(err));
            if (userOnError) {
              return new Promise((resolve2, reject) => {
                const userRetry = () => resolve2(retry());
                const userFail = () => reject(err);
                userOnError(err, userRetry, userFail, retries + 1);
              });
            } else {
              throw err;
            }
          })
          .then((comp) => {
            if (thisRequest !== pendingRequest && pendingRequest) {
              return pendingRequest;
            }
            if (
              comp &&
              (comp.__esModule || comp[Symbol.toStringTag] === "Module")
            ) {
              comp = comp.default;
            }
            resolvedComp = comp;
            return comp;
          }))
    );
  };
  return defineComponent({
    name: "AsyncComponentWrapper",
    __asyncLoader: load,
    get __asyncResolved() {
      return resolvedComp;
    },
    setup() {
      const instance = currentInstance;
      if (resolvedComp) {
        return () => createInnerComp(resolvedComp, instance);
      }
      const onError = (err) => {
        pendingRequest = null;
        handleError(
          err,
          instance,
          13,
          !errorComponent
          /* do not throw in dev if user provided error component */
        );
      };
      if ((suspensible && instance.suspense) || isInSSRComponentSetup) {
        return load()
          .then((comp) => {
            return () => createInnerComp(comp, instance);
          })
          .catch((err) => {
            onError(err);
            return () =>
              errorComponent
                ? createVNode(errorComponent, {
                    error: err,
                  })
                : null;
          });
      }
      const loaded = ref(false);
      const error = ref();
      const delayed = ref(!!delay);
      if (delay) {
        setTimeout(() => {
          delayed.value = false;
        }, delay);
      }
      if (timeout != null) {
        setTimeout(() => {
          if (!loaded.value && !error.value) {
            const err = new Error(
              `Async component timed out after ${timeout}ms.`
            );
            onError(err);
            error.value = err;
          }
        }, timeout);
      }
      load()
        .then(() => {
          loaded.value = true;
          if (instance.parent && isKeepAlive(instance.parent.vnode)) {
            queueJob(instance.parent.update);
          }
        })
        .catch((err) => {
          onError(err);
          error.value = err;
        });
      return () => {
        if (loaded.value && resolvedComp) {
          return createInnerComp(resolvedComp, instance);
        } else if (error.value && errorComponent) {
          return createVNode(errorComponent, {
            error: error.value,
          });
        } else if (loadingComponent && !delayed.value) {
          return createVNode(loadingComponent);
        }
      };
    },
  });
}
function createInnerComp(comp, { vnode: { ref: ref2, props, children } }) {
  const vnode = createVNode(comp, props, children);
  vnode.ref = ref2;
  return vnode;
}
function matches(pattern, name) {
  if (isArray(pattern)) {
    return pattern.some((p2) => matches(p2, name));
  } else if (isString$1(pattern)) {
    return pattern.split(",").includes(name);
  } else if (pattern.test) {
    return pattern.test(name);
  }
  return false;
}
function onActivated(hook, target) {
  registerKeepAliveHook(hook, "a", target);
}
function onDeactivated(hook, target) {
  registerKeepAliveHook(hook, "da", target);
}
function registerKeepAliveHook(hook, type, target = currentInstance) {
  const wrappedHook =
    hook.__wdc ||
    (hook.__wdc = () => {
      let current = target;
      while (current) {
        if (current.isDeactivated) {
          return;
        }
        current = current.parent;
      }
      return hook();
    });
  injectHook(type, wrappedHook, target);
  if (target) {
    let current = target.parent;
    while (current && current.parent) {
      if (isKeepAlive(current.parent.vnode)) {
        injectToKeepAliveRoot(wrappedHook, type, target, current);
      }
      current = current.parent;
    }
  }
}
function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
  const injected = injectHook(
    type,
    hook,
    keepAliveRoot,
    true
    /* prepend */
  );
  onUnmounted$1(() => {
    remove(keepAliveRoot[type], injected);
  }, target);
}
function resetShapeFlag(vnode) {
  let shapeFlag = vnode.shapeFlag;
  if (shapeFlag & 256) {
    shapeFlag -= 256;
  }
  if (shapeFlag & 512) {
    shapeFlag -= 512;
  }
  vnode.shapeFlag = shapeFlag;
}
function getInnerChild(vnode) {
  return vnode.shapeFlag & 128 ? vnode.ssContent : vnode;
}
function injectHook(type, hook, target = currentInstance, prepend = false) {
  if (target) {
    const hooks = target[type] || (target[type] = []);
    const wrappedHook =
      hook.__weh ||
      (hook.__weh = (...args) => {
        if (target.isUnmounted) {
          return;
        }
        pauseTracking();
        setCurrentInstance(target);
        const res = callWithAsyncErrorHandling(hook, target, type, args);
        unsetCurrentInstance();
        resetTracking();
        return res;
      });
    if (prepend) {
      hooks.unshift(wrappedHook);
    } else {
      hooks.push(wrappedHook);
    }
    return wrappedHook;
  }
}
function onErrorCaptured(hook, target = currentInstance) {
  injectHook("ec", hook, target);
}
function applyOptions(instance) {
  const options = resolveMergedOptions(instance);
  const publicThis = instance.proxy;
  const ctx = instance.ctx;
  shouldCacheAccess = false;
  if (options.beforeCreate) {
    callHook(
      options.beforeCreate,
      instance,
      "bc"
      /* BEFORE_CREATE */
    );
  }
  const {
    // state
    data: dataOptions,
    computed: computedOptions,
    methods,
    watch: watchOptions,
    provide: provideOptions,
    inject: injectOptions,
    // lifecycle
    created,
    beforeMount,
    mounted,
    beforeUpdate,
    updated,
    activated,
    deactivated,
    beforeDestroy,
    beforeUnmount,
    destroyed,
    unmounted,
    render: render2,
    renderTracked,
    renderTriggered,
    errorCaptured,
    serverPrefetch,
    // public API
    expose,
    inheritAttrs,
    // assets
    components,
    directives,
    filters,
  } = options;
  const checkDuplicateProperties = null;
  if (injectOptions) {
    resolveInjections(
      injectOptions,
      ctx,
      checkDuplicateProperties,
      instance.appContext.config.unwrapInjectedRef
    );
  }
  if (methods) {
    for (const key in methods) {
      const methodHandler = methods[key];
      if (isFunction$1(methodHandler)) {
        {
          ctx[key] = methodHandler.bind(publicThis);
        }
      }
    }
  }
  if (dataOptions) {
    const data = dataOptions.call(publicThis, publicThis);
    if (!isObject$f(data));
    else {
      instance.data = reactive(data);
    }
  }
  shouldCacheAccess = true;
  if (computedOptions) {
    for (const key in computedOptions) {
      const opt = computedOptions[key];
      const get2 = isFunction$1(opt)
        ? opt.bind(publicThis, publicThis)
        : isFunction$1(opt.get)
        ? opt.get.bind(publicThis, publicThis)
        : NOOP;
      const set2 =
        !isFunction$1(opt) && isFunction$1(opt.set)
          ? opt.set.bind(publicThis)
          : NOOP;
      const c = computed2({
        get: get2,
        set: set2,
      });
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => c.value,
        set: (v) => (c.value = v),
      });
    }
  }
  if (watchOptions) {
    for (const key in watchOptions) {
      createWatcher(watchOptions[key], ctx, publicThis, key);
    }
  }
  if (provideOptions) {
    const provides = isFunction$1(provideOptions)
      ? provideOptions.call(publicThis)
      : provideOptions;
    Reflect.ownKeys(provides).forEach((key) => {
      provide(key, provides[key]);
    });
  }
  if (created) {
    callHook(
      created,
      instance,
      "c"
      /* CREATED */
    );
  }
  function registerLifecycleHook(register, hook) {
    if (isArray(hook)) {
      hook.forEach((_hook) => register(_hook.bind(publicThis)));
    } else if (hook) {
      register(hook.bind(publicThis));
    }
  }
  registerLifecycleHook(onBeforeMount, beforeMount);
  registerLifecycleHook(onMounted$1, mounted);
  registerLifecycleHook(onBeforeUpdate, beforeUpdate);
  registerLifecycleHook(onUpdated$1, updated);
  registerLifecycleHook(onActivated, activated);
  registerLifecycleHook(onDeactivated, deactivated);
  registerLifecycleHook(onErrorCaptured, errorCaptured);
  registerLifecycleHook(onRenderTracked, renderTracked);
  registerLifecycleHook(onRenderTriggered, renderTriggered);
  registerLifecycleHook(onBeforeUnmount, beforeUnmount);
  registerLifecycleHook(onUnmounted$1, unmounted);
  registerLifecycleHook(onServerPrefetch, serverPrefetch);
  if (isArray(expose)) {
    if (expose.length) {
      const exposed = instance.exposed || (instance.exposed = {});
      expose.forEach((key) => {
        Object.defineProperty(exposed, key, {
          get: () => publicThis[key],
          set: (val) => (publicThis[key] = val),
        });
      });
    } else if (!instance.exposed) {
      instance.exposed = {};
    }
  }
  if (render2 && instance.render === NOOP) {
    instance.render = render2;
  }
  if (inheritAttrs != null) {
    instance.inheritAttrs = inheritAttrs;
  }
  if (components) instance.components = components;
  if (directives) instance.directives = directives;
}
function resolveInjections(
  injectOptions,
  ctx,
  checkDuplicateProperties = NOOP,
  unwrapRef = false
) {
  if (isArray(injectOptions)) {
    injectOptions = normalizeInject(injectOptions);
  }
  for (const key in injectOptions) {
    const opt = injectOptions[key];
    let injected;
    if (isObject$f(opt)) {
      if ("default" in opt) {
        injected = inject(
          opt.from || key,
          opt.default,
          true
          /* treat default function as factory */
        );
      } else {
        injected = inject(opt.from || key);
      }
    } else {
      injected = inject(opt);
    }
    if (isRef(injected)) {
      if (unwrapRef) {
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          get: () => injected.value,
          set: (v) => (injected.value = v),
        });
      } else {
        ctx[key] = injected;
      }
    } else {
      ctx[key] = injected;
    }
  }
}
function callHook(hook, instance, type) {
  callWithAsyncErrorHandling(
    isArray(hook)
      ? hook.map((h2) => h2.bind(instance.proxy))
      : hook.bind(instance.proxy),
    instance,
    type
  );
}
function createWatcher(raw, ctx, publicThis, key) {
  const getter = key.includes(".")
    ? createPathGetter(publicThis, key)
    : () => publicThis[key];
  if (isString$1(raw)) {
    const handler = ctx[raw];
    if (isFunction$1(handler)) {
      watch(getter, handler);
    }
  } else if (isFunction$1(raw)) {
    watch(getter, raw.bind(publicThis));
  } else if (isObject$f(raw)) {
    if (isArray(raw)) {
      raw.forEach((r) => createWatcher(r, ctx, publicThis, key));
    } else {
      const handler = isFunction$1(raw.handler)
        ? raw.handler.bind(publicThis)
        : ctx[raw.handler];
      if (isFunction$1(handler)) {
        watch(getter, handler, raw);
      }
    }
  } else;
}
function resolveMergedOptions(instance) {
  const base = instance.type;
  const { mixins, extends: extendsOptions } = base;
  const {
    mixins: globalMixins,
    optionsCache: cache,
    config: { optionMergeStrategies },
  } = instance.appContext;
  const cached = cache.get(base);
  let resolved;
  if (cached) {
    resolved = cached;
  } else if (!globalMixins.length && !mixins && !extendsOptions) {
    {
      resolved = base;
    }
  } else {
    resolved = {};
    if (globalMixins.length) {
      globalMixins.forEach((m) =>
        mergeOptions$1(resolved, m, optionMergeStrategies, true)
      );
    }
    mergeOptions$1(resolved, base, optionMergeStrategies);
  }
  cache.set(base, resolved);
  return resolved;
}
function mergeOptions$1(to, from, strats, asMixin = false) {
  const { mixins, extends: extendsOptions } = from;
  if (extendsOptions) {
    mergeOptions$1(to, extendsOptions, strats, true);
  }
  if (mixins) {
    mixins.forEach((m) => mergeOptions$1(to, m, strats, true));
  }
  for (const key in from) {
    if (asMixin && key === "expose");
    else {
      const strat = internalOptionMergeStrats[key] || (strats && strats[key]);
      to[key] = strat ? strat(to[key], from[key]) : from[key];
    }
  }
  return to;
}
function mergeDataFn(to, from) {
  if (!from) {
    return to;
  }
  if (!to) {
    return from;
  }
  return function mergedDataFn() {
    return extend(
      isFunction$1(to) ? to.call(this, this) : to,
      isFunction$1(from) ? from.call(this, this) : from
    );
  };
}
function mergeInject(to, from) {
  return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
}
function normalizeInject(raw) {
  if (isArray(raw)) {
    const res = {};
    for (let i = 0; i < raw.length; i++) {
      res[raw[i]] = raw[i];
    }
    return res;
  }
  return raw;
}
function mergeAsArray$1(to, from) {
  return to ? [...new Set([].concat(to, from))] : from;
}
function mergeObjectOptions(to, from) {
  return to
    ? extend(extend(/* @__PURE__ */ Object.create(null), to), from)
    : from;
}
function mergeWatchOptions(to, from) {
  if (!to) return from;
  if (!from) return to;
  const merged = extend(/* @__PURE__ */ Object.create(null), to);
  for (const key in from) {
    merged[key] = mergeAsArray$1(to[key], from[key]);
  }
  return merged;
}
function initProps(instance, rawProps, isStateful, isSSR = false) {
  const props = {};
  const attrs = {};
  def(attrs, InternalObjectKey, 1);
  instance.propsDefaults = /* @__PURE__ */ Object.create(null);
  setFullProps(instance, rawProps, props, attrs);
  for (const key in instance.propsOptions[0]) {
    if (!(key in props)) {
      props[key] = void 0;
    }
  }
  if (isStateful) {
    instance.props = isSSR ? props : shallowReactive(props);
  } else {
    if (!instance.type.props) {
      instance.props = attrs;
    } else {
      instance.props = props;
    }
  }
  instance.attrs = attrs;
}
function updateProps(instance, rawProps, rawPrevProps, optimized) {
  const {
    props,
    attrs,
    vnode: { patchFlag },
  } = instance;
  const rawCurrentProps = toRaw(props);
  const [options] = instance.propsOptions;
  let hasAttrsChanged = false;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    (optimized || patchFlag > 0) &&
    !(patchFlag & 16)
  ) {
    if (patchFlag & 8) {
      const propsToUpdate = instance.vnode.dynamicProps;
      for (let i = 0; i < propsToUpdate.length; i++) {
        let key = propsToUpdate[i];
        if (isEmitListener(instance.emitsOptions, key)) {
          continue;
        }
        const value = rawProps[key];
        if (options) {
          if (hasOwn(attrs, key)) {
            if (value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          } else {
            const camelizedKey = camelize(key);
            props[camelizedKey] = resolvePropValue(
              options,
              rawCurrentProps,
              camelizedKey,
              value,
              instance,
              false
              /* isAbsent */
            );
          }
        } else {
          if (value !== attrs[key]) {
            attrs[key] = value;
            hasAttrsChanged = true;
          }
        }
      }
    }
  } else {
    if (setFullProps(instance, rawProps, props, attrs)) {
      hasAttrsChanged = true;
    }
    let kebabKey;
    for (const key in rawCurrentProps) {
      if (
        !rawProps || // for camelCase
        (!hasOwn(rawProps, key) && // it's possible the original props was passed in as kebab-case
          // and converted to camelCase (#955)
          ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey)))
      ) {
        if (options) {
          if (
            rawPrevProps && // for camelCase
            (rawPrevProps[key] !== void 0 || // for kebab-case
              rawPrevProps[kebabKey] !== void 0)
          ) {
            props[key] = resolvePropValue(
              options,
              rawCurrentProps,
              key,
              void 0,
              instance,
              true
              /* isAbsent */
            );
          }
        } else {
          delete props[key];
        }
      }
    }
    if (attrs !== rawCurrentProps) {
      for (const key in attrs) {
        if (!rawProps || (!hasOwn(rawProps, key) && true)) {
          delete attrs[key];
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (hasAttrsChanged) {
    trigger(instance, "set", "$attrs");
  }
}
function setFullProps(instance, rawProps, props, attrs) {
  const [options, needCastKeys] = instance.propsOptions;
  let hasAttrsChanged = false;
  let rawCastValues;
  if (rawProps) {
    for (let key in rawProps) {
      if (isReservedProp(key)) {
        continue;
      }
      const value = rawProps[key];
      let camelKey;
      if (options && hasOwn(options, (camelKey = camelize(key)))) {
        if (!needCastKeys || !needCastKeys.includes(camelKey)) {
          props[camelKey] = value;
        } else {
          (rawCastValues || (rawCastValues = {}))[camelKey] = value;
        }
      } else if (!isEmitListener(instance.emitsOptions, key)) {
        if (!(key in attrs) || value !== attrs[key]) {
          attrs[key] = value;
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (needCastKeys) {
    const rawCurrentProps = toRaw(props);
    const castValues = rawCastValues || EMPTY_OBJ;
    for (let i = 0; i < needCastKeys.length; i++) {
      const key = needCastKeys[i];
      props[key] = resolvePropValue(
        options,
        rawCurrentProps,
        key,
        castValues[key],
        instance,
        !hasOwn(castValues, key)
      );
    }
  }
  return hasAttrsChanged;
}
function resolvePropValue(options, props, key, value, instance, isAbsent) {
  const opt = options[key];
  if (opt != null) {
    const hasDefault = hasOwn(opt, "default");
    if (hasDefault && value === void 0) {
      const defaultValue = opt.default;
      if (opt.type !== Function && isFunction$1(defaultValue)) {
        const { propsDefaults } = instance;
        if (key in propsDefaults) {
          value = propsDefaults[key];
        } else {
          setCurrentInstance(instance);
          value = propsDefaults[key] = defaultValue.call(null, props);
          unsetCurrentInstance();
        }
      } else {
        value = defaultValue;
      }
    }
    if (
      opt[0]
      /* shouldCast */
    ) {
      if (isAbsent && !hasDefault) {
        value = false;
      } else if (
        opt[1] &&
        /* shouldCastTrue */
        (value === "" || value === hyphenate(key))
      ) {
        value = true;
      }
    }
  }
  return value;
}
function normalizePropsOptions(comp, appContext, asMixin = false) {
  const cache = appContext.propsCache;
  const cached = cache.get(comp);
  if (cached) {
    return cached;
  }
  const raw = comp.props;
  const normalized = {};
  const needCastKeys = [];
  let hasExtends = false;
  if (!isFunction$1(comp)) {
    const extendProps = (raw2) => {
      hasExtends = true;
      const [props, keys] = normalizePropsOptions(raw2, appContext, true);
      extend(normalized, props);
      if (keys) needCastKeys.push(...keys);
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendProps);
    }
    if (comp.extends) {
      extendProps(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendProps);
    }
  }
  if (!raw && !hasExtends) {
    cache.set(comp, EMPTY_ARR);
    return EMPTY_ARR;
  }
  if (isArray(raw)) {
    for (let i = 0; i < raw.length; i++) {
      const normalizedKey = camelize(raw[i]);
      if (validatePropName(normalizedKey)) {
        normalized[normalizedKey] = EMPTY_OBJ;
      }
    }
  } else if (raw) {
    for (const key in raw) {
      const normalizedKey = camelize(key);
      if (validatePropName(normalizedKey)) {
        const opt = raw[key];
        const prop = (normalized[normalizedKey] =
          isArray(opt) || isFunction$1(opt) ? { type: opt } : opt);
        if (prop) {
          const booleanIndex = getTypeIndex(Boolean, prop.type);
          const stringIndex = getTypeIndex(String, prop.type);
          prop[0] = booleanIndex > -1;
          /* shouldCast */
          prop[1] = stringIndex < 0 || booleanIndex < stringIndex;
          /* shouldCastTrue */
          if (booleanIndex > -1 || hasOwn(prop, "default")) {
            needCastKeys.push(normalizedKey);
          }
        }
      }
    }
  }
  const res = [normalized, needCastKeys];
  cache.set(comp, res);
  return res;
}
function validatePropName(key) {
  if (key[0] !== "$") {
    return true;
  }
  return false;
}
function getType(ctor) {
  const match = ctor && ctor.toString().match(/^\s*function (\w+)/);
  return match ? match[1] : ctor === null ? "null" : "";
}
function isSameType(a, b) {
  return getType(a) === getType(b);
}
function getTypeIndex(type, expectedTypes) {
  if (isArray(expectedTypes)) {
    return expectedTypes.findIndex((t) => isSameType(t, type));
  } else if (isFunction$1(expectedTypes)) {
    return isSameType(expectedTypes, type) ? 0 : -1;
  }
  return -1;
}
function withDirectives(vnode, directives) {
  const internalInstance = currentRenderingInstance;
  if (internalInstance === null) {
    return vnode;
  }
  const instance = getExposeProxy(internalInstance) || internalInstance.proxy;
  const bindings = vnode.dirs || (vnode.dirs = []);
  for (let i = 0; i < directives.length; i++) {
    let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i];
    if (isFunction$1(dir)) {
      dir = {
        mounted: dir,
        updated: dir,
      };
    }
    if (dir.deep) {
      traverse(value);
    }
    bindings.push({
      dir,
      instance,
      value,
      oldValue: void 0,
      arg,
      modifiers,
    });
  }
  return vnode;
}
function invokeDirectiveHook(vnode, prevVNode, instance, name) {
  const bindings = vnode.dirs;
  const oldBindings = prevVNode && prevVNode.dirs;
  for (let i = 0; i < bindings.length; i++) {
    const binding = bindings[i];
    if (oldBindings) {
      binding.oldValue = oldBindings[i].value;
    }
    let hook = binding.dir[name];
    if (hook) {
      pauseTracking();
      callWithAsyncErrorHandling(hook, instance, 8, [
        vnode.el,
        binding,
        vnode,
        prevVNode,
      ]);
      resetTracking();
    }
  }
}
function createAppContext() {
  return {
    app: null,
    config: {
      isNativeTag: NO,
      performance: false,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {},
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap(),
  };
}
function createAppAPI(render2, hydrate2) {
  return function createApp2(rootComponent, rootProps = null) {
    if (!isFunction$1(rootComponent)) {
      rootComponent = Object.assign({}, rootComponent);
    }
    if (rootProps != null && !isObject$f(rootProps)) {
      rootProps = null;
    }
    const context = createAppContext();
    const installedPlugins = /* @__PURE__ */ new Set();
    let isMounted = false;
    const app = (context.app = {
      _uid: uid$6++,
      _component: rootComponent,
      _props: rootProps,
      _container: null,
      _context: context,
      _instance: null,
      version: version$4,
      get config() {
        return context.config;
      },
      set config(v) {},
      use(plugin, ...options) {
        if (installedPlugins.has(plugin));
        else if (plugin && isFunction$1(plugin.install)) {
          installedPlugins.add(plugin);
          plugin.install(app, ...options);
        } else if (isFunction$1(plugin)) {
          installedPlugins.add(plugin);
          plugin(app, ...options);
        } else;
        return app;
      },
      mixin(mixin) {
        {
          if (!context.mixins.includes(mixin)) {
            context.mixins.push(mixin);
          }
        }
        return app;
      },
      component(name, component) {
        if (!component) {
          return context.components[name];
        }
        context.components[name] = component;
        return app;
      },
      directive(name, directive) {
        if (!directive) {
          return context.directives[name];
        }
        context.directives[name] = directive;
        return app;
      },
      mount(rootContainer, isHydrate, isSVG) {
        if (!isMounted) {
          const vnode = createVNode(rootComponent, rootProps);
          vnode.appContext = context;
          if (isHydrate && hydrate2) {
            hydrate2(vnode, rootContainer);
          } else {
            render2(vnode, rootContainer, isSVG);
          }
          isMounted = true;
          app._container = rootContainer;
          rootContainer.__vue_app__ = app;
          return getExposeProxy(vnode.component) || vnode.component.proxy;
        }
      },
      unmount() {
        if (isMounted) {
          render2(null, app._container);
          delete app._container.__vue_app__;
        }
      },
      provide(key, value) {
        context.provides[key] = value;
        return app;
      },
    });
    return app;
  };
}
function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
  if (isArray(rawRef)) {
    rawRef.forEach((r, i) =>
      setRef(
        r,
        oldRawRef && (isArray(oldRawRef) ? oldRawRef[i] : oldRawRef),
        parentSuspense,
        vnode,
        isUnmount
      )
    );
    return;
  }
  if (isAsyncWrapper(vnode) && !isUnmount) {
    return;
  }
  const refValue =
    vnode.shapeFlag & 4
      ? getExposeProxy(vnode.component) || vnode.component.proxy
      : vnode.el;
  const value = isUnmount ? null : refValue;
  const { i: owner, r: ref2 } = rawRef;
  const oldRef = oldRawRef && oldRawRef.r;
  const refs = owner.refs === EMPTY_OBJ ? (owner.refs = {}) : owner.refs;
  const setupState = owner.setupState;
  if (oldRef != null && oldRef !== ref2) {
    if (isString$1(oldRef)) {
      refs[oldRef] = null;
      if (hasOwn(setupState, oldRef)) {
        setupState[oldRef] = null;
      }
    } else if (isRef(oldRef)) {
      oldRef.value = null;
    }
  }
  if (isFunction$1(ref2)) {
    callWithErrorHandling(ref2, owner, 12, [value, refs]);
  } else {
    const _isString = isString$1(ref2);
    const _isRef = isRef(ref2);
    if (_isString || _isRef) {
      const doSet = () => {
        if (rawRef.f) {
          const existing = _isString ? refs[ref2] : ref2.value;
          if (isUnmount) {
            isArray(existing) && remove(existing, refValue);
          } else {
            if (!isArray(existing)) {
              if (_isString) {
                refs[ref2] = [refValue];
                if (hasOwn(setupState, ref2)) {
                  setupState[ref2] = refs[ref2];
                }
              } else {
                ref2.value = [refValue];
                if (rawRef.k) refs[rawRef.k] = ref2.value;
              }
            } else if (!existing.includes(refValue)) {
              existing.push(refValue);
            }
          }
        } else if (_isString) {
          refs[ref2] = value;
          if (hasOwn(setupState, ref2)) {
            setupState[ref2] = value;
          }
        } else if (isRef(ref2)) {
          ref2.value = value;
          if (rawRef.k) refs[rawRef.k] = value;
        } else;
      };
      if (value) {
        doSet.id = -1;
        queuePostRenderEffect(doSet, parentSuspense);
      } else {
        doSet();
      }
    }
  }
}
function createHydrationFunctions(rendererInternals) {
  const {
    mt: mountComponent,
    p: patch,
    o: {
      patchProp: patchProp2,
      nextSibling,
      parentNode,
      remove: remove2,
      insert,
      createComment,
    },
  } = rendererInternals;
  const hydrate2 = (vnode, container) => {
    if (!container.hasChildNodes()) {
      patch(null, vnode, container);
      flushPostFlushCbs();
      return;
    }
    hasMismatch = false;
    hydrateNode(container.firstChild, vnode, null, null, null);
    flushPostFlushCbs();
    if (hasMismatch && true) {
      console.error(`Hydration completed but contains mismatches.`);
    }
  };
  const hydrateNode = (
    node,
    vnode,
    parentComponent,
    parentSuspense,
    slotScopeIds,
    optimized = false
  ) => {
    const isFragmentStart = isComment(node) && node.data === "[";
    const onMismatch = () =>
      handleMismatch(
        node,
        vnode,
        parentComponent,
        parentSuspense,
        slotScopeIds,
        isFragmentStart
      );
    const { type, ref: ref2, shapeFlag } = vnode;
    const domType = node.nodeType;
    vnode.el = node;
    let nextNode = null;
    switch (type) {
      case Text:
        if (domType !== 3) {
          nextNode = onMismatch();
        } else {
          if (node.data !== vnode.children) {
            hasMismatch = true;
            node.data = vnode.children;
          }
          nextNode = nextSibling(node);
        }
        break;
      case Comment:
        if (domType !== 8 || isFragmentStart) {
          nextNode = onMismatch();
        } else {
          nextNode = nextSibling(node);
        }
        break;
      case Static:
        if (domType !== 1) {
          nextNode = onMismatch();
        } else {
          nextNode = node;
          const needToAdoptContent = !vnode.children.length;
          for (let i = 0; i < vnode.staticCount; i++) {
            if (needToAdoptContent) vnode.children += nextNode.outerHTML;
            if (i === vnode.staticCount - 1) {
              vnode.anchor = nextNode;
            }
            nextNode = nextSibling(nextNode);
          }
          return nextNode;
        }
        break;
      case Fragment:
        if (!isFragmentStart) {
          nextNode = onMismatch();
        } else {
          nextNode = hydrateFragment(
            node,
            vnode,
            parentComponent,
            parentSuspense,
            slotScopeIds,
            optimized
          );
        }
        break;
      default:
        if (shapeFlag & 1) {
          if (
            domType !== 1 ||
            vnode.type.toLowerCase() !== node.tagName.toLowerCase()
          ) {
            nextNode = onMismatch();
          } else {
            nextNode = hydrateElement(
              node,
              vnode,
              parentComponent,
              parentSuspense,
              slotScopeIds,
              optimized
            );
          }
        } else if (shapeFlag & 6) {
          vnode.slotScopeIds = slotScopeIds;
          const container = parentNode(node);
          mountComponent(
            vnode,
            container,
            null,
            parentComponent,
            parentSuspense,
            isSVGContainer(container),
            optimized
          );
          nextNode = isFragmentStart
            ? locateClosingAsyncAnchor(node)
            : nextSibling(node);
          if (isAsyncWrapper(vnode)) {
            let subTree;
            if (isFragmentStart) {
              subTree = createVNode(Fragment);
              subTree.anchor = nextNode
                ? nextNode.previousSibling
                : container.lastChild;
            } else {
              subTree =
                node.nodeType === 3 ? createTextVNode("") : createVNode("div");
            }
            subTree.el = node;
            vnode.component.subTree = subTree;
          }
        } else if (shapeFlag & 64) {
          if (domType !== 8) {
            nextNode = onMismatch();
          } else {
            nextNode = vnode.type.hydrate(
              node,
              vnode,
              parentComponent,
              parentSuspense,
              slotScopeIds,
              optimized,
              rendererInternals,
              hydrateChildren
            );
          }
        } else if (shapeFlag & 128) {
          nextNode = vnode.type.hydrate(
            node,
            vnode,
            parentComponent,
            parentSuspense,
            isSVGContainer(parentNode(node)),
            slotScopeIds,
            optimized,
            rendererInternals,
            hydrateNode
          );
        } else;
    }
    if (ref2 != null) {
      setRef(ref2, null, parentSuspense, vnode);
    }
    return nextNode;
  };
  const hydrateElement = (
    el,
    vnode,
    parentComponent,
    parentSuspense,
    slotScopeIds,
    optimized
  ) => {
    optimized = optimized || !!vnode.dynamicChildren;
    const { type, props, patchFlag, shapeFlag, dirs } = vnode;
    const forcePatchValue = (type === "input" && dirs) || type === "option";
    if (forcePatchValue || patchFlag !== -1) {
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "created");
      }
      if (props) {
        if (forcePatchValue || !optimized || patchFlag & (16 | 32)) {
          for (const key in props) {
            if (
              (forcePatchValue && key.endsWith("value")) ||
              (isOn(key) && !isReservedProp(key))
            ) {
              patchProp2(
                el,
                key,
                null,
                props[key],
                false,
                void 0,
                parentComponent
              );
            }
          }
        } else if (props.onClick) {
          patchProp2(
            el,
            "onClick",
            null,
            props.onClick,
            false,
            void 0,
            parentComponent
          );
        }
      }
      let vnodeHooks;
      if ((vnodeHooks = props && props.onVnodeBeforeMount)) {
        invokeVNodeHook(vnodeHooks, parentComponent, vnode);
      }
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
      }
      if ((vnodeHooks = props && props.onVnodeMounted) || dirs) {
        queueEffectWithSuspense(() => {
          vnodeHooks && invokeVNodeHook(vnodeHooks, parentComponent, vnode);
          dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
        }, parentSuspense);
      }
      if (
        shapeFlag & 16 && // skip if element has innerHTML / textContent
        !(props && (props.innerHTML || props.textContent))
      ) {
        let next = hydrateChildren(
          el.firstChild,
          vnode,
          el,
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized
        );
        while (next) {
          hasMismatch = true;
          const cur = next;
          next = next.nextSibling;
          remove2(cur);
        }
      } else if (shapeFlag & 8) {
        if (el.textContent !== vnode.children) {
          hasMismatch = true;
          el.textContent = vnode.children;
        }
      }
    }
    return el.nextSibling;
  };
  const hydrateChildren = (
    node,
    parentVNode,
    container,
    parentComponent,
    parentSuspense,
    slotScopeIds,
    optimized
  ) => {
    optimized = optimized || !!parentVNode.dynamicChildren;
    const children = parentVNode.children;
    const l = children.length;
    for (let i = 0; i < l; i++) {
      const vnode = optimized
        ? children[i]
        : (children[i] = normalizeVNode(children[i]));
      if (node) {
        node = hydrateNode(
          node,
          vnode,
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized
        );
      } else if (vnode.type === Text && !vnode.children) {
        continue;
      } else {
        hasMismatch = true;
        patch(
          null,
          vnode,
          container,
          null,
          parentComponent,
          parentSuspense,
          isSVGContainer(container),
          slotScopeIds
        );
      }
    }
    return node;
  };
  const hydrateFragment = (
    node,
    vnode,
    parentComponent,
    parentSuspense,
    slotScopeIds,
    optimized
  ) => {
    const { slotScopeIds: fragmentSlotScopeIds } = vnode;
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds
        ? slotScopeIds.concat(fragmentSlotScopeIds)
        : fragmentSlotScopeIds;
    }
    const container = parentNode(node);
    const next = hydrateChildren(
      nextSibling(node),
      vnode,
      container,
      parentComponent,
      parentSuspense,
      slotScopeIds,
      optimized
    );
    if (next && isComment(next) && next.data === "]") {
      return nextSibling((vnode.anchor = next));
    } else {
      hasMismatch = true;
      insert((vnode.anchor = createComment(`]`)), container, next);
      return next;
    }
  };
  const handleMismatch = (
    node,
    vnode,
    parentComponent,
    parentSuspense,
    slotScopeIds,
    isFragment
  ) => {
    hasMismatch = true;
    vnode.el = null;
    if (isFragment) {
      const end = locateClosingAsyncAnchor(node);
      while (true) {
        const next2 = nextSibling(node);
        if (next2 && next2 !== end) {
          remove2(next2);
        } else {
          break;
        }
      }
    }
    const next = nextSibling(node);
    const container = parentNode(node);
    remove2(node);
    patch(
      null,
      vnode,
      container,
      next,
      parentComponent,
      parentSuspense,
      isSVGContainer(container),
      slotScopeIds
    );
    return next;
  };
  const locateClosingAsyncAnchor = (node) => {
    let match = 0;
    while (node) {
      node = nextSibling(node);
      if (node && isComment(node)) {
        if (node.data === "[") match++;
        if (node.data === "]") {
          if (match === 0) {
            return nextSibling(node);
          } else {
            match--;
          }
        }
      }
    }
    return node;
  };
  return [hydrate2, hydrateNode];
}
function createRenderer(options) {
  return baseCreateRenderer(options);
}
function createHydrationRenderer(options) {
  return baseCreateRenderer(options, createHydrationFunctions);
}
function baseCreateRenderer(options, createHydrationFns) {
  const target = getGlobalThis();
  target.__VUE__ = true;
  const {
    insert: hostInsert,
    remove: hostRemove,
    patchProp: hostPatchProp,
    createElement: hostCreateElement,
    createText: hostCreateText,
    createComment: hostCreateComment,
    setText: hostSetText,
    setElementText: hostSetElementText,
    parentNode: hostParentNode,
    nextSibling: hostNextSibling,
    setScopeId: hostSetScopeId = NOOP,
    cloneNode: hostCloneNode,
    insertStaticContent: hostInsertStaticContent,
  } = options;
  const patch = (
    n1,
    n2,
    container,
    anchor = null,
    parentComponent = null,
    parentSuspense = null,
    isSVG = false,
    slotScopeIds = null,
    optimized = !!n2.dynamicChildren
  ) => {
    if (n1 === n2) {
      return;
    }
    if (n1 && !isSameVNodeType(n1, n2)) {
      anchor = getNextHostNode(n1);
      unmount(n1, parentComponent, parentSuspense, true);
      n1 = null;
    }
    if (n2.patchFlag === -2) {
      optimized = false;
      n2.dynamicChildren = null;
    }
    const { type, ref: ref2, shapeFlag } = n2;
    switch (type) {
      case Text:
        processText(n1, n2, container, anchor);
        break;
      case Comment:
        processCommentNode(n1, n2, container, anchor);
        break;
      case Static:
        if (n1 == null) {
          mountStaticNode(n2, container, anchor, isSVG);
        }
        break;
      case Fragment:
        processFragment(
          n1,
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds,
          optimized
        );
        break;
      default:
        if (shapeFlag & 1) {
          processElement(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
        } else if (shapeFlag & 6) {
          processComponent(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
        } else if (shapeFlag & 64) {
          type.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized,
            internals
          );
        } else if (shapeFlag & 128) {
          type.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized,
            internals
          );
        } else;
    }
    if (ref2 != null && parentComponent) {
      setRef(ref2, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
    }
  };
  const processText = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert((n2.el = hostCreateText(n2.children)), container, anchor);
    } else {
      const el = (n2.el = n1.el);
      if (n2.children !== n1.children) {
        hostSetText(el, n2.children);
      }
    }
  };
  const processCommentNode = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(
        (n2.el = hostCreateComment(n2.children || "")),
        container,
        anchor
      );
    } else {
      n2.el = n1.el;
    }
  };
  const mountStaticNode = (n2, container, anchor, isSVG) => {
    [n2.el, n2.anchor] = hostInsertStaticContent(
      n2.children,
      container,
      anchor,
      isSVG,
      n2.el,
      n2.anchor
    );
  };
  const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostInsert(el, container, nextSibling);
      el = next;
    }
    hostInsert(anchor, container, nextSibling);
  };
  const removeStaticNode = ({ el, anchor }) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostRemove(el);
      el = next;
    }
    hostRemove(anchor);
  };
  const processElement = (
    n1,
    n2,
    container,
    anchor,
    parentComponent,
    parentSuspense,
    isSVG,
    slotScopeIds,
    optimized
  ) => {
    isSVG = isSVG || n2.type === "svg";
    if (n1 == null) {
      mountElement(
        n2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized
      );
    } else {
      patchElement(
        n1,
        n2,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized
      );
    }
  };
  const mountElement = (
    vnode,
    container,
    anchor,
    parentComponent,
    parentSuspense,
    isSVG,
    slotScopeIds,
    optimized
  ) => {
    let el;
    let vnodeHook;
    const { type, props, shapeFlag, transition, patchFlag, dirs } = vnode;
    if (vnode.el && hostCloneNode !== void 0 && patchFlag === -1) {
      el = vnode.el = hostCloneNode(vnode.el);
    } else {
      el = vnode.el = hostCreateElement(
        vnode.type,
        isSVG,
        props && props.is,
        props
      );
      if (shapeFlag & 8) {
        hostSetElementText(el, vnode.children);
      } else if (shapeFlag & 16) {
        mountChildren(
          vnode.children,
          el,
          null,
          parentComponent,
          parentSuspense,
          isSVG && type !== "foreignObject",
          slotScopeIds,
          optimized
        );
      }
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "created");
      }
      if (props) {
        for (const key in props) {
          if (key !== "value" && !isReservedProp(key)) {
            hostPatchProp(
              el,
              key,
              null,
              props[key],
              isSVG,
              vnode.children,
              parentComponent,
              parentSuspense,
              unmountChildren
            );
          }
        }
        if ("value" in props) {
          hostPatchProp(el, "value", null, props.value);
        }
        if ((vnodeHook = props.onVnodeBeforeMount)) {
          invokeVNodeHook(vnodeHook, parentComponent, vnode);
        }
      }
      setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
    }
    const needCallTransitionHooks =
      (!parentSuspense || (parentSuspense && !parentSuspense.pendingBranch)) &&
      transition &&
      !transition.persisted;
    if (needCallTransitionHooks) {
      transition.beforeEnter(el);
    }
    hostInsert(el, container, anchor);
    if (
      (vnodeHook = props && props.onVnodeMounted) ||
      needCallTransitionHooks ||
      dirs
    ) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        needCallTransitionHooks && transition.enter(el);
        dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
      }, parentSuspense);
    }
  };
  const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
    if (scopeId) {
      hostSetScopeId(el, scopeId);
    }
    if (slotScopeIds) {
      for (let i = 0; i < slotScopeIds.length; i++) {
        hostSetScopeId(el, slotScopeIds[i]);
      }
    }
    if (parentComponent) {
      let subTree = parentComponent.subTree;
      if (vnode === subTree) {
        const parentVNode = parentComponent.vnode;
        setScopeId(
          el,
          parentVNode,
          parentVNode.scopeId,
          parentVNode.slotScopeIds,
          parentComponent.parent
        );
      }
    }
  };
  const mountChildren = (
    children,
    container,
    anchor,
    parentComponent,
    parentSuspense,
    isSVG,
    slotScopeIds,
    optimized,
    start = 0
  ) => {
    for (let i = start; i < children.length; i++) {
      const child = (children[i] = optimized
        ? cloneIfMounted(children[i])
        : normalizeVNode(children[i]));
      patch(
        null,
        child,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized
      );
    }
  };
  const patchElement = (
    n1,
    n2,
    parentComponent,
    parentSuspense,
    isSVG,
    slotScopeIds,
    optimized
  ) => {
    const el = (n2.el = n1.el);
    let { patchFlag, dynamicChildren, dirs } = n2;
    patchFlag |= n1.patchFlag & 16;
    const oldProps = n1.props || EMPTY_OBJ;
    const newProps = n2.props || EMPTY_OBJ;
    let vnodeHook;
    parentComponent && toggleRecurse(parentComponent, false);
    if ((vnodeHook = newProps.onVnodeBeforeUpdate)) {
      invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
    }
    if (dirs) {
      invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
    }
    parentComponent && toggleRecurse(parentComponent, true);
    const areChildrenSVG = isSVG && n2.type !== "foreignObject";
    if (dynamicChildren) {
      patchBlockChildren(
        n1.dynamicChildren,
        dynamicChildren,
        el,
        parentComponent,
        parentSuspense,
        areChildrenSVG,
        slotScopeIds
      );
    } else if (!optimized) {
      patchChildren(
        n1,
        n2,
        el,
        null,
        parentComponent,
        parentSuspense,
        areChildrenSVG,
        slotScopeIds,
        false
      );
    }
    if (patchFlag > 0) {
      if (patchFlag & 16) {
        patchProps(
          el,
          n2,
          oldProps,
          newProps,
          parentComponent,
          parentSuspense,
          isSVG
        );
      } else {
        if (patchFlag & 2) {
          if (oldProps.class !== newProps.class) {
            hostPatchProp(el, "class", null, newProps.class, isSVG);
          }
        }
        if (patchFlag & 4) {
          hostPatchProp(el, "style", oldProps.style, newProps.style, isSVG);
        }
        if (patchFlag & 8) {
          const propsToUpdate = n2.dynamicProps;
          for (let i = 0; i < propsToUpdate.length; i++) {
            const key = propsToUpdate[i];
            const prev = oldProps[key];
            const next = newProps[key];
            if (next !== prev || key === "value") {
              hostPatchProp(
                el,
                key,
                prev,
                next,
                isSVG,
                n1.children,
                parentComponent,
                parentSuspense,
                unmountChildren
              );
            }
          }
        }
      }
      if (patchFlag & 1) {
        if (n1.children !== n2.children) {
          hostSetElementText(el, n2.children);
        }
      }
    } else if (!optimized && dynamicChildren == null) {
      patchProps(
        el,
        n2,
        oldProps,
        newProps,
        parentComponent,
        parentSuspense,
        isSVG
      );
    }
    if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
      }, parentSuspense);
    }
  };
  const patchBlockChildren = (
    oldChildren,
    newChildren,
    fallbackContainer,
    parentComponent,
    parentSuspense,
    isSVG,
    slotScopeIds
  ) => {
    for (let i = 0; i < newChildren.length; i++) {
      const oldVNode = oldChildren[i];
      const newVNode = newChildren[i];
      const container =
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
          // which also requires the correct parent container
          !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
          oldVNode.shapeFlag & (6 | 64))
          ? hostParentNode(oldVNode.el)
          : // In other cases, the parent container is not actually used so we
            // just pass the block element here to avoid a DOM parentNode call.
            fallbackContainer;
      patch(
        oldVNode,
        newVNode,
        container,
        null,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        true
      );
    }
  };
  const patchProps = (
    el,
    vnode,
    oldProps,
    newProps,
    parentComponent,
    parentSuspense,
    isSVG
  ) => {
    if (oldProps !== newProps) {
      for (const key in newProps) {
        if (isReservedProp(key)) continue;
        const next = newProps[key];
        const prev = oldProps[key];
        if (next !== prev && key !== "value") {
          hostPatchProp(
            el,
            key,
            prev,
            next,
            isSVG,
            vnode.children,
            parentComponent,
            parentSuspense,
            unmountChildren
          );
        }
      }
      if (oldProps !== EMPTY_OBJ) {
        for (const key in oldProps) {
          if (!isReservedProp(key) && !(key in newProps)) {
            hostPatchProp(
              el,
              key,
              oldProps[key],
              null,
              isSVG,
              vnode.children,
              parentComponent,
              parentSuspense,
              unmountChildren
            );
          }
        }
      }
      if ("value" in newProps) {
        hostPatchProp(el, "value", oldProps.value, newProps.value);
      }
    }
  };
  const processFragment = (
    n1,
    n2,
    container,
    anchor,
    parentComponent,
    parentSuspense,
    isSVG,
    slotScopeIds,
    optimized
  ) => {
    const fragmentStartAnchor = (n2.el = n1 ? n1.el : hostCreateText(""));
    const fragmentEndAnchor = (n2.anchor = n1 ? n1.anchor : hostCreateText(""));
    let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds
        ? slotScopeIds.concat(fragmentSlotScopeIds)
        : fragmentSlotScopeIds;
    }
    if (n1 == null) {
      hostInsert(fragmentStartAnchor, container, anchor);
      hostInsert(fragmentEndAnchor, container, anchor);
      mountChildren(
        n2.children,
        container,
        fragmentEndAnchor,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized
      );
    } else {
      if (
        patchFlag > 0 &&
        patchFlag & 64 &&
        dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
        // of renderSlot() with no valid children
        n1.dynamicChildren
      ) {
        patchBlockChildren(
          n1.dynamicChildren,
          dynamicChildren,
          container,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds
        );
        if (
          // #2080 if the stable fragment has a key, it's a <template v-for> that may
          //  get moved around. Make sure all root level vnodes inherit el.
          // #2134 or if it's a component root, it may also get moved around
          // as the component is being moved.
          n2.key != null ||
          (parentComponent && n2 === parentComponent.subTree)
        ) {
          traverseStaticChildren(
            n1,
            n2,
            true
            /* shallow */
          );
        }
      } else {
        patchChildren(
          n1,
          n2,
          container,
          fragmentEndAnchor,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds,
          optimized
        );
      }
    }
  };
  const processComponent = (
    n1,
    n2,
    container,
    anchor,
    parentComponent,
    parentSuspense,
    isSVG,
    slotScopeIds,
    optimized
  ) => {
    n2.slotScopeIds = slotScopeIds;
    if (n1 == null) {
      if (n2.shapeFlag & 512) {
        parentComponent.ctx.activate(n2, container, anchor, isSVG, optimized);
      } else {
        mountComponent(
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          isSVG,
          optimized
        );
      }
    } else {
      updateComponent(n1, n2, optimized);
    }
  };
  const mountComponent = (
    initialVNode,
    container,
    anchor,
    parentComponent,
    parentSuspense,
    isSVG,
    optimized
  ) => {
    const instance = (initialVNode.component = createComponentInstance(
      initialVNode,
      parentComponent,
      parentSuspense
    ));
    if (isKeepAlive(initialVNode)) {
      instance.ctx.renderer = internals;
    }
    {
      setupComponent(instance);
    }
    if (instance.asyncDep) {
      parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);
      if (!initialVNode.el) {
        const placeholder = (instance.subTree = createVNode(Comment));
        processCommentNode(null, placeholder, container, anchor);
      }
      return;
    }
    setupRenderEffect(
      instance,
      initialVNode,
      container,
      anchor,
      parentSuspense,
      isSVG,
      optimized
    );
  };
  const updateComponent = (n1, n2, optimized) => {
    const instance = (n2.component = n1.component);
    if (shouldUpdateComponent(n1, n2, optimized)) {
      if (instance.asyncDep && !instance.asyncResolved) {
        updateComponentPreRender(instance, n2, optimized);
        return;
      } else {
        instance.next = n2;
        invalidateJob(instance.update);
        instance.update();
      }
    } else {
      n2.component = n1.component;
      n2.el = n1.el;
      instance.vnode = n2;
    }
  };
  const setupRenderEffect = (
    instance,
    initialVNode,
    container,
    anchor,
    parentSuspense,
    isSVG,
    optimized
  ) => {
    const componentUpdateFn = () => {
      if (!instance.isMounted) {
        let vnodeHook;
        const { el, props } = initialVNode;
        const { bm, m, parent } = instance;
        const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
        toggleRecurse(instance, false);
        if (bm) {
          invokeArrayFns(bm);
        }
        if (
          !isAsyncWrapperVNode &&
          (vnodeHook = props && props.onVnodeBeforeMount)
        ) {
          invokeVNodeHook(vnodeHook, parent, initialVNode);
        }
        toggleRecurse(instance, true);
        if (el && hydrateNode) {
          const hydrateSubTree = () => {
            instance.subTree = renderComponentRoot(instance);
            hydrateNode(el, instance.subTree, instance, parentSuspense, null);
          };
          if (isAsyncWrapperVNode) {
            initialVNode.type.__asyncLoader().then(
              // note: we are moving the render call into an async callback,
              // which means it won't track dependencies - but it's ok because
              // a server-rendered async wrapper is already in resolved state
              // and it will never need to change.
              () => !instance.isUnmounted && hydrateSubTree()
            );
          } else {
            hydrateSubTree();
          }
        } else {
          const subTree = (instance.subTree = renderComponentRoot(instance));
          patch(
            null,
            subTree,
            container,
            anchor,
            instance,
            parentSuspense,
            isSVG
          );
          initialVNode.el = subTree.el;
        }
        if (m) {
          queuePostRenderEffect(m, parentSuspense);
        }
        if (
          !isAsyncWrapperVNode &&
          (vnodeHook = props && props.onVnodeMounted)
        ) {
          const scopedInitialVNode = initialVNode;
          queuePostRenderEffect(
            () => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode),
            parentSuspense
          );
        }
        if (initialVNode.shapeFlag & 256) {
          instance.a && queuePostRenderEffect(instance.a, parentSuspense);
        }
        instance.isMounted = true;
        initialVNode = container = anchor = null;
      } else {
        let { next, bu, u, parent, vnode } = instance;
        let originNext = next;
        let vnodeHook;
        toggleRecurse(instance, false);
        if (next) {
          next.el = vnode.el;
          updateComponentPreRender(instance, next, optimized);
        } else {
          next = vnode;
        }
        if (bu) {
          invokeArrayFns(bu);
        }
        if ((vnodeHook = next.props && next.props.onVnodeBeforeUpdate)) {
          invokeVNodeHook(vnodeHook, parent, next, vnode);
        }
        toggleRecurse(instance, true);
        const nextTree = renderComponentRoot(instance);
        const prevTree = instance.subTree;
        instance.subTree = nextTree;
        patch(
          prevTree,
          nextTree,
          // parent may have changed if it's in a teleport
          hostParentNode(prevTree.el),
          // anchor may have changed if it's in a fragment
          getNextHostNode(prevTree),
          instance,
          parentSuspense,
          isSVG
        );
        next.el = nextTree.el;
        if (originNext === null) {
          updateHOCHostEl(instance, nextTree.el);
        }
        if (u) {
          queuePostRenderEffect(u, parentSuspense);
        }
        if ((vnodeHook = next.props && next.props.onVnodeUpdated)) {
          queuePostRenderEffect(
            () => invokeVNodeHook(vnodeHook, parent, next, vnode),
            parentSuspense
          );
        }
      }
    };
    const effect2 = (instance.effect = new ReactiveEffect(
      componentUpdateFn,
      () => queueJob(instance.update),
      instance.scope
      // track it in component's effect scope
    ));
    const update = (instance.update = effect2.run.bind(effect2));
    update.id = instance.uid;
    toggleRecurse(instance, true);
    update();
  };
  const updateComponentPreRender = (instance, nextVNode, optimized) => {
    nextVNode.component = instance;
    const prevProps = instance.vnode.props;
    instance.vnode = nextVNode;
    instance.next = null;
    updateProps(instance, nextVNode.props, prevProps, optimized);
    updateSlots(instance, nextVNode.children, optimized);
    pauseTracking();
    flushPreFlushCbs(void 0, instance.update);
    resetTracking();
  };
  const patchChildren = (
    n1,
    n2,
    container,
    anchor,
    parentComponent,
    parentSuspense,
    isSVG,
    slotScopeIds,
    optimized = false
  ) => {
    const c1 = n1 && n1.children;
    const prevShapeFlag = n1 ? n1.shapeFlag : 0;
    const c2 = n2.children;
    const { patchFlag, shapeFlag } = n2;
    if (patchFlag > 0) {
      if (patchFlag & 128) {
        patchKeyedChildren(
          c1,
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds,
          optimized
        );
        return;
      } else if (patchFlag & 256) {
        patchUnkeyedChildren(
          c1,
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds,
          optimized
        );
        return;
      }
    }
    if (shapeFlag & 8) {
      if (prevShapeFlag & 16) {
        unmountChildren(c1, parentComponent, parentSuspense);
      }
      if (c2 !== c1) {
        hostSetElementText(container, c2);
      }
    } else {
      if (prevShapeFlag & 16) {
        if (shapeFlag & 16) {
          patchKeyedChildren(
            c1,
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
        } else {
          unmountChildren(c1, parentComponent, parentSuspense, true);
        }
      } else {
        if (prevShapeFlag & 8) {
          hostSetElementText(container, "");
        }
        if (shapeFlag & 16) {
          mountChildren(
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
        }
      }
    }
  };
  const patchUnkeyedChildren = (
    c1,
    c2,
    container,
    anchor,
    parentComponent,
    parentSuspense,
    isSVG,
    slotScopeIds,
    optimized
  ) => {
    c1 = c1 || EMPTY_ARR;
    c2 = c2 || EMPTY_ARR;
    const oldLength = c1.length;
    const newLength = c2.length;
    const commonLength = Math.min(oldLength, newLength);
    let i;
    for (i = 0; i < commonLength; i++) {
      const nextChild = (c2[i] = optimized
        ? cloneIfMounted(c2[i])
        : normalizeVNode(c2[i]));
      patch(
        c1[i],
        nextChild,
        container,
        null,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized
      );
    }
    if (oldLength > newLength) {
      unmountChildren(
        c1,
        parentComponent,
        parentSuspense,
        true,
        false,
        commonLength
      );
    } else {
      mountChildren(
        c2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized,
        commonLength
      );
    }
  };
  const patchKeyedChildren = (
    c1,
    c2,
    container,
    parentAnchor,
    parentComponent,
    parentSuspense,
    isSVG,
    slotScopeIds,
    optimized
  ) => {
    let i = 0;
    const l2 = c2.length;
    let e1 = c1.length - 1;
    let e2 = l2 - 1;
    while (i <= e1 && i <= e2) {
      const n1 = c1[i];
      const n2 = (c2[i] = optimized
        ? cloneIfMounted(c2[i])
        : normalizeVNode(c2[i]));
      if (isSameVNodeType(n1, n2)) {
        patch(
          n1,
          n2,
          container,
          null,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds,
          optimized
        );
      } else {
        break;
      }
      i++;
    }
    while (i <= e1 && i <= e2) {
      const n1 = c1[e1];
      const n2 = (c2[e2] = optimized
        ? cloneIfMounted(c2[e2])
        : normalizeVNode(c2[e2]));
      if (isSameVNodeType(n1, n2)) {
        patch(
          n1,
          n2,
          container,
          null,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds,
          optimized
        );
      } else {
        break;
      }
      e1--;
      e2--;
    }
    if (i > e1) {
      if (i <= e2) {
        const nextPos = e2 + 1;
        const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
        while (i <= e2) {
          patch(
            null,
            (c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i])),
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
          i++;
        }
      }
    } else if (i > e2) {
      while (i <= e1) {
        unmount(c1[i], parentComponent, parentSuspense, true);
        i++;
      }
    } else {
      const s1 = i;
      const s2 = i;
      const keyToNewIndexMap = /* @__PURE__ */ new Map();
      for (i = s2; i <= e2; i++) {
        const nextChild = (c2[i] = optimized
          ? cloneIfMounted(c2[i])
          : normalizeVNode(c2[i]));
        if (nextChild.key != null) {
          keyToNewIndexMap.set(nextChild.key, i);
        }
      }
      let j;
      let patched = 0;
      const toBePatched = e2 - s2 + 1;
      let moved = false;
      let maxNewIndexSoFar = 0;
      const newIndexToOldIndexMap = new Array(toBePatched);
      for (i = 0; i < toBePatched; i++) newIndexToOldIndexMap[i] = 0;
      for (i = s1; i <= e1; i++) {
        const prevChild = c1[i];
        if (patched >= toBePatched) {
          unmount(prevChild, parentComponent, parentSuspense, true);
          continue;
        }
        let newIndex;
        if (prevChild.key != null) {
          newIndex = keyToNewIndexMap.get(prevChild.key);
        } else {
          for (j = s2; j <= e2; j++) {
            if (
              newIndexToOldIndexMap[j - s2] === 0 &&
              isSameVNodeType(prevChild, c2[j])
            ) {
              newIndex = j;
              break;
            }
          }
        }
        if (newIndex === void 0) {
          unmount(prevChild, parentComponent, parentSuspense, true);
        } else {
          newIndexToOldIndexMap[newIndex - s2] = i + 1;
          if (newIndex >= maxNewIndexSoFar) {
            maxNewIndexSoFar = newIndex;
          } else {
            moved = true;
          }
          patch(
            prevChild,
            c2[newIndex],
            container,
            null,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
          patched++;
        }
      }
      const increasingNewIndexSequence = moved
        ? getSequence(newIndexToOldIndexMap)
        : EMPTY_ARR;
      j = increasingNewIndexSequence.length - 1;
      for (i = toBePatched - 1; i >= 0; i--) {
        const nextIndex = s2 + i;
        const nextChild = c2[nextIndex];
        const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
        if (newIndexToOldIndexMap[i] === 0) {
          patch(
            null,
            nextChild,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
        } else if (moved) {
          if (j < 0 || i !== increasingNewIndexSequence[j]) {
            move(
              nextChild,
              container,
              anchor,
              2
              /* REORDER */
            );
          } else {
            j--;
          }
        }
      }
    }
  };
  const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
    const { el, type, transition, children, shapeFlag } = vnode;
    if (shapeFlag & 6) {
      move(vnode.component.subTree, container, anchor, moveType);
      return;
    }
    if (shapeFlag & 128) {
      vnode.suspense.move(container, anchor, moveType);
      return;
    }
    if (shapeFlag & 64) {
      type.move(vnode, container, anchor, internals);
      return;
    }
    if (type === Fragment) {
      hostInsert(el, container, anchor);
      for (let i = 0; i < children.length; i++) {
        move(children[i], container, anchor, moveType);
      }
      hostInsert(vnode.anchor, container, anchor);
      return;
    }
    if (type === Static) {
      moveStaticNode(vnode, container, anchor);
      return;
    }
    const needTransition = moveType !== 2 && shapeFlag & 1 && transition;
    if (needTransition) {
      if (moveType === 0) {
        transition.beforeEnter(el);
        hostInsert(el, container, anchor);
        queuePostRenderEffect(() => transition.enter(el), parentSuspense);
      } else {
        const { leave, delayLeave, afterLeave } = transition;
        const remove3 = () => hostInsert(el, container, anchor);
        const performLeave = () => {
          leave(el, () => {
            remove3();
            afterLeave && afterLeave();
          });
        };
        if (delayLeave) {
          delayLeave(el, remove3, performLeave);
        } else {
          performLeave();
        }
      }
    } else {
      hostInsert(el, container, anchor);
    }
  };
  const unmount = (
    vnode,
    parentComponent,
    parentSuspense,
    doRemove = false,
    optimized = false
  ) => {
    const {
      type,
      props,
      ref: ref2,
      children,
      dynamicChildren,
      shapeFlag,
      patchFlag,
      dirs,
    } = vnode;
    if (ref2 != null) {
      setRef(ref2, null, parentSuspense, vnode, true);
    }
    if (shapeFlag & 256) {
      parentComponent.ctx.deactivate(vnode);
      return;
    }
    const shouldInvokeDirs = shapeFlag & 1 && dirs;
    const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
    let vnodeHook;
    if (
      shouldInvokeVnodeHook &&
      (vnodeHook = props && props.onVnodeBeforeUnmount)
    ) {
      invokeVNodeHook(vnodeHook, parentComponent, vnode);
    }
    if (shapeFlag & 6) {
      unmountComponent(vnode.component, parentSuspense, doRemove);
    } else {
      if (shapeFlag & 128) {
        vnode.suspense.unmount(parentSuspense, doRemove);
        return;
      }
      if (shouldInvokeDirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
      }
      if (shapeFlag & 64) {
        vnode.type.remove(
          vnode,
          parentComponent,
          parentSuspense,
          optimized,
          internals,
          doRemove
        );
      } else if (
        dynamicChildren && // #1153: fast path should not be taken for non-stable (v-for) fragments
        (type !== Fragment || (patchFlag > 0 && patchFlag & 64))
      ) {
        unmountChildren(
          dynamicChildren,
          parentComponent,
          parentSuspense,
          false,
          true
        );
      } else if (
        (type === Fragment && patchFlag & (128 | 256)) ||
        (!optimized && shapeFlag & 16)
      ) {
        unmountChildren(children, parentComponent, parentSuspense);
      }
      if (doRemove) {
        remove2(vnode);
      }
    }
    if (
      (shouldInvokeVnodeHook &&
        (vnodeHook = props && props.onVnodeUnmounted)) ||
      shouldInvokeDirs
    ) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        shouldInvokeDirs &&
          invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
      }, parentSuspense);
    }
  };
  const remove2 = (vnode) => {
    const { type, el, anchor, transition } = vnode;
    if (type === Fragment) {
      removeFragment(el, anchor);
      return;
    }
    if (type === Static) {
      removeStaticNode(vnode);
      return;
    }
    const performRemove = () => {
      hostRemove(el);
      if (transition && !transition.persisted && transition.afterLeave) {
        transition.afterLeave();
      }
    };
    if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
      const { leave, delayLeave } = transition;
      const performLeave = () => leave(el, performRemove);
      if (delayLeave) {
        delayLeave(vnode.el, performRemove, performLeave);
      } else {
        performLeave();
      }
    } else {
      performRemove();
    }
  };
  const removeFragment = (cur, end) => {
    let next;
    while (cur !== end) {
      next = hostNextSibling(cur);
      hostRemove(cur);
      cur = next;
    }
    hostRemove(end);
  };
  const unmountComponent = (instance, parentSuspense, doRemove) => {
    const { bum, scope, update, subTree, um } = instance;
    if (bum) {
      invokeArrayFns(bum);
    }
    scope.stop();
    if (update) {
      update.active = false;
      unmount(subTree, instance, parentSuspense, doRemove);
    }
    if (um) {
      queuePostRenderEffect(um, parentSuspense);
    }
    queuePostRenderEffect(() => {
      instance.isUnmounted = true;
    }, parentSuspense);
    if (
      parentSuspense &&
      parentSuspense.pendingBranch &&
      !parentSuspense.isUnmounted &&
      instance.asyncDep &&
      !instance.asyncResolved &&
      instance.suspenseId === parentSuspense.pendingId
    ) {
      parentSuspense.deps--;
      if (parentSuspense.deps === 0) {
        parentSuspense.resolve();
      }
    }
  };
  const unmountChildren = (
    children,
    parentComponent,
    parentSuspense,
    doRemove = false,
    optimized = false,
    start = 0
  ) => {
    for (let i = start; i < children.length; i++) {
      unmount(
        children[i],
        parentComponent,
        parentSuspense,
        doRemove,
        optimized
      );
    }
  };
  const getNextHostNode = (vnode) => {
    if (vnode.shapeFlag & 6) {
      return getNextHostNode(vnode.component.subTree);
    }
    if (vnode.shapeFlag & 128) {
      return vnode.suspense.next();
    }
    return hostNextSibling(vnode.anchor || vnode.el);
  };
  const render2 = (vnode, container, isSVG) => {
    if (vnode == null) {
      if (container._vnode) {
        unmount(container._vnode, null, null, true);
      }
    } else {
      patch(
        container._vnode || null,
        vnode,
        container,
        null,
        null,
        null,
        isSVG
      );
    }
    flushPostFlushCbs();
    container._vnode = vnode;
  };
  const internals = {
    p: patch,
    um: unmount,
    m: move,
    r: remove2,
    mt: mountComponent,
    mc: mountChildren,
    pc: patchChildren,
    pbc: patchBlockChildren,
    n: getNextHostNode,
    o: options,
  };
  let hydrate2;
  let hydrateNode;
  if (createHydrationFns) {
    [hydrate2, hydrateNode] = createHydrationFns(internals);
  }
  return {
    render: render2,
    hydrate: hydrate2,
    createApp: createAppAPI(render2, hydrate2),
  };
}
function toggleRecurse({ effect: effect2, update }, allowed) {
  effect2.allowRecurse = update.allowRecurse = allowed;
}
function traverseStaticChildren(n1, n2, shallow = false) {
  const ch1 = n1.children;
  const ch2 = n2.children;
  if (isArray(ch1) && isArray(ch2)) {
    for (let i = 0; i < ch1.length; i++) {
      const c1 = ch1[i];
      let c2 = ch2[i];
      if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
        if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
          c2 = ch2[i] = cloneIfMounted(ch2[i]);
          c2.el = c1.el;
        }
        if (!shallow) traverseStaticChildren(c1, c2);
      }
    }
  }
}
function getSequence(arr) {
  const p2 = arr.slice();
  const result = [0];
  let i, j, u, v, c;
  const len = arr.length;
  for (i = 0; i < len; i++) {
    const arrI = arr[i];
    if (arrI !== 0) {
      j = result[result.length - 1];
      if (arr[j] < arrI) {
        p2[i] = j;
        result.push(i);
        continue;
      }
      u = 0;
      v = result.length - 1;
      while (u < v) {
        c = (u + v) >> 1;
        if (arr[result[c]] < arrI) {
          u = c + 1;
        } else {
          v = c;
        }
      }
      if (arrI < arr[result[u]]) {
        if (u > 0) {
          p2[i] = result[u - 1];
        }
        result[u] = i;
      }
    }
  }
  u = result.length;
  v = result[u - 1];
  while (u-- > 0) {
    result[u] = v;
    v = p2[v];
  }
  return result;
}
function moveTeleport(
  vnode,
  container,
  parentAnchor,
  { o: { insert }, m: move },
  moveType = 2
) {
  if (moveType === 0) {
    insert(vnode.targetAnchor, container, parentAnchor);
  }
  const { el, anchor, shapeFlag, children, props } = vnode;
  const isReorder = moveType === 2;
  if (isReorder) {
    insert(el, container, parentAnchor);
  }
  if (!isReorder || isTeleportDisabled(props)) {
    if (shapeFlag & 16) {
      for (let i = 0; i < children.length; i++) {
        move(
          children[i],
          container,
          parentAnchor,
          2
          /* REORDER */
        );
      }
    }
  }
  if (isReorder) {
    insert(anchor, container, parentAnchor);
  }
}
function hydrateTeleport(
  node,
  vnode,
  parentComponent,
  parentSuspense,
  slotScopeIds,
  optimized,
  { o: { nextSibling, parentNode, querySelector } },
  hydrateChildren
) {
  const target = (vnode.target = resolveTarget(vnode.props, querySelector));
  if (target) {
    const targetNode = target._lpa || target.firstChild;
    if (vnode.shapeFlag & 16) {
      if (isTeleportDisabled(vnode.props)) {
        vnode.anchor = hydrateChildren(
          nextSibling(node),
          vnode,
          parentNode(node),
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized
        );
        vnode.targetAnchor = targetNode;
      } else {
        vnode.anchor = nextSibling(node);
        vnode.targetAnchor = hydrateChildren(
          targetNode,
          vnode,
          target,
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized
        );
      }
      target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
    }
  }
  return vnode.anchor && nextSibling(vnode.anchor);
}
function resolveComponent(name, maybeSelfReference) {
  return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
}
function resolveDynamicComponent(component) {
  if (isString$1(component)) {
    return resolveAsset(COMPONENTS, component, false) || component;
  } else {
    return component || NULL_DYNAMIC_COMPONENT;
  }
}
function resolveDirective(name) {
  return resolveAsset(DIRECTIVES, name);
}
function resolveAsset(
  type,
  name,
  warnMissing = true,
  maybeSelfReference = false
) {
  const instance = currentRenderingInstance || currentInstance;
  if (instance) {
    const Component = instance.type;
    if (type === COMPONENTS) {
      const selfName = getComponentName(Component);
      if (
        selfName &&
        (selfName === name ||
          selfName === camelize(name) ||
          selfName === capitalize(camelize(name)))
      ) {
        return Component;
      }
    }
    const res =
      // local registration
      // check instance[type] first which is resolved for options API
      resolve(instance[type] || Component[type], name) || // global registration
      resolve(instance.appContext[type], name);
    if (!res && maybeSelfReference) {
      return Component;
    }
    return res;
  }
}
function resolve(registry, name) {
  return (
    registry &&
    (registry[name] ||
      registry[camelize(name)] ||
      registry[capitalize(camelize(name))])
  );
}
function openBlock(disableTracking = false) {
  blockStack.push((currentBlock = disableTracking ? null : []));
}
function closeBlock() {
  blockStack.pop();
  currentBlock = blockStack[blockStack.length - 1] || null;
}
function setBlockTracking(value) {
  isBlockTreeEnabled += value;
}
function setupBlock(vnode) {
  vnode.dynamicChildren =
    isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
  closeBlock();
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(vnode);
  }
  return vnode;
}
function createElementBlock(
  type,
  props,
  children,
  patchFlag,
  dynamicProps,
  shapeFlag
) {
  return setupBlock(
    createBaseVNode(
      type,
      props,
      children,
      patchFlag,
      dynamicProps,
      shapeFlag,
      true
      /* isBlock */
    )
  );
}
function createBlock(type, props, children, patchFlag, dynamicProps) {
  return setupBlock(
    createVNode(
      type,
      props,
      children,
      patchFlag,
      dynamicProps,
      true
      /* isBlock: prevent a block from tracking itself */
    )
  );
}
function isVNode(value) {
  return value ? value.__v_isVNode === true : false;
}
function isSameVNodeType(n1, n2) {
  return n1.type === n2.type && n1.key === n2.key;
}
function transformVNodeArgs(transformer) {}
function createBaseVNode(
  type,
  props = null,
  children = null,
  patchFlag = 0,
  dynamicProps = null,
  shapeFlag = type === Fragment ? 0 : 1,
  isBlockNode = false,
  needFullChildrenNormalization = false
) {
  const vnode = {
    __v_isVNode: true,
    __v_skip: true,
    type,
    props,
    key: props && normalizeKey(props),
    ref: props && normalizeRef(props),
    scopeId: currentScopeId,
    slotScopeIds: null,
    children,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag,
    patchFlag,
    dynamicProps,
    dynamicChildren: null,
    appContext: null,
  };
  if (needFullChildrenNormalization) {
    normalizeChildren(vnode, children);
    if (shapeFlag & 128) {
      type.normalize(vnode);
    }
  } else if (children) {
    vnode.shapeFlag |= isString$1(children) ? 8 : 16;
  }
  if (
    isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
    !isBlockNode && // has current parent block
    currentBlock && // presence of a patch flag indicates this node needs patching on updates.
    // component nodes also should always be patched, because even if the
    // component doesn't need to update, it needs to persist the instance on to
    // the next vnode so that it can be properly unmounted later.
    (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
    // vnode should not be considered dynamic due to handler caching.
    vnode.patchFlag !== 32
  ) {
    currentBlock.push(vnode);
  }
  return vnode;
}
function _createVNode(
  type,
  props = null,
  children = null,
  patchFlag = 0,
  dynamicProps = null,
  isBlockNode = false
) {
  if (!type || type === NULL_DYNAMIC_COMPONENT) {
    type = Comment;
  }
  if (isVNode(type)) {
    const cloned = cloneVNode(
      type,
      props,
      true
      /* mergeRef: true */
    );
    if (children) {
      normalizeChildren(cloned, children);
    }
    return cloned;
  }
  if (isClassComponent(type)) {
    type = type.__vccOpts;
  }
  if (props) {
    props = guardReactiveProps(props);
    let { class: klass, style } = props;
    if (klass && !isString$1(klass)) {
      props.class = normalizeClass(klass);
    }
    if (isObject$f(style)) {
      if (isProxy(style) && !isArray(style)) {
        style = extend({}, style);
      }
      props.style = normalizeStyle(style);
    }
  }
  const shapeFlag = isString$1(type)
    ? 1
    : isSuspense(type)
    ? 128
    : isTeleport(type)
    ? 64
    : isObject$f(type)
    ? 4
    : isFunction$1(type)
    ? 2
    : 0;
  return createBaseVNode(
    type,
    props,
    children,
    patchFlag,
    dynamicProps,
    shapeFlag,
    isBlockNode,
    true
  );
}
function guardReactiveProps(props) {
  if (!props) return null;
  return isProxy(props) || InternalObjectKey in props
    ? extend({}, props)
    : props;
}
function cloneVNode(vnode, extraProps, mergeRef = false) {
  const { props, ref: ref2, patchFlag, children } = vnode;
  const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
  const cloned = {
    __v_isVNode: true,
    __v_skip: true,
    type: vnode.type,
    props: mergedProps,
    key: mergedProps && normalizeKey(mergedProps),
    ref:
      extraProps && extraProps.ref
        ? // #2078 in the case of <component :is="vnode" ref="extra"/>
          // if the vnode itself already has a ref, cloneVNode will need to merge
          // the refs so the single vnode can be set on multiple refs
          mergeRef && ref2
          ? isArray(ref2)
            ? ref2.concat(normalizeRef(extraProps))
            : [ref2, normalizeRef(extraProps)]
          : normalizeRef(extraProps)
        : ref2,
    scopeId: vnode.scopeId,
    slotScopeIds: vnode.slotScopeIds,
    children: children,
    target: vnode.target,
    targetAnchor: vnode.targetAnchor,
    staticCount: vnode.staticCount,
    shapeFlag: vnode.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag:
      extraProps && vnode.type !== Fragment
        ? patchFlag === -1
          ? 16
          : patchFlag | 16
        : patchFlag,
    dynamicProps: vnode.dynamicProps,
    dynamicChildren: vnode.dynamicChildren,
    appContext: vnode.appContext,
    dirs: vnode.dirs,
    transition: vnode.transition,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: vnode.component,
    suspense: vnode.suspense,
    ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
    ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
    el: vnode.el,
    anchor: vnode.anchor,
  };
  return cloned;
}
function createTextVNode(text = " ", flag = 0) {
  return createVNode(Text, null, text, flag);
}
function createStaticVNode(content, numberOfNodes) {
  const vnode = createVNode(Static, null, content);
  vnode.staticCount = numberOfNodes;
  return vnode;
}
function createCommentVNode(text = "", asBlock = false) {
  return asBlock
    ? (openBlock(), createBlock(Comment, null, text))
    : createVNode(Comment, null, text);
}
function normalizeVNode(child) {
  if (child == null || typeof child === "boolean") {
    return createVNode(Comment);
  } else if (isArray(child)) {
    return createVNode(
      Fragment,
      null,
      // #3666, avoid reference pollution when reusing vnode
      child.slice()
    );
  } else if (typeof child === "object") {
    return cloneIfMounted(child);
  } else {
    return createVNode(Text, null, String(child));
  }
}
function cloneIfMounted(child) {
  return child.el === null || child.memo ? child : cloneVNode(child);
}
function normalizeChildren(vnode, children) {
  let type = 0;
  const { shapeFlag } = vnode;
  if (children == null) {
    children = null;
  } else if (isArray(children)) {
    type = 16;
  } else if (typeof children === "object") {
    if (shapeFlag & (1 | 64)) {
      const slot = children.default;
      if (slot) {
        slot._c && (slot._d = false);
        normalizeChildren(vnode, slot());
        slot._c && (slot._d = true);
      }
      return;
    } else {
      type = 32;
      const slotFlag = children._;
      if (!slotFlag && !(InternalObjectKey in children)) {
        children._ctx = currentRenderingInstance;
      } else if (slotFlag === 3 && currentRenderingInstance) {
        if (currentRenderingInstance.slots._ === 1) {
          children._ = 1;
        } else {
          children._ = 2;
          vnode.patchFlag |= 1024;
        }
      }
    }
  } else if (isFunction$1(children)) {
    children = { default: children, _ctx: currentRenderingInstance };
    type = 32;
  } else {
    children = String(children);
    if (shapeFlag & 64) {
      type = 16;
      children = [createTextVNode(children)];
    } else {
      type = 8;
    }
  }
  vnode.children = children;
  vnode.shapeFlag |= type;
}
function mergeProps(...args) {
  const ret = {};
  for (let i = 0; i < args.length; i++) {
    const toMerge = args[i];
    for (const key in toMerge) {
      if (key === "class") {
        if (ret.class !== toMerge.class) {
          ret.class = normalizeClass([ret.class, toMerge.class]);
        }
      } else if (key === "style") {
        ret.style = normalizeStyle([ret.style, toMerge.style]);
      } else if (isOn(key)) {
        const existing = ret[key];
        const incoming = toMerge[key];
        if (
          incoming &&
          existing !== incoming &&
          !(isArray(existing) && existing.includes(incoming))
        ) {
          ret[key] = existing ? [].concat(existing, incoming) : incoming;
        }
      } else if (key !== "") {
        ret[key] = toMerge[key];
      }
    }
  }
  return ret;
}
function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
  callWithAsyncErrorHandling(hook, instance, 7, [vnode, prevVNode]);
}
function renderList(source, renderItem, cache, index) {
  let ret;
  const cached = cache && cache[index];
  if (isArray(source) || isString$1(source)) {
    ret = new Array(source.length);
    for (let i = 0, l = source.length; i < l; i++) {
      ret[i] = renderItem(source[i], i, void 0, cached && cached[i]);
    }
  } else if (typeof source === "number") {
    ret = new Array(source);
    for (let i = 0; i < source; i++) {
      ret[i] = renderItem(i + 1, i, void 0, cached && cached[i]);
    }
  } else if (isObject$f(source)) {
    if (source[Symbol.iterator]) {
      ret = Array.from(source, (item, i) =>
        renderItem(item, i, void 0, cached && cached[i])
      );
    } else {
      const keys = Object.keys(source);
      ret = new Array(keys.length);
      for (let i = 0, l = keys.length; i < l; i++) {
        const key = keys[i];
        ret[i] = renderItem(source[key], key, i, cached && cached[i]);
      }
    }
  } else {
    ret = [];
  }
  if (cache) {
    cache[index] = ret;
  }
  return ret;
}
function createSlots(slots, dynamicSlots) {
  for (let i = 0; i < dynamicSlots.length; i++) {
    const slot = dynamicSlots[i];
    if (isArray(slot)) {
      for (let j = 0; j < slot.length; j++) {
        slots[slot[j].name] = slot[j].fn;
      }
    } else if (slot) {
      slots[slot.name] = slot.fn;
    }
  }
  return slots;
}
function renderSlot(slots, name, props = {}, fallback, noSlotted) {
  if (currentRenderingInstance.isCE) {
    return createVNode(
      "slot",
      name === "default" ? null : { name },
      fallback && fallback()
    );
  }
  let slot = slots[name];
  if (slot && slot._c) {
    slot._d = false;
  }
  openBlock();
  const validSlotContent = slot && ensureValidVNode(slot(props));
  const rendered = createBlock(
    Fragment,
    { key: props.key || `_${name}` },
    validSlotContent || (fallback ? fallback() : []),
    validSlotContent && slots._ === 1 ? 64 : -2
    /* BAIL */
  );
  if (!noSlotted && rendered.scopeId) {
    rendered.slotScopeIds = [rendered.scopeId + "-s"];
  }
  if (slot && slot._c) {
    slot._d = true;
  }
  return rendered;
}
function ensureValidVNode(vnodes) {
  return vnodes.some((child) => {
    if (!isVNode(child)) return true;
    if (child.type === Comment) return false;
    if (child.type === Fragment && !ensureValidVNode(child.children))
      return false;
    return true;
  })
    ? vnodes
    : null;
}
function toHandlers(obj) {
  const ret = {};
  for (const key in obj) {
    ret[toHandlerKey(key)] = obj[key];
  }
  return ret;
}
function createComponentInstance(vnode, parent, suspense) {
  const type = vnode.type;
  const appContext =
    (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
  const instance = {
    uid: uid$1$4++,
    vnode,
    type,
    parent,
    appContext,
    root: null,
    next: null,
    subTree: null,
    effect: null,
    update: null,
    scope: new EffectScope(
      true
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: parent ? parent.provides : Object.create(appContext.provides),
    accessCache: null,
    renderCache: [],
    // local resovled assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: normalizePropsOptions(type, appContext),
    emitsOptions: normalizeEmitsOptions(type, appContext),
    // emit
    emit: null,
    emitted: null,
    // props default value
    propsDefaults: EMPTY_OBJ,
    // inheritAttrs
    inheritAttrs: type.inheritAttrs,
    // state
    ctx: EMPTY_OBJ,
    data: EMPTY_OBJ,
    props: EMPTY_OBJ,
    attrs: EMPTY_OBJ,
    slots: EMPTY_OBJ,
    refs: EMPTY_OBJ,
    setupState: EMPTY_OBJ,
    setupContext: null,
    // suspense related
    suspense,
    suspenseId: suspense ? suspense.pendingId : 0,
    asyncDep: null,
    asyncResolved: false,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: false,
    isUnmounted: false,
    isDeactivated: false,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null,
  };
  {
    instance.ctx = { _: instance };
  }
  instance.root = parent ? parent.root : instance;
  instance.emit = emit$1.bind(null, instance);
  if (vnode.ce) {
    vnode.ce(instance);
  }
  return instance;
}
function isStatefulComponent(instance) {
  return instance.vnode.shapeFlag & 4;
}
function setupComponent(instance, isSSR = false) {
  isInSSRComponentSetup = isSSR;
  const { props, children } = instance.vnode;
  const isStateful = isStatefulComponent(instance);
  initProps(instance, props, isStateful, isSSR);
  initSlots(instance, children);
  const setupResult = isStateful
    ? setupStatefulComponent(instance, isSSR)
    : void 0;
  isInSSRComponentSetup = false;
  return setupResult;
}
function setupStatefulComponent(instance, isSSR) {
  const Component = instance.type;
  instance.accessCache = /* @__PURE__ */ Object.create(null);
  instance.proxy = markRaw(
    new Proxy(instance.ctx, PublicInstanceProxyHandlers)
  );
  const { setup } = Component;
  if (setup) {
    const setupContext = (instance.setupContext =
      setup.length > 1 ? createSetupContext(instance) : null);
    setCurrentInstance(instance);
    pauseTracking();
    const setupResult = callWithErrorHandling(setup, instance, 0, [
      instance.props,
      setupContext,
    ]);
    resetTracking();
    unsetCurrentInstance();
    if (isPromise(setupResult)) {
      setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
      if (isSSR) {
        return setupResult
          .then((resolvedResult) => {
            handleSetupResult(instance, resolvedResult, isSSR);
          })
          .catch((e) => {
            handleError(
              e,
              instance,
              0
              /* SETUP_FUNCTION */
            );
          });
      } else {
        instance.asyncDep = setupResult;
      }
    } else {
      handleSetupResult(instance, setupResult, isSSR);
    }
  } else {
    finishComponentSetup(instance, isSSR);
  }
}
function handleSetupResult(instance, setupResult, isSSR) {
  if (isFunction$1(setupResult)) {
    if (instance.type.__ssrInlineRender) {
      instance.ssrRender = setupResult;
    } else {
      instance.render = setupResult;
    }
  } else if (isObject$f(setupResult)) {
    instance.setupState = proxyRefs(setupResult);
  } else;
  finishComponentSetup(instance, isSSR);
}
function registerRuntimeCompiler(_compile) {
  compile$1 = _compile;
  installWithProxy = (i) => {
    if (i.render._rc) {
      i.withProxy = new Proxy(
        i.ctx,
        RuntimeCompiledPublicInstanceProxyHandlers
      );
    }
  };
}
function finishComponentSetup(instance, isSSR, skipOptions) {
  const Component = instance.type;
  if (!instance.render) {
    if (!isSSR && compile$1 && !Component.render) {
      const template = Component.template;
      if (template) {
        const { isCustomElement, compilerOptions } = instance.appContext.config;
        const { delimiters, compilerOptions: componentCompilerOptions } =
          Component;
        const finalCompilerOptions = extend(
          extend(
            {
              isCustomElement,
              delimiters,
            },
            compilerOptions
          ),
          componentCompilerOptions
        );
        Component.render = compile$1(template, finalCompilerOptions);
      }
    }
    instance.render = Component.render || NOOP;
    if (installWithProxy) {
      installWithProxy(instance);
    }
  }
  {
    setCurrentInstance(instance);
    pauseTracking();
    applyOptions(instance);
    resetTracking();
    unsetCurrentInstance();
  }
}
function createAttrsProxy(instance) {
  return new Proxy(instance.attrs, {
    get(target, key) {
      track(instance, "get", "$attrs");
      return target[key];
    },
  });
}
function createSetupContext(instance) {
  const expose = (exposed) => {
    instance.exposed = exposed || {};
  };
  let attrs;
  {
    return {
      get attrs() {
        return attrs || (attrs = createAttrsProxy(instance));
      },
      slots: instance.slots,
      emit: instance.emit,
      expose,
    };
  }
}
function getExposeProxy(instance) {
  if (instance.exposed) {
    return (
      instance.exposeProxy ||
      (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
        get(target, key) {
          if (key in target) {
            return target[key];
          } else if (key in publicPropertiesMap) {
            return publicPropertiesMap[key](instance);
          }
        },
      }))
    );
  }
}
function getComponentName(Component) {
  return isFunction$1(Component)
    ? Component.displayName || Component.name
    : Component.name;
}
function formatComponentName(instance, Component, isRoot = false) {
  let name = getComponentName(Component);
  if (!name && Component.__file) {
    const match = Component.__file.match(/([^/\\]+)\.\w+$/);
    if (match) {
      name = match[1];
    }
  }
  if (!name && instance && instance.parent) {
    const inferFromRegistry = (registry) => {
      for (const key in registry) {
        if (registry[key] === Component) {
          return key;
        }
      }
    };
    name =
      inferFromRegistry(
        instance.components || instance.parent.type.components
      ) || inferFromRegistry(instance.appContext.components);
  }
  return name ? classify(name) : isRoot ? `App` : `Anonymous`;
}
function isClassComponent(value) {
  return isFunction$1(value) && "__vccOpts" in value;
}
function defineProps() {
  return null;
}
function defineEmits() {
  return null;
}
function defineExpose(exposed) {}
function withDefaults(props, defaults) {
  return null;
}
function useSlots() {
  return getContext().slots;
}
function useAttrs() {
  return getContext().attrs;
}
function getContext() {
  const i = getCurrentInstance();
  return i.setupContext || (i.setupContext = createSetupContext(i));
}
function mergeDefaults(raw, defaults) {
  const props = isArray(raw)
    ? raw.reduce((normalized, p2) => ((normalized[p2] = {}), normalized), {})
    : raw;
  for (const key in defaults) {
    const opt = props[key];
    if (opt) {
      if (isArray(opt) || isFunction$1(opt)) {
        props[key] = { type: opt, default: defaults[key] };
      } else {
        opt.default = defaults[key];
      }
    } else if (opt === null) {
      props[key] = { default: defaults[key] };
    } else;
  }
  return props;
}
function createPropsRestProxy(props, excludedKeys) {
  const ret = {};
  for (const key in props) {
    if (!excludedKeys.includes(key)) {
      Object.defineProperty(ret, key, {
        enumerable: true,
        get: () => props[key],
      });
    }
  }
  return ret;
}
function withAsyncContext(getAwaitable) {
  const ctx = getCurrentInstance();
  let awaitable = getAwaitable();
  unsetCurrentInstance();
  if (isPromise(awaitable)) {
    awaitable = awaitable.catch((e) => {
      setCurrentInstance(ctx);
      throw e;
    });
  }
  return [awaitable, () => setCurrentInstance(ctx)];
}
function h(type, propsOrChildren, children) {
  const l = arguments.length;
  if (l === 2) {
    if (isObject$f(propsOrChildren) && !isArray(propsOrChildren)) {
      if (isVNode(propsOrChildren)) {
        return createVNode(type, null, [propsOrChildren]);
      }
      return createVNode(type, propsOrChildren);
    } else {
      return createVNode(type, null, propsOrChildren);
    }
  } else {
    if (l > 3) {
      children = Array.prototype.slice.call(arguments, 2);
    } else if (l === 3 && isVNode(children)) {
      children = [children];
    }
    return createVNode(type, propsOrChildren, children);
  }
}
function initCustomFormatter() {
  {
    return;
  }
}
function withMemo(memo, render2, cache, index) {
  const cached = cache[index];
  if (cached && isMemoSame(cached, memo)) {
    return cached;
  }
  const ret = render2();
  ret.memo = memo.slice();
  return (cache[index] = ret);
}
function isMemoSame(cached, memo) {
  const prev = cached.memo;
  if (prev.length != memo.length) {
    return false;
  }
  for (let i = 0; i < prev.length; i++) {
    if (prev[i] !== memo[i]) {
      return false;
    }
  }
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(cached);
  }
  return true;
}
var stack,
  isFlushing,
  isFlushPending,
  queue$4,
  flushIndex,
  pendingPreFlushCbs,
  activePreFlushCbs,
  preFlushIndex,
  pendingPostFlushCbs,
  activePostFlushCbs,
  postFlushIndex,
  resolvedPromise,
  currentFlushPromise,
  currentPreFlushParentJob,
  getId,
  devtools,
  buffer,
  currentRenderingInstance,
  currentScopeId,
  withScopeId,
  getFunctionalFallthrough,
  filterModelListeners,
  isSuspense,
  SuspenseImpl,
  Suspense,
  INITIAL_WATCHER_VALUE,
  TransitionHookValidator,
  BaseTransitionImpl,
  BaseTransition,
  isAsyncWrapper,
  isKeepAlive,
  KeepAliveImpl,
  KeepAlive,
  createHook,
  onBeforeMount,
  onMounted$1,
  onBeforeUpdate,
  onUpdated$1,
  onBeforeUnmount,
  onUnmounted$1,
  onServerPrefetch,
  onRenderTriggered,
  onRenderTracked,
  shouldCacheAccess,
  internalOptionMergeStrats,
  isInternalKey,
  normalizeSlotValue,
  normalizeSlot$1,
  normalizeObjectSlots,
  normalizeVNodeSlots,
  initSlots,
  updateSlots,
  uid$6,
  hasMismatch,
  isSVGContainer,
  isComment,
  queuePostRenderEffect,
  isTeleport,
  isTeleportDisabled,
  isTargetSVG,
  resolveTarget,
  TeleportImpl,
  Teleport,
  COMPONENTS,
  DIRECTIVES,
  NULL_DYNAMIC_COMPONENT,
  Fragment,
  Text,
  Comment,
  Static,
  blockStack,
  currentBlock,
  isBlockTreeEnabled,
  InternalObjectKey,
  normalizeKey,
  normalizeRef,
  createVNode,
  getPublicInstance,
  publicPropertiesMap,
  PublicInstanceProxyHandlers,
  RuntimeCompiledPublicInstanceProxyHandlers,
  emptyAppContext,
  uid$1$4,
  currentInstance,
  getCurrentInstance,
  setCurrentInstance,
  unsetCurrentInstance,
  isInSSRComponentSetup,
  compile$1,
  installWithProxy,
  isRuntimeOnly,
  classifyRE,
  classify,
  computed2,
  ssrContextKey,
  useSSRContext,
  version$4,
  _ssrUtils,
  ssrUtils,
  resolveFilter,
  compatUtils;
var init_runtime_core_esm_bundler = __esm({
  "node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js"() {
    init_reactivity_esm_bundler();
    init_reactivity_esm_bundler();
    init_shared_esm_bundler();
    init_shared_esm_bundler();
    stack = [];
    isFlushing = false;
    isFlushPending = false;
    queue$4 = [];
    flushIndex = 0;
    pendingPreFlushCbs = [];
    activePreFlushCbs = null;
    preFlushIndex = 0;
    pendingPostFlushCbs = [];
    activePostFlushCbs = null;
    postFlushIndex = 0;
    resolvedPromise = Promise.resolve();
    currentFlushPromise = null;
    currentPreFlushParentJob = null;
    getId = (job) => (job.id == null ? Infinity : job.id);
    buffer = [];
    currentRenderingInstance = null;
    currentScopeId = null;
    withScopeId = (_id) => withCtx;
    getFunctionalFallthrough = (attrs) => {
      let res;
      for (const key in attrs) {
        if (key === "class" || key === "style" || isOn(key)) {
          (res || (res = {}))[key] = attrs[key];
        }
      }
      return res;
    };
    filterModelListeners = (attrs, props) => {
      const res = {};
      for (const key in attrs) {
        if (!isModelListener(key) || !(key.slice(9) in props)) {
          res[key] = attrs[key];
        }
      }
      return res;
    };
    isSuspense = (type) => type.__isSuspense;
    SuspenseImpl = {
      name: "Suspense",
      // In order to make Suspense tree-shakable, we need to avoid importing it
      // directly in the renderer. The renderer checks for the __isSuspense flag
      // on a vnode's type and calls the `process` method, passing in renderer
      // internals.
      __isSuspense: true,
      process(
        n1,
        n2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized,
        rendererInternals
      ) {
        if (n1 == null) {
          mountSuspense(
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized,
            rendererInternals
          );
        } else {
          patchSuspense(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            isSVG,
            slotScopeIds,
            optimized,
            rendererInternals
          );
        }
      },
      hydrate: hydrateSuspense,
      create: createSuspenseBoundary,
      normalize: normalizeSuspenseChildren,
    };
    Suspense = SuspenseImpl;
    INITIAL_WATCHER_VALUE = {};
    TransitionHookValidator = [Function, Array];
    BaseTransitionImpl = {
      name: `BaseTransition`,
      props: {
        mode: String,
        appear: Boolean,
        persisted: Boolean,
        // enter
        onBeforeEnter: TransitionHookValidator,
        onEnter: TransitionHookValidator,
        onAfterEnter: TransitionHookValidator,
        onEnterCancelled: TransitionHookValidator,
        // leave
        onBeforeLeave: TransitionHookValidator,
        onLeave: TransitionHookValidator,
        onAfterLeave: TransitionHookValidator,
        onLeaveCancelled: TransitionHookValidator,
        // appear
        onBeforeAppear: TransitionHookValidator,
        onAppear: TransitionHookValidator,
        onAfterAppear: TransitionHookValidator,
        onAppearCancelled: TransitionHookValidator,
      },
      setup(props, { slots }) {
        const instance = getCurrentInstance();
        const state = useTransitionState();
        let prevTransitionKey;
        return () => {
          const children =
            slots.default && getTransitionRawChildren(slots.default(), true);
          if (!children || !children.length) {
            return;
          }
          const rawProps = toRaw(props);
          const { mode } = rawProps;
          const child = children[0];
          if (state.isLeaving) {
            return emptyPlaceholder(child);
          }
          const innerChild = getKeepAliveChild(child);
          if (!innerChild) {
            return emptyPlaceholder(child);
          }
          const enterHooks = resolveTransitionHooks(
            innerChild,
            rawProps,
            state,
            instance
          );
          setTransitionHooks(innerChild, enterHooks);
          const oldChild = instance.subTree;
          const oldInnerChild = oldChild && getKeepAliveChild(oldChild);
          let transitionKeyChanged = false;
          const { getTransitionKey } = innerChild.type;
          if (getTransitionKey) {
            const key = getTransitionKey();
            if (prevTransitionKey === void 0) {
              prevTransitionKey = key;
            } else if (key !== prevTransitionKey) {
              prevTransitionKey = key;
              transitionKeyChanged = true;
            }
          }
          if (
            oldInnerChild &&
            oldInnerChild.type !== Comment &&
            (!isSameVNodeType(innerChild, oldInnerChild) ||
              transitionKeyChanged)
          ) {
            const leavingHooks = resolveTransitionHooks(
              oldInnerChild,
              rawProps,
              state,
              instance
            );
            setTransitionHooks(oldInnerChild, leavingHooks);
            if (mode === "out-in") {
              state.isLeaving = true;
              leavingHooks.afterLeave = () => {
                state.isLeaving = false;
                instance.update();
              };
              return emptyPlaceholder(child);
            } else if (mode === "in-out" && innerChild.type !== Comment) {
              leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
                const leavingVNodesCache = getLeavingNodesForType(
                  state,
                  oldInnerChild
                );
                leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
                el._leaveCb = () => {
                  earlyRemove();
                  el._leaveCb = void 0;
                  delete enterHooks.delayedLeave;
                };
                enterHooks.delayedLeave = delayedLeave;
              };
            }
          }
          return child;
        };
      },
    };
    BaseTransition = BaseTransitionImpl;
    isAsyncWrapper = (i) => !!i.type.__asyncLoader;
    isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
    KeepAliveImpl = {
      name: `KeepAlive`,
      // Marker for special handling inside the renderer. We are not using a ===
      // check directly on KeepAlive in the renderer, because importing it directly
      // would prevent it from being tree-shaken.
      __isKeepAlive: true,
      props: {
        include: [String, RegExp, Array],
        exclude: [String, RegExp, Array],
        max: [String, Number],
      },
      setup(props, { slots }) {
        const instance = getCurrentInstance();
        const sharedContext = instance.ctx;
        if (!sharedContext.renderer) {
          return slots.default;
        }
        const cache = /* @__PURE__ */ new Map();
        const keys = /* @__PURE__ */ new Set();
        let current = null;
        const parentSuspense = instance.suspense;
        const {
          renderer: {
            p: patch,
            m: move,
            um: _unmount,
            o: { createElement },
          },
        } = sharedContext;
        const storageContainer = createElement("div");
        sharedContext.activate = (
          vnode,
          container,
          anchor,
          isSVG,
          optimized
        ) => {
          const instance2 = vnode.component;
          move(vnode, container, anchor, 0, parentSuspense);
          patch(
            instance2.vnode,
            vnode,
            container,
            anchor,
            instance2,
            parentSuspense,
            isSVG,
            vnode.slotScopeIds,
            optimized
          );
          queuePostRenderEffect(() => {
            instance2.isDeactivated = false;
            if (instance2.a) {
              invokeArrayFns(instance2.a);
            }
            const vnodeHook = vnode.props && vnode.props.onVnodeMounted;
            if (vnodeHook) {
              invokeVNodeHook(vnodeHook, instance2.parent, vnode);
            }
          }, parentSuspense);
        };
        sharedContext.deactivate = (vnode) => {
          const instance2 = vnode.component;
          move(vnode, storageContainer, null, 1, parentSuspense);
          queuePostRenderEffect(() => {
            if (instance2.da) {
              invokeArrayFns(instance2.da);
            }
            const vnodeHook = vnode.props && vnode.props.onVnodeUnmounted;
            if (vnodeHook) {
              invokeVNodeHook(vnodeHook, instance2.parent, vnode);
            }
            instance2.isDeactivated = true;
          }, parentSuspense);
        };
        function unmount(vnode) {
          resetShapeFlag(vnode);
          _unmount(vnode, instance, parentSuspense, true);
        }
        function pruneCache(filter) {
          cache.forEach((vnode, key) => {
            const name = getComponentName(vnode.type);
            if (name && (!filter || !filter(name))) {
              pruneCacheEntry(key);
            }
          });
        }
        function pruneCacheEntry(key) {
          const cached = cache.get(key);
          if (!current || cached.type !== current.type) {
            unmount(cached);
          } else if (current) {
            resetShapeFlag(current);
          }
          cache.delete(key);
          keys.delete(key);
        }
        watch(
          () => [props.include, props.exclude],
          ([include, exclude]) => {
            include && pruneCache((name) => matches(include, name));
            exclude && pruneCache((name) => !matches(exclude, name));
          },
          // prune post-render after `current` has been updated
          { flush: "post", deep: true }
        );
        let pendingCacheKey = null;
        const cacheSubtree = () => {
          if (pendingCacheKey != null) {
            cache.set(pendingCacheKey, getInnerChild(instance.subTree));
          }
        };
        onMounted$1(cacheSubtree);
        onUpdated$1(cacheSubtree);
        onBeforeUnmount(() => {
          cache.forEach((cached) => {
            const { subTree, suspense } = instance;
            const vnode = getInnerChild(subTree);
            if (cached.type === vnode.type) {
              resetShapeFlag(vnode);
              const da = vnode.component.da;
              da && queuePostRenderEffect(da, suspense);
              return;
            }
            unmount(cached);
          });
        });
        return () => {
          pendingCacheKey = null;
          if (!slots.default) {
            return null;
          }
          const children = slots.default();
          const rawVNode = children[0];
          if (children.length > 1) {
            current = null;
            return children;
          } else if (
            !isVNode(rawVNode) ||
            (!(rawVNode.shapeFlag & 4) && !(rawVNode.shapeFlag & 128))
          ) {
            current = null;
            return rawVNode;
          }
          let vnode = getInnerChild(rawVNode);
          const comp = vnode.type;
          const name = getComponentName(
            isAsyncWrapper(vnode) ? vnode.type.__asyncResolved || {} : comp
          );
          const { include, exclude, max } = props;
          if (
            (include && (!name || !matches(include, name))) ||
            (exclude && name && matches(exclude, name))
          ) {
            current = vnode;
            return rawVNode;
          }
          const key = vnode.key == null ? comp : vnode.key;
          const cachedVNode = cache.get(key);
          if (vnode.el) {
            vnode = cloneVNode(vnode);
            if (rawVNode.shapeFlag & 128) {
              rawVNode.ssContent = vnode;
            }
          }
          pendingCacheKey = key;
          if (cachedVNode) {
            vnode.el = cachedVNode.el;
            vnode.component = cachedVNode.component;
            if (vnode.transition) {
              setTransitionHooks(vnode, vnode.transition);
            }
            vnode.shapeFlag |= 512;
            keys.delete(key);
            keys.add(key);
          } else {
            keys.add(key);
            if (max && keys.size > parseInt(max, 10)) {
              pruneCacheEntry(keys.values().next().value);
            }
          }
          vnode.shapeFlag |= 256;
          current = vnode;
          return rawVNode;
        };
      },
    };
    KeepAlive = KeepAliveImpl;
    createHook =
      (lifecycle) =>
      (hook, target = currentInstance) =>
        // post-create lifecycle registrations are noops during SSR (except for serverPrefetch)
        (!isInSSRComponentSetup || lifecycle === "sp") &&
        injectHook(lifecycle, hook, target);
    onBeforeMount = createHook(
      "bm"
      /* BEFORE_MOUNT */
    );
    onMounted$1 = createHook(
      "m"
      /* MOUNTED */
    );
    onBeforeUpdate = createHook(
      "bu"
      /* BEFORE_UPDATE */
    );
    onUpdated$1 = createHook(
      "u"
      /* UPDATED */
    );
    onBeforeUnmount = createHook(
      "bum"
      /* BEFORE_UNMOUNT */
    );
    onUnmounted$1 = createHook(
      "um"
      /* UNMOUNTED */
    );
    onServerPrefetch = createHook(
      "sp"
      /* SERVER_PREFETCH */
    );
    onRenderTriggered = createHook(
      "rtg"
      /* RENDER_TRIGGERED */
    );
    onRenderTracked = createHook(
      "rtc"
      /* RENDER_TRACKED */
    );
    shouldCacheAccess = true;
    internalOptionMergeStrats = {
      data: mergeDataFn,
      props: mergeObjectOptions,
      emits: mergeObjectOptions,
      // objects
      methods: mergeObjectOptions,
      computed: mergeObjectOptions,
      // lifecycle
      beforeCreate: mergeAsArray$1,
      created: mergeAsArray$1,
      beforeMount: mergeAsArray$1,
      mounted: mergeAsArray$1,
      beforeUpdate: mergeAsArray$1,
      updated: mergeAsArray$1,
      beforeDestroy: mergeAsArray$1,
      beforeUnmount: mergeAsArray$1,
      destroyed: mergeAsArray$1,
      unmounted: mergeAsArray$1,
      activated: mergeAsArray$1,
      deactivated: mergeAsArray$1,
      errorCaptured: mergeAsArray$1,
      serverPrefetch: mergeAsArray$1,
      // assets
      components: mergeObjectOptions,
      directives: mergeObjectOptions,
      // watch
      watch: mergeWatchOptions,
      // provide / inject
      provide: mergeDataFn,
      inject: mergeInject,
    };
    isInternalKey = (key) => key[0] === "_" || key === "$stable";
    normalizeSlotValue = (value) =>
      isArray(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
    normalizeSlot$1 = (key, rawSlot, ctx) => {
      const normalized = withCtx((...args) => {
        return normalizeSlotValue(rawSlot(...args));
      }, ctx);
      normalized._c = false;
      return normalized;
    };
    normalizeObjectSlots = (rawSlots, slots, instance) => {
      const ctx = rawSlots._ctx;
      for (const key in rawSlots) {
        if (isInternalKey(key)) continue;
        const value = rawSlots[key];
        if (isFunction$1(value)) {
          slots[key] = normalizeSlot$1(key, value, ctx);
        } else if (value != null) {
          const normalized = normalizeSlotValue(value);
          slots[key] = () => normalized;
        }
      }
    };
    normalizeVNodeSlots = (instance, children) => {
      const normalized = normalizeSlotValue(children);
      instance.slots.default = () => normalized;
    };
    initSlots = (instance, children) => {
      if (instance.vnode.shapeFlag & 32) {
        const type = children._;
        if (type) {
          instance.slots = toRaw(children);
          def(children, "_", type);
        } else {
          normalizeObjectSlots(children, (instance.slots = {}));
        }
      } else {
        instance.slots = {};
        if (children) {
          normalizeVNodeSlots(instance, children);
        }
      }
      def(instance.slots, InternalObjectKey, 1);
    };
    updateSlots = (instance, children, optimized) => {
      const { vnode, slots } = instance;
      let needDeletionCheck = true;
      let deletionComparisonTarget = EMPTY_OBJ;
      if (vnode.shapeFlag & 32) {
        const type = children._;
        if (type) {
          if (optimized && type === 1) {
            needDeletionCheck = false;
          } else {
            extend(slots, children);
            if (!optimized && type === 1) {
              delete slots._;
            }
          }
        } else {
          needDeletionCheck = !children.$stable;
          normalizeObjectSlots(children, slots);
        }
        deletionComparisonTarget = children;
      } else if (children) {
        normalizeVNodeSlots(instance, children);
        deletionComparisonTarget = { default: 1 };
      }
      if (needDeletionCheck) {
        for (const key in slots) {
          if (!isInternalKey(key) && !(key in deletionComparisonTarget)) {
            delete slots[key];
          }
        }
      }
    };
    uid$6 = 0;
    hasMismatch = false;
    isSVGContainer = (container) =>
      /svg/.test(container.namespaceURI) &&
      container.tagName !== "foreignObject";
    isComment = (node) => node.nodeType === 8;
    queuePostRenderEffect = queueEffectWithSuspense;
    isTeleport = (type) => type.__isTeleport;
    isTeleportDisabled = (props) =>
      props && (props.disabled || props.disabled === "");
    isTargetSVG = (target) =>
      typeof SVGElement !== "undefined" && target instanceof SVGElement;
    resolveTarget = (props, select) => {
      const targetSelector = props && props.to;
      if (isString$1(targetSelector)) {
        if (!select) {
          return null;
        } else {
          const target = select(targetSelector);
          return target;
        }
      } else {
        return targetSelector;
      }
    };
    TeleportImpl = {
      __isTeleport: true,
      process(
        n1,
        n2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized,
        internals
      ) {
        const {
          mc: mountChildren,
          pc: patchChildren,
          pbc: patchBlockChildren,
          o: { insert, querySelector, createText, createComment },
        } = internals;
        const disabled = isTeleportDisabled(n2.props);
        let { shapeFlag, children, dynamicChildren } = n2;
        if (n1 == null) {
          const placeholder = (n2.el = createText(""));
          const mainAnchor = (n2.anchor = createText(""));
          insert(placeholder, container, anchor);
          insert(mainAnchor, container, anchor);
          const target = (n2.target = resolveTarget(n2.props, querySelector));
          const targetAnchor = (n2.targetAnchor = createText(""));
          if (target) {
            insert(targetAnchor, target);
            isSVG = isSVG || isTargetSVG(target);
          }
          const mount = (container2, anchor2) => {
            if (shapeFlag & 16) {
              mountChildren(
                children,
                container2,
                anchor2,
                parentComponent,
                parentSuspense,
                isSVG,
                slotScopeIds,
                optimized
              );
            }
          };
          if (disabled) {
            mount(container, mainAnchor);
          } else if (target) {
            mount(target, targetAnchor);
          }
        } else {
          n2.el = n1.el;
          const mainAnchor = (n2.anchor = n1.anchor);
          const target = (n2.target = n1.target);
          const targetAnchor = (n2.targetAnchor = n1.targetAnchor);
          const wasDisabled = isTeleportDisabled(n1.props);
          const currentContainer = wasDisabled ? container : target;
          const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
          isSVG = isSVG || isTargetSVG(target);
          if (dynamicChildren) {
            patchBlockChildren(
              n1.dynamicChildren,
              dynamicChildren,
              currentContainer,
              parentComponent,
              parentSuspense,
              isSVG,
              slotScopeIds
            );
            traverseStaticChildren(n1, n2, true);
          } else if (!optimized) {
            patchChildren(
              n1,
              n2,
              currentContainer,
              currentAnchor,
              parentComponent,
              parentSuspense,
              isSVG,
              slotScopeIds,
              false
            );
          }
          if (disabled) {
            if (!wasDisabled) {
              moveTeleport(
                n2,
                container,
                mainAnchor,
                internals,
                1
                /* TOGGLE */
              );
            }
          } else {
            if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
              const nextTarget = (n2.target = resolveTarget(
                n2.props,
                querySelector
              ));
              if (nextTarget) {
                moveTeleport(
                  n2,
                  nextTarget,
                  null,
                  internals,
                  0
                  /* TARGET_CHANGE */
                );
              }
            } else if (wasDisabled) {
              moveTeleport(
                n2,
                target,
                targetAnchor,
                internals,
                1
                /* TOGGLE */
              );
            }
          }
        }
      },
      remove(
        vnode,
        parentComponent,
        parentSuspense,
        optimized,
        { um: unmount, o: { remove: hostRemove } },
        doRemove
      ) {
        const { shapeFlag, children, anchor, targetAnchor, target, props } =
          vnode;
        if (target) {
          hostRemove(targetAnchor);
        }
        if (doRemove || !isTeleportDisabled(props)) {
          hostRemove(anchor);
          if (shapeFlag & 16) {
            for (let i = 0; i < children.length; i++) {
              const child = children[i];
              unmount(
                child,
                parentComponent,
                parentSuspense,
                true,
                !!child.dynamicChildren
              );
            }
          }
        }
      },
      move: moveTeleport,
      hydrate: hydrateTeleport,
    };
    Teleport = TeleportImpl;
    COMPONENTS = "components";
    DIRECTIVES = "directives";
    NULL_DYNAMIC_COMPONENT = Symbol();
    Fragment = Symbol(void 0);
    Text = Symbol(void 0);
    Comment = Symbol(void 0);
    Static = Symbol(void 0);
    blockStack = [];
    currentBlock = null;
    isBlockTreeEnabled = 1;
    InternalObjectKey = `__vInternal`;
    normalizeKey = ({ key }) => (key != null ? key : null);
    normalizeRef = ({ ref: ref2, ref_key, ref_for }) => {
      return ref2 != null
        ? isString$1(ref2) || isRef(ref2) || isFunction$1(ref2)
          ? { i: currentRenderingInstance, r: ref2, k: ref_key, f: !!ref_for }
          : ref2
        : null;
    };
    createVNode = _createVNode;
    getPublicInstance = (i) => {
      if (!i) return null;
      if (isStatefulComponent(i)) return getExposeProxy(i) || i.proxy;
      return getPublicInstance(i.parent);
    };
    publicPropertiesMap = extend(/* @__PURE__ */ Object.create(null), {
      $: (i) => i,
      $el: (i) => i.vnode.el,
      $data: (i) => i.data,
      $props: (i) => i.props,
      $attrs: (i) => i.attrs,
      $slots: (i) => i.slots,
      $refs: (i) => i.refs,
      $parent: (i) => getPublicInstance(i.parent),
      $root: (i) => getPublicInstance(i.root),
      $emit: (i) => i.emit,
      $options: (i) => resolveMergedOptions(i),
      $forceUpdate: (i) => () => queueJob(i.update),
      $nextTick: (i) => nextTick.bind(i.proxy),
      $watch: (i) => instanceWatch.bind(i),
    });
    PublicInstanceProxyHandlers = {
      get({ _: instance }, key) {
        const { ctx, setupState, data, props, accessCache, type, appContext } =
          instance;
        let normalizedProps;
        if (key[0] !== "$") {
          const n = accessCache[key];
          if (n !== void 0) {
            switch (n) {
              case 1:
                return setupState[key];
              case 2:
                return data[key];
              case 4:
                return ctx[key];
              case 3:
                return props[key];
            }
          } else if (setupState !== EMPTY_OBJ && hasOwn(setupState, key)) {
            accessCache[key] = 1;
            return setupState[key];
          } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
            accessCache[key] = 2;
            return data[key];
          } else if (
            // only cache other properties when instance has declared (thus stable)
            // props
            (normalizedProps = instance.propsOptions[0]) &&
            hasOwn(normalizedProps, key)
          ) {
            accessCache[key] = 3;
            return props[key];
          } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
            accessCache[key] = 4;
            return ctx[key];
          } else if (shouldCacheAccess) {
            accessCache[key] = 0;
          }
        }
        const publicGetter = publicPropertiesMap[key];
        let cssModule, globalProperties;
        if (publicGetter) {
          if (key === "$attrs") {
            track(instance, "get", key);
          }
          return publicGetter(instance);
        } else if (
          // css module (injected by vue-loader)
          (cssModule = type.__cssModules) &&
          (cssModule = cssModule[key])
        ) {
          return cssModule;
        } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
          accessCache[key] = 4;
          return ctx[key];
        } else if (
          // global properties
          ((globalProperties = appContext.config.globalProperties),
          hasOwn(globalProperties, key))
        ) {
          {
            return globalProperties[key];
          }
        } else;
      },
      set({ _: instance }, key, value) {
        const { data, setupState, ctx } = instance;
        if (setupState !== EMPTY_OBJ && hasOwn(setupState, key)) {
          setupState[key] = value;
          return true;
        } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
          data[key] = value;
          return true;
        } else if (hasOwn(instance.props, key)) {
          return false;
        }
        if (key[0] === "$" && key.slice(1) in instance) {
          return false;
        } else {
          {
            ctx[key] = value;
          }
        }
        return true;
      },
      has(
        { _: { data, setupState, accessCache, ctx, appContext, propsOptions } },
        key
      ) {
        let normalizedProps;
        return (
          !!accessCache[key] ||
          (data !== EMPTY_OBJ && hasOwn(data, key)) ||
          (setupState !== EMPTY_OBJ && hasOwn(setupState, key)) ||
          ((normalizedProps = propsOptions[0]) &&
            hasOwn(normalizedProps, key)) ||
          hasOwn(ctx, key) ||
          hasOwn(publicPropertiesMap, key) ||
          hasOwn(appContext.config.globalProperties, key)
        );
      },
      defineProperty(target, key, descriptor) {
        if (descriptor.get != null) {
          target.$.accessCache[key] = 0;
        } else if (hasOwn(descriptor, "value")) {
          this.set(target, key, descriptor.value, null);
        }
        return Reflect.defineProperty(target, key, descriptor);
      },
    };
    RuntimeCompiledPublicInstanceProxyHandlers = /* @__PURE__ */ extend(
      {},
      PublicInstanceProxyHandlers,
      {
        get(target, key) {
          if (key === Symbol.unscopables) {
            return;
          }
          return PublicInstanceProxyHandlers.get(target, key, target);
        },
        has(_, key) {
          const has2 = key[0] !== "_" && !isGloballyWhitelisted(key);
          return has2;
        },
      }
    );
    emptyAppContext = createAppContext();
    uid$1$4 = 0;
    currentInstance = null;
    getCurrentInstance = () => currentInstance || currentRenderingInstance;
    setCurrentInstance = (instance) => {
      currentInstance = instance;
      instance.scope.on();
    };
    unsetCurrentInstance = () => {
      currentInstance && currentInstance.scope.off();
      currentInstance = null;
    };
    isInSSRComponentSetup = false;
    isRuntimeOnly = () => !compile$1;
    classifyRE = /(?:^|[-_])(\w)/g;
    classify = (str) =>
      str.replace(classifyRE, (c) => c.toUpperCase()).replace(/[-_]/g, "");
    computed2 = (getterOrOptions, debugOptions) => {
      return computed(getterOrOptions, debugOptions, isInSSRComponentSetup);
    };
    ssrContextKey = Symbol(``);
    useSSRContext = () => {
      {
        const ctx = inject(ssrContextKey);
        if (!ctx) {
          warn2(
            `Server rendering context not provided. Make sure to only call useSSRContext() conditionally in the server build.`
          );
        }
        return ctx;
      }
    };
    version$4 = "3.2.32";
    _ssrUtils = {
      createComponentInstance,
      setupComponent,
      renderComponentRoot,
      setCurrentRenderingInstance,
      isVNode,
      normalizeVNode,
    };
    ssrUtils = _ssrUtils;
    resolveFilter = null;
    compatUtils = null;
  },
});

// node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js
var runtime_dom_esm_bundler_exports = {};
__export(runtime_dom_esm_bundler_exports, {
  BaseTransition: () => BaseTransition,
  Comment: () => Comment,
  EffectScope: () => EffectScope,
  Fragment: () => Fragment,
  KeepAlive: () => KeepAlive,
  ReactiveEffect: () => ReactiveEffect,
  Static: () => Static,
  Suspense: () => Suspense,
  Teleport: () => Teleport,
  Text: () => Text,
  Transition: () => Transition,
  TransitionGroup: () => TransitionGroup,
  VueElement: () => VueElement,
  callWithAsyncErrorHandling: () => callWithAsyncErrorHandling,
  callWithErrorHandling: () => callWithErrorHandling,
  camelize: () => camelize,
  capitalize: () => capitalize,
  cloneVNode: () => cloneVNode,
  compatUtils: () => compatUtils,
  computed: () => computed2,
  createApp: () => createApp,
  createBlock: () => createBlock,
  createCommentVNode: () => createCommentVNode,
  createElementBlock: () => createElementBlock,
  createElementVNode: () => createBaseVNode,
  createHydrationRenderer: () => createHydrationRenderer,
  createPropsRestProxy: () => createPropsRestProxy,
  createRenderer: () => createRenderer,
  createSSRApp: () => createSSRApp,
  createSlots: () => createSlots,
  createStaticVNode: () => createStaticVNode,
  createTextVNode: () => createTextVNode,
  createVNode: () => createVNode,
  customRef: () => customRef,
  defineAsyncComponent: () => defineAsyncComponent,
  defineComponent: () => defineComponent,
  defineCustomElement: () => defineCustomElement,
  defineEmits: () => defineEmits,
  defineExpose: () => defineExpose,
  defineProps: () => defineProps,
  defineSSRCustomElement: () => defineSSRCustomElement,
  devtools: () => devtools,
  effect: () => effect$3,
  effectScope: () => effectScope,
  getCurrentInstance: () => getCurrentInstance,
  getCurrentScope: () => getCurrentScope,
  getTransitionRawChildren: () => getTransitionRawChildren,
  guardReactiveProps: () => guardReactiveProps,
  h: () => h,
  handleError: () => handleError,
  hydrate: () => hydrate,
  initCustomFormatter: () => initCustomFormatter,
  initDirectivesForSSR: () => initDirectivesForSSR,
  inject: () => inject,
  isMemoSame: () => isMemoSame,
  isProxy: () => isProxy,
  isReactive: () => isReactive,
  isReadonly: () => isReadonly,
  isRef: () => isRef,
  isRuntimeOnly: () => isRuntimeOnly,
  isShallow: () => isShallow,
  isVNode: () => isVNode,
  markRaw: () => markRaw,
  mergeDefaults: () => mergeDefaults,
  mergeProps: () => mergeProps,
  nextTick: () => nextTick,
  normalizeClass: () => normalizeClass,
  normalizeProps: () => normalizeProps,
  normalizeStyle: () => normalizeStyle,
  onActivated: () => onActivated,
  onBeforeMount: () => onBeforeMount,
  onBeforeUnmount: () => onBeforeUnmount,
  onBeforeUpdate: () => onBeforeUpdate,
  onDeactivated: () => onDeactivated,
  onErrorCaptured: () => onErrorCaptured,
  onMounted: () => onMounted$1,
  onRenderTracked: () => onRenderTracked,
  onRenderTriggered: () => onRenderTriggered,
  onScopeDispose: () => onScopeDispose,
  onServerPrefetch: () => onServerPrefetch,
  onUnmounted: () => onUnmounted$1,
  onUpdated: () => onUpdated$1,
  openBlock: () => openBlock,
  popScopeId: () => popScopeId,
  provide: () => provide,
  proxyRefs: () => proxyRefs,
  pushScopeId: () => pushScopeId,
  queuePostFlushCb: () => queuePostFlushCb,
  reactive: () => reactive,
  readonly: () => readonly,
  ref: () => ref,
  registerRuntimeCompiler: () => registerRuntimeCompiler,
  render: () => render$1,
  renderList: () => renderList,
  renderSlot: () => renderSlot,
  resolveComponent: () => resolveComponent,
  resolveDirective: () => resolveDirective,
  resolveDynamicComponent: () => resolveDynamicComponent,
  resolveFilter: () => resolveFilter,
  resolveTransitionHooks: () => resolveTransitionHooks,
  setBlockTracking: () => setBlockTracking,
  setDevtoolsHook: () => setDevtoolsHook,
  setTransitionHooks: () => setTransitionHooks,
  shallowReactive: () => shallowReactive,
  shallowReadonly: () => shallowReadonly,
  shallowRef: () => shallowRef,
  ssrContextKey: () => ssrContextKey,
  ssrUtils: () => ssrUtils,
  stop: () => stop,
  toDisplayString: () => toDisplayString,
  toHandlerKey: () => toHandlerKey,
  toHandlers: () => toHandlers,
  toRaw: () => toRaw,
  toRef: () => toRef,
  toRefs: () => toRefs,
  transformVNodeArgs: () => transformVNodeArgs,
  triggerRef: () => triggerRef,
  unref: () => unref,
  useAttrs: () => useAttrs,
  useCssModule: () => useCssModule,
  useCssVars: () => useCssVars,
  useSSRContext: () => useSSRContext,
  useSlots: () => useSlots,
  useTransitionState: () => useTransitionState,
  vModelCheckbox: () => vModelCheckbox,
  vModelDynamic: () => vModelDynamic,
  vModelRadio: () => vModelRadio,
  vModelSelect: () => vModelSelect,
  vModelText: () => vModelText,
  vShow: () => vShow,
  version: () => version$4,
  warn: () => warn2,
  watch: () => watch,
  watchEffect: () => watchEffect,
  watchPostEffect: () => watchPostEffect,
  watchSyncEffect: () => watchSyncEffect,
  withAsyncContext: () => withAsyncContext,
  withCtx: () => withCtx,
  withDefaults: () => withDefaults,
  withDirectives: () => withDirectives,
  withKeys: () => withKeys,
  withMemo: () => withMemo,
  withModifiers: () => withModifiers,
  withScopeId: () => withScopeId,
});
function patchClass(el, value, isSVG) {
  const transitionClasses = el._vtc;
  if (transitionClasses) {
    value = (
      value ? [value, ...transitionClasses] : [...transitionClasses]
    ).join(" ");
  }
  if (value == null) {
    el.removeAttribute("class");
  } else if (isSVG) {
    el.setAttribute("class", value);
  } else {
    el.className = value;
  }
}
function patchStyle(el, prev, next) {
  const style = el.style;
  const isCssString = isString$1(next);
  if (next && !isCssString) {
    for (const key in next) {
      setStyle(style, key, next[key]);
    }
    if (prev && !isString$1(prev)) {
      for (const key in prev) {
        if (next[key] == null) {
          setStyle(style, key, "");
        }
      }
    }
  } else {
    const currentDisplay = style.display;
    if (isCssString) {
      if (prev !== next) {
        style.cssText = next;
      }
    } else if (prev) {
      el.removeAttribute("style");
    }
    if ("_vod" in el) {
      style.display = currentDisplay;
    }
  }
}
function setStyle(style, name, val) {
  if (isArray(val)) {
    val.forEach((v) => setStyle(style, name, v));
  } else {
    if (name.startsWith("--")) {
      style.setProperty(name, val);
    } else {
      const prefixed = autoPrefix(style, name);
      if (importantRE.test(val)) {
        style.setProperty(
          hyphenate(prefixed),
          val.replace(importantRE, ""),
          "important"
        );
      } else {
        style[prefixed] = val;
      }
    }
  }
}
function autoPrefix(style, rawName) {
  const cached = prefixCache[rawName];
  if (cached) {
    return cached;
  }
  let name = camelize(rawName);
  if (name !== "filter" && name in style) {
    return (prefixCache[rawName] = name);
  }
  name = capitalize(name);
  for (let i = 0; i < prefixes.length; i++) {
    const prefixed = prefixes[i] + name;
    if (prefixed in style) {
      return (prefixCache[rawName] = prefixed);
    }
  }
  return rawName;
}
function patchAttr(el, key, value, isSVG, instance) {
  if (isSVG && key.startsWith("xlink:")) {
    if (value == null) {
      el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    const isBoolean2 = isSpecialBooleanAttr(key);
    if (value == null || (isBoolean2 && !includeBooleanAttr(value))) {
      el.removeAttribute(key);
    } else {
      el.setAttribute(key, isBoolean2 ? "" : value);
    }
  }
}
function patchDOMProp(
  el,
  key,
  value,
  prevChildren,
  parentComponent,
  parentSuspense,
  unmountChildren
) {
  if (key === "innerHTML" || key === "textContent") {
    if (prevChildren) {
      unmountChildren(prevChildren, parentComponent, parentSuspense);
    }
    el[key] = value == null ? "" : value;
    return;
  }
  if (
    key === "value" &&
    el.tagName !== "PROGRESS" && // custom elements may use _value internally
    !el.tagName.includes("-")
  ) {
    el._value = value;
    const newValue = value == null ? "" : value;
    if (
      el.value !== newValue || // #4956: always set for OPTION elements because its value falls back to
      // textContent if no value attribute is present. And setting .value for
      // OPTION has no side effect
      el.tagName === "OPTION"
    ) {
      el.value = newValue;
    }
    if (value == null) {
      el.removeAttribute(key);
    }
    return;
  }
  if (value === "" || value == null) {
    const type = typeof el[key];
    if (type === "boolean") {
      el[key] = includeBooleanAttr(value);
      return;
    } else if (value == null && type === "string") {
      el[key] = "";
      el.removeAttribute(key);
      return;
    } else if (type === "number") {
      try {
        el[key] = 0;
      } catch (_a2) {}
      el.removeAttribute(key);
      return;
    }
  }
  try {
    el[key] = value;
  } catch (e) {}
}
function addEventListener(el, event, handler, options) {
  el.addEventListener(event, handler, options);
}
function removeEventListener(el, event, handler, options) {
  el.removeEventListener(event, handler, options);
}
function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
  const invokers = el._vei || (el._vei = {});
  const existingInvoker = invokers[rawName];
  if (nextValue && existingInvoker) {
    existingInvoker.value = nextValue;
  } else {
    const [name, options] = parseName(rawName);
    if (nextValue) {
      const invoker = (invokers[rawName] = createInvoker(nextValue, instance));
      addEventListener(el, name, invoker, options);
    } else if (existingInvoker) {
      removeEventListener(el, name, existingInvoker, options);
      invokers[rawName] = void 0;
    }
  }
}
function parseName(name) {
  let options;
  if (optionsModifierRE.test(name)) {
    options = {};
    let m;
    while ((m = name.match(optionsModifierRE))) {
      name = name.slice(0, name.length - m[0].length);
      options[m[0].toLowerCase()] = true;
    }
  }
  return [hyphenate(name.slice(2)), options];
}
function createInvoker(initialValue, instance) {
  const invoker = (e) => {
    const timeStamp = e.timeStamp || _getNow();
    if (skipTimestampCheck || timeStamp >= invoker.attached - 1) {
      callWithAsyncErrorHandling(
        patchStopImmediatePropagation(e, invoker.value),
        instance,
        5,
        [e]
      );
    }
  };
  invoker.value = initialValue;
  invoker.attached = getNow();
  return invoker;
}
function patchStopImmediatePropagation(e, value) {
  if (isArray(value)) {
    const originalStop = e.stopImmediatePropagation;
    e.stopImmediatePropagation = () => {
      originalStop.call(e);
      e._stopped = true;
    };
    return value.map((fn) => (e2) => !e2._stopped && fn && fn(e2));
  } else {
    return value;
  }
}
function shouldSetAsProp(el, key, value, isSVG) {
  if (isSVG) {
    if (key === "innerHTML" || key === "textContent") {
      return true;
    }
    if (key in el && nativeOnRE.test(key) && isFunction$1(value)) {
      return true;
    }
    return false;
  }
  if (key === "spellcheck" || key === "draggable") {
    return false;
  }
  if (key === "form") {
    return false;
  }
  if (key === "list" && el.tagName === "INPUT") {
    return false;
  }
  if (key === "type" && el.tagName === "TEXTAREA") {
    return false;
  }
  if (nativeOnRE.test(key) && isString$1(value)) {
    return false;
  }
  return key in el;
}
function defineCustomElement(options, hydate) {
  const Comp = defineComponent(options);
  class VueCustomElement extends VueElement {
    constructor(initialProps) {
      super(Comp, initialProps, hydate);
    }
  }
  VueCustomElement.def = Comp;
  return VueCustomElement;
}
function useCssModule(name = "$style") {
  {
    const instance = getCurrentInstance();
    if (!instance) {
      return EMPTY_OBJ;
    }
    const modules = instance.type.__cssModules;
    if (!modules) {
      return EMPTY_OBJ;
    }
    const mod = modules[name];
    if (!mod) {
      return EMPTY_OBJ;
    }
    return mod;
  }
}
function useCssVars(getter) {
  const instance = getCurrentInstance();
  if (!instance) {
    return;
  }
  const setVars = () =>
    setVarsOnVNode(instance.subTree, getter(instance.proxy));
  watchPostEffect(setVars);
  onMounted$1(() => {
    const ob = new MutationObserver(setVars);
    ob.observe(instance.subTree.el.parentNode, { childList: true });
    onUnmounted$1(() => ob.disconnect());
  });
}
function setVarsOnVNode(vnode, vars) {
  if (vnode.shapeFlag & 128) {
    const suspense = vnode.suspense;
    vnode = suspense.activeBranch;
    if (suspense.pendingBranch && !suspense.isHydrating) {
      suspense.effects.push(() => {
        setVarsOnVNode(suspense.activeBranch, vars);
      });
    }
  }
  while (vnode.component) {
    vnode = vnode.component.subTree;
  }
  if (vnode.shapeFlag & 1 && vnode.el) {
    setVarsOnNode(vnode.el, vars);
  } else if (vnode.type === Fragment) {
    vnode.children.forEach((c) => setVarsOnVNode(c, vars));
  } else if (vnode.type === Static) {
    let { el, anchor } = vnode;
    while (el) {
      setVarsOnNode(el, vars);
      if (el === anchor) break;
      el = el.nextSibling;
    }
  }
}
function setVarsOnNode(el, vars) {
  if (el.nodeType === 1) {
    const style = el.style;
    for (const key in vars) {
      style.setProperty(`--${key}`, vars[key]);
    }
  }
}
function resolveTransitionProps(rawProps) {
  const baseProps = {};
  for (const key in rawProps) {
    if (!(key in DOMTransitionPropsValidators)) {
      baseProps[key] = rawProps[key];
    }
  }
  if (rawProps.css === false) {
    return baseProps;
  }
  const {
    name = "v",
    type,
    duration,
    enterFromClass = `${name}-enter-from`,
    enterActiveClass = `${name}-enter-active`,
    enterToClass = `${name}-enter-to`,
    appearFromClass = enterFromClass,
    appearActiveClass = enterActiveClass,
    appearToClass = enterToClass,
    leaveFromClass = `${name}-leave-from`,
    leaveActiveClass = `${name}-leave-active`,
    leaveToClass = `${name}-leave-to`,
  } = rawProps;
  const durations = normalizeDuration(duration);
  const enterDuration = durations && durations[0];
  const leaveDuration = durations && durations[1];
  const {
    onBeforeEnter,
    onEnter,
    onEnterCancelled,
    onLeave,
    onLeaveCancelled,
    onBeforeAppear = onBeforeEnter,
    onAppear = onEnter,
    onAppearCancelled = onEnterCancelled,
  } = baseProps;
  const finishEnter = (el, isAppear, done) => {
    removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
    removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
    done && done();
  };
  const finishLeave = (el, done) => {
    removeTransitionClass(el, leaveToClass);
    removeTransitionClass(el, leaveActiveClass);
    done && done();
  };
  const makeEnterHook = (isAppear) => {
    return (el, done) => {
      const hook = isAppear ? onAppear : onEnter;
      const resolve2 = () => finishEnter(el, isAppear, done);
      callHook2(hook, [el, resolve2]);
      nextFrame(() => {
        removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
        addTransitionClass(el, isAppear ? appearToClass : enterToClass);
        if (!hasExplicitCallback(hook)) {
          whenTransitionEnds(el, type, enterDuration, resolve2);
        }
      });
    };
  };
  return extend(baseProps, {
    onBeforeEnter(el) {
      callHook2(onBeforeEnter, [el]);
      addTransitionClass(el, enterFromClass);
      addTransitionClass(el, enterActiveClass);
    },
    onBeforeAppear(el) {
      callHook2(onBeforeAppear, [el]);
      addTransitionClass(el, appearFromClass);
      addTransitionClass(el, appearActiveClass);
    },
    onEnter: makeEnterHook(false),
    onAppear: makeEnterHook(true),
    onLeave(el, done) {
      const resolve2 = () => finishLeave(el, done);
      addTransitionClass(el, leaveFromClass);
      forceReflow();
      addTransitionClass(el, leaveActiveClass);
      nextFrame(() => {
        removeTransitionClass(el, leaveFromClass);
        addTransitionClass(el, leaveToClass);
        if (!hasExplicitCallback(onLeave)) {
          whenTransitionEnds(el, type, leaveDuration, resolve2);
        }
      });
      callHook2(onLeave, [el, resolve2]);
    },
    onEnterCancelled(el) {
      finishEnter(el, false);
      callHook2(onEnterCancelled, [el]);
    },
    onAppearCancelled(el) {
      finishEnter(el, true);
      callHook2(onAppearCancelled, [el]);
    },
    onLeaveCancelled(el) {
      finishLeave(el);
      callHook2(onLeaveCancelled, [el]);
    },
  });
}
function normalizeDuration(duration) {
  if (duration == null) {
    return null;
  } else if (isObject$f(duration)) {
    return [NumberOf(duration.enter), NumberOf(duration.leave)];
  } else {
    const n = NumberOf(duration);
    return [n, n];
  }
}
function NumberOf(val) {
  const res = toNumber(val);
  return res;
}
function addTransitionClass(el, cls) {
  cls.split(/\s+/).forEach((c) => c && el.classList.add(c));
  (el._vtc || (el._vtc = /* @__PURE__ */ new Set())).add(cls);
}
function removeTransitionClass(el, cls) {
  cls.split(/\s+/).forEach((c) => c && el.classList.remove(c));
  const { _vtc } = el;
  if (_vtc) {
    _vtc.delete(cls);
    if (!_vtc.size) {
      el._vtc = void 0;
    }
  }
}
function nextFrame(cb) {
  requestAnimationFrame(() => {
    requestAnimationFrame(cb);
  });
}
function whenTransitionEnds(el, expectedType, explicitTimeout, resolve2) {
  const id = (el._endId = ++endId);
  const resolveIfNotStale = () => {
    if (id === el._endId) {
      resolve2();
    }
  };
  if (explicitTimeout) {
    return setTimeout(resolveIfNotStale, explicitTimeout);
  }
  const { type, timeout, propCount } = getTransitionInfo(el, expectedType);
  if (!type) {
    return resolve2();
  }
  const endEvent = type + "end";
  let ended = 0;
  const end = () => {
    el.removeEventListener(endEvent, onEnd);
    resolveIfNotStale();
  };
  const onEnd = (e) => {
    if (e.target === el && ++ended >= propCount) {
      end();
    }
  };
  setTimeout(() => {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(endEvent, onEnd);
}
function getTransitionInfo(el, expectedType) {
  const styles = window.getComputedStyle(el);
  const getStyleProperties = (key) => (styles[key] || "").split(", ");
  const transitionDelays = getStyleProperties(TRANSITION$1 + "Delay");
  const transitionDurations = getStyleProperties(TRANSITION$1 + "Duration");
  const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  const animationDelays = getStyleProperties(ANIMATION + "Delay");
  const animationDurations = getStyleProperties(ANIMATION + "Duration");
  const animationTimeout = getTimeout(animationDelays, animationDurations);
  let type = null;
  let timeout = 0;
  let propCount = 0;
  if (expectedType === TRANSITION$1) {
    if (transitionTimeout > 0) {
      type = TRANSITION$1;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type =
      timeout > 0
        ? transitionTimeout > animationTimeout
          ? TRANSITION$1
          : ANIMATION
        : null;
    propCount = type
      ? type === TRANSITION$1
        ? transitionDurations.length
        : animationDurations.length
      : 0;
  }
  const hasTransform =
    type === TRANSITION$1 &&
    /\b(transform|all)(,|$)/.test(styles[TRANSITION$1 + "Property"]);
  return {
    type,
    timeout,
    propCount,
    hasTransform,
  };
}
function getTimeout(delays, durations) {
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }
  return Math.max(...durations.map((d, i) => toMs(d) + toMs(delays[i])));
}
function toMs(s) {
  return Number(s.slice(0, -1).replace(",", ".")) * 1e3;
}
function forceReflow() {
  return document.body.offsetHeight;
}
function callPendingCbs(c) {
  const el = c.el;
  if (el._moveCb) {
    el._moveCb();
  }
  if (el._enterCb) {
    el._enterCb();
  }
}
function recordPosition(c) {
  newPositionMap.set(c, c.el.getBoundingClientRect());
}
function applyTranslation(c) {
  const oldPos = positionMap.get(c);
  const newPos = newPositionMap.get(c);
  const dx = oldPos.left - newPos.left;
  const dy = oldPos.top - newPos.top;
  if (dx || dy) {
    const s = c.el.style;
    s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`;
    s.transitionDuration = "0s";
    return c;
  }
}
function hasCSSTransform(el, root, moveClass) {
  const clone = el.cloneNode();
  if (el._vtc) {
    el._vtc.forEach((cls) => {
      cls.split(/\s+/).forEach((c) => c && clone.classList.remove(c));
    });
  }
  moveClass.split(/\s+/).forEach((c) => c && clone.classList.add(c));
  clone.style.display = "none";
  const container = root.nodeType === 1 ? root : root.parentNode;
  container.appendChild(clone);
  const { hasTransform } = getTransitionInfo(clone);
  container.removeChild(clone);
  return hasTransform;
}
function onCompositionStart(e) {
  e.target.composing = true;
}
function onCompositionEnd(e) {
  const target = e.target;
  if (target.composing) {
    target.composing = false;
    trigger2(target, "input");
  }
}
function trigger2(el, type) {
  const e = document.createEvent("HTMLEvents");
  e.initEvent(type, true, true);
  el.dispatchEvent(e);
}
function setChecked(el, { value, oldValue }, vnode) {
  el._modelValue = value;
  if (isArray(value)) {
    el.checked = looseIndexOf(value, vnode.props.value) > -1;
  } else if (isSet(value)) {
    el.checked = value.has(vnode.props.value);
  } else if (value !== oldValue) {
    el.checked = looseEqual(value, getCheckboxValue(el, true));
  }
}
function setSelected(el, value) {
  const isMultiple = el.multiple;
  if (isMultiple && !isArray(value) && !isSet(value)) {
    return;
  }
  for (let i = 0, l = el.options.length; i < l; i++) {
    const option = el.options[i];
    const optionValue = getValue(option);
    if (isMultiple) {
      if (isArray(value)) {
        option.selected = looseIndexOf(value, optionValue) > -1;
      } else {
        option.selected = value.has(optionValue);
      }
    } else {
      if (looseEqual(getValue(option), value)) {
        if (el.selectedIndex !== i) el.selectedIndex = i;
        return;
      }
    }
  }
  if (!isMultiple && el.selectedIndex !== -1) {
    el.selectedIndex = -1;
  }
}
function getValue(el) {
  return "_value" in el ? el._value : el.value;
}
function getCheckboxValue(el, checked) {
  const key = checked ? "_trueValue" : "_falseValue";
  return key in el ? el[key] : checked;
}
function callModelHook(el, binding, vnode, prevVNode, hook) {
  let modelToUse;
  switch (el.tagName) {
    case "SELECT":
      modelToUse = vModelSelect;
      break;
    case "TEXTAREA":
      modelToUse = vModelText;
      break;
    default:
      switch (vnode.props && vnode.props.type) {
        case "checkbox":
          modelToUse = vModelCheckbox;
          break;
        case "radio":
          modelToUse = vModelRadio;
          break;
        default:
          modelToUse = vModelText;
      }
  }
  const fn = modelToUse[hook];
  fn && fn(el, binding, vnode, prevVNode);
}
function initVModelForSSR() {
  vModelText.getSSRProps = ({ value }) => ({ value });
  vModelRadio.getSSRProps = ({ value }, vnode) => {
    if (vnode.props && looseEqual(vnode.props.value, value)) {
      return { checked: true };
    }
  };
  vModelCheckbox.getSSRProps = ({ value }, vnode) => {
    if (isArray(value)) {
      if (vnode.props && looseIndexOf(value, vnode.props.value) > -1) {
        return { checked: true };
      }
    } else if (isSet(value)) {
      if (vnode.props && value.has(vnode.props.value)) {
        return { checked: true };
      }
    } else if (value) {
      return { checked: true };
    }
  };
}
function setDisplay(el, value) {
  el.style.display = value ? el._vod : "none";
}
function initVShowForSSR() {
  vShow.getSSRProps = ({ value }) => {
    if (!value) {
      return { style: { display: "none" } };
    }
  };
}
function ensureRenderer() {
  return renderer || (renderer = createRenderer(rendererOptions));
}
function ensureHydrationRenderer() {
  renderer = enabledHydration
    ? renderer
    : createHydrationRenderer(rendererOptions);
  enabledHydration = true;
  return renderer;
}
function normalizeContainer(container) {
  if (isString$1(container)) {
    const res = document.querySelector(container);
    return res;
  }
  return container;
}
var svgNS,
  doc,
  templateContainer,
  nodeOps,
  importantRE,
  prefixes,
  prefixCache,
  xlinkNS,
  _getNow,
  skipTimestampCheck,
  cachedNow,
  p,
  reset,
  getNow,
  optionsModifierRE,
  nativeOnRE,
  patchProp,
  defineSSRCustomElement,
  BaseClass,
  VueElement,
  TRANSITION$1,
  ANIMATION,
  Transition,
  DOMTransitionPropsValidators,
  TransitionPropsValidators,
  callHook2,
  hasExplicitCallback,
  endId,
  positionMap,
  newPositionMap,
  TransitionGroupImpl,
  TransitionGroup,
  getModelAssigner,
  vModelText,
  vModelCheckbox,
  vModelRadio,
  vModelSelect,
  vModelDynamic,
  systemModifiers,
  modifierGuards,
  withModifiers,
  keyNames,
  withKeys,
  vShow,
  rendererOptions,
  renderer,
  enabledHydration,
  render$1,
  hydrate,
  createApp,
  createSSRApp,
  ssrDirectiveInitialized,
  initDirectivesForSSR;
var init_runtime_dom_esm_bundler = __esm({
  "node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js"() {
    init_runtime_core_esm_bundler();
    init_runtime_core_esm_bundler();
    init_shared_esm_bundler();
    svgNS = "http://www.w3.org/2000/svg";
    doc = typeof document !== "undefined" ? document : null;
    templateContainer = doc && doc.createElement("template");
    nodeOps = {
      insert: (child, parent, anchor) => {
        parent.insertBefore(child, anchor || null);
      },
      remove: (child) => {
        const parent = child.parentNode;
        if (parent) {
          parent.removeChild(child);
        }
      },
      createElement: (tag, isSVG, is, props) => {
        const el = isSVG
          ? doc.createElementNS(svgNS, tag)
          : doc.createElement(tag, is ? { is } : void 0);
        if (tag === "select" && props && props.multiple != null) {
          el.setAttribute("multiple", props.multiple);
        }
        return el;
      },
      createText: (text) => doc.createTextNode(text),
      createComment: (text) => doc.createComment(text),
      setText: (node, text) => {
        node.nodeValue = text;
      },
      setElementText: (el, text) => {
        el.textContent = text;
      },
      parentNode: (node) => node.parentNode,
      nextSibling: (node) => node.nextSibling,
      querySelector: (selector) => doc.querySelector(selector),
      setScopeId(el, id) {
        el.setAttribute(id, "");
      },
      cloneNode(el) {
        const cloned = el.cloneNode(true);
        if (`_value` in el) {
          cloned._value = el._value;
        }
        return cloned;
      },
      // __UNSAFE__
      // Reason: innerHTML.
      // Static content here can only come from compiled templates.
      // As long as the user only uses trusted templates, this is safe.
      insertStaticContent(content, parent, anchor, isSVG, start, end) {
        const before = anchor ? anchor.previousSibling : parent.lastChild;
        if (start && (start === end || start.nextSibling)) {
          while (true) {
            parent.insertBefore(start.cloneNode(true), anchor);
            if (start === end || !(start = start.nextSibling)) break;
          }
        } else {
          templateContainer.innerHTML = isSVG
            ? `<svg>${content}</svg>`
            : content;
          const template = templateContainer.content;
          if (isSVG) {
            const wrapper = template.firstChild;
            while (wrapper.firstChild) {
              template.appendChild(wrapper.firstChild);
            }
            template.removeChild(wrapper);
          }
          parent.insertBefore(template, anchor);
        }
        return [
          // first
          before ? before.nextSibling : parent.firstChild,
          // last
          anchor ? anchor.previousSibling : parent.lastChild,
        ];
      },
    };
    importantRE = /\s*!important$/;
    prefixes = ["Webkit", "Moz", "ms"];
    prefixCache = {};
    xlinkNS = "http://www.w3.org/1999/xlink";
    _getNow = Date.now;
    skipTimestampCheck = false;
    if (typeof window !== "undefined") {
      if (_getNow() > document.createEvent("Event").timeStamp) {
        _getNow = () => performance.now();
      }
      const ffMatch = navigator.userAgent.match(/firefox\/(\d+)/i);
      skipTimestampCheck = !!(ffMatch && Number(ffMatch[1]) <= 53);
    }
    cachedNow = 0;
    p = Promise.resolve();
    reset = () => {
      cachedNow = 0;
    };
    getNow = () => cachedNow || (p.then(reset), (cachedNow = _getNow()));
    optionsModifierRE = /(?:Once|Passive|Capture)$/;
    nativeOnRE = /^on[a-z]/;
    patchProp = (
      el,
      key,
      prevValue,
      nextValue,
      isSVG = false,
      prevChildren,
      parentComponent,
      parentSuspense,
      unmountChildren
    ) => {
      if (key === "class") {
        patchClass(el, nextValue, isSVG);
      } else if (key === "style") {
        patchStyle(el, prevValue, nextValue);
      } else if (isOn(key)) {
        if (!isModelListener(key)) {
          patchEvent(el, key, prevValue, nextValue, parentComponent);
        }
      } else if (
        key[0] === "."
          ? ((key = key.slice(1)), true)
          : key[0] === "^"
          ? ((key = key.slice(1)), false)
          : shouldSetAsProp(el, key, nextValue, isSVG)
      ) {
        patchDOMProp(
          el,
          key,
          nextValue,
          prevChildren,
          parentComponent,
          parentSuspense,
          unmountChildren
        );
      } else {
        if (key === "true-value") {
          el._trueValue = nextValue;
        } else if (key === "false-value") {
          el._falseValue = nextValue;
        }
        patchAttr(el, key, nextValue, isSVG);
      }
    };
    defineSSRCustomElement = (options) => {
      return defineCustomElement(options, hydrate);
    };
    BaseClass = typeof HTMLElement !== "undefined" ? HTMLElement : class {};
    VueElement = class _VueElement extends BaseClass {
      constructor(_def, _props = {}, hydrate2) {
        super();
        this._def = _def;
        this._props = _props;
        this._instance = null;
        this._connected = false;
        this._resolved = false;
        this._numberProps = null;
        if (this.shadowRoot && hydrate2) {
          hydrate2(this._createVNode(), this.shadowRoot);
        } else {
          this.attachShadow({ mode: "open" });
        }
      }
      connectedCallback() {
        this._connected = true;
        if (!this._instance) {
          this._resolveDef();
        }
      }
      disconnectedCallback() {
        this._connected = false;
        nextTick(() => {
          if (!this._connected) {
            render$1(null, this.shadowRoot);
            this._instance = null;
          }
        });
      }
      /**
       * resolve inner component definition (handle possible async component)
       */
      _resolveDef() {
        if (this._resolved) {
          return;
        }
        this._resolved = true;
        for (let i = 0; i < this.attributes.length; i++) {
          this._setAttr(this.attributes[i].name);
        }
        new MutationObserver((mutations) => {
          for (const m of mutations) {
            this._setAttr(m.attributeName);
          }
        }).observe(this, { attributes: true });
        const resolve2 = (def2) => {
          const { props, styles } = def2;
          const hasOptions = !isArray(props);
          const rawKeys = props
            ? hasOptions
              ? Object.keys(props)
              : props
            : [];
          let numberProps;
          if (hasOptions) {
            for (const key in this._props) {
              const opt = props[key];
              if (opt === Number || (opt && opt.type === Number)) {
                this._props[key] = toNumber(this._props[key]);
                (numberProps ||
                  (numberProps = /* @__PURE__ */ Object.create(null)))[
                  key
                ] = true;
              }
            }
          }
          this._numberProps = numberProps;
          for (const key of Object.keys(this)) {
            if (key[0] !== "_") {
              this._setProp(key, this[key], true, false);
            }
          }
          for (const key of rawKeys.map(camelize)) {
            Object.defineProperty(this, key, {
              get() {
                return this._getProp(key);
              },
              set(val) {
                this._setProp(key, val);
              },
            });
          }
          this._applyStyles(styles);
          this._update();
        };
        const asyncDef = this._def.__asyncLoader;
        if (asyncDef) {
          asyncDef().then(resolve2);
        } else {
          resolve2(this._def);
        }
      }
      _setAttr(key) {
        let value = this.getAttribute(key);
        if (this._numberProps && this._numberProps[key]) {
          value = toNumber(value);
        }
        this._setProp(camelize(key), value, false);
      }
      /**
       * @internal
       */
      _getProp(key) {
        return this._props[key];
      }
      /**
       * @internal
       */
      _setProp(key, val, shouldReflect = true, shouldUpdate = true) {
        if (val !== this._props[key]) {
          this._props[key] = val;
          if (shouldUpdate && this._instance) {
            this._update();
          }
          if (shouldReflect) {
            if (val === true) {
              this.setAttribute(hyphenate(key), "");
            } else if (typeof val === "string" || typeof val === "number") {
              this.setAttribute(hyphenate(key), val + "");
            } else if (!val) {
              this.removeAttribute(hyphenate(key));
            }
          }
        }
      }
      _update() {
        render$1(this._createVNode(), this.shadowRoot);
      }
      _createVNode() {
        const vnode = createVNode(this._def, extend({}, this._props));
        if (!this._instance) {
          vnode.ce = (instance) => {
            this._instance = instance;
            instance.isCE = true;
            instance.emit = (event, ...args) => {
              this.dispatchEvent(
                new CustomEvent(event, {
                  detail: args,
                })
              );
            };
            let parent = this;
            while ((parent = parent && (parent.parentNode || parent.host))) {
              if (parent instanceof _VueElement) {
                instance.parent = parent._instance;
                break;
              }
            }
          };
        }
        return vnode;
      }
      _applyStyles(styles) {
        if (styles) {
          styles.forEach((css) => {
            const s = document.createElement("style");
            s.textContent = css;
            this.shadowRoot.appendChild(s);
          });
        }
      }
    };
    TRANSITION$1 = "transition";
    ANIMATION = "animation";
    Transition = (props, { slots }) =>
      h(BaseTransition, resolveTransitionProps(props), slots);
    Transition.displayName = "Transition";
    DOMTransitionPropsValidators = {
      name: String,
      type: String,
      css: {
        type: Boolean,
        default: true,
      },
      duration: [String, Number, Object],
      enterFromClass: String,
      enterActiveClass: String,
      enterToClass: String,
      appearFromClass: String,
      appearActiveClass: String,
      appearToClass: String,
      leaveFromClass: String,
      leaveActiveClass: String,
      leaveToClass: String,
    };
    TransitionPropsValidators = Transition.props = /* @__PURE__ */ extend(
      {},
      BaseTransition.props,
      DOMTransitionPropsValidators
    );
    callHook2 = (hook, args = []) => {
      if (isArray(hook)) {
        hook.forEach((h2) => h2(...args));
      } else if (hook) {
        hook(...args);
      }
    };
    hasExplicitCallback = (hook) => {
      return hook
        ? isArray(hook)
          ? hook.some((h2) => h2.length > 1)
          : hook.length > 1
        : false;
    };
    endId = 0;
    positionMap = /* @__PURE__ */ new WeakMap();
    newPositionMap = /* @__PURE__ */ new WeakMap();
    TransitionGroupImpl = {
      name: "TransitionGroup",
      props: /* @__PURE__ */ extend({}, TransitionPropsValidators, {
        tag: String,
        moveClass: String,
      }),
      setup(props, { slots }) {
        const instance = getCurrentInstance();
        const state = useTransitionState();
        let prevChildren;
        let children;
        onUpdated$1(() => {
          if (!prevChildren.length) {
            return;
          }
          const moveClass = props.moveClass || `${props.name || "v"}-move`;
          if (
            !hasCSSTransform(prevChildren[0].el, instance.vnode.el, moveClass)
          ) {
            return;
          }
          prevChildren.forEach(callPendingCbs);
          prevChildren.forEach(recordPosition);
          const movedChildren = prevChildren.filter(applyTranslation);
          forceReflow();
          movedChildren.forEach((c) => {
            const el = c.el;
            const style = el.style;
            addTransitionClass(el, moveClass);
            style.transform =
              style.webkitTransform =
              style.transitionDuration =
                "";
            const cb = (el._moveCb = (e) => {
              if (e && e.target !== el) {
                return;
              }
              if (!e || /transform$/.test(e.propertyName)) {
                el.removeEventListener("transitionend", cb);
                el._moveCb = null;
                removeTransitionClass(el, moveClass);
              }
            });
            el.addEventListener("transitionend", cb);
          });
        });
        return () => {
          const rawProps = toRaw(props);
          const cssTransitionProps = resolveTransitionProps(rawProps);
          let tag = rawProps.tag || Fragment;
          prevChildren = children;
          children = slots.default
            ? getTransitionRawChildren(slots.default())
            : [];
          for (let i = 0; i < children.length; i++) {
            const child = children[i];
            if (child.key != null) {
              setTransitionHooks(
                child,
                resolveTransitionHooks(
                  child,
                  cssTransitionProps,
                  state,
                  instance
                )
              );
            }
          }
          if (prevChildren) {
            for (let i = 0; i < prevChildren.length; i++) {
              const child = prevChildren[i];
              setTransitionHooks(
                child,
                resolveTransitionHooks(
                  child,
                  cssTransitionProps,
                  state,
                  instance
                )
              );
              positionMap.set(child, child.el.getBoundingClientRect());
            }
          }
          return createVNode(tag, null, children);
        };
      },
    };
    TransitionGroup = TransitionGroupImpl;
    getModelAssigner = (vnode) => {
      const fn = vnode.props["onUpdate:modelValue"];
      return isArray(fn) ? (value) => invokeArrayFns(fn, value) : fn;
    };
    vModelText = {
      created(el, { modifiers: { lazy, trim, number } }, vnode) {
        el._assign = getModelAssigner(vnode);
        const castToNumber =
          number || (vnode.props && vnode.props.type === "number");
        addEventListener(el, lazy ? "change" : "input", (e) => {
          if (e.target.composing) return;
          let domValue = el.value;
          if (trim) {
            domValue = domValue.trim();
          } else if (castToNumber) {
            domValue = toNumber(domValue);
          }
          el._assign(domValue);
        });
        if (trim) {
          addEventListener(el, "change", () => {
            el.value = el.value.trim();
          });
        }
        if (!lazy) {
          addEventListener(el, "compositionstart", onCompositionStart);
          addEventListener(el, "compositionend", onCompositionEnd);
          addEventListener(el, "change", onCompositionEnd);
        }
      },
      // set value on mounted so it's after min/max for type="range"
      mounted(el, { value }) {
        el.value = value == null ? "" : value;
      },
      beforeUpdate(el, { value, modifiers: { lazy, trim, number } }, vnode) {
        el._assign = getModelAssigner(vnode);
        if (el.composing) return;
        if (document.activeElement === el) {
          if (lazy) {
            return;
          }
          if (trim && el.value.trim() === value) {
            return;
          }
          if (
            (number || el.type === "number") &&
            toNumber(el.value) === value
          ) {
            return;
          }
        }
        const newValue = value == null ? "" : value;
        if (el.value !== newValue) {
          el.value = newValue;
        }
      },
    };
    vModelCheckbox = {
      // #4096 array checkboxes need to be deep traversed
      deep: true,
      created(el, _, vnode) {
        el._assign = getModelAssigner(vnode);
        addEventListener(el, "change", () => {
          const modelValue = el._modelValue;
          const elementValue = getValue(el);
          const checked = el.checked;
          const assign = el._assign;
          if (isArray(modelValue)) {
            const index = looseIndexOf(modelValue, elementValue);
            const found = index !== -1;
            if (checked && !found) {
              assign(modelValue.concat(elementValue));
            } else if (!checked && found) {
              const filtered = [...modelValue];
              filtered.splice(index, 1);
              assign(filtered);
            }
          } else if (isSet(modelValue)) {
            const cloned = new Set(modelValue);
            if (checked) {
              cloned.add(elementValue);
            } else {
              cloned.delete(elementValue);
            }
            assign(cloned);
          } else {
            assign(getCheckboxValue(el, checked));
          }
        });
      },
      // set initial checked on mount to wait for true-value/false-value
      mounted: setChecked,
      beforeUpdate(el, binding, vnode) {
        el._assign = getModelAssigner(vnode);
        setChecked(el, binding, vnode);
      },
    };
    vModelRadio = {
      created(el, { value }, vnode) {
        el.checked = looseEqual(value, vnode.props.value);
        el._assign = getModelAssigner(vnode);
        addEventListener(el, "change", () => {
          el._assign(getValue(el));
        });
      },
      beforeUpdate(el, { value, oldValue }, vnode) {
        el._assign = getModelAssigner(vnode);
        if (value !== oldValue) {
          el.checked = looseEqual(value, vnode.props.value);
        }
      },
    };
    vModelSelect = {
      // <select multiple> value need to be deep traversed
      deep: true,
      created(el, { value, modifiers: { number } }, vnode) {
        const isSetModel = isSet(value);
        addEventListener(el, "change", () => {
          const selectedVal = Array.prototype.filter
            .call(el.options, (o) => o.selected)
            .map((o) => (number ? toNumber(getValue(o)) : getValue(o)));
          el._assign(
            el.multiple
              ? isSetModel
                ? new Set(selectedVal)
                : selectedVal
              : selectedVal[0]
          );
        });
        el._assign = getModelAssigner(vnode);
      },
      // set value in mounted & updated because <select> relies on its children
      // <option>s.
      mounted(el, { value }) {
        setSelected(el, value);
      },
      beforeUpdate(el, _binding, vnode) {
        el._assign = getModelAssigner(vnode);
      },
      updated(el, { value }) {
        setSelected(el, value);
      },
    };
    vModelDynamic = {
      created(el, binding, vnode) {
        callModelHook(el, binding, vnode, null, "created");
      },
      mounted(el, binding, vnode) {
        callModelHook(el, binding, vnode, null, "mounted");
      },
      beforeUpdate(el, binding, vnode, prevVNode) {
        callModelHook(el, binding, vnode, prevVNode, "beforeUpdate");
      },
      updated(el, binding, vnode, prevVNode) {
        callModelHook(el, binding, vnode, prevVNode, "updated");
      },
    };
    systemModifiers = ["ctrl", "shift", "alt", "meta"];
    modifierGuards = {
      stop: (e) => e.stopPropagation(),
      prevent: (e) => e.preventDefault(),
      self: (e) => e.target !== e.currentTarget,
      ctrl: (e) => !e.ctrlKey,
      shift: (e) => !e.shiftKey,
      alt: (e) => !e.altKey,
      meta: (e) => !e.metaKey,
      left: (e) => "button" in e && e.button !== 0,
      middle: (e) => "button" in e && e.button !== 1,
      right: (e) => "button" in e && e.button !== 2,
      exact: (e, modifiers) =>
        systemModifiers.some((m) => e[`${m}Key`] && !modifiers.includes(m)),
    };
    withModifiers = (fn, modifiers) => {
      return (event, ...args) => {
        for (let i = 0; i < modifiers.length; i++) {
          const guard = modifierGuards[modifiers[i]];
          if (guard && guard(event, modifiers)) return;
        }
        return fn(event, ...args);
      };
    };
    keyNames = {
      esc: "escape",
      space: " ",
      up: "arrow-up",
      left: "arrow-left",
      right: "arrow-right",
      down: "arrow-down",
      delete: "backspace",
    };
    withKeys = (fn, modifiers) => {
      return (event) => {
        if (!("key" in event)) {
          return;
        }
        const eventKey = hyphenate(event.key);
        if (modifiers.some((k) => k === eventKey || keyNames[k] === eventKey)) {
          return fn(event);
        }
      };
    };
    vShow = {
      beforeMount(el, { value }, { transition }) {
        el._vod = el.style.display === "none" ? "" : el.style.display;
        if (transition && value) {
          transition.beforeEnter(el);
        } else {
          setDisplay(el, value);
        }
      },
      mounted(el, { value }, { transition }) {
        if (transition && value) {
          transition.enter(el);
        }
      },
      updated(el, { value, oldValue }, { transition }) {
        if (!value === !oldValue) return;
        if (transition) {
          if (value) {
            transition.beforeEnter(el);
            setDisplay(el, true);
            transition.enter(el);
          } else {
            transition.leave(el, () => {
              setDisplay(el, false);
            });
          }
        } else {
          setDisplay(el, value);
        }
      },
      beforeUnmount(el, { value }) {
        setDisplay(el, value);
      },
    };
    rendererOptions = extend({ patchProp }, nodeOps);
    enabledHydration = false;
    render$1 = (...args) => {
      ensureRenderer().render(...args);
    };
    hydrate = (...args) => {
      ensureHydrationRenderer().hydrate(...args);
    };
    createApp = (...args) => {
      const app = ensureRenderer().createApp(...args);
      const { mount } = app;
      app.mount = (containerOrSelector) => {
        const container = normalizeContainer(containerOrSelector);
        if (!container) return;
        const component = app._component;
        if (
          !isFunction$1(component) &&
          !component.render &&
          !component.template
        ) {
          component.template = container.innerHTML;
        }
        container.innerHTML = "";
        const proxy = mount(container, false, container instanceof SVGElement);
        if (container instanceof Element) {
          container.removeAttribute("v-cloak");
          container.setAttribute("data-v-app", "");
        }
        return proxy;
      };
      return app;
    };
    createSSRApp = (...args) => {
      const app = ensureHydrationRenderer().createApp(...args);
      const { mount } = app;
      app.mount = (containerOrSelector) => {
        const container = normalizeContainer(containerOrSelector);
        if (container) {
          return mount(container, true, container instanceof SVGElement);
        }
      };
      return app;
    };
    ssrDirectiveInitialized = false;
    initDirectivesForSSR = () => {
      if (!ssrDirectiveInitialized) {
        ssrDirectiveInitialized = true;
        initVModelForSSR();
        initVShowForSSR();
      }
    };
  },
});

// node_modules/vue/dist/vue.runtime.esm-bundler.js
init_runtime_dom_esm_bundler();
init_runtime_dom_esm_bundler();

// node_modules/pinia/node_modules/vue-demi/lib/index.mjs
var isVue2 = false;

// node_modules/pinia/dist/pinia.esm-browser.js
var activePinia;
var setActivePinia = (pinia) => (activePinia = pinia);
var piniaSymbol =
  /* istanbul ignore next */
  Symbol();
function isPlainObject(o) {
  return (
    o &&
    typeof o === "object" &&
    Object.prototype.toString.call(o) === "[object Object]" &&
    typeof o.toJSON !== "function"
  );
}
var MutationType;
(function (MutationType2) {
  MutationType2["direct"] = "direct";
  MutationType2["patchObject"] = "patch object";
  MutationType2["patchFunction"] = "patch function";
})(MutationType || (MutationType = {}));
function createPinia() {
  const scope = effectScope(true);
  const state = scope.run(() => ref({}));
  let _p = [];
  let toBeInstalled = [];
  const pinia = markRaw({
    install(app) {
      setActivePinia(pinia);
      {
        pinia._a = app;
        app.provide(piniaSymbol, pinia);
        app.config.globalProperties.$pinia = pinia;
        toBeInstalled.forEach((plugin) => _p.push(plugin));
        toBeInstalled = [];
      }
    },
    use(plugin) {
      if (!this._a && !isVue2) {
        toBeInstalled.push(plugin);
      } else {
        _p.push(plugin);
      }
      return this;
    },
    _p,
    // it's actually undefined here
    // @ts-expect-error
    _a: null,
    _e: scope,
    _s: /* @__PURE__ */ new Map(),
    state,
  });
  return pinia;
}
var noop$4 = () => {};
function addSubscription(
  subscriptions,
  callback,
  detached,
  onCleanup = noop$4
) {
  subscriptions.push(callback);
  const removeSubscription = () => {
    const idx = subscriptions.indexOf(callback);
    if (idx > -1) {
      subscriptions.splice(idx, 1);
      onCleanup();
    }
  };
  if (!detached && getCurrentInstance()) {
    onUnmounted$1(removeSubscription);
  }
  return removeSubscription;
}
function triggerSubscriptions(subscriptions, ...args) {
  subscriptions.slice().forEach((callback) => {
    callback(...args);
  });
}
function mergeReactiveObjects(target, patchToApply) {
  for (const key in patchToApply) {
    if (!patchToApply.hasOwnProperty(key)) continue;
    const subPatch = patchToApply[key];
    const targetValue = target[key];
    if (
      isPlainObject(targetValue) &&
      isPlainObject(subPatch) &&
      target.hasOwnProperty(key) &&
      !isRef(subPatch) &&
      !isReactive(subPatch)
    ) {
      target[key] = mergeReactiveObjects(targetValue, subPatch);
    } else {
      target[key] = subPatch;
    }
  }
  return target;
}
var skipHydrateSymbol =
  /* istanbul ignore next */
  Symbol();
function shouldHydrate(obj) {
  return !isPlainObject(obj) || !obj.hasOwnProperty(skipHydrateSymbol);
}
var { assign: assign$1 } = Object;
function isComputed(o) {
  return !!(isRef(o) && o.effect);
}
function createOptionsStore(id, options, pinia, hot) {
  const { state, actions, getters } = options;
  const initialState = pinia.state.value[id];
  let store;
  function setup() {
    if (!initialState && !("production" !== "production")) {
      {
        pinia.state.value[id] = state ? state() : {};
      }
    }
    const localState = toRefs(pinia.state.value[id]);
    return assign$1(
      localState,
      actions,
      Object.keys(getters || {}).reduce((computedGetters, name) => {
        computedGetters[name] = markRaw(
          computed2(() => {
            setActivePinia(pinia);
            const store2 = pinia._s.get(id);
            return getters[name].call(store2, store2);
          })
        );
        return computedGetters;
      }, {})
    );
  }
  store = createSetupStore(id, setup, options, pinia);
  store.$reset = function $reset() {
    const newState = state ? state() : {};
    this.$patch(($state) => {
      assign$1($state, newState);
    });
  };
  return store;
}
function createSetupStore($id, setup, options = {}, pinia, hot) {
  let scope;
  const buildState = options.state;
  const optionsForPlugin = assign$1({ actions: {} }, options);
  const $subscribeOptions = {
    deep: true,
    // flush: 'post',
  };
  let isListening;
  let isSyncListening;
  let subscriptions = markRaw([]);
  let actionSubscriptions = markRaw([]);
  let debuggerEvents;
  const initialState = pinia.state.value[$id];
  if (!buildState && !initialState && !("production" !== "production")) {
    {
      pinia.state.value[$id] = {};
    }
  }
  ref({});
  function $patch(partialStateOrMutator) {
    let subscriptionMutation;
    isListening = isSyncListening = false;
    if (typeof partialStateOrMutator === "function") {
      partialStateOrMutator(pinia.state.value[$id]);
      subscriptionMutation = {
        type: MutationType.patchFunction,
        storeId: $id,
        events: debuggerEvents,
      };
    } else {
      mergeReactiveObjects(pinia.state.value[$id], partialStateOrMutator);
      subscriptionMutation = {
        type: MutationType.patchObject,
        payload: partialStateOrMutator,
        storeId: $id,
        events: debuggerEvents,
      };
    }
    nextTick().then(() => {
      isListening = true;
    });
    isSyncListening = true;
    triggerSubscriptions(
      subscriptions,
      subscriptionMutation,
      pinia.state.value[$id]
    );
  }
  const $reset = noop$4;
  function $dispose() {
    scope.stop();
    subscriptions = [];
    actionSubscriptions = [];
    pinia._s.delete($id);
  }
  function wrapAction(name, action) {
    return function () {
      setActivePinia(pinia);
      const args = Array.from(arguments);
      const afterCallbackList = [];
      const onErrorCallbackList = [];
      function after(callback) {
        afterCallbackList.push(callback);
      }
      function onError(callback) {
        onErrorCallbackList.push(callback);
      }
      triggerSubscriptions(actionSubscriptions, {
        args,
        name,
        store,
        after,
        onError,
      });
      let ret;
      try {
        ret = action.apply(this && this.$id === $id ? this : store, args);
      } catch (error) {
        triggerSubscriptions(onErrorCallbackList, error);
        throw error;
      }
      if (ret instanceof Promise) {
        return ret
          .then((value) => {
            triggerSubscriptions(afterCallbackList, value);
            return value;
          })
          .catch((error) => {
            triggerSubscriptions(onErrorCallbackList, error);
            return Promise.reject(error);
          });
      }
      triggerSubscriptions(afterCallbackList, ret);
      return ret;
    };
  }
  const partialStore = {
    _p: pinia,
    // _s: scope,
    $id,
    $onAction: addSubscription.bind(null, actionSubscriptions),
    $patch,
    $reset,
    $subscribe(callback, options2 = {}) {
      const removeSubscription = addSubscription(
        subscriptions,
        callback,
        options2.detached,
        () => stopWatcher()
      );
      const stopWatcher = scope.run(() =>
        watch(
          () => pinia.state.value[$id],
          (state) => {
            if (options2.flush === "sync" ? isSyncListening : isListening) {
              callback(
                {
                  storeId: $id,
                  type: MutationType.direct,
                  events: debuggerEvents,
                },
                state
              );
            }
          },
          assign$1({}, $subscribeOptions, options2)
        )
      );
      return removeSubscription;
    },
    $dispose,
  };
  const store = reactive(
    assign$1(
      {},
      partialStore
      // must be added later
      // setupStore
    )
  );
  pinia._s.set($id, store);
  const setupStore = pinia._e.run(() => {
    scope = effectScope();
    return scope.run(() => setup());
  });
  for (const key in setupStore) {
    const prop = setupStore[key];
    if ((isRef(prop) && !isComputed(prop)) || isReactive(prop)) {
      if (!buildState) {
        if (initialState && shouldHydrate(prop)) {
          if (isRef(prop)) {
            prop.value = initialState[key];
          } else {
            mergeReactiveObjects(prop, initialState[key]);
          }
        }
        {
          pinia.state.value[$id][key] = prop;
        }
      }
    } else if (typeof prop === "function") {
      const actionValue = wrapAction(key, prop);
      {
        setupStore[key] = actionValue;
      }
      optionsForPlugin.actions[key] = prop;
    } else;
  }
  {
    assign$1(store, setupStore);
    assign$1(toRaw(store), setupStore);
  }
  Object.defineProperty(store, "$state", {
    get: () => pinia.state.value[$id],
    set: (state) => {
      $patch(($state) => {
        assign$1($state, state);
      });
    },
  });
  pinia._p.forEach((extender) => {
    {
      assign$1(
        store,
        scope.run(() =>
          extender({
            store,
            app: pinia._a,
            pinia,
            options: optionsForPlugin,
          })
        )
      );
    }
  });
  if (initialState && buildState && options.hydrate) {
    options.hydrate(store.$state, initialState);
  }
  isListening = true;
  isSyncListening = true;
  return store;
}
function defineStore(idOrOptions, setup, setupOptions) {
  let id;
  let options;
  const isSetupStore = typeof setup === "function";
  if (typeof idOrOptions === "string") {
    id = idOrOptions;
    options = isSetupStore ? setupOptions : setup;
  } else {
    options = idOrOptions;
    id = idOrOptions.id;
  }
  function useStore(pinia, hot) {
    const currentInstance = getCurrentInstance();
    pinia = // in test mode, ignore the argument provided as we can always retrieve a
      // pinia instance with getActivePinia()
      pinia || (currentInstance && inject(piniaSymbol));
    if (pinia) setActivePinia(pinia);
    pinia = activePinia;
    if (!pinia._s.has(id)) {
      if (isSetupStore) {
        createSetupStore(id, setup, options, pinia);
      } else {
        createOptionsStore(id, options, pinia);
      }
    }
    const store = pinia._s.get(id);
    return store;
  }
  useStore.$id = id;
  return useStore;
}
/*! Bundled license information:

pinia/dist/pinia.esm-browser.js:
  (*!
    * pinia v2.0.13
    * (c) 2022 Eduardo San Martin Morote
    * @license MIT
    *)
*/

// node_modules/luxon/src/errors.js
var LuxonError = class extends Error {};
var InvalidDateTimeError = class extends LuxonError {
  constructor(reason) {
    super(`Invalid DateTime: ${reason.toMessage()}`);
  }
};
var InvalidIntervalError = class extends LuxonError {
  constructor(reason) {
    super(`Invalid Interval: ${reason.toMessage()}`);
  }
};
var InvalidDurationError = class extends LuxonError {
  constructor(reason) {
    super(`Invalid Duration: ${reason.toMessage()}`);
  }
};
var ConflictingSpecificationError = class extends LuxonError {};
var InvalidUnitError = class extends LuxonError {
  constructor(unit) {
    super(`Invalid unit ${unit}`);
  }
};
var InvalidArgumentError = class extends LuxonError {};
var ZoneIsAbstractError = class extends LuxonError {
  constructor() {
    super("Zone is an abstract class");
  }
};

// node_modules/luxon/src/impl/formats.js
var n = "numeric";
var s = "short";
var l = "long";
var DATE_SHORT = {
  year: n,
  month: n,
  day: n,
};
var DATE_MED = {
  year: n,
  month: s,
  day: n,
};
var DATE_MED_WITH_WEEKDAY = {
  year: n,
  month: s,
  day: n,
  weekday: s,
};
var DATE_FULL = {
  year: n,
  month: l,
  day: n,
};
var DATE_HUGE = {
  year: n,
  month: l,
  day: n,
  weekday: l,
};
var TIME_SIMPLE = {
  hour: n,
  minute: n,
};
var TIME_WITH_SECONDS = {
  hour: n,
  minute: n,
  second: n,
};
var TIME_WITH_SHORT_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  timeZoneName: s,
};
var TIME_WITH_LONG_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  timeZoneName: l,
};
var TIME_24_SIMPLE = {
  hour: n,
  minute: n,
  hourCycle: "h23",
};
var TIME_24_WITH_SECONDS = {
  hour: n,
  minute: n,
  second: n,
  hourCycle: "h23",
};
var TIME_24_WITH_SHORT_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  hourCycle: "h23",
  timeZoneName: s,
};
var TIME_24_WITH_LONG_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  hourCycle: "h23",
  timeZoneName: l,
};
var DATETIME_SHORT = {
  year: n,
  month: n,
  day: n,
  hour: n,
  minute: n,
};
var DATETIME_SHORT_WITH_SECONDS = {
  year: n,
  month: n,
  day: n,
  hour: n,
  minute: n,
  second: n,
};
var DATETIME_MED = {
  year: n,
  month: s,
  day: n,
  hour: n,
  minute: n,
};
var DATETIME_MED_WITH_SECONDS = {
  year: n,
  month: s,
  day: n,
  hour: n,
  minute: n,
  second: n,
};
var DATETIME_MED_WITH_WEEKDAY = {
  year: n,
  month: s,
  day: n,
  weekday: s,
  hour: n,
  minute: n,
};
var DATETIME_FULL = {
  year: n,
  month: l,
  day: n,
  hour: n,
  minute: n,
  timeZoneName: s,
};
var DATETIME_FULL_WITH_SECONDS = {
  year: n,
  month: l,
  day: n,
  hour: n,
  minute: n,
  second: n,
  timeZoneName: s,
};
var DATETIME_HUGE = {
  year: n,
  month: l,
  day: n,
  weekday: l,
  hour: n,
  minute: n,
  timeZoneName: l,
};
var DATETIME_HUGE_WITH_SECONDS = {
  year: n,
  month: l,
  day: n,
  weekday: l,
  hour: n,
  minute: n,
  second: n,
  timeZoneName: l,
};

// node_modules/luxon/src/impl/util.js
function isUndefined(o) {
  return typeof o === "undefined";
}
function isNumber(o) {
  return typeof o === "number";
}
function isInteger(o) {
  return typeof o === "number" && o % 1 === 0;
}
function isString(o) {
  return typeof o === "string";
}
function isDate(o) {
  return Object.prototype.toString.call(o) === "[object Date]";
}
function hasRelative() {
  try {
    return typeof Intl !== "undefined" && !!Intl.RelativeTimeFormat;
  } catch (e) {
    return false;
  }
}
function maybeArray(thing) {
  return Array.isArray(thing) ? thing : [thing];
}
function bestBy(arr, by, compare) {
  if (arr.length === 0) {
    return void 0;
  }
  return arr.reduce((best, next) => {
    const pair = [by(next), next];
    if (!best) {
      return pair;
    } else if (compare(best[0], pair[0]) === best[0]) {
      return best;
    } else {
      return pair;
    }
  }, null)[1];
}
function pick(obj, keys) {
  return keys.reduce((a, k) => {
    a[k] = obj[k];
    return a;
  }, {});
}
function hasOwnProperty$4(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
function integerBetween(thing, bottom, top) {
  return isInteger(thing) && thing >= bottom && thing <= top;
}
function floorMod(x, n2) {
  return x - n2 * Math.floor(x / n2);
}
function padStart(input, n2 = 2) {
  const isNeg = input < 0;
  let padded;
  if (isNeg) {
    padded = "-" + ("" + -input).padStart(n2, "0");
  } else {
    padded = ("" + input).padStart(n2, "0");
  }
  return padded;
}
function parseInteger(string) {
  if (isUndefined(string) || string === null || string === "") {
    return void 0;
  } else {
    return parseInt(string, 10);
  }
}
function parseFloating(string) {
  if (isUndefined(string) || string === null || string === "") {
    return void 0;
  } else {
    return parseFloat(string);
  }
}
function parseMillis(fraction) {
  if (isUndefined(fraction) || fraction === null || fraction === "") {
    return void 0;
  } else {
    const f = parseFloat("0." + fraction) * 1e3;
    return Math.floor(f);
  }
}
function roundTo(number, digits, towardZero = false) {
  const factor = 10 ** digits,
    rounder = towardZero ? Math.trunc : Math.round;
  return rounder(number * factor) / factor;
}
function isLeapYear(year) {
  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}
function daysInYear(year) {
  return isLeapYear(year) ? 366 : 365;
}
function daysInMonth(year, month) {
  const modMonth = floorMod(month - 1, 12) + 1,
    modYear = year + (month - modMonth) / 12;
  if (modMonth === 2) {
    return isLeapYear(modYear) ? 29 : 28;
  } else {
    return [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][modMonth - 1];
  }
}
function objToLocalTS(obj) {
  let d = Date.UTC(
    obj.year,
    obj.month - 1,
    obj.day,
    obj.hour,
    obj.minute,
    obj.second,
    obj.millisecond
  );
  if (obj.year < 100 && obj.year >= 0) {
    d = new Date(d);
    d.setUTCFullYear(d.getUTCFullYear() - 1900);
  }
  return +d;
}
function weeksInWeekYear(weekYear) {
  const p1 =
      (weekYear +
        Math.floor(weekYear / 4) -
        Math.floor(weekYear / 100) +
        Math.floor(weekYear / 400)) %
      7,
    last = weekYear - 1,
    p2 =
      (last +
        Math.floor(last / 4) -
        Math.floor(last / 100) +
        Math.floor(last / 400)) %
      7;
  return p1 === 4 || p2 === 3 ? 53 : 52;
}
function untruncateYear(year) {
  if (year > 99) {
    return year;
  } else return year > 60 ? 1900 + year : 2e3 + year;
}
function parseZoneInfo(ts, offsetFormat, locale, timeZone = null) {
  const date = new Date(ts),
    intlOpts = {
      hourCycle: "h23",
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
    };
  if (timeZone) {
    intlOpts.timeZone = timeZone;
  }
  const modified = { timeZoneName: offsetFormat, ...intlOpts };
  const parsed = new Intl.DateTimeFormat(locale, modified)
    .formatToParts(date)
    .find((m) => m.type.toLowerCase() === "timezonename");
  return parsed ? parsed.value : null;
}
function signedOffset(offHourStr, offMinuteStr) {
  let offHour = parseInt(offHourStr, 10);
  if (Number.isNaN(offHour)) {
    offHour = 0;
  }
  const offMin = parseInt(offMinuteStr, 10) || 0,
    offMinSigned = offHour < 0 || Object.is(offHour, -0) ? -offMin : offMin;
  return offHour * 60 + offMinSigned;
}
function asNumber(value) {
  const numericValue = Number(value);
  if (typeof value === "boolean" || value === "" || Number.isNaN(numericValue))
    throw new InvalidArgumentError(`Invalid unit value ${value}`);
  return numericValue;
}
function normalizeObject(obj, normalizer) {
  const normalized = {};
  for (const u in obj) {
    if (hasOwnProperty$4(obj, u)) {
      const v = obj[u];
      if (v === void 0 || v === null) continue;
      normalized[normalizer(u)] = asNumber(v);
    }
  }
  return normalized;
}
function formatOffset(offset2, format) {
  const hours = Math.trunc(Math.abs(offset2 / 60)),
    minutes = Math.trunc(Math.abs(offset2 % 60)),
    sign = offset2 >= 0 ? "+" : "-";
  switch (format) {
    case "short":
      return `${sign}${padStart(hours, 2)}:${padStart(minutes, 2)}`;
    case "narrow":
      return `${sign}${hours}${minutes > 0 ? `:${minutes}` : ""}`;
    case "techie":
      return `${sign}${padStart(hours, 2)}${padStart(minutes, 2)}`;
    default:
      throw new RangeError(
        `Value format ${format} is out of range for property format`
      );
  }
}
function timeObject(obj) {
  return pick(obj, ["hour", "minute", "second", "millisecond"]);
}
var ianaRegex =
  /[A-Za-z_+-]{1,256}(:?\/[A-Za-z0-9_+-]{1,256}(\/[A-Za-z0-9_+-]{1,256})?)?/;

// node_modules/luxon/src/impl/english.js
var monthsLong = [
  "January",
  "February",
  "March",
  "April",
  "May",
  "June",
  "July",
  "August",
  "September",
  "October",
  "November",
  "December",
];
var monthsShort = [
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "May",
  "Jun",
  "Jul",
  "Aug",
  "Sep",
  "Oct",
  "Nov",
  "Dec",
];
var monthsNarrow = ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"];
function months(length) {
  switch (length) {
    case "narrow":
      return [...monthsNarrow];
    case "short":
      return [...monthsShort];
    case "long":
      return [...monthsLong];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];
    case "2-digit":
      return [
        "01",
        "02",
        "03",
        "04",
        "05",
        "06",
        "07",
        "08",
        "09",
        "10",
        "11",
        "12",
      ];
    default:
      return null;
  }
}
var weekdaysLong = [
  "Monday",
  "Tuesday",
  "Wednesday",
  "Thursday",
  "Friday",
  "Saturday",
  "Sunday",
];
var weekdaysShort = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];
var weekdaysNarrow = ["M", "T", "W", "T", "F", "S", "S"];
function weekdays(length) {
  switch (length) {
    case "narrow":
      return [...weekdaysNarrow];
    case "short":
      return [...weekdaysShort];
    case "long":
      return [...weekdaysLong];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7"];
    default:
      return null;
  }
}
var meridiems = ["AM", "PM"];
var erasLong = ["Before Christ", "Anno Domini"];
var erasShort = ["BC", "AD"];
var erasNarrow = ["B", "A"];
function eras(length) {
  switch (length) {
    case "narrow":
      return [...erasNarrow];
    case "short":
      return [...erasShort];
    case "long":
      return [...erasLong];
    default:
      return null;
  }
}
function meridiemForDateTime(dt) {
  return meridiems[dt.hour < 12 ? 0 : 1];
}
function weekdayForDateTime(dt, length) {
  return weekdays(length)[dt.weekday - 1];
}
function monthForDateTime(dt, length) {
  return months(length)[dt.month - 1];
}
function eraForDateTime(dt, length) {
  return eras(length)[dt.year < 0 ? 0 : 1];
}
function formatRelativeTime(unit, count, numeric = "always", narrow = false) {
  const units = {
    years: ["year", "yr."],
    quarters: ["quarter", "qtr."],
    months: ["month", "mo."],
    weeks: ["week", "wk."],
    days: ["day", "day", "days"],
    hours: ["hour", "hr."],
    minutes: ["minute", "min."],
    seconds: ["second", "sec."],
  };
  const lastable = ["hours", "minutes", "seconds"].indexOf(unit) === -1;
  if (numeric === "auto" && lastable) {
    const isDay = unit === "days";
    switch (count) {
      case 1:
        return isDay ? "tomorrow" : `next ${units[unit][0]}`;
      case -1:
        return isDay ? "yesterday" : `last ${units[unit][0]}`;
      case 0:
        return isDay ? "today" : `this ${units[unit][0]}`;
    }
  }
  const isInPast = Object.is(count, -0) || count < 0,
    fmtValue = Math.abs(count),
    singular = fmtValue === 1,
    lilUnits = units[unit],
    fmtUnit = narrow
      ? singular
        ? lilUnits[1]
        : lilUnits[2] || lilUnits[1]
      : singular
      ? units[unit][0]
      : unit;
  return isInPast ? `${fmtValue} ${fmtUnit} ago` : `in ${fmtValue} ${fmtUnit}`;
}

// node_modules/luxon/src/impl/formatter.js
function stringifyTokens(splits, tokenToString) {
  let s2 = "";
  for (const token of splits) {
    if (token.literal) {
      s2 += token.val;
    } else {
      s2 += tokenToString(token.val);
    }
  }
  return s2;
}
var macroTokenToFormatOpts = {
  D: DATE_SHORT,
  DD: DATE_MED,
  DDD: DATE_FULL,
  DDDD: DATE_HUGE,
  t: TIME_SIMPLE,
  tt: TIME_WITH_SECONDS,
  ttt: TIME_WITH_SHORT_OFFSET,
  tttt: TIME_WITH_LONG_OFFSET,
  T: TIME_24_SIMPLE,
  TT: TIME_24_WITH_SECONDS,
  TTT: TIME_24_WITH_SHORT_OFFSET,
  TTTT: TIME_24_WITH_LONG_OFFSET,
  f: DATETIME_SHORT,
  ff: DATETIME_MED,
  fff: DATETIME_FULL,
  ffff: DATETIME_HUGE,
  F: DATETIME_SHORT_WITH_SECONDS,
  FF: DATETIME_MED_WITH_SECONDS,
  FFF: DATETIME_FULL_WITH_SECONDS,
  FFFF: DATETIME_HUGE_WITH_SECONDS,
};
var Formatter = class _Formatter {
  static create(locale, opts = {}) {
    return new _Formatter(locale, opts);
  }
  static parseFormat(fmt) {
    let current = null,
      currentFull = "",
      bracketed = false;
    const splits = [];
    for (let i = 0; i < fmt.length; i++) {
      const c = fmt.charAt(i);
      if (c === "'") {
        if (currentFull.length > 0) {
          splits.push({ literal: bracketed, val: currentFull });
        }
        current = null;
        currentFull = "";
        bracketed = !bracketed;
      } else if (bracketed) {
        currentFull += c;
      } else if (c === current) {
        currentFull += c;
      } else {
        if (currentFull.length > 0) {
          splits.push({ literal: false, val: currentFull });
        }
        currentFull = c;
        current = c;
      }
    }
    if (currentFull.length > 0) {
      splits.push({ literal: bracketed, val: currentFull });
    }
    return splits;
  }
  static macroTokenToFormatOpts(token) {
    return macroTokenToFormatOpts[token];
  }
  constructor(locale, formatOpts) {
    this.opts = formatOpts;
    this.loc = locale;
    this.systemLoc = null;
  }
  formatWithSystemDefault(dt, opts) {
    if (this.systemLoc === null) {
      this.systemLoc = this.loc.redefaultToSystem();
    }
    const df = this.systemLoc.dtFormatter(dt, { ...this.opts, ...opts });
    return df.format();
  }
  formatDateTime(dt, opts = {}) {
    const df = this.loc.dtFormatter(dt, { ...this.opts, ...opts });
    return df.format();
  }
  formatDateTimeParts(dt, opts = {}) {
    const df = this.loc.dtFormatter(dt, { ...this.opts, ...opts });
    return df.formatToParts();
  }
  resolvedOptions(dt, opts = {}) {
    const df = this.loc.dtFormatter(dt, { ...this.opts, ...opts });
    return df.resolvedOptions();
  }
  num(n2, p = 0) {
    if (this.opts.forceSimple) {
      return padStart(n2, p);
    }
    const opts = { ...this.opts };
    if (p > 0) {
      opts.padTo = p;
    }
    return this.loc.numberFormatter(opts).format(n2);
  }
  formatDateTimeFromString(dt, fmt) {
    const knownEnglish = this.loc.listingMode() === "en",
      useDateTimeFormatter =
        this.loc.outputCalendar && this.loc.outputCalendar !== "gregory",
      string = (opts, extract) => this.loc.extract(dt, opts, extract),
      formatOffset2 = (opts) => {
        if (dt.isOffsetFixed && dt.offset === 0 && opts.allowZ) {
          return "Z";
        }
        return dt.isValid ? dt.zone.formatOffset(dt.ts, opts.format) : "";
      },
      meridiem = () =>
        knownEnglish
          ? meridiemForDateTime(dt)
          : string({ hour: "numeric", hourCycle: "h12" }, "dayperiod"),
      month = (length, standalone) =>
        knownEnglish
          ? monthForDateTime(dt, length)
          : string(
              standalone
                ? { month: length }
                : { month: length, day: "numeric" },
              "month"
            ),
      weekday = (length, standalone) =>
        knownEnglish
          ? weekdayForDateTime(dt, length)
          : string(
              standalone
                ? { weekday: length }
                : { weekday: length, month: "long", day: "numeric" },
              "weekday"
            ),
      maybeMacro = (token) => {
        const formatOpts = _Formatter.macroTokenToFormatOpts(token);
        if (formatOpts) {
          return this.formatWithSystemDefault(dt, formatOpts);
        } else {
          return token;
        }
      },
      era = (length) =>
        knownEnglish
          ? eraForDateTime(dt, length)
          : string({ era: length }, "era"),
      tokenToString = (token) => {
        switch (token) {
          case "S":
            return this.num(dt.millisecond);
          case "u":
          case "SSS":
            return this.num(dt.millisecond, 3);
          case "s":
            return this.num(dt.second);
          case "ss":
            return this.num(dt.second, 2);
          case "uu":
            return this.num(Math.floor(dt.millisecond / 10), 2);
          case "uuu":
            return this.num(Math.floor(dt.millisecond / 100));
          case "m":
            return this.num(dt.minute);
          case "mm":
            return this.num(dt.minute, 2);
          case "h":
            return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12);
          case "hh":
            return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12, 2);
          case "H":
            return this.num(dt.hour);
          case "HH":
            return this.num(dt.hour, 2);
          case "Z":
            return formatOffset2({
              format: "narrow",
              allowZ: this.opts.allowZ,
            });
          case "ZZ":
            return formatOffset2({ format: "short", allowZ: this.opts.allowZ });
          case "ZZZ":
            return formatOffset2({
              format: "techie",
              allowZ: this.opts.allowZ,
            });
          case "ZZZZ":
            return dt.zone.offsetName(dt.ts, {
              format: "short",
              locale: this.loc.locale,
            });
          case "ZZZZZ":
            return dt.zone.offsetName(dt.ts, {
              format: "long",
              locale: this.loc.locale,
            });
          case "z":
            return dt.zoneName;
          case "a":
            return meridiem();
          case "d":
            return useDateTimeFormatter
              ? string({ day: "numeric" }, "day")
              : this.num(dt.day);
          case "dd":
            return useDateTimeFormatter
              ? string({ day: "2-digit" }, "day")
              : this.num(dt.day, 2);
          case "c":
            return this.num(dt.weekday);
          case "ccc":
            return weekday("short", true);
          case "cccc":
            return weekday("long", true);
          case "ccccc":
            return weekday("narrow", true);
          case "E":
            return this.num(dt.weekday);
          case "EEE":
            return weekday("short", false);
          case "EEEE":
            return weekday("long", false);
          case "EEEEE":
            return weekday("narrow", false);
          case "L":
            return useDateTimeFormatter
              ? string({ month: "numeric", day: "numeric" }, "month")
              : this.num(dt.month);
          case "LL":
            return useDateTimeFormatter
              ? string({ month: "2-digit", day: "numeric" }, "month")
              : this.num(dt.month, 2);
          case "LLL":
            return month("short", true);
          case "LLLL":
            return month("long", true);
          case "LLLLL":
            return month("narrow", true);
          case "M":
            return useDateTimeFormatter
              ? string({ month: "numeric" }, "month")
              : this.num(dt.month);
          case "MM":
            return useDateTimeFormatter
              ? string({ month: "2-digit" }, "month")
              : this.num(dt.month, 2);
          case "MMM":
            return month("short", false);
          case "MMMM":
            return month("long", false);
          case "MMMMM":
            return month("narrow", false);
          case "y":
            return useDateTimeFormatter
              ? string({ year: "numeric" }, "year")
              : this.num(dt.year);
          case "yy":
            return useDateTimeFormatter
              ? string({ year: "2-digit" }, "year")
              : this.num(dt.year.toString().slice(-2), 2);
          case "yyyy":
            return useDateTimeFormatter
              ? string({ year: "numeric" }, "year")
              : this.num(dt.year, 4);
          case "yyyyyy":
            return useDateTimeFormatter
              ? string({ year: "numeric" }, "year")
              : this.num(dt.year, 6);
          case "G":
            return era("short");
          case "GG":
            return era("long");
          case "GGGGG":
            return era("narrow");
          case "kk":
            return this.num(dt.weekYear.toString().slice(-2), 2);
          case "kkkk":
            return this.num(dt.weekYear, 4);
          case "W":
            return this.num(dt.weekNumber);
          case "WW":
            return this.num(dt.weekNumber, 2);
          case "o":
            return this.num(dt.ordinal);
          case "ooo":
            return this.num(dt.ordinal, 3);
          case "q":
            return this.num(dt.quarter);
          case "qq":
            return this.num(dt.quarter, 2);
          case "X":
            return this.num(Math.floor(dt.ts / 1e3));
          case "x":
            return this.num(dt.ts);
          default:
            return maybeMacro(token);
        }
      };
    return stringifyTokens(_Formatter.parseFormat(fmt), tokenToString);
  }
  formatDurationFromString(dur, fmt) {
    const tokenToField = (token) => {
        switch (token[0]) {
          case "S":
            return "millisecond";
          case "s":
            return "second";
          case "m":
            return "minute";
          case "h":
            return "hour";
          case "d":
            return "day";
          case "M":
            return "month";
          case "y":
            return "year";
          default:
            return null;
        }
      },
      tokenToString = (lildur) => (token) => {
        const mapped = tokenToField(token);
        if (mapped) {
          return this.num(lildur.get(mapped), token.length);
        } else {
          return token;
        }
      },
      tokens = _Formatter.parseFormat(fmt),
      realTokens = tokens.reduce(
        (found, { literal, val }) => (literal ? found : found.concat(val)),
        []
      ),
      collapsed = dur.shiftTo(...realTokens.map(tokenToField).filter((t) => t));
    return stringifyTokens(tokens, tokenToString(collapsed));
  }
};

// node_modules/luxon/src/impl/invalid.js
var Invalid = class {
  constructor(reason, explanation) {
    this.reason = reason;
    this.explanation = explanation;
  }
  toMessage() {
    if (this.explanation) {
      return `${this.reason}: ${this.explanation}`;
    } else {
      return this.reason;
    }
  }
};

// node_modules/luxon/src/zone.js
var Zone = class {
  /**
   * The type of zone
   * @abstract
   * @type {string}
   */
  get type() {
    throw new ZoneIsAbstractError();
  }
  /**
   * The name of this zone.
   * @abstract
   * @type {string}
   */
  get name() {
    throw new ZoneIsAbstractError();
  }
  /**
   * Returns whether the offset is known to be fixed for the whole year.
   * @abstract
   * @type {boolean}
   */
  get isUniversal() {
    throw new ZoneIsAbstractError();
  }
  /**
   * Returns the offset's common name (such as EST) at the specified timestamp
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to get the name
   * @param {Object} opts - Options to affect the format
   * @param {string} opts.format - What style of offset to return. Accepts 'long' or 'short'.
   * @param {string} opts.locale - What locale to return the offset name in.
   * @return {string}
   */
  offsetName(ts, opts) {
    throw new ZoneIsAbstractError();
  }
  /**
   * Returns the offset's value as a string
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to get the offset
   * @param {string} format - What style of offset to return.
   *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively
   * @return {string}
   */
  formatOffset(ts, format) {
    throw new ZoneIsAbstractError();
  }
  /**
   * Return the offset in minutes for this zone at the specified timestamp.
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to compute the offset
   * @return {number}
   */
  offset(ts) {
    throw new ZoneIsAbstractError();
  }
  /**
   * Return whether this Zone is equal to another zone
   * @abstract
   * @param {Zone} otherZone - the zone to compare
   * @return {boolean}
   */
  equals(otherZone) {
    throw new ZoneIsAbstractError();
  }
  /**
   * Return whether this Zone is valid.
   * @abstract
   * @type {boolean}
   */
  get isValid() {
    throw new ZoneIsAbstractError();
  }
};

// node_modules/luxon/src/zones/systemZone.js
var singleton = null;
var SystemZone = class _SystemZone extends Zone {
  /**
   * Get a singleton instance of the local zone
   * @return {SystemZone}
   */
  static get instance() {
    if (singleton === null) {
      singleton = new _SystemZone();
    }
    return singleton;
  }
  /** @override **/
  get type() {
    return "system";
  }
  /** @override **/
  get name() {
    return new Intl.DateTimeFormat().resolvedOptions().timeZone;
  }
  /** @override **/
  get isUniversal() {
    return false;
  }
  /** @override **/
  offsetName(ts, { format, locale }) {
    return parseZoneInfo(ts, format, locale);
  }
  /** @override **/
  formatOffset(ts, format) {
    return formatOffset(this.offset(ts), format);
  }
  /** @override **/
  offset(ts) {
    return -new Date(ts).getTimezoneOffset();
  }
  /** @override **/
  equals(otherZone) {
    return otherZone.type === "system";
  }
  /** @override **/
  get isValid() {
    return true;
  }
};
var dtfCache = {};
function makeDTF(zone) {
  if (!dtfCache[zone]) {
    dtfCache[zone] = new Intl.DateTimeFormat("en-US", {
      hour12: false,
      timeZone: zone,
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit",
    });
  }
  return dtfCache[zone];
}
var typeToPos = {
  year: 0,
  month: 1,
  day: 2,
  hour: 3,
  minute: 4,
  second: 5,
};
function hackyOffset(dtf, date) {
  const formatted = dtf.format(date).replace(/\u200E/g, ""),
    parsed = /(\d+)\/(\d+)\/(\d+),? (\d+):(\d+):(\d+)/.exec(formatted),
    [, fMonth, fDay, fYear, fHour, fMinute, fSecond] = parsed;
  return [fYear, fMonth, fDay, fHour, fMinute, fSecond];
}
function partsOffset(dtf, date) {
  const formatted = dtf.formatToParts(date),
    filled = [];
  for (let i = 0; i < formatted.length; i++) {
    const { type, value } = formatted[i],
      pos = typeToPos[type];
    if (!isUndefined(pos)) {
      filled[pos] = parseInt(value, 10);
    }
  }
  return filled;
}
var ianaZoneCache = {};
var IANAZone = class _IANAZone extends Zone {
  /**
   * @param {string} name - Zone name
   * @return {IANAZone}
   */
  static create(name) {
    if (!ianaZoneCache[name]) {
      ianaZoneCache[name] = new _IANAZone(name);
    }
    return ianaZoneCache[name];
  }
  /**
   * Reset local caches. Should only be necessary in testing scenarios.
   * @return {void}
   */
  static resetCache() {
    ianaZoneCache = {};
    dtfCache = {};
  }
  /**
   * Returns whether the provided string is a valid specifier. This only checks the string's format, not that the specifier identifies a known zone; see isValidZone for that.
   * @param {string} s - The string to check validity on
   * @example IANAZone.isValidSpecifier("America/New_York") //=> true
   * @example IANAZone.isValidSpecifier("Sport~~blorp") //=> false
   * @deprecated This method returns false some valid IANA names. Use isValidZone instead
   * @return {boolean}
   */
  static isValidSpecifier(s2) {
    return this.isValidZone(s2);
  }
  /**
   * Returns whether the provided string identifies a real zone
   * @param {string} zone - The string to check
   * @example IANAZone.isValidZone("America/New_York") //=> true
   * @example IANAZone.isValidZone("Fantasia/Castle") //=> false
   * @example IANAZone.isValidZone("Sport~~blorp") //=> false
   * @return {boolean}
   */
  static isValidZone(zone) {
    if (!zone) {
      return false;
    }
    try {
      new Intl.DateTimeFormat("en-US", { timeZone: zone }).format();
      return true;
    } catch (e) {
      return false;
    }
  }
  constructor(name) {
    super();
    this.zoneName = name;
    this.valid = _IANAZone.isValidZone(name);
  }
  /** @override **/
  get type() {
    return "iana";
  }
  /** @override **/
  get name() {
    return this.zoneName;
  }
  /** @override **/
  get isUniversal() {
    return false;
  }
  /** @override **/
  offsetName(ts, { format, locale }) {
    return parseZoneInfo(ts, format, locale, this.name);
  }
  /** @override **/
  formatOffset(ts, format) {
    return formatOffset(this.offset(ts), format);
  }
  /** @override **/
  offset(ts) {
    const date = new Date(ts);
    if (isNaN(date)) return NaN;
    const dtf = makeDTF(this.name),
      [year, month, day, hour, minute, second] = dtf.formatToParts
        ? partsOffset(dtf, date)
        : hackyOffset(dtf, date);
    const adjustedHour = hour === 24 ? 0 : hour;
    const asUTC = objToLocalTS({
      year,
      month,
      day,
      hour: adjustedHour,
      minute,
      second,
      millisecond: 0,
    });
    let asTS = +date;
    const over = asTS % 1e3;
    asTS -= over >= 0 ? over : 1e3 + over;
    return (asUTC - asTS) / (60 * 1e3);
  }
  /** @override **/
  equals(otherZone) {
    return otherZone.type === "iana" && otherZone.name === this.name;
  }
  /** @override **/
  get isValid() {
    return this.valid;
  }
};

// node_modules/luxon/src/zones/fixedOffsetZone.js
var singleton2 = null;
var FixedOffsetZone = class _FixedOffsetZone extends Zone {
  /**
   * Get a singleton instance of UTC
   * @return {FixedOffsetZone}
   */
  static get utcInstance() {
    if (singleton2 === null) {
      singleton2 = new _FixedOffsetZone(0);
    }
    return singleton2;
  }
  /**
   * Get an instance with a specified offset
   * @param {number} offset - The offset in minutes
   * @return {FixedOffsetZone}
   */
  static instance(offset2) {
    return offset2 === 0
      ? _FixedOffsetZone.utcInstance
      : new _FixedOffsetZone(offset2);
  }
  /**
   * Get an instance of FixedOffsetZone from a UTC offset string, like "UTC+6"
   * @param {string} s - The offset string to parse
   * @example FixedOffsetZone.parseSpecifier("UTC+6")
   * @example FixedOffsetZone.parseSpecifier("UTC+06")
   * @example FixedOffsetZone.parseSpecifier("UTC-6:00")
   * @return {FixedOffsetZone}
   */
  static parseSpecifier(s2) {
    if (s2) {
      const r = s2.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);
      if (r) {
        return new _FixedOffsetZone(signedOffset(r[1], r[2]));
      }
    }
    return null;
  }
  constructor(offset2) {
    super();
    this.fixed = offset2;
  }
  /** @override **/
  get type() {
    return "fixed";
  }
  /** @override **/
  get name() {
    return this.fixed === 0
      ? "UTC"
      : `UTC${formatOffset(this.fixed, "narrow")}`;
  }
  /** @override **/
  offsetName() {
    return this.name;
  }
  /** @override **/
  formatOffset(ts, format) {
    return formatOffset(this.fixed, format);
  }
  /** @override **/
  get isUniversal() {
    return true;
  }
  /** @override **/
  offset() {
    return this.fixed;
  }
  /** @override **/
  equals(otherZone) {
    return otherZone.type === "fixed" && otherZone.fixed === this.fixed;
  }
  /** @override **/
  get isValid() {
    return true;
  }
};

// node_modules/luxon/src/zones/invalidZone.js
var InvalidZone = class extends Zone {
  constructor(zoneName) {
    super();
    this.zoneName = zoneName;
  }
  /** @override **/
  get type() {
    return "invalid";
  }
  /** @override **/
  get name() {
    return this.zoneName;
  }
  /** @override **/
  get isUniversal() {
    return false;
  }
  /** @override **/
  offsetName() {
    return null;
  }
  /** @override **/
  formatOffset() {
    return "";
  }
  /** @override **/
  offset() {
    return NaN;
  }
  /** @override **/
  equals() {
    return false;
  }
  /** @override **/
  get isValid() {
    return false;
  }
};

// node_modules/luxon/src/impl/zoneUtil.js
function normalizeZone(input, defaultZone2) {
  if (isUndefined(input) || input === null) {
    return defaultZone2;
  } else if (input instanceof Zone) {
    return input;
  } else if (isString(input)) {
    const lowered = input.toLowerCase();
    if (lowered === "local" || lowered === "system") return defaultZone2;
    else if (lowered === "utc" || lowered === "gmt")
      return FixedOffsetZone.utcInstance;
    else
      return FixedOffsetZone.parseSpecifier(lowered) || IANAZone.create(input);
  } else if (isNumber(input)) {
    return FixedOffsetZone.instance(input);
  } else if (
    typeof input === "object" &&
    input.offset &&
    typeof input.offset === "number"
  ) {
    return input;
  } else {
    return new InvalidZone(input);
  }
}

// node_modules/luxon/src/settings.js
var now = () => Date.now();
var defaultZone = "system";
var defaultLocale = null;
var defaultNumberingSystem = null;
var defaultOutputCalendar = null;
var throwOnInvalid;
var Settings = class {
  /**
   * Get the callback for returning the current timestamp.
   * @type {function}
   */
  static get now() {
    return now;
  }
  /**
   * Set the callback for returning the current timestamp.
   * The function should return a number, which will be interpreted as an Epoch millisecond count
   * @type {function}
   * @example Settings.now = () => Date.now() + 3000 // pretend it is 3 seconds in the future
   * @example Settings.now = () => 0 // always pretend it's Jan 1, 1970 at midnight in UTC time
   */
  static set now(n2) {
    now = n2;
  }
  /**
   * Set the default time zone to create DateTimes in. Does not affect existing instances.
   * Use the value "system" to reset this value to the system's time zone.
   * @type {string}
   */
  static set defaultZone(zone) {
    defaultZone = zone;
  }
  /**
   * Get the default time zone object currently used to create DateTimes. Does not affect existing instances.
   * The default value is the system's time zone (the one set on the machine that runs this code).
   * @type {Zone}
   */
  static get defaultZone() {
    return normalizeZone(defaultZone, SystemZone.instance);
  }
  /**
   * Get the default locale to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultLocale() {
    return defaultLocale;
  }
  /**
   * Set the default locale to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultLocale(locale) {
    defaultLocale = locale;
  }
  /**
   * Get the default numbering system to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultNumberingSystem() {
    return defaultNumberingSystem;
  }
  /**
   * Set the default numbering system to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultNumberingSystem(numberingSystem) {
    defaultNumberingSystem = numberingSystem;
  }
  /**
   * Get the default output calendar to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultOutputCalendar() {
    return defaultOutputCalendar;
  }
  /**
   * Set the default output calendar to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultOutputCalendar(outputCalendar) {
    defaultOutputCalendar = outputCalendar;
  }
  /**
   * Get whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
   * @type {boolean}
   */
  static get throwOnInvalid() {
    return throwOnInvalid;
  }
  /**
   * Set whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
   * @type {boolean}
   */
  static set throwOnInvalid(t) {
    throwOnInvalid = t;
  }
  /**
   * Reset Luxon's global caches. Should only be necessary in testing scenarios.
   * @return {void}
   */
  static resetCaches() {
    Locale.resetCache();
    IANAZone.resetCache();
  }
};

// node_modules/luxon/src/impl/locale.js
var intlLFCache = {};
function getCachedLF(locString, opts = {}) {
  const key = JSON.stringify([locString, opts]);
  let dtf = intlLFCache[key];
  if (!dtf) {
    dtf = new Intl.ListFormat(locString, opts);
    intlLFCache[key] = dtf;
  }
  return dtf;
}
var intlDTCache = {};
function getCachedDTF(locString, opts = {}) {
  const key = JSON.stringify([locString, opts]);
  let dtf = intlDTCache[key];
  if (!dtf) {
    dtf = new Intl.DateTimeFormat(locString, opts);
    intlDTCache[key] = dtf;
  }
  return dtf;
}
var intlNumCache = {};
function getCachedINF(locString, opts = {}) {
  const key = JSON.stringify([locString, opts]);
  let inf = intlNumCache[key];
  if (!inf) {
    inf = new Intl.NumberFormat(locString, opts);
    intlNumCache[key] = inf;
  }
  return inf;
}
var intlRelCache = {};
function getCachedRTF(locString, opts = {}) {
  const { base, ...cacheKeyOpts } = opts;
  const key = JSON.stringify([locString, cacheKeyOpts]);
  let inf = intlRelCache[key];
  if (!inf) {
    inf = new Intl.RelativeTimeFormat(locString, opts);
    intlRelCache[key] = inf;
  }
  return inf;
}
var sysLocaleCache = null;
function systemLocale() {
  if (sysLocaleCache) {
    return sysLocaleCache;
  } else {
    sysLocaleCache = new Intl.DateTimeFormat().resolvedOptions().locale;
    return sysLocaleCache;
  }
}
function parseLocaleString(localeStr) {
  const uIndex = localeStr.indexOf("-u-");
  if (uIndex === -1) {
    return [localeStr];
  } else {
    let options;
    const smaller = localeStr.substring(0, uIndex);
    try {
      options = getCachedDTF(localeStr).resolvedOptions();
    } catch (e) {
      options = getCachedDTF(smaller).resolvedOptions();
    }
    const { numberingSystem, calendar } = options;
    return [smaller, numberingSystem, calendar];
  }
}
function intlConfigString(localeStr, numberingSystem, outputCalendar) {
  if (outputCalendar || numberingSystem) {
    localeStr += "-u";
    if (outputCalendar) {
      localeStr += `-ca-${outputCalendar}`;
    }
    if (numberingSystem) {
      localeStr += `-nu-${numberingSystem}`;
    }
    return localeStr;
  } else {
    return localeStr;
  }
}
function mapMonths(f) {
  const ms = [];
  for (let i = 1; i <= 12; i++) {
    const dt = DateTime.utc(2016, i, 1);
    ms.push(f(dt));
  }
  return ms;
}
function mapWeekdays(f) {
  const ms = [];
  for (let i = 1; i <= 7; i++) {
    const dt = DateTime.utc(2016, 11, 13 + i);
    ms.push(f(dt));
  }
  return ms;
}
function listStuff(loc, length, defaultOK, englishFn, intlFn) {
  const mode = loc.listingMode(defaultOK);
  if (mode === "error") {
    return null;
  } else if (mode === "en") {
    return englishFn(length);
  } else {
    return intlFn(length);
  }
}
function supportsFastNumbers(loc) {
  if (loc.numberingSystem && loc.numberingSystem !== "latn") {
    return false;
  } else {
    return (
      loc.numberingSystem === "latn" ||
      !loc.locale ||
      loc.locale.startsWith("en") ||
      new Intl.DateTimeFormat(loc.intl).resolvedOptions().numberingSystem ===
        "latn"
    );
  }
}
var PolyNumberFormatter = class {
  constructor(intl, forceSimple, opts) {
    this.padTo = opts.padTo || 0;
    this.floor = opts.floor || false;
    const { padTo, floor, ...otherOpts } = opts;
    if (!forceSimple || Object.keys(otherOpts).length > 0) {
      const intlOpts = { useGrouping: false, ...opts };
      if (opts.padTo > 0) intlOpts.minimumIntegerDigits = opts.padTo;
      this.inf = getCachedINF(intl, intlOpts);
    }
  }
  format(i) {
    if (this.inf) {
      const fixed = this.floor ? Math.floor(i) : i;
      return this.inf.format(fixed);
    } else {
      const fixed = this.floor ? Math.floor(i) : roundTo(i, 3);
      return padStart(fixed, this.padTo);
    }
  }
};
var PolyDateFormatter = class {
  constructor(dt, intl, opts) {
    this.opts = opts;
    let z;
    if (dt.zone.isUniversal) {
      const gmtOffset = -1 * (dt.offset / 60);
      const offsetZ =
        gmtOffset >= 0 ? `Etc/GMT+${gmtOffset}` : `Etc/GMT${gmtOffset}`;
      if (dt.offset !== 0 && IANAZone.create(offsetZ).valid) {
        z = offsetZ;
        this.dt = dt;
      } else {
        z = "UTC";
        if (opts.timeZoneName) {
          this.dt = dt;
        } else {
          this.dt =
            dt.offset === 0
              ? dt
              : DateTime.fromMillis(dt.ts + dt.offset * 60 * 1e3);
        }
      }
    } else if (dt.zone.type === "system") {
      this.dt = dt;
    } else {
      this.dt = dt;
      z = dt.zone.name;
    }
    const intlOpts = { ...this.opts };
    if (z) {
      intlOpts.timeZone = z;
    }
    this.dtf = getCachedDTF(intl, intlOpts);
  }
  format() {
    return this.dtf.format(this.dt.toJSDate());
  }
  formatToParts() {
    return this.dtf.formatToParts(this.dt.toJSDate());
  }
  resolvedOptions() {
    return this.dtf.resolvedOptions();
  }
};
var PolyRelFormatter = class {
  constructor(intl, isEnglish, opts) {
    this.opts = { style: "long", ...opts };
    if (!isEnglish && hasRelative()) {
      this.rtf = getCachedRTF(intl, opts);
    }
  }
  format(count, unit) {
    if (this.rtf) {
      return this.rtf.format(count, unit);
    } else {
      return formatRelativeTime(
        unit,
        count,
        this.opts.numeric,
        this.opts.style !== "long"
      );
    }
  }
  formatToParts(count, unit) {
    if (this.rtf) {
      return this.rtf.formatToParts(count, unit);
    } else {
      return [];
    }
  }
};
var Locale = class _Locale {
  static fromOpts(opts) {
    return _Locale.create(
      opts.locale,
      opts.numberingSystem,
      opts.outputCalendar,
      opts.defaultToEN
    );
  }
  static create(locale, numberingSystem, outputCalendar, defaultToEN = false) {
    const specifiedLocale = locale || Settings.defaultLocale;
    const localeR = specifiedLocale || (defaultToEN ? "en-US" : systemLocale());
    const numberingSystemR = numberingSystem || Settings.defaultNumberingSystem;
    const outputCalendarR = outputCalendar || Settings.defaultOutputCalendar;
    return new _Locale(
      localeR,
      numberingSystemR,
      outputCalendarR,
      specifiedLocale
    );
  }
  static resetCache() {
    sysLocaleCache = null;
    intlDTCache = {};
    intlNumCache = {};
    intlRelCache = {};
  }
  static fromObject({ locale, numberingSystem, outputCalendar } = {}) {
    return _Locale.create(locale, numberingSystem, outputCalendar);
  }
  constructor(locale, numbering, outputCalendar, specifiedLocale) {
    const [parsedLocale, parsedNumberingSystem, parsedOutputCalendar] =
      parseLocaleString(locale);
    this.locale = parsedLocale;
    this.numberingSystem = numbering || parsedNumberingSystem || null;
    this.outputCalendar = outputCalendar || parsedOutputCalendar || null;
    this.intl = intlConfigString(
      this.locale,
      this.numberingSystem,
      this.outputCalendar
    );
    this.weekdaysCache = { format: {}, standalone: {} };
    this.monthsCache = { format: {}, standalone: {} };
    this.meridiemCache = null;
    this.eraCache = {};
    this.specifiedLocale = specifiedLocale;
    this.fastNumbersCached = null;
  }
  get fastNumbers() {
    if (this.fastNumbersCached == null) {
      this.fastNumbersCached = supportsFastNumbers(this);
    }
    return this.fastNumbersCached;
  }
  listingMode() {
    const isActuallyEn = this.isEnglish();
    const hasNoWeirdness =
      (this.numberingSystem === null || this.numberingSystem === "latn") &&
      (this.outputCalendar === null || this.outputCalendar === "gregory");
    return isActuallyEn && hasNoWeirdness ? "en" : "intl";
  }
  clone(alts) {
    if (!alts || Object.getOwnPropertyNames(alts).length === 0) {
      return this;
    } else {
      return _Locale.create(
        alts.locale || this.specifiedLocale,
        alts.numberingSystem || this.numberingSystem,
        alts.outputCalendar || this.outputCalendar,
        alts.defaultToEN || false
      );
    }
  }
  redefaultToEN(alts = {}) {
    return this.clone({ ...alts, defaultToEN: true });
  }
  redefaultToSystem(alts = {}) {
    return this.clone({ ...alts, defaultToEN: false });
  }
  months(length, format = false, defaultOK = true) {
    return listStuff(this, length, defaultOK, months, () => {
      const intl = format
          ? { month: length, day: "numeric" }
          : { month: length },
        formatStr = format ? "format" : "standalone";
      if (!this.monthsCache[formatStr][length]) {
        this.monthsCache[formatStr][length] = mapMonths((dt) =>
          this.extract(dt, intl, "month")
        );
      }
      return this.monthsCache[formatStr][length];
    });
  }
  weekdays(length, format = false, defaultOK = true) {
    return listStuff(this, length, defaultOK, weekdays, () => {
      const intl = format
          ? { weekday: length, year: "numeric", month: "long", day: "numeric" }
          : { weekday: length },
        formatStr = format ? "format" : "standalone";
      if (!this.weekdaysCache[formatStr][length]) {
        this.weekdaysCache[formatStr][length] = mapWeekdays((dt) =>
          this.extract(dt, intl, "weekday")
        );
      }
      return this.weekdaysCache[formatStr][length];
    });
  }
  meridiems(defaultOK = true) {
    return listStuff(
      this,
      void 0,
      defaultOK,
      () => meridiems,
      () => {
        if (!this.meridiemCache) {
          const intl = { hour: "numeric", hourCycle: "h12" };
          this.meridiemCache = [
            DateTime.utc(2016, 11, 13, 9),
            DateTime.utc(2016, 11, 13, 19),
          ].map((dt) => this.extract(dt, intl, "dayperiod"));
        }
        return this.meridiemCache;
      }
    );
  }
  eras(length, defaultOK = true) {
    return listStuff(this, length, defaultOK, eras, () => {
      const intl = { era: length };
      if (!this.eraCache[length]) {
        this.eraCache[length] = [
          DateTime.utc(-40, 1, 1),
          DateTime.utc(2017, 1, 1),
        ].map((dt) => this.extract(dt, intl, "era"));
      }
      return this.eraCache[length];
    });
  }
  extract(dt, intlOpts, field) {
    const df = this.dtFormatter(dt, intlOpts),
      results = df.formatToParts(),
      matching = results.find((m) => m.type.toLowerCase() === field);
    return matching ? matching.value : null;
  }
  numberFormatter(opts = {}) {
    return new PolyNumberFormatter(
      this.intl,
      opts.forceSimple || this.fastNumbers,
      opts
    );
  }
  dtFormatter(dt, intlOpts = {}) {
    return new PolyDateFormatter(dt, this.intl, intlOpts);
  }
  relFormatter(opts = {}) {
    return new PolyRelFormatter(this.intl, this.isEnglish(), opts);
  }
  listFormatter(opts = {}) {
    return getCachedLF(this.intl, opts);
  }
  isEnglish() {
    return (
      this.locale === "en" ||
      this.locale.toLowerCase() === "en-us" ||
      new Intl.DateTimeFormat(this.intl)
        .resolvedOptions()
        .locale.startsWith("en-us")
    );
  }
  equals(other) {
    return (
      this.locale === other.locale &&
      this.numberingSystem === other.numberingSystem &&
      this.outputCalendar === other.outputCalendar
    );
  }
};

// node_modules/luxon/src/impl/regexParser.js
function combineRegexes(...regexes) {
  const full = regexes.reduce((f, r) => f + r.source, "");
  return RegExp(`^${full}$`);
}
function combineExtractors(...extractors) {
  return (m) =>
    extractors
      .reduce(
        ([mergedVals, mergedZone, cursor], ex) => {
          const [val, zone, next] = ex(m, cursor);
          return [{ ...mergedVals, ...val }, mergedZone || zone, next];
        },
        [{}, null, 1]
      )
      .slice(0, 2);
}
function parse$1(s2, ...patterns) {
  if (s2 == null) {
    return [null, null];
  }
  for (const [regex, extractor] of patterns) {
    const m = regex.exec(s2);
    if (m) {
      return extractor(m);
    }
  }
  return [null, null];
}
function simpleParse(...keys) {
  return (match2, cursor) => {
    const ret = {};
    let i;
    for (i = 0; i < keys.length; i++) {
      ret[keys[i]] = parseInteger(match2[cursor + i]);
    }
    return [ret, null, cursor + i];
  };
}
var offsetRegex = /(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/;
var isoTimeBaseRegex = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/;
var isoTimeRegex = RegExp(`${isoTimeBaseRegex.source}${offsetRegex.source}?`);
var isoTimeExtensionRegex = RegExp(`(?:T${isoTimeRegex.source})?`);
var isoYmdRegex = /([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/;
var isoWeekRegex = /(\d{4})-?W(\d\d)(?:-?(\d))?/;
var isoOrdinalRegex = /(\d{4})-?(\d{3})/;
var extractISOWeekData = simpleParse("weekYear", "weekNumber", "weekDay");
var extractISOOrdinalData = simpleParse("year", "ordinal");
var sqlYmdRegex = /(\d{4})-(\d\d)-(\d\d)/;
var sqlTimeRegex = RegExp(
  `${isoTimeBaseRegex.source} ?(?:${offsetRegex.source}|(${ianaRegex.source}))?`
);
var sqlTimeExtensionRegex = RegExp(`(?: ${sqlTimeRegex.source})?`);
function int(match2, pos, fallback) {
  const m = match2[pos];
  return isUndefined(m) ? fallback : parseInteger(m);
}
function extractISOYmd(match2, cursor) {
  const item = {
    year: int(match2, cursor),
    month: int(match2, cursor + 1, 1),
    day: int(match2, cursor + 2, 1),
  };
  return [item, null, cursor + 3];
}
function extractISOTime(match2, cursor) {
  const item = {
    hours: int(match2, cursor, 0),
    minutes: int(match2, cursor + 1, 0),
    seconds: int(match2, cursor + 2, 0),
    milliseconds: parseMillis(match2[cursor + 3]),
  };
  return [item, null, cursor + 4];
}
function extractISOOffset(match2, cursor) {
  const local = !match2[cursor] && !match2[cursor + 1],
    fullOffset = signedOffset(match2[cursor + 1], match2[cursor + 2]),
    zone = local ? null : FixedOffsetZone.instance(fullOffset);
  return [{}, zone, cursor + 3];
}
function extractIANAZone(match2, cursor) {
  const zone = match2[cursor] ? IANAZone.create(match2[cursor]) : null;
  return [{}, zone, cursor + 1];
}
var isoTimeOnly = RegExp(`^T?${isoTimeBaseRegex.source}$`);
var isoDuration =
  /^-?P(?:(?:(-?\d{1,9}(?:\.\d{1,9})?)Y)?(?:(-?\d{1,9}(?:\.\d{1,9})?)M)?(?:(-?\d{1,9}(?:\.\d{1,9})?)W)?(?:(-?\d{1,9}(?:\.\d{1,9})?)D)?(?:T(?:(-?\d{1,9}(?:\.\d{1,9})?)H)?(?:(-?\d{1,9}(?:\.\d{1,9})?)M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,9}))?S)?)?)$/;
function extractISODuration(match2) {
  const [
    s2,
    yearStr,
    monthStr,
    weekStr,
    dayStr,
    hourStr,
    minuteStr,
    secondStr,
    millisecondsStr,
  ] = match2;
  const hasNegativePrefix = s2[0] === "-";
  const negativeSeconds = secondStr && secondStr[0] === "-";
  const maybeNegate = (num, force = false) =>
    num !== void 0 && (force || (num && hasNegativePrefix)) ? -num : num;
  return [
    {
      years: maybeNegate(parseFloating(yearStr)),
      months: maybeNegate(parseFloating(monthStr)),
      weeks: maybeNegate(parseFloating(weekStr)),
      days: maybeNegate(parseFloating(dayStr)),
      hours: maybeNegate(parseFloating(hourStr)),
      minutes: maybeNegate(parseFloating(minuteStr)),
      seconds: maybeNegate(parseFloating(secondStr), secondStr === "-0"),
      milliseconds: maybeNegate(parseMillis(millisecondsStr), negativeSeconds),
    },
  ];
}
var obsOffsets = {
  GMT: 0,
  EDT: -4 * 60,
  EST: -5 * 60,
  CDT: -5 * 60,
  CST: -6 * 60,
  MDT: -6 * 60,
  MST: -7 * 60,
  PDT: -7 * 60,
  PST: -8 * 60,
};
function fromStrings(
  weekdayStr,
  yearStr,
  monthStr,
  dayStr,
  hourStr,
  minuteStr,
  secondStr
) {
  const result = {
    year:
      yearStr.length === 2
        ? untruncateYear(parseInteger(yearStr))
        : parseInteger(yearStr),
    month: monthsShort.indexOf(monthStr) + 1,
    day: parseInteger(dayStr),
    hour: parseInteger(hourStr),
    minute: parseInteger(minuteStr),
  };
  if (secondStr) result.second = parseInteger(secondStr);
  if (weekdayStr) {
    result.weekday =
      weekdayStr.length > 3
        ? weekdaysLong.indexOf(weekdayStr) + 1
        : weekdaysShort.indexOf(weekdayStr) + 1;
  }
  return result;
}
var rfc2822 =
  /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;
function extractRFC2822(match2) {
  const [
      ,
      weekdayStr,
      dayStr,
      monthStr,
      yearStr,
      hourStr,
      minuteStr,
      secondStr,
      obsOffset,
      milOffset,
      offHourStr,
      offMinuteStr,
    ] = match2,
    result = fromStrings(
      weekdayStr,
      yearStr,
      monthStr,
      dayStr,
      hourStr,
      minuteStr,
      secondStr
    );
  let offset2;
  if (obsOffset) {
    offset2 = obsOffsets[obsOffset];
  } else if (milOffset) {
    offset2 = 0;
  } else {
    offset2 = signedOffset(offHourStr, offMinuteStr);
  }
  return [result, new FixedOffsetZone(offset2)];
}
function preprocessRFC2822(s2) {
  return s2
    .replace(/\([^)]*\)|[\n\t]/g, " ")
    .replace(/(\s\s+)/g, " ")
    .trim();
}
var rfc1123 =
  /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/;
var rfc850 =
  /^(Monday|Tuesday|Wedsday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/;
var ascii =
  /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;
function extractRFC1123Or850(match2) {
  const [
      ,
      weekdayStr,
      dayStr,
      monthStr,
      yearStr,
      hourStr,
      minuteStr,
      secondStr,
    ] = match2,
    result = fromStrings(
      weekdayStr,
      yearStr,
      monthStr,
      dayStr,
      hourStr,
      minuteStr,
      secondStr
    );
  return [result, FixedOffsetZone.utcInstance];
}
function extractASCII(match2) {
  const [
      ,
      weekdayStr,
      monthStr,
      dayStr,
      hourStr,
      minuteStr,
      secondStr,
      yearStr,
    ] = match2,
    result = fromStrings(
      weekdayStr,
      yearStr,
      monthStr,
      dayStr,
      hourStr,
      minuteStr,
      secondStr
    );
  return [result, FixedOffsetZone.utcInstance];
}
var isoYmdWithTimeExtensionRegex = combineRegexes(
  isoYmdRegex,
  isoTimeExtensionRegex
);
var isoWeekWithTimeExtensionRegex = combineRegexes(
  isoWeekRegex,
  isoTimeExtensionRegex
);
var isoOrdinalWithTimeExtensionRegex = combineRegexes(
  isoOrdinalRegex,
  isoTimeExtensionRegex
);
var isoTimeCombinedRegex = combineRegexes(isoTimeRegex);
var extractISOYmdTimeAndOffset = combineExtractors(
  extractISOYmd,
  extractISOTime,
  extractISOOffset
);
var extractISOWeekTimeAndOffset = combineExtractors(
  extractISOWeekData,
  extractISOTime,
  extractISOOffset
);
var extractISOOrdinalDateAndTime = combineExtractors(
  extractISOOrdinalData,
  extractISOTime,
  extractISOOffset
);
var extractISOTimeAndOffset = combineExtractors(
  extractISOTime,
  extractISOOffset
);
function parseISODate(s2) {
  return parse$1(
    s2,
    [isoYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset],
    [isoWeekWithTimeExtensionRegex, extractISOWeekTimeAndOffset],
    [isoOrdinalWithTimeExtensionRegex, extractISOOrdinalDateAndTime],
    [isoTimeCombinedRegex, extractISOTimeAndOffset]
  );
}
function parseRFC2822Date(s2) {
  return parse$1(preprocessRFC2822(s2), [rfc2822, extractRFC2822]);
}
function parseHTTPDate(s2) {
  return parse$1(
    s2,
    [rfc1123, extractRFC1123Or850],
    [rfc850, extractRFC1123Or850],
    [ascii, extractASCII]
  );
}
function parseISODuration(s2) {
  return parse$1(s2, [isoDuration, extractISODuration]);
}
var extractISOTimeOnly = combineExtractors(extractISOTime);
function parseISOTimeOnly(s2) {
  return parse$1(s2, [isoTimeOnly, extractISOTimeOnly]);
}
var sqlYmdWithTimeExtensionRegex = combineRegexes(
  sqlYmdRegex,
  sqlTimeExtensionRegex
);
var sqlTimeCombinedRegex = combineRegexes(sqlTimeRegex);
var extractISOYmdTimeOffsetAndIANAZone = combineExtractors(
  extractISOYmd,
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
var extractISOTimeOffsetAndIANAZone = combineExtractors(
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
function parseSQL(s2) {
  return parse$1(
    s2,
    [sqlYmdWithTimeExtensionRegex, extractISOYmdTimeOffsetAndIANAZone],
    [sqlTimeCombinedRegex, extractISOTimeOffsetAndIANAZone]
  );
}

// node_modules/luxon/src/duration.js
var INVALID = "Invalid Duration";
var lowOrderMatrix = {
  weeks: {
    days: 7,
    hours: 7 * 24,
    minutes: 7 * 24 * 60,
    seconds: 7 * 24 * 60 * 60,
    milliseconds: 7 * 24 * 60 * 60 * 1e3,
  },
  days: {
    hours: 24,
    minutes: 24 * 60,
    seconds: 24 * 60 * 60,
    milliseconds: 24 * 60 * 60 * 1e3,
  },
  hours: { minutes: 60, seconds: 60 * 60, milliseconds: 60 * 60 * 1e3 },
  minutes: { seconds: 60, milliseconds: 60 * 1e3 },
  seconds: { milliseconds: 1e3 },
};
var casualMatrix = {
  years: {
    quarters: 4,
    months: 12,
    weeks: 52,
    days: 365,
    hours: 365 * 24,
    minutes: 365 * 24 * 60,
    seconds: 365 * 24 * 60 * 60,
    milliseconds: 365 * 24 * 60 * 60 * 1e3,
  },
  quarters: {
    months: 3,
    weeks: 13,
    days: 91,
    hours: 91 * 24,
    minutes: 91 * 24 * 60,
    seconds: 91 * 24 * 60 * 60,
    milliseconds: 91 * 24 * 60 * 60 * 1e3,
  },
  months: {
    weeks: 4,
    days: 30,
    hours: 30 * 24,
    minutes: 30 * 24 * 60,
    seconds: 30 * 24 * 60 * 60,
    milliseconds: 30 * 24 * 60 * 60 * 1e3,
  },
  ...lowOrderMatrix,
};
var daysInYearAccurate = 146097 / 400;
var daysInMonthAccurate = 146097 / 4800;
var accurateMatrix = {
  years: {
    quarters: 4,
    months: 12,
    weeks: daysInYearAccurate / 7,
    days: daysInYearAccurate,
    hours: daysInYearAccurate * 24,
    minutes: daysInYearAccurate * 24 * 60,
    seconds: daysInYearAccurate * 24 * 60 * 60,
    milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1e3,
  },
  quarters: {
    months: 3,
    weeks: daysInYearAccurate / 28,
    days: daysInYearAccurate / 4,
    hours: (daysInYearAccurate * 24) / 4,
    minutes: (daysInYearAccurate * 24 * 60) / 4,
    seconds: (daysInYearAccurate * 24 * 60 * 60) / 4,
    milliseconds: (daysInYearAccurate * 24 * 60 * 60 * 1e3) / 4,
  },
  months: {
    weeks: daysInMonthAccurate / 7,
    days: daysInMonthAccurate,
    hours: daysInMonthAccurate * 24,
    minutes: daysInMonthAccurate * 24 * 60,
    seconds: daysInMonthAccurate * 24 * 60 * 60,
    milliseconds: daysInMonthAccurate * 24 * 60 * 60 * 1e3,
  },
  ...lowOrderMatrix,
};
var orderedUnits = [
  "years",
  "quarters",
  "months",
  "weeks",
  "days",
  "hours",
  "minutes",
  "seconds",
  "milliseconds",
];
var reverseUnits = orderedUnits.slice(0).reverse();
function clone(dur, alts, clear = false) {
  const conf = {
    values: clear ? alts.values : { ...dur.values, ...(alts.values || {}) },
    loc: dur.loc.clone(alts.loc),
    conversionAccuracy: alts.conversionAccuracy || dur.conversionAccuracy,
  };
  return new Duration(conf);
}
function antiTrunc(n2) {
  return n2 < 0 ? Math.floor(n2) : Math.ceil(n2);
}
function convert(matrix, fromMap, fromUnit, toMap, toUnit) {
  const conv = matrix[toUnit][fromUnit],
    raw = fromMap[fromUnit] / conv,
    sameSign = Math.sign(raw) === Math.sign(toMap[toUnit]),
    added =
      !sameSign && toMap[toUnit] !== 0 && Math.abs(raw) <= 1
        ? antiTrunc(raw)
        : Math.trunc(raw);
  toMap[toUnit] += added;
  fromMap[fromUnit] -= added * conv;
}
function normalizeValues(matrix, vals) {
  reverseUnits.reduce((previous, current) => {
    if (!isUndefined(vals[current])) {
      if (previous) {
        convert(matrix, vals, previous, vals, current);
      }
      return current;
    } else {
      return previous;
    }
  }, null);
}
var Duration = class _Duration {
  /**
   * @private
   */
  constructor(config) {
    const accurate = config.conversionAccuracy === "longterm" || false;
    this.values = config.values;
    this.loc = config.loc || Locale.create();
    this.conversionAccuracy = accurate ? "longterm" : "casual";
    this.invalid = config.invalid || null;
    this.matrix = accurate ? accurateMatrix : casualMatrix;
    this.isLuxonDuration = true;
  }
  /**
   * Create Duration from a number of milliseconds.
   * @param {number} count of milliseconds
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @return {Duration}
   */
  static fromMillis(count, opts) {
    return _Duration.fromObject({ milliseconds: count }, opts);
  }
  /**
   * Create a Duration from a JavaScript object with keys like 'years' and 'hours'.
   * If this object is empty then a zero milliseconds duration is returned.
   * @param {Object} obj - the object to create the DateTime from
   * @param {number} obj.years
   * @param {number} obj.quarters
   * @param {number} obj.months
   * @param {number} obj.weeks
   * @param {number} obj.days
   * @param {number} obj.hours
   * @param {number} obj.minutes
   * @param {number} obj.seconds
   * @param {number} obj.milliseconds
   * @param {Object} [opts=[]] - options for creating this Duration
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @return {Duration}
   */
  static fromObject(obj, opts = {}) {
    if (obj == null || typeof obj !== "object") {
      throw new InvalidArgumentError(
        `Duration.fromObject: argument expected to be an object, got ${
          obj === null ? "null" : typeof obj
        }`
      );
    }
    return new _Duration({
      values: normalizeObject(obj, _Duration.normalizeUnit),
      loc: Locale.fromObject(opts),
      conversionAccuracy: opts.conversionAccuracy,
    });
  }
  /**
   * Create a Duration from DurationLike.
   *
   * @param {Object | number | Duration} durationLike
   * One of:
   * - object with keys like 'years' and 'hours'.
   * - number representing milliseconds
   * - Duration instance
   * @return {Duration}
   */
  static fromDurationLike(durationLike) {
    if (isNumber(durationLike)) {
      return _Duration.fromMillis(durationLike);
    } else if (_Duration.isDuration(durationLike)) {
      return durationLike;
    } else if (typeof durationLike === "object") {
      return _Duration.fromObject(durationLike);
    } else {
      throw new InvalidArgumentError(
        `Unknown duration argument ${durationLike} of type ${typeof durationLike}`
      );
    }
  }
  /**
   * Create a Duration from an ISO 8601 duration string.
   * @param {string} text - text to parse
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
   * @example Duration.fromISO('P3Y6M1W4DT12H30M5S').toObject() //=> { years: 3, months: 6, weeks: 1, days: 4, hours: 12, minutes: 30, seconds: 5 }
   * @example Duration.fromISO('PT23H').toObject() //=> { hours: 23 }
   * @example Duration.fromISO('P5Y3M').toObject() //=> { years: 5, months: 3 }
   * @return {Duration}
   */
  static fromISO(text, opts) {
    const [parsed] = parseISODuration(text);
    if (parsed) {
      return _Duration.fromObject(parsed, opts);
    } else {
      return _Duration.invalid(
        "unparsable",
        `the input "${text}" can't be parsed as ISO 8601`
      );
    }
  }
  /**
   * Create a Duration from an ISO 8601 time string.
   * @param {string} text - text to parse
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @see https://en.wikipedia.org/wiki/ISO_8601#Times
   * @example Duration.fromISOTime('11:22:33.444').toObject() //=> { hours: 11, minutes: 22, seconds: 33, milliseconds: 444 }
   * @example Duration.fromISOTime('11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('T11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('T1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @return {Duration}
   */
  static fromISOTime(text, opts) {
    const [parsed] = parseISOTimeOnly(text);
    if (parsed) {
      return _Duration.fromObject(parsed, opts);
    } else {
      return _Duration.invalid(
        "unparsable",
        `the input "${text}" can't be parsed as ISO 8601`
      );
    }
  }
  /**
   * Create an invalid Duration.
   * @param {string} reason - simple string of why this datetime is invalid. Should not contain parameters or anything else data-dependent
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {Duration}
   */
  static invalid(reason, explanation = null) {
    if (!reason) {
      throw new InvalidArgumentError(
        "need to specify a reason the Duration is invalid"
      );
    }
    const invalid =
      reason instanceof Invalid ? reason : new Invalid(reason, explanation);
    if (Settings.throwOnInvalid) {
      throw new InvalidDurationError(invalid);
    } else {
      return new _Duration({ invalid });
    }
  }
  /**
   * @private
   */
  static normalizeUnit(unit) {
    const normalized = {
      year: "years",
      years: "years",
      quarter: "quarters",
      quarters: "quarters",
      month: "months",
      months: "months",
      week: "weeks",
      weeks: "weeks",
      day: "days",
      days: "days",
      hour: "hours",
      hours: "hours",
      minute: "minutes",
      minutes: "minutes",
      second: "seconds",
      seconds: "seconds",
      millisecond: "milliseconds",
      milliseconds: "milliseconds",
    }[unit ? unit.toLowerCase() : unit];
    if (!normalized) throw new InvalidUnitError(unit);
    return normalized;
  }
  /**
   * Check if an object is a Duration. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isDuration(o) {
    return (o && o.isLuxonDuration) || false;
  }
  /**
   * Get  the locale of a Duration, such 'en-GB'
   * @type {string}
   */
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }
  /**
   * Get the numbering system of a Duration, such 'beng'. The numbering system is used when formatting the Duration
   *
   * @type {string}
   */
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }
  /**
   * Returns a string representation of this Duration formatted according to the specified format string. You may use these tokens:
   * * `S` for milliseconds
   * * `s` for seconds
   * * `m` for minutes
   * * `h` for hours
   * * `d` for days
   * * `M` for months
   * * `y` for years
   * Notes:
   * * Add padding by repeating the token, e.g. "yy" pads the years to two digits, "hhhh" pads the hours out to four digits
   * * The duration will be converted to the set of units in the format string using {@link Duration#shiftTo} and the Durations's conversion accuracy setting.
   * @param {string} fmt - the format string
   * @param {Object} opts - options
   * @param {boolean} [opts.floor=true] - floor numerical values
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("y d s") //=> "1 6 2"
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("yy dd sss") //=> "01 06 002"
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("M S") //=> "12 518402000"
   * @return {string}
   */
  toFormat(fmt, opts = {}) {
    const fmtOpts = {
      ...opts,
      floor: opts.round !== false && opts.floor !== false,
    };
    return this.isValid
      ? Formatter.create(this.loc, fmtOpts).formatDurationFromString(this, fmt)
      : INVALID;
  }
  /**
   * Returns a string representation of a Duration with all units included
   * To modify its behavior use the `listStyle` and any Intl.NumberFormat option, though `unitDisplay` is especially relevant. See {@link Intl.NumberFormat}.
   * @param opts - On option object to override the formatting. Accepts the same keys as the options parameter of the native `Int.NumberFormat` constructor, as well as `listStyle`.
   * @example
   * ```js
   * var dur = Duration.fromObject({ days: 1, hours: 5, minutes: 6 })
   * dur.toHuman() //=> '1 day, 5 hours, 6 minutes'
   * dur.toHuman({ listStyle: "long" }) //=> '1 day, 5 hours, and 6 minutes'
   * dur.toHuman({ unitDisplay: "short" }) //=> '1 day, 5 hr, 6 min'
   * ```
   */
  toHuman(opts = {}) {
    const l2 = orderedUnits
      .map((unit) => {
        const val = this.values[unit];
        if (isUndefined(val)) {
          return null;
        }
        return this.loc
          .numberFormatter({
            style: "unit",
            unitDisplay: "long",
            ...opts,
            unit: unit.slice(0, -1),
          })
          .format(val);
      })
      .filter((n2) => n2);
    return this.loc
      .listFormatter({
        type: "conjunction",
        style: opts.listStyle || "narrow",
        ...opts,
      })
      .format(l2);
  }
  /**
   * Returns a JavaScript object with this Duration's values.
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toObject() //=> { years: 1, days: 6, seconds: 2 }
   * @return {Object}
   */
  toObject() {
    if (!this.isValid) return {};
    return { ...this.values };
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Duration.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
   * @example Duration.fromObject({ years: 3, seconds: 45 }).toISO() //=> 'P3YT45S'
   * @example Duration.fromObject({ months: 4, seconds: 45 }).toISO() //=> 'P4MT45S'
   * @example Duration.fromObject({ months: 5 }).toISO() //=> 'P5M'
   * @example Duration.fromObject({ minutes: 5 }).toISO() //=> 'PT5M'
   * @example Duration.fromObject({ milliseconds: 6 }).toISO() //=> 'PT0.006S'
   * @return {string}
   */
  toISO() {
    if (!this.isValid) return null;
    let s2 = "P";
    if (this.years !== 0) s2 += this.years + "Y";
    if (this.months !== 0 || this.quarters !== 0)
      s2 += this.months + this.quarters * 3 + "M";
    if (this.weeks !== 0) s2 += this.weeks + "W";
    if (this.days !== 0) s2 += this.days + "D";
    if (
      this.hours !== 0 ||
      this.minutes !== 0 ||
      this.seconds !== 0 ||
      this.milliseconds !== 0
    )
      s2 += "T";
    if (this.hours !== 0) s2 += this.hours + "H";
    if (this.minutes !== 0) s2 += this.minutes + "M";
    if (this.seconds !== 0 || this.milliseconds !== 0)
      s2 += roundTo(this.seconds + this.milliseconds / 1e3, 3) + "S";
    if (s2 === "P") s2 += "T0S";
    return s2;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Duration, formatted as a time of day.
   * Note that this will return null if the duration is invalid, negative, or equal to or greater than 24 hours.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Times
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example Duration.fromObject({ hours: 11 }).toISOTime() //=> '11:00:00.000'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressMilliseconds: true }) //=> '11:00:00'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressSeconds: true }) //=> '11:00'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ includePrefix: true }) //=> 'T11:00:00.000'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ format: 'basic' }) //=> '110000.000'
   * @return {string}
   */
  toISOTime(opts = {}) {
    if (!this.isValid) return null;
    const millis = this.toMillis();
    if (millis < 0 || millis >= 864e5) return null;
    opts = {
      suppressMilliseconds: false,
      suppressSeconds: false,
      includePrefix: false,
      format: "extended",
      ...opts,
    };
    const value = this.shiftTo("hours", "minutes", "seconds", "milliseconds");
    let fmt = opts.format === "basic" ? "hhmm" : "hh:mm";
    if (
      !opts.suppressSeconds ||
      value.seconds !== 0 ||
      value.milliseconds !== 0
    ) {
      fmt += opts.format === "basic" ? "ss" : ":ss";
      if (!opts.suppressMilliseconds || value.milliseconds !== 0) {
        fmt += ".SSS";
      }
    }
    let str = value.toFormat(fmt);
    if (opts.includePrefix) {
      str = "T" + str;
    }
    return str;
  }
  /**
   * Returns an ISO 8601 representation of this Duration appropriate for use in JSON.
   * @return {string}
   */
  toJSON() {
    return this.toISO();
  }
  /**
   * Returns an ISO 8601 representation of this Duration appropriate for use in debugging.
   * @return {string}
   */
  toString() {
    return this.toISO();
  }
  /**
   * Returns an milliseconds value of this Duration.
   * @return {number}
   */
  toMillis() {
    return this.as("milliseconds");
  }
  /**
   * Returns an milliseconds value of this Duration. Alias of {@link toMillis}
   * @return {number}
   */
  valueOf() {
    return this.toMillis();
  }
  /**
   * Make this Duration longer by the specified amount. Return a newly-constructed Duration.
   * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @return {Duration}
   */
  plus(duration) {
    if (!this.isValid) return this;
    const dur = _Duration.fromDurationLike(duration),
      result = {};
    for (const k of orderedUnits) {
      if (hasOwnProperty$4(dur.values, k) || hasOwnProperty$4(this.values, k)) {
        result[k] = dur.get(k) + this.get(k);
      }
    }
    return clone(this, { values: result }, true);
  }
  /**
   * Make this Duration shorter by the specified amount. Return a newly-constructed Duration.
   * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @return {Duration}
   */
  minus(duration) {
    if (!this.isValid) return this;
    const dur = _Duration.fromDurationLike(duration);
    return this.plus(dur.negate());
  }
  /**
   * Scale this Duration by the specified amount. Return a newly-constructed Duration.
   * @param {function} fn - The function to apply to each unit. Arity is 1 or 2: the value of the unit and, optionally, the unit name. Must return a number.
   * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits(x => x * 2) //=> { hours: 2, minutes: 60 }
   * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits((x, u) => u === "hour" ? x * 2 : x) //=> { hours: 2, minutes: 30 }
   * @return {Duration}
   */
  mapUnits(fn) {
    if (!this.isValid) return this;
    const result = {};
    for (const k of Object.keys(this.values)) {
      result[k] = asNumber(fn(this.values[k], k));
    }
    return clone(this, { values: result }, true);
  }
  /**
   * Get the value of unit.
   * @param {string} unit - a unit such as 'minute' or 'day'
   * @example Duration.fromObject({years: 2, days: 3}).get('years') //=> 2
   * @example Duration.fromObject({years: 2, days: 3}).get('months') //=> 0
   * @example Duration.fromObject({years: 2, days: 3}).get('days') //=> 3
   * @return {number}
   */
  get(unit) {
    return this[_Duration.normalizeUnit(unit)];
  }
  /**
   * "Set" the values of specified units. Return a newly-constructed Duration.
   * @param {Object} values - a mapping of units to numbers
   * @example dur.set({ years: 2017 })
   * @example dur.set({ hours: 8, minutes: 30 })
   * @return {Duration}
   */
  set(values) {
    if (!this.isValid) return this;
    const mixed = {
      ...this.values,
      ...normalizeObject(values, _Duration.normalizeUnit),
    };
    return clone(this, { values: mixed });
  }
  /**
   * "Set" the locale and/or numberingSystem.  Returns a newly-constructed Duration.
   * @example dur.reconfigure({ locale: 'en-GB' })
   * @return {Duration}
   */
  reconfigure({ locale, numberingSystem, conversionAccuracy } = {}) {
    const loc = this.loc.clone({ locale, numberingSystem }),
      opts = { loc };
    if (conversionAccuracy) {
      opts.conversionAccuracy = conversionAccuracy;
    }
    return clone(this, opts);
  }
  /**
   * Return the length of the duration in the specified unit.
   * @param {string} unit - a unit such as 'minutes' or 'days'
   * @example Duration.fromObject({years: 1}).as('days') //=> 365
   * @example Duration.fromObject({years: 1}).as('months') //=> 12
   * @example Duration.fromObject({hours: 60}).as('days') //=> 2.5
   * @return {number}
   */
  as(unit) {
    return this.isValid ? this.shiftTo(unit).get(unit) : NaN;
  }
  /**
   * Reduce this Duration to its canonical representation in its current units.
   * @example Duration.fromObject({ years: 2, days: 5000 }).normalize().toObject() //=> { years: 15, days: 255 }
   * @example Duration.fromObject({ hours: 12, minutes: -45 }).normalize().toObject() //=> { hours: 11, minutes: 15 }
   * @return {Duration}
   */
  normalize() {
    if (!this.isValid) return this;
    const vals = this.toObject();
    normalizeValues(this.matrix, vals);
    return clone(this, { values: vals }, true);
  }
  /**
   * Convert this Duration into its representation in a different set of units.
   * @example Duration.fromObject({ hours: 1, seconds: 30 }).shiftTo('minutes', 'milliseconds').toObject() //=> { minutes: 60, milliseconds: 30000 }
   * @return {Duration}
   */
  shiftTo(...units) {
    if (!this.isValid) return this;
    if (units.length === 0) {
      return this;
    }
    units = units.map((u) => _Duration.normalizeUnit(u));
    const built = {},
      accumulated = {},
      vals = this.toObject();
    let lastUnit;
    for (const k of orderedUnits) {
      if (units.indexOf(k) >= 0) {
        lastUnit = k;
        let own = 0;
        for (const ak in accumulated) {
          own += this.matrix[ak][k] * accumulated[ak];
          accumulated[ak] = 0;
        }
        if (isNumber(vals[k])) {
          own += vals[k];
        }
        const i = Math.trunc(own);
        built[k] = i;
        accumulated[k] = (own * 1e3 - i * 1e3) / 1e3;
        for (const down in vals) {
          if (orderedUnits.indexOf(down) > orderedUnits.indexOf(k)) {
            convert(this.matrix, vals, down, built, k);
          }
        }
      } else if (isNumber(vals[k])) {
        accumulated[k] = vals[k];
      }
    }
    for (const key in accumulated) {
      if (accumulated[key] !== 0) {
        built[lastUnit] +=
          key === lastUnit
            ? accumulated[key]
            : accumulated[key] / this.matrix[lastUnit][key];
      }
    }
    return clone(this, { values: built }, true).normalize();
  }
  /**
   * Return the negative of this Duration.
   * @example Duration.fromObject({ hours: 1, seconds: 30 }).negate().toObject() //=> { hours: -1, seconds: -30 }
   * @return {Duration}
   */
  negate() {
    if (!this.isValid) return this;
    const negated = {};
    for (const k of Object.keys(this.values)) {
      negated[k] = this.values[k] === 0 ? 0 : -this.values[k];
    }
    return clone(this, { values: negated }, true);
  }
  /**
   * Get the years.
   * @type {number}
   */
  get years() {
    return this.isValid ? this.values.years || 0 : NaN;
  }
  /**
   * Get the quarters.
   * @type {number}
   */
  get quarters() {
    return this.isValid ? this.values.quarters || 0 : NaN;
  }
  /**
   * Get the months.
   * @type {number}
   */
  get months() {
    return this.isValid ? this.values.months || 0 : NaN;
  }
  /**
   * Get the weeks
   * @type {number}
   */
  get weeks() {
    return this.isValid ? this.values.weeks || 0 : NaN;
  }
  /**
   * Get the days.
   * @type {number}
   */
  get days() {
    return this.isValid ? this.values.days || 0 : NaN;
  }
  /**
   * Get the hours.
   * @type {number}
   */
  get hours() {
    return this.isValid ? this.values.hours || 0 : NaN;
  }
  /**
   * Get the minutes.
   * @type {number}
   */
  get minutes() {
    return this.isValid ? this.values.minutes || 0 : NaN;
  }
  /**
   * Get the seconds.
   * @return {number}
   */
  get seconds() {
    return this.isValid ? this.values.seconds || 0 : NaN;
  }
  /**
   * Get the milliseconds.
   * @return {number}
   */
  get milliseconds() {
    return this.isValid ? this.values.milliseconds || 0 : NaN;
  }
  /**
   * Returns whether the Duration is invalid. Invalid durations are returned by diff operations
   * on invalid DateTimes or Intervals.
   * @return {boolean}
   */
  get isValid() {
    return this.invalid === null;
  }
  /**
   * Returns an error code if this Duration became invalid, or null if the Duration is valid
   * @return {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  /**
   * Returns an explanation of why this Duration became invalid, or null if the Duration is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  /**
   * Equality check
   * Two Durations are equal iff they have the same units and the same values for each unit.
   * @param {Duration} other
   * @return {boolean}
   */
  equals(other) {
    if (!this.isValid || !other.isValid) {
      return false;
    }
    if (!this.loc.equals(other.loc)) {
      return false;
    }
    function eq(v1, v2) {
      if (v1 === void 0 || v1 === 0) return v2 === void 0 || v2 === 0;
      return v1 === v2;
    }
    for (const u of orderedUnits) {
      if (!eq(this.values[u], other.values[u])) {
        return false;
      }
    }
    return true;
  }
};

// node_modules/luxon/src/interval.js
var INVALID2 = "Invalid Interval";
function validateStartEnd(start, end) {
  if (!start || !start.isValid) {
    return Interval.invalid("missing or invalid start");
  } else if (!end || !end.isValid) {
    return Interval.invalid("missing or invalid end");
  } else if (end < start) {
    return Interval.invalid(
      "end before start",
      `The end of an interval must be after its start, but you had start=${start.toISO()} and end=${end.toISO()}`
    );
  } else {
    return null;
  }
}
var Interval = class _Interval {
  /**
   * @private
   */
  constructor(config) {
    this.s = config.start;
    this.e = config.end;
    this.invalid = config.invalid || null;
    this.isLuxonInterval = true;
  }
  /**
   * Create an invalid Interval.
   * @param {string} reason - simple string of why this Interval is invalid. Should not contain parameters or anything else data-dependent
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {Interval}
   */
  static invalid(reason, explanation = null) {
    if (!reason) {
      throw new InvalidArgumentError(
        "need to specify a reason the Interval is invalid"
      );
    }
    const invalid =
      reason instanceof Invalid ? reason : new Invalid(reason, explanation);
    if (Settings.throwOnInvalid) {
      throw new InvalidIntervalError(invalid);
    } else {
      return new _Interval({ invalid });
    }
  }
  /**
   * Create an Interval from a start DateTime and an end DateTime. Inclusive of the start but not the end.
   * @param {DateTime|Date|Object} start
   * @param {DateTime|Date|Object} end
   * @return {Interval}
   */
  static fromDateTimes(start, end) {
    const builtStart = friendlyDateTime(start),
      builtEnd = friendlyDateTime(end);
    const validateError = validateStartEnd(builtStart, builtEnd);
    if (validateError == null) {
      return new _Interval({
        start: builtStart,
        end: builtEnd,
      });
    } else {
      return validateError;
    }
  }
  /**
   * Create an Interval from a start DateTime and a Duration to extend to.
   * @param {DateTime|Date|Object} start
   * @param {Duration|Object|number} duration - the length of the Interval.
   * @return {Interval}
   */
  static after(start, duration) {
    const dur = Duration.fromDurationLike(duration),
      dt = friendlyDateTime(start);
    return _Interval.fromDateTimes(dt, dt.plus(dur));
  }
  /**
   * Create an Interval from an end DateTime and a Duration to extend backwards to.
   * @param {DateTime|Date|Object} end
   * @param {Duration|Object|number} duration - the length of the Interval.
   * @return {Interval}
   */
  static before(end, duration) {
    const dur = Duration.fromDurationLike(duration),
      dt = friendlyDateTime(end);
    return _Interval.fromDateTimes(dt.minus(dur), dt);
  }
  /**
   * Create an Interval from an ISO 8601 string.
   * Accepts `<start>/<end>`, `<start>/<duration>`, and `<duration>/<end>` formats.
   * @param {string} text - the ISO string to parse
   * @param {Object} [opts] - options to pass {@link DateTime#fromISO} and optionally {@link Duration#fromISO}
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @return {Interval}
   */
  static fromISO(text, opts) {
    const [s2, e] = (text || "").split("/", 2);
    if (s2 && e) {
      let start, startIsValid;
      try {
        start = DateTime.fromISO(s2, opts);
        startIsValid = start.isValid;
      } catch (e2) {
        startIsValid = false;
      }
      let end, endIsValid;
      try {
        end = DateTime.fromISO(e, opts);
        endIsValid = end.isValid;
      } catch (e2) {
        endIsValid = false;
      }
      if (startIsValid && endIsValid) {
        return _Interval.fromDateTimes(start, end);
      }
      if (startIsValid) {
        const dur = Duration.fromISO(e, opts);
        if (dur.isValid) {
          return _Interval.after(start, dur);
        }
      } else if (endIsValid) {
        const dur = Duration.fromISO(s2, opts);
        if (dur.isValid) {
          return _Interval.before(end, dur);
        }
      }
    }
    return _Interval.invalid(
      "unparsable",
      `the input "${text}" can't be parsed as ISO 8601`
    );
  }
  /**
   * Check if an object is an Interval. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isInterval(o) {
    return (o && o.isLuxonInterval) || false;
  }
  /**
   * Returns the start of the Interval
   * @type {DateTime}
   */
  get start() {
    return this.isValid ? this.s : null;
  }
  /**
   * Returns the end of the Interval
   * @type {DateTime}
   */
  get end() {
    return this.isValid ? this.e : null;
  }
  /**
   * Returns whether this Interval's end is at least its start, meaning that the Interval isn't 'backwards'.
   * @type {boolean}
   */
  get isValid() {
    return this.invalidReason === null;
  }
  /**
   * Returns an error code if this Interval is invalid, or null if the Interval is valid
   * @type {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  /**
   * Returns an explanation of why this Interval became invalid, or null if the Interval is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  /**
   * Returns the length of the Interval in the specified unit.
   * @param {string} unit - the unit (such as 'hours' or 'days') to return the length in.
   * @return {number}
   */
  length(unit = "milliseconds") {
    return this.isValid ? this.toDuration(...[unit]).get(unit) : NaN;
  }
  /**
   * Returns the count of minutes, hours, days, months, or years included in the Interval, even in part.
   * Unlike {@link Interval#length} this counts sections of the calendar, not periods of time, e.g. specifying 'day'
   * asks 'what dates are included in this interval?', not 'how many days long is this interval?'
   * @param {string} [unit='milliseconds'] - the unit of time to count.
   * @return {number}
   */
  count(unit = "milliseconds") {
    if (!this.isValid) return NaN;
    const start = this.start.startOf(unit),
      end = this.end.startOf(unit);
    return Math.floor(end.diff(start, unit).get(unit)) + 1;
  }
  /**
   * Returns whether this Interval's start and end are both in the same unit of time
   * @param {string} unit - the unit of time to check sameness on
   * @return {boolean}
   */
  hasSame(unit) {
    return this.isValid
      ? this.isEmpty() || this.e.minus(1).hasSame(this.s, unit)
      : false;
  }
  /**
   * Return whether this Interval has the same start and end DateTimes.
   * @return {boolean}
   */
  isEmpty() {
    return this.s.valueOf() === this.e.valueOf();
  }
  /**
   * Return whether this Interval's start is after the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  isAfter(dateTime) {
    if (!this.isValid) return false;
    return this.s > dateTime;
  }
  /**
   * Return whether this Interval's end is before the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  isBefore(dateTime) {
    if (!this.isValid) return false;
    return this.e <= dateTime;
  }
  /**
   * Return whether this Interval contains the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  contains(dateTime) {
    if (!this.isValid) return false;
    return this.s <= dateTime && this.e > dateTime;
  }
  /**
   * "Sets" the start and/or end dates. Returns a newly-constructed Interval.
   * @param {Object} values - the values to set
   * @param {DateTime} values.start - the starting DateTime
   * @param {DateTime} values.end - the ending DateTime
   * @return {Interval}
   */
  set({ start, end } = {}) {
    if (!this.isValid) return this;
    return _Interval.fromDateTimes(start || this.s, end || this.e);
  }
  /**
   * Split this Interval at each of the specified DateTimes
   * @param {...DateTime} dateTimes - the unit of time to count.
   * @return {Array}
   */
  splitAt(...dateTimes) {
    if (!this.isValid) return [];
    const sorted = dateTimes
        .map(friendlyDateTime)
        .filter((d) => this.contains(d))
        .sort(),
      results = [];
    let { s: s2 } = this,
      i = 0;
    while (s2 < this.e) {
      const added = sorted[i] || this.e,
        next = +added > +this.e ? this.e : added;
      results.push(_Interval.fromDateTimes(s2, next));
      s2 = next;
      i += 1;
    }
    return results;
  }
  /**
   * Split this Interval into smaller Intervals, each of the specified length.
   * Left over time is grouped into a smaller interval
   * @param {Duration|Object|number} duration - The length of each resulting interval.
   * @return {Array}
   */
  splitBy(duration) {
    const dur = Duration.fromDurationLike(duration);
    if (!this.isValid || !dur.isValid || dur.as("milliseconds") === 0) {
      return [];
    }
    let { s: s2 } = this,
      idx = 1,
      next;
    const results = [];
    while (s2 < this.e) {
      const added = this.start.plus(dur.mapUnits((x) => x * idx));
      next = +added > +this.e ? this.e : added;
      results.push(_Interval.fromDateTimes(s2, next));
      s2 = next;
      idx += 1;
    }
    return results;
  }
  /**
   * Split this Interval into the specified number of smaller intervals.
   * @param {number} numberOfParts - The number of Intervals to divide the Interval into.
   * @return {Array}
   */
  divideEqually(numberOfParts) {
    if (!this.isValid) return [];
    return this.splitBy(this.length() / numberOfParts).slice(0, numberOfParts);
  }
  /**
   * Return whether this Interval overlaps with the specified Interval
   * @param {Interval} other
   * @return {boolean}
   */
  overlaps(other) {
    return this.e > other.s && this.s < other.e;
  }
  /**
   * Return whether this Interval's end is adjacent to the specified Interval's start.
   * @param {Interval} other
   * @return {boolean}
   */
  abutsStart(other) {
    if (!this.isValid) return false;
    return +this.e === +other.s;
  }
  /**
   * Return whether this Interval's start is adjacent to the specified Interval's end.
   * @param {Interval} other
   * @return {boolean}
   */
  abutsEnd(other) {
    if (!this.isValid) return false;
    return +other.e === +this.s;
  }
  /**
   * Return whether this Interval engulfs the start and end of the specified Interval.
   * @param {Interval} other
   * @return {boolean}
   */
  engulfs(other) {
    if (!this.isValid) return false;
    return this.s <= other.s && this.e >= other.e;
  }
  /**
   * Return whether this Interval has the same start and end as the specified Interval.
   * @param {Interval} other
   * @return {boolean}
   */
  equals(other) {
    if (!this.isValid || !other.isValid) {
      return false;
    }
    return this.s.equals(other.s) && this.e.equals(other.e);
  }
  /**
   * Return an Interval representing the intersection of this Interval and the specified Interval.
   * Specifically, the resulting Interval has the maximum start time and the minimum end time of the two Intervals.
   * Returns null if the intersection is empty, meaning, the intervals don't intersect.
   * @param {Interval} other
   * @return {Interval}
   */
  intersection(other) {
    if (!this.isValid) return this;
    const s2 = this.s > other.s ? this.s : other.s,
      e = this.e < other.e ? this.e : other.e;
    if (s2 >= e) {
      return null;
    } else {
      return _Interval.fromDateTimes(s2, e);
    }
  }
  /**
   * Return an Interval representing the union of this Interval and the specified Interval.
   * Specifically, the resulting Interval has the minimum start time and the maximum end time of the two Intervals.
   * @param {Interval} other
   * @return {Interval}
   */
  union(other) {
    if (!this.isValid) return this;
    const s2 = this.s < other.s ? this.s : other.s,
      e = this.e > other.e ? this.e : other.e;
    return _Interval.fromDateTimes(s2, e);
  }
  /**
   * Merge an array of Intervals into a equivalent minimal set of Intervals.
   * Combines overlapping and adjacent Intervals.
   * @param {Array} intervals
   * @return {Array}
   */
  static merge(intervals) {
    const [found, final] = intervals
      .sort((a, b) => a.s - b.s)
      .reduce(
        ([sofar, current], item) => {
          if (!current) {
            return [sofar, item];
          } else if (current.overlaps(item) || current.abutsStart(item)) {
            return [sofar, current.union(item)];
          } else {
            return [sofar.concat([current]), item];
          }
        },
        [[], null]
      );
    if (final) {
      found.push(final);
    }
    return found;
  }
  /**
   * Return an array of Intervals representing the spans of time that only appear in one of the specified Intervals.
   * @param {Array} intervals
   * @return {Array}
   */
  static xor(intervals) {
    let start = null,
      currentCount = 0;
    const results = [],
      ends = intervals.map((i) => [
        { time: i.s, type: "s" },
        { time: i.e, type: "e" },
      ]),
      flattened = Array.prototype.concat(...ends),
      arr = flattened.sort((a, b) => a.time - b.time);
    for (const i of arr) {
      currentCount += i.type === "s" ? 1 : -1;
      if (currentCount === 1) {
        start = i.time;
      } else {
        if (start && +start !== +i.time) {
          results.push(_Interval.fromDateTimes(start, i.time));
        }
        start = null;
      }
    }
    return _Interval.merge(results);
  }
  /**
   * Return an Interval representing the span of time in this Interval that doesn't overlap with any of the specified Intervals.
   * @param {...Interval} intervals
   * @return {Array}
   */
  difference(...intervals) {
    return _Interval
      .xor([this].concat(intervals))
      .map((i) => this.intersection(i))
      .filter((i) => i && !i.isEmpty());
  }
  /**
   * Returns a string representation of this Interval appropriate for debugging.
   * @return {string}
   */
  toString() {
    if (!this.isValid) return INVALID2;
    return `[${this.s.toISO()}  ${this.e.toISO()})`;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Interval.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @param {Object} opts - The same options as {@link DateTime#toISO}
   * @return {string}
   */
  toISO(opts) {
    if (!this.isValid) return INVALID2;
    return `${this.s.toISO(opts)}/${this.e.toISO(opts)}`;
  }
  /**
   * Returns an ISO 8601-compliant string representation of date of this Interval.
   * The time components are ignored.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @return {string}
   */
  toISODate() {
    if (!this.isValid) return INVALID2;
    return `${this.s.toISODate()}/${this.e.toISODate()}`;
  }
  /**
   * Returns an ISO 8601-compliant string representation of time of this Interval.
   * The date components are ignored.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @param {Object} opts - The same options as {@link DateTime#toISO}
   * @return {string}
   */
  toISOTime(opts) {
    if (!this.isValid) return INVALID2;
    return `${this.s.toISOTime(opts)}/${this.e.toISOTime(opts)}`;
  }
  /**
   * Returns a string representation of this Interval formatted according to the specified format string.
   * @param {string} dateFormat - the format string. This string formats the start and end time. See {@link DateTime#toFormat} for details.
   * @param {Object} opts - options
   * @param {string} [opts.separator =  '  '] - a separator to place between the start and end representations
   * @return {string}
   */
  toFormat(dateFormat, { separator = "  " } = {}) {
    if (!this.isValid) return INVALID2;
    return `${this.s.toFormat(dateFormat)}${separator}${this.e.toFormat(
      dateFormat
    )}`;
  }
  /**
   * Return a Duration representing the time spanned by this interval.
   * @param {string|string[]} [unit=['milliseconds']] - the unit or units (such as 'hours' or 'days') to include in the duration.
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @example Interval.fromDateTimes(dt1, dt2).toDuration().toObject() //=> { milliseconds: 88489257 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration('days').toObject() //=> { days: 1.0241812152777778 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes']).toObject() //=> { hours: 24, minutes: 34.82095 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes', 'seconds']).toObject() //=> { hours: 24, minutes: 34, seconds: 49.257 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration('seconds').toObject() //=> { seconds: 88489.257 }
   * @return {Duration}
   */
  toDuration(unit, opts) {
    if (!this.isValid) {
      return Duration.invalid(this.invalidReason);
    }
    return this.e.diff(this.s, unit, opts);
  }
  /**
   * Run mapFn on the interval start and end, returning a new Interval from the resulting DateTimes
   * @param {function} mapFn
   * @return {Interval}
   * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.toUTC())
   * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.plus({ hours: 2 }))
   */
  mapEndpoints(mapFn) {
    return _Interval.fromDateTimes(mapFn(this.s), mapFn(this.e));
  }
};

// node_modules/luxon/src/info.js
var Info = class {
  /**
   * Return whether the specified zone contains a DST.
   * @param {string|Zone} [zone='local'] - Zone to check. Defaults to the environment's local zone.
   * @return {boolean}
   */
  static hasDST(zone = Settings.defaultZone) {
    const proto = DateTime.now().setZone(zone).set({ month: 12 });
    return !zone.isUniversal && proto.offset !== proto.set({ month: 6 }).offset;
  }
  /**
   * Return whether the specified zone is a valid IANA specifier.
   * @param {string} zone - Zone to check
   * @return {boolean}
   */
  static isValidIANAZone(zone) {
    return IANAZone.isValidZone(zone);
  }
  /**
   * Converts the input into a {@link Zone} instance.
   *
   * * If `input` is already a Zone instance, it is returned unchanged.
   * * If `input` is a string containing a valid time zone name, a Zone instance
   *   with that name is returned.
   * * If `input` is a string that doesn't refer to a known time zone, a Zone
   *   instance with {@link Zone#isValid} == false is returned.
   * * If `input is a number, a Zone instance with the specified fixed offset
   *   in minutes is returned.
   * * If `input` is `null` or `undefined`, the default zone is returned.
   * @param {string|Zone|number} [input] - the value to be converted
   * @return {Zone}
   */
  static normalizeZone(input) {
    return normalizeZone(input, Settings.defaultZone);
  }
  /**
   * Return an array of standalone month names.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @param {string} [opts.outputCalendar='gregory'] - the calendar
   * @example Info.months()[0] //=> 'January'
   * @example Info.months('short')[0] //=> 'Jan'
   * @example Info.months('numeric')[0] //=> '1'
   * @example Info.months('short', { locale: 'fr-CA' } )[0] //=> 'janv.'
   * @example Info.months('numeric', { locale: 'ar' })[0] //=> ''
   * @example Info.months('long', { outputCalendar: 'islamic' })[0] //=> 'Rabi I'
   * @return {Array}
   */
  static months(
    length = "long",
    {
      locale = null,
      numberingSystem = null,
      locObj = null,
      outputCalendar = "gregory",
    } = {}
  ) {
    return (
      locObj || Locale.create(locale, numberingSystem, outputCalendar)
    ).months(length);
  }
  /**
   * Return an array of format month names.
   * Format months differ from standalone months in that they're meant to appear next to the day of the month. In some languages, that
   * changes the string.
   * See {@link Info#months}
   * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @param {string} [opts.outputCalendar='gregory'] - the calendar
   * @return {Array}
   */
  static monthsFormat(
    length = "long",
    {
      locale = null,
      numberingSystem = null,
      locObj = null,
      outputCalendar = "gregory",
    } = {}
  ) {
    return (
      locObj || Locale.create(locale, numberingSystem, outputCalendar)
    ).months(length, true);
  }
  /**
   * Return an array of standalone week names.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {string} [length='long'] - the length of the weekday representation, such as "narrow", "short", "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @example Info.weekdays()[0] //=> 'Monday'
   * @example Info.weekdays('short')[0] //=> 'Mon'
   * @example Info.weekdays('short', { locale: 'fr-CA' })[0] //=> 'lun.'
   * @example Info.weekdays('short', { locale: 'ar' })[0] //=> ''
   * @return {Array}
   */
  static weekdays(
    length = "long",
    { locale = null, numberingSystem = null, locObj = null } = {}
  ) {
    return (locObj || Locale.create(locale, numberingSystem, null)).weekdays(
      length
    );
  }
  /**
   * Return an array of format week names.
   * Format weekdays differ from standalone weekdays in that they're meant to appear next to more date information. In some languages, that
   * changes the string.
   * See {@link Info#weekdays}
   * @param {string} [length='long'] - the length of the month representation, such as "narrow", "short", "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale=null] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @return {Array}
   */
  static weekdaysFormat(
    length = "long",
    { locale = null, numberingSystem = null, locObj = null } = {}
  ) {
    return (locObj || Locale.create(locale, numberingSystem, null)).weekdays(
      length,
      true
    );
  }
  /**
   * Return an array of meridiems.
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @example Info.meridiems() //=> [ 'AM', 'PM' ]
   * @example Info.meridiems({ locale: 'my' }) //=> [ '', '' ]
   * @return {Array}
   */
  static meridiems({ locale = null } = {}) {
    return Locale.create(locale).meridiems();
  }
  /**
   * Return an array of eras, such as ['BC', 'AD']. The locale can be specified, but the calendar system is always Gregorian.
   * @param {string} [length='short'] - the length of the era representation, such as "short" or "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @example Info.eras() //=> [ 'BC', 'AD' ]
   * @example Info.eras('long') //=> [ 'Before Christ', 'Anno Domini' ]
   * @example Info.eras('long', { locale: 'fr' }) //=> [ 'avant Jsus-Christ', 'aprs Jsus-Christ' ]
   * @return {Array}
   */
  static eras(length = "short", { locale = null } = {}) {
    return Locale.create(locale, null, "gregory").eras(length);
  }
  /**
   * Return the set of available features in this environment.
   * Some features of Luxon are not available in all environments. For example, on older browsers, relative time formatting support is not available. Use this function to figure out if that's the case.
   * Keys:
   * * `relative`: whether this environment supports relative time formatting
   * @example Info.features() //=> { relative: false }
   * @return {Object}
   */
  static features() {
    return { relative: hasRelative() };
  }
};

// node_modules/luxon/src/impl/diff.js
function dayDiff(earlier, later) {
  const utcDayStart = (dt) =>
      dt.toUTC(0, { keepLocalTime: true }).startOf("day").valueOf(),
    ms = utcDayStart(later) - utcDayStart(earlier);
  return Math.floor(Duration.fromMillis(ms).as("days"));
}
function highOrderDiffs(cursor, later, units) {
  const differs = [
    ["years", (a, b) => b.year - a.year],
    ["quarters", (a, b) => b.quarter - a.quarter],
    ["months", (a, b) => b.month - a.month + (b.year - a.year) * 12],
    [
      "weeks",
      (a, b) => {
        const days = dayDiff(a, b);
        return (days - (days % 7)) / 7;
      },
    ],
    ["days", dayDiff],
  ];
  const results = {};
  let lowestOrder, highWater;
  for (const [unit, differ] of differs) {
    if (units.indexOf(unit) >= 0) {
      lowestOrder = unit;
      let delta = differ(cursor, later);
      highWater = cursor.plus({ [unit]: delta });
      if (highWater > later) {
        cursor = cursor.plus({ [unit]: delta - 1 });
        delta -= 1;
      } else {
        cursor = highWater;
      }
      results[unit] = delta;
    }
  }
  return [cursor, results, highWater, lowestOrder];
}
function diff_default(earlier, later, units, opts) {
  let [cursor, results, highWater, lowestOrder] = highOrderDiffs(
    earlier,
    later,
    units
  );
  const remainingMillis = later - cursor;
  const lowerOrderUnits = units.filter(
    (u) => ["hours", "minutes", "seconds", "milliseconds"].indexOf(u) >= 0
  );
  if (lowerOrderUnits.length === 0) {
    if (highWater < later) {
      highWater = cursor.plus({ [lowestOrder]: 1 });
    }
    if (highWater !== cursor) {
      results[lowestOrder] =
        (results[lowestOrder] || 0) + remainingMillis / (highWater - cursor);
    }
  }
  const duration = Duration.fromObject(results, opts);
  if (lowerOrderUnits.length > 0) {
    return Duration.fromMillis(remainingMillis, opts)
      .shiftTo(...lowerOrderUnits)
      .plus(duration);
  } else {
    return duration;
  }
}

// node_modules/luxon/src/impl/digits.js
var numberingSystems = {
  arab: "[-]",
  arabext: "[-]",
  bali: "[-]",
  beng: "[-]",
  deva: "[-]",
  fullwide: "[-]",
  gujr: "[-]",
  hanidec: "[|||||||||]",
  khmr: "[-]",
  knda: "[-]",
  laoo: "[-]",
  limb: "[-]",
  mlym: "[-]",
  mong: "[-]",
  mymr: "[-]",
  orya: "[-]",
  tamldec: "[-]",
  telu: "[-]",
  thai: "[-]",
  tibt: "[-]",
  latn: "\\d",
};
var numberingSystemsUTF16 = {
  arab: [1632, 1641],
  arabext: [1776, 1785],
  bali: [6992, 7001],
  beng: [2534, 2543],
  deva: [2406, 2415],
  fullwide: [65296, 65303],
  gujr: [2790, 2799],
  khmr: [6112, 6121],
  knda: [3302, 3311],
  laoo: [3792, 3801],
  limb: [6470, 6479],
  mlym: [3430, 3439],
  mong: [6160, 6169],
  mymr: [4160, 4169],
  orya: [2918, 2927],
  tamldec: [3046, 3055],
  telu: [3174, 3183],
  thai: [3664, 3673],
  tibt: [3872, 3881],
};
var hanidecChars = numberingSystems.hanidec.replace(/[\[|\]]/g, "").split("");
function parseDigits(str) {
  let value = parseInt(str, 10);
  if (isNaN(value)) {
    value = "";
    for (let i = 0; i < str.length; i++) {
      const code = str.charCodeAt(i);
      if (str[i].search(numberingSystems.hanidec) !== -1) {
        value += hanidecChars.indexOf(str[i]);
      } else {
        for (const key in numberingSystemsUTF16) {
          const [min, max] = numberingSystemsUTF16[key];
          if (code >= min && code <= max) {
            value += code - min;
          }
        }
      }
    }
    return parseInt(value, 10);
  } else {
    return value;
  }
}
function digitRegex({ numberingSystem }, append = "") {
  return new RegExp(`${numberingSystems[numberingSystem || "latn"]}${append}`);
}

// node_modules/luxon/src/impl/tokenParser.js
var MISSING_FTP = "missing Intl.DateTimeFormat.formatToParts support";
function intUnit(regex, post = (i) => i) {
  return { regex, deser: ([s2]) => post(parseDigits(s2)) };
}
var NBSP = String.fromCharCode(160);
var spaceOrNBSP = `( |${NBSP})`;
var spaceOrNBSPRegExp = new RegExp(spaceOrNBSP, "g");
function fixListRegex(s2) {
  return s2.replace(/\./g, "\\.?").replace(spaceOrNBSPRegExp, spaceOrNBSP);
}
function stripInsensitivities(s2) {
  return s2.replace(/\./g, "").replace(spaceOrNBSPRegExp, " ").toLowerCase();
}
function oneOf(strings, startIndex) {
  if (strings === null) {
    return null;
  } else {
    return {
      regex: RegExp(strings.map(fixListRegex).join("|")),
      deser: ([s2]) =>
        strings.findIndex(
          (i) => stripInsensitivities(s2) === stripInsensitivities(i)
        ) + startIndex,
    };
  }
}
function offset$2(regex, groups) {
  return { regex, deser: ([, h, m]) => signedOffset(h, m), groups };
}
function simple(regex) {
  return { regex, deser: ([s2]) => s2 };
}
function escapeToken(value) {
  return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
}
function unitForToken(token, loc) {
  const one = digitRegex(loc),
    two = digitRegex(loc, "{2}"),
    three = digitRegex(loc, "{3}"),
    four = digitRegex(loc, "{4}"),
    six = digitRegex(loc, "{6}"),
    oneOrTwo = digitRegex(loc, "{1,2}"),
    oneToThree = digitRegex(loc, "{1,3}"),
    oneToSix = digitRegex(loc, "{1,6}"),
    oneToNine = digitRegex(loc, "{1,9}"),
    twoToFour = digitRegex(loc, "{2,4}"),
    fourToSix = digitRegex(loc, "{4,6}"),
    literal = (t) => ({
      regex: RegExp(escapeToken(t.val)),
      deser: ([s2]) => s2,
      literal: true,
    }),
    unitate = (t) => {
      if (token.literal) {
        return literal(t);
      }
      switch (t.val) {
        case "G":
          return oneOf(loc.eras("short", false), 0);
        case "GG":
          return oneOf(loc.eras("long", false), 0);
        case "y":
          return intUnit(oneToSix);
        case "yy":
          return intUnit(twoToFour, untruncateYear);
        case "yyyy":
          return intUnit(four);
        case "yyyyy":
          return intUnit(fourToSix);
        case "yyyyyy":
          return intUnit(six);
        case "M":
          return intUnit(oneOrTwo);
        case "MM":
          return intUnit(two);
        case "MMM":
          return oneOf(loc.months("short", true, false), 1);
        case "MMMM":
          return oneOf(loc.months("long", true, false), 1);
        case "L":
          return intUnit(oneOrTwo);
        case "LL":
          return intUnit(two);
        case "LLL":
          return oneOf(loc.months("short", false, false), 1);
        case "LLLL":
          return oneOf(loc.months("long", false, false), 1);
        case "d":
          return intUnit(oneOrTwo);
        case "dd":
          return intUnit(two);
        case "o":
          return intUnit(oneToThree);
        case "ooo":
          return intUnit(three);
        case "HH":
          return intUnit(two);
        case "H":
          return intUnit(oneOrTwo);
        case "hh":
          return intUnit(two);
        case "h":
          return intUnit(oneOrTwo);
        case "mm":
          return intUnit(two);
        case "m":
          return intUnit(oneOrTwo);
        case "q":
          return intUnit(oneOrTwo);
        case "qq":
          return intUnit(two);
        case "s":
          return intUnit(oneOrTwo);
        case "ss":
          return intUnit(two);
        case "S":
          return intUnit(oneToThree);
        case "SSS":
          return intUnit(three);
        case "u":
          return simple(oneToNine);
        case "uu":
          return simple(oneOrTwo);
        case "uuu":
          return intUnit(one);
        case "a":
          return oneOf(loc.meridiems(), 0);
        case "kkkk":
          return intUnit(four);
        case "kk":
          return intUnit(twoToFour, untruncateYear);
        case "W":
          return intUnit(oneOrTwo);
        case "WW":
          return intUnit(two);
        case "E":
        case "c":
          return intUnit(one);
        case "EEE":
          return oneOf(loc.weekdays("short", false, false), 1);
        case "EEEE":
          return oneOf(loc.weekdays("long", false, false), 1);
        case "ccc":
          return oneOf(loc.weekdays("short", true, false), 1);
        case "cccc":
          return oneOf(loc.weekdays("long", true, false), 1);
        case "Z":
        case "ZZ":
          return offset$2(
            new RegExp(`([+-]${oneOrTwo.source})(?::(${two.source}))?`),
            2
          );
        case "ZZZ":
          return offset$2(
            new RegExp(`([+-]${oneOrTwo.source})(${two.source})?`),
            2
          );
        case "z":
          return simple(/[a-z_+-/]{1,256}?/i);
        default:
          return literal(t);
      }
    };
  const unit = unitate(token) || {
    invalidReason: MISSING_FTP,
  };
  unit.token = token;
  return unit;
}
var partTypeStyleToTokenVal = {
  year: {
    "2-digit": "yy",
    numeric: "yyyyy",
  },
  month: {
    numeric: "M",
    "2-digit": "MM",
    short: "MMM",
    long: "MMMM",
  },
  day: {
    numeric: "d",
    "2-digit": "dd",
  },
  weekday: {
    short: "EEE",
    long: "EEEE",
  },
  dayperiod: "a",
  dayPeriod: "a",
  hour: {
    numeric: "h",
    "2-digit": "hh",
  },
  minute: {
    numeric: "m",
    "2-digit": "mm",
  },
  second: {
    numeric: "s",
    "2-digit": "ss",
  },
};
function tokenForPart(part, locale, formatOpts) {
  const { type, value } = part;
  if (type === "literal") {
    return {
      literal: true,
      val: value,
    };
  }
  const style = formatOpts[type];
  let val = partTypeStyleToTokenVal[type];
  if (typeof val === "object") {
    val = val[style];
  }
  if (val) {
    return {
      literal: false,
      val,
    };
  }
  return void 0;
}
function buildRegex(units) {
  const re = units
    .map((u) => u.regex)
    .reduce((f, r) => `${f}(${r.source})`, "");
  return [`^${re}$`, units];
}
function match$4(input, regex, handlers) {
  const matches = input.match(regex);
  if (matches) {
    const all = {};
    let matchIndex = 1;
    for (const i in handlers) {
      if (hasOwnProperty$4(handlers, i)) {
        const h = handlers[i],
          groups = h.groups ? h.groups + 1 : 1;
        if (!h.literal && h.token) {
          all[h.token.val[0]] = h.deser(
            matches.slice(matchIndex, matchIndex + groups)
          );
        }
        matchIndex += groups;
      }
    }
    return [matches, all];
  } else {
    return [matches, {}];
  }
}
function dateTimeFromMatches(matches) {
  const toField = (token) => {
    switch (token) {
      case "S":
        return "millisecond";
      case "s":
        return "second";
      case "m":
        return "minute";
      case "h":
      case "H":
        return "hour";
      case "d":
        return "day";
      case "o":
        return "ordinal";
      case "L":
      case "M":
        return "month";
      case "y":
        return "year";
      case "E":
      case "c":
        return "weekday";
      case "W":
        return "weekNumber";
      case "k":
        return "weekYear";
      case "q":
        return "quarter";
      default:
        return null;
    }
  };
  let zone = null;
  let specificOffset;
  if (!isUndefined(matches.z)) {
    zone = IANAZone.create(matches.z);
  }
  if (!isUndefined(matches.Z)) {
    if (!zone) {
      zone = new FixedOffsetZone(matches.Z);
    }
    specificOffset = matches.Z;
  }
  if (!isUndefined(matches.q)) {
    matches.M = (matches.q - 1) * 3 + 1;
  }
  if (!isUndefined(matches.h)) {
    if (matches.h < 12 && matches.a === 1) {
      matches.h += 12;
    } else if (matches.h === 12 && matches.a === 0) {
      matches.h = 0;
    }
  }
  if (matches.G === 0 && matches.y) {
    matches.y = -matches.y;
  }
  if (!isUndefined(matches.u)) {
    matches.S = parseMillis(matches.u);
  }
  const vals = Object.keys(matches).reduce((r, k) => {
    const f = toField(k);
    if (f) {
      r[f] = matches[k];
    }
    return r;
  }, {});
  return [vals, zone, specificOffset];
}
var dummyDateTimeCache = null;
function getDummyDateTime() {
  if (!dummyDateTimeCache) {
    dummyDateTimeCache = DateTime.fromMillis(1555555555555);
  }
  return dummyDateTimeCache;
}
function maybeExpandMacroToken(token, locale) {
  if (token.literal) {
    return token;
  }
  const formatOpts = Formatter.macroTokenToFormatOpts(token.val);
  if (!formatOpts) {
    return token;
  }
  const formatter = Formatter.create(locale, formatOpts);
  const parts = formatter.formatDateTimeParts(getDummyDateTime());
  const tokens = parts.map((p) => tokenForPart(p, locale, formatOpts));
  if (tokens.includes(void 0)) {
    return token;
  }
  return tokens;
}
function expandMacroTokens(tokens, locale) {
  return Array.prototype.concat(
    ...tokens.map((t) => maybeExpandMacroToken(t, locale))
  );
}
function explainFromTokens(locale, input, format) {
  const tokens = expandMacroTokens(Formatter.parseFormat(format), locale),
    units = tokens.map((t) => unitForToken(t, locale)),
    disqualifyingUnit = units.find((t) => t.invalidReason);
  if (disqualifyingUnit) {
    return { input, tokens, invalidReason: disqualifyingUnit.invalidReason };
  } else {
    const [regexString, handlers] = buildRegex(units),
      regex = RegExp(regexString, "i"),
      [rawMatches, matches] = match$4(input, regex, handlers),
      [result, zone, specificOffset] = matches
        ? dateTimeFromMatches(matches)
        : [null, null, void 0];
    if (hasOwnProperty$4(matches, "a") && hasOwnProperty$4(matches, "H")) {
      throw new ConflictingSpecificationError(
        "Can't include meridiem when specifying 24-hour format"
      );
    }
    return {
      input,
      tokens,
      regex,
      rawMatches,
      matches,
      result,
      zone,
      specificOffset,
    };
  }
}
function parseFromTokens(locale, input, format) {
  const { result, zone, specificOffset, invalidReason } = explainFromTokens(
    locale,
    input,
    format
  );
  return [result, zone, specificOffset, invalidReason];
}

// node_modules/luxon/src/impl/conversions.js
var nonLeapLadder = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
var leapLadder = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
function unitOutOfRange(unit, value) {
  return new Invalid(
    "unit out of range",
    `you specified ${value} (of type ${typeof value}) as a ${unit}, which is invalid`
  );
}
function dayOfWeek(year, month, day) {
  const js = new Date(Date.UTC(year, month - 1, day)).getUTCDay();
  return js === 0 ? 7 : js;
}
function computeOrdinal(year, month, day) {
  return day + (isLeapYear(year) ? leapLadder : nonLeapLadder)[month - 1];
}
function uncomputeOrdinal(year, ordinal) {
  const table = isLeapYear(year) ? leapLadder : nonLeapLadder,
    month0 = table.findIndex((i) => i < ordinal),
    day = ordinal - table[month0];
  return { month: month0 + 1, day };
}
function gregorianToWeek(gregObj) {
  const { year, month, day } = gregObj,
    ordinal = computeOrdinal(year, month, day),
    weekday = dayOfWeek(year, month, day);
  let weekNumber = Math.floor((ordinal - weekday + 10) / 7),
    weekYear;
  if (weekNumber < 1) {
    weekYear = year - 1;
    weekNumber = weeksInWeekYear(weekYear);
  } else if (weekNumber > weeksInWeekYear(year)) {
    weekYear = year + 1;
    weekNumber = 1;
  } else {
    weekYear = year;
  }
  return { weekYear, weekNumber, weekday, ...timeObject(gregObj) };
}
function weekToGregorian(weekData) {
  const { weekYear, weekNumber, weekday } = weekData,
    weekdayOfJan4 = dayOfWeek(weekYear, 1, 4),
    yearInDays = daysInYear(weekYear);
  let ordinal = weekNumber * 7 + weekday - weekdayOfJan4 - 3,
    year;
  if (ordinal < 1) {
    year = weekYear - 1;
    ordinal += daysInYear(year);
  } else if (ordinal > yearInDays) {
    year = weekYear + 1;
    ordinal -= daysInYear(weekYear);
  } else {
    year = weekYear;
  }
  const { month, day } = uncomputeOrdinal(year, ordinal);
  return { year, month, day, ...timeObject(weekData) };
}
function gregorianToOrdinal(gregData) {
  const { year, month, day } = gregData;
  const ordinal = computeOrdinal(year, month, day);
  return { year, ordinal, ...timeObject(gregData) };
}
function ordinalToGregorian(ordinalData) {
  const { year, ordinal } = ordinalData;
  const { month, day } = uncomputeOrdinal(year, ordinal);
  return { year, month, day, ...timeObject(ordinalData) };
}
function hasInvalidWeekData(obj) {
  const validYear = isInteger(obj.weekYear),
    validWeek = integerBetween(
      obj.weekNumber,
      1,
      weeksInWeekYear(obj.weekYear)
    ),
    validWeekday = integerBetween(obj.weekday, 1, 7);
  if (!validYear) {
    return unitOutOfRange("weekYear", obj.weekYear);
  } else if (!validWeek) {
    return unitOutOfRange("week", obj.week);
  } else if (!validWeekday) {
    return unitOutOfRange("weekday", obj.weekday);
  } else return false;
}
function hasInvalidOrdinalData(obj) {
  const validYear = isInteger(obj.year),
    validOrdinal = integerBetween(obj.ordinal, 1, daysInYear(obj.year));
  if (!validYear) {
    return unitOutOfRange("year", obj.year);
  } else if (!validOrdinal) {
    return unitOutOfRange("ordinal", obj.ordinal);
  } else return false;
}
function hasInvalidGregorianData(obj) {
  const validYear = isInteger(obj.year),
    validMonth = integerBetween(obj.month, 1, 12),
    validDay = integerBetween(obj.day, 1, daysInMonth(obj.year, obj.month));
  if (!validYear) {
    return unitOutOfRange("year", obj.year);
  } else if (!validMonth) {
    return unitOutOfRange("month", obj.month);
  } else if (!validDay) {
    return unitOutOfRange("day", obj.day);
  } else return false;
}
function hasInvalidTimeData(obj) {
  const { hour, minute, second, millisecond } = obj;
  const validHour =
      integerBetween(hour, 0, 23) ||
      (hour === 24 && minute === 0 && second === 0 && millisecond === 0),
    validMinute = integerBetween(minute, 0, 59),
    validSecond = integerBetween(second, 0, 59),
    validMillisecond = integerBetween(millisecond, 0, 999);
  if (!validHour) {
    return unitOutOfRange("hour", hour);
  } else if (!validMinute) {
    return unitOutOfRange("minute", minute);
  } else if (!validSecond) {
    return unitOutOfRange("second", second);
  } else if (!validMillisecond) {
    return unitOutOfRange("millisecond", millisecond);
  } else return false;
}

// node_modules/luxon/src/datetime.js
var INVALID3 = "Invalid DateTime";
var MAX_DATE = 864e13;
function unsupportedZone(zone) {
  return new Invalid(
    "unsupported zone",
    `the zone "${zone.name}" is not supported`
  );
}
function possiblyCachedWeekData(dt) {
  if (dt.weekData === null) {
    dt.weekData = gregorianToWeek(dt.c);
  }
  return dt.weekData;
}
function clone2(inst, alts) {
  const current = {
    ts: inst.ts,
    zone: inst.zone,
    c: inst.c,
    o: inst.o,
    loc: inst.loc,
    invalid: inst.invalid,
  };
  return new DateTime({ ...current, ...alts, old: current });
}
function fixOffset(localTS, o, tz) {
  let utcGuess = localTS - o * 60 * 1e3;
  const o2 = tz.offset(utcGuess);
  if (o === o2) {
    return [utcGuess, o];
  }
  utcGuess -= (o2 - o) * 60 * 1e3;
  const o3 = tz.offset(utcGuess);
  if (o2 === o3) {
    return [utcGuess, o2];
  }
  return [localTS - Math.min(o2, o3) * 60 * 1e3, Math.max(o2, o3)];
}
function tsToObj(ts, offset2) {
  ts += offset2 * 60 * 1e3;
  const d = new Date(ts);
  return {
    year: d.getUTCFullYear(),
    month: d.getUTCMonth() + 1,
    day: d.getUTCDate(),
    hour: d.getUTCHours(),
    minute: d.getUTCMinutes(),
    second: d.getUTCSeconds(),
    millisecond: d.getUTCMilliseconds(),
  };
}
function objToTS(obj, offset2, zone) {
  return fixOffset(objToLocalTS(obj), offset2, zone);
}
function adjustTime(inst, dur) {
  const oPre = inst.o,
    year = inst.c.year + Math.trunc(dur.years),
    month =
      inst.c.month + Math.trunc(dur.months) + Math.trunc(dur.quarters) * 3,
    c = {
      ...inst.c,
      year,
      month,
      day:
        Math.min(inst.c.day, daysInMonth(year, month)) +
        Math.trunc(dur.days) +
        Math.trunc(dur.weeks) * 7,
    },
    millisToAdd = Duration.fromObject({
      years: dur.years - Math.trunc(dur.years),
      quarters: dur.quarters - Math.trunc(dur.quarters),
      months: dur.months - Math.trunc(dur.months),
      weeks: dur.weeks - Math.trunc(dur.weeks),
      days: dur.days - Math.trunc(dur.days),
      hours: dur.hours,
      minutes: dur.minutes,
      seconds: dur.seconds,
      milliseconds: dur.milliseconds,
    }).as("milliseconds"),
    localTS = objToLocalTS(c);
  let [ts, o] = fixOffset(localTS, oPre, inst.zone);
  if (millisToAdd !== 0) {
    ts += millisToAdd;
    o = inst.zone.offset(ts);
  }
  return { ts, o };
}
function parseDataToDateTime(
  parsed,
  parsedZone,
  opts,
  format,
  text,
  specificOffset
) {
  const { setZone, zone } = opts;
  if (parsed && Object.keys(parsed).length !== 0) {
    const interpretationZone = parsedZone || zone,
      inst = DateTime.fromObject(parsed, {
        ...opts,
        zone: interpretationZone,
        specificOffset,
      });
    return setZone ? inst : inst.setZone(zone);
  } else {
    return DateTime.invalid(
      new Invalid(
        "unparsable",
        `the input "${text}" can't be parsed as ${format}`
      )
    );
  }
}
function toTechFormat(dt, format, allowZ = true) {
  return dt.isValid
    ? Formatter.create(Locale.create("en-US"), {
        allowZ,
        forceSimple: true,
      }).formatDateTimeFromString(dt, format)
    : null;
}
function toISODate(o, extended) {
  const longFormat = o.c.year > 9999 || o.c.year < 0;
  let c = "";
  if (longFormat && o.c.year >= 0) c += "+";
  c += padStart(o.c.year, longFormat ? 6 : 4);
  if (extended) {
    c += "-";
    c += padStart(o.c.month);
    c += "-";
    c += padStart(o.c.day);
  } else {
    c += padStart(o.c.month);
    c += padStart(o.c.day);
  }
  return c;
}
function toISOTime(
  o,
  extended,
  suppressSeconds,
  suppressMilliseconds,
  includeOffset
) {
  let c = padStart(o.c.hour);
  if (extended) {
    c += ":";
    c += padStart(o.c.minute);
    if (o.c.second !== 0 || !suppressSeconds) {
      c += ":";
    }
  } else {
    c += padStart(o.c.minute);
  }
  if (o.c.second !== 0 || !suppressSeconds) {
    c += padStart(o.c.second);
    if (o.c.millisecond !== 0 || !suppressMilliseconds) {
      c += ".";
      c += padStart(o.c.millisecond, 3);
    }
  }
  if (includeOffset) {
    if (o.isOffsetFixed && o.offset === 0) {
      c += "Z";
    } else if (o.o < 0) {
      c += "-";
      c += padStart(Math.trunc(-o.o / 60));
      c += ":";
      c += padStart(Math.trunc(-o.o % 60));
    } else {
      c += "+";
      c += padStart(Math.trunc(o.o / 60));
      c += ":";
      c += padStart(Math.trunc(o.o % 60));
    }
  }
  return c;
}
var defaultUnitValues = {
  month: 1,
  day: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0,
};
var defaultWeekUnitValues = {
  weekNumber: 1,
  weekday: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0,
};
var defaultOrdinalUnitValues = {
  ordinal: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0,
};
var orderedUnits2 = [
  "year",
  "month",
  "day",
  "hour",
  "minute",
  "second",
  "millisecond",
];
var orderedWeekUnits = [
  "weekYear",
  "weekNumber",
  "weekday",
  "hour",
  "minute",
  "second",
  "millisecond",
];
var orderedOrdinalUnits = [
  "year",
  "ordinal",
  "hour",
  "minute",
  "second",
  "millisecond",
];
function normalizeUnit(unit) {
  const normalized = {
    year: "year",
    years: "year",
    month: "month",
    months: "month",
    day: "day",
    days: "day",
    hour: "hour",
    hours: "hour",
    minute: "minute",
    minutes: "minute",
    quarter: "quarter",
    quarters: "quarter",
    second: "second",
    seconds: "second",
    millisecond: "millisecond",
    milliseconds: "millisecond",
    weekday: "weekday",
    weekdays: "weekday",
    weeknumber: "weekNumber",
    weeksnumber: "weekNumber",
    weeknumbers: "weekNumber",
    weekyear: "weekYear",
    weekyears: "weekYear",
    ordinal: "ordinal",
  }[unit.toLowerCase()];
  if (!normalized) throw new InvalidUnitError(unit);
  return normalized;
}
function quickDT(obj, opts) {
  const zone = normalizeZone(opts.zone, Settings.defaultZone),
    loc = Locale.fromObject(opts),
    tsNow = Settings.now();
  let ts, o;
  if (!isUndefined(obj.year)) {
    for (const u of orderedUnits2) {
      if (isUndefined(obj[u])) {
        obj[u] = defaultUnitValues[u];
      }
    }
    const invalid = hasInvalidGregorianData(obj) || hasInvalidTimeData(obj);
    if (invalid) {
      return DateTime.invalid(invalid);
    }
    const offsetProvis = zone.offset(tsNow);
    [ts, o] = objToTS(obj, offsetProvis, zone);
  } else {
    ts = tsNow;
  }
  return new DateTime({ ts, zone, loc, o });
}
function diffRelative(start, end, opts) {
  const round = isUndefined(opts.round) ? true : opts.round,
    format = (c, unit) => {
      c = roundTo(c, round || opts.calendary ? 0 : 2, true);
      const formatter = end.loc.clone(opts).relFormatter(opts);
      return formatter.format(c, unit);
    },
    differ = (unit) => {
      if (opts.calendary) {
        if (!end.hasSame(start, unit)) {
          return end.startOf(unit).diff(start.startOf(unit), unit).get(unit);
        } else return 0;
      } else {
        return end.diff(start, unit).get(unit);
      }
    };
  if (opts.unit) {
    return format(differ(opts.unit), opts.unit);
  }
  for (const unit of opts.units) {
    const count = differ(unit);
    if (Math.abs(count) >= 1) {
      return format(count, unit);
    }
  }
  return format(start > end ? -0 : 0, opts.units[opts.units.length - 1]);
}
function lastOpts(argList) {
  let opts = {},
    args;
  if (argList.length > 0 && typeof argList[argList.length - 1] === "object") {
    opts = argList[argList.length - 1];
    args = Array.from(argList).slice(0, argList.length - 1);
  } else {
    args = Array.from(argList);
  }
  return [opts, args];
}
var DateTime = class _DateTime {
  /**
   * @access private
   */
  constructor(config) {
    const zone = config.zone || Settings.defaultZone;
    let invalid =
      config.invalid ||
      (Number.isNaN(config.ts) ? new Invalid("invalid input") : null) ||
      (!zone.isValid ? unsupportedZone(zone) : null);
    this.ts = isUndefined(config.ts) ? Settings.now() : config.ts;
    let c = null,
      o = null;
    if (!invalid) {
      const unchanged =
        config.old && config.old.ts === this.ts && config.old.zone.equals(zone);
      if (unchanged) {
        [c, o] = [config.old.c, config.old.o];
      } else {
        const ot = zone.offset(this.ts);
        c = tsToObj(this.ts, ot);
        invalid = Number.isNaN(c.year) ? new Invalid("invalid input") : null;
        c = invalid ? null : c;
        o = invalid ? null : ot;
      }
    }
    this._zone = zone;
    this.loc = config.loc || Locale.create();
    this.invalid = invalid;
    this.weekData = null;
    this.c = c;
    this.o = o;
    this.isLuxonDateTime = true;
  }
  // CONSTRUCT
  /**
   * Create a DateTime for the current instant, in the system's time zone.
   *
   * Use Settings to override these default values if needed.
   * @example DateTime.now().toISO() //~> now in the ISO format
   * @return {DateTime}
   */
  static now() {
    return new _DateTime({});
  }
  /**
   * Create a local DateTime
   * @param {number} [year] - The calendar year. If omitted (as in, call `local()` with no arguments), the current time will be used
   * @param {number} [month=1] - The month, 1-indexed
   * @param {number} [day=1] - The day of the month, 1-indexed
   * @param {number} [hour=0] - The hour of the day, in 24-hour time
   * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
   * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
   * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
   * @example DateTime.local()                                  //~> now
   * @example DateTime.local({ zone: "America/New_York" })      //~> now, in US east coast time
   * @example DateTime.local(2017)                              //~> 2017-01-01T00:00:00
   * @example DateTime.local(2017, 3)                           //~> 2017-03-01T00:00:00
   * @example DateTime.local(2017, 3, 12, { locale: "fr" })     //~> 2017-03-12T00:00:00, with a French locale
   * @example DateTime.local(2017, 3, 12, 5)                    //~> 2017-03-12T05:00:00
   * @example DateTime.local(2017, 3, 12, 5, { zone: "utc" })   //~> 2017-03-12T05:00:00, in UTC
   * @example DateTime.local(2017, 3, 12, 5, 45)                //~> 2017-03-12T05:45:00
   * @example DateTime.local(2017, 3, 12, 5, 45, 10)            //~> 2017-03-12T05:45:10
   * @example DateTime.local(2017, 3, 12, 5, 45, 10, 765)       //~> 2017-03-12T05:45:10.765
   * @return {DateTime}
   */
  static local() {
    const [opts, args] = lastOpts(arguments),
      [year, month, day, hour, minute, second, millisecond] = args;
    return quickDT(
      { year, month, day, hour, minute, second, millisecond },
      opts
    );
  }
  /**
   * Create a DateTime in UTC
   * @param {number} [year] - The calendar year. If omitted (as in, call `utc()` with no arguments), the current time will be used
   * @param {number} [month=1] - The month, 1-indexed
   * @param {number} [day=1] - The day of the month
   * @param {number} [hour=0] - The hour of the day, in 24-hour time
   * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
   * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
   * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
   * @param {Object} options - configuration options for the DateTime
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} [options.outputCalendar] - the output calendar to set on the resulting DateTime instance
   * @param {string} [options.numberingSystem] - the numbering system to set on the resulting DateTime instance
   * @example DateTime.utc()                                              //~> now
   * @example DateTime.utc(2017)                                          //~> 2017-01-01T00:00:00Z
   * @example DateTime.utc(2017, 3)                                       //~> 2017-03-01T00:00:00Z
   * @example DateTime.utc(2017, 3, 12)                                   //~> 2017-03-12T00:00:00Z
   * @example DateTime.utc(2017, 3, 12, 5)                                //~> 2017-03-12T05:00:00Z
   * @example DateTime.utc(2017, 3, 12, 5, 45)                            //~> 2017-03-12T05:45:00Z
   * @example DateTime.utc(2017, 3, 12, 5, 45, { locale: "fr" })          //~> 2017-03-12T05:45:00Z with a French locale
   * @example DateTime.utc(2017, 3, 12, 5, 45, 10)                        //~> 2017-03-12T05:45:10Z
   * @example DateTime.utc(2017, 3, 12, 5, 45, 10, 765, { locale: "fr" }) //~> 2017-03-12T05:45:10.765Z with a French locale
   * @return {DateTime}
   */
  static utc() {
    const [opts, args] = lastOpts(arguments),
      [year, month, day, hour, minute, second, millisecond] = args;
    opts.zone = FixedOffsetZone.utcInstance;
    return quickDT(
      { year, month, day, hour, minute, second, millisecond },
      opts
    );
  }
  /**
   * Create a DateTime from a JavaScript Date object. Uses the default zone.
   * @param {Date} date - a JavaScript Date object
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @return {DateTime}
   */
  static fromJSDate(date, options = {}) {
    const ts = isDate(date) ? date.valueOf() : NaN;
    if (Number.isNaN(ts)) {
      return _DateTime.invalid("invalid input");
    }
    const zoneToUse = normalizeZone(options.zone, Settings.defaultZone);
    if (!zoneToUse.isValid) {
      return _DateTime.invalid(unsupportedZone(zoneToUse));
    }
    return new _DateTime({
      ts,
      zone: zoneToUse,
      loc: Locale.fromObject(options),
    });
  }
  /**
   * Create a DateTime from a number of milliseconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
   * @param {number} milliseconds - a number of milliseconds since 1970 UTC
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromMillis(milliseconds, options = {}) {
    if (!isNumber(milliseconds)) {
      throw new InvalidArgumentError(
        `fromMillis requires a numerical input, but received a ${typeof milliseconds} with value ${milliseconds}`
      );
    } else if (milliseconds < -MAX_DATE || milliseconds > MAX_DATE) {
      return _DateTime.invalid("Timestamp out of range");
    } else {
      return new _DateTime({
        ts: milliseconds,
        zone: normalizeZone(options.zone, Settings.defaultZone),
        loc: Locale.fromObject(options),
      });
    }
  }
  /**
   * Create a DateTime from a number of seconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
   * @param {number} seconds - a number of seconds since 1970 UTC
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromSeconds(seconds, options = {}) {
    if (!isNumber(seconds)) {
      throw new InvalidArgumentError("fromSeconds requires a numerical input");
    } else {
      return new _DateTime({
        ts: seconds * 1e3,
        zone: normalizeZone(options.zone, Settings.defaultZone),
        loc: Locale.fromObject(options),
      });
    }
  }
  /**
   * Create a DateTime from a JavaScript object with keys like 'year' and 'hour' with reasonable defaults.
   * @param {Object} obj - the object to create the DateTime from
   * @param {number} obj.year - a year, such as 1987
   * @param {number} obj.month - a month, 1-12
   * @param {number} obj.day - a day of the month, 1-31, depending on the month
   * @param {number} obj.ordinal - day of the year, 1-365 or 366
   * @param {number} obj.weekYear - an ISO week year
   * @param {number} obj.weekNumber - an ISO week number, between 1 and 52 or 53, depending on the year
   * @param {number} obj.weekday - an ISO weekday, 1-7, where 1 is Monday and 7 is Sunday
   * @param {number} obj.hour - hour of the day, 0-23
   * @param {number} obj.minute - minute of the hour, 0-59
   * @param {number} obj.second - second of the minute, 0-59
   * @param {number} obj.millisecond - millisecond of the second, 0-999
   * @param {Object} opts - options for creating this DateTime
   * @param {string|Zone} [opts.zone='local'] - interpret the numbers in the context of a particular zone. Can take any value taken as the first argument to setZone()
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromObject({ year: 1982, month: 5, day: 25}).toISODate() //=> '1982-05-25'
   * @example DateTime.fromObject({ year: 1982 }).toISODate() //=> '1982-01-01'
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }) //~> today at 10:26:06
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'utc' }),
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'local' })
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'America/New_York' })
   * @example DateTime.fromObject({ weekYear: 2016, weekNumber: 2, weekday: 3 }).toISODate() //=> '2016-01-13'
   * @return {DateTime}
   */
  static fromObject(obj, opts = {}) {
    obj = obj || {};
    const zoneToUse = normalizeZone(opts.zone, Settings.defaultZone);
    if (!zoneToUse.isValid) {
      return _DateTime.invalid(unsupportedZone(zoneToUse));
    }
    const tsNow = Settings.now(),
      offsetProvis = !isUndefined(opts.specificOffset)
        ? opts.specificOffset
        : zoneToUse.offset(tsNow),
      normalized = normalizeObject(obj, normalizeUnit),
      containsOrdinal = !isUndefined(normalized.ordinal),
      containsGregorYear = !isUndefined(normalized.year),
      containsGregorMD =
        !isUndefined(normalized.month) || !isUndefined(normalized.day),
      containsGregor = containsGregorYear || containsGregorMD,
      definiteWeekDef = normalized.weekYear || normalized.weekNumber,
      loc = Locale.fromObject(opts);
    if ((containsGregor || containsOrdinal) && definiteWeekDef) {
      throw new ConflictingSpecificationError(
        "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
      );
    }
    if (containsGregorMD && containsOrdinal) {
      throw new ConflictingSpecificationError(
        "Can't mix ordinal dates with month/day"
      );
    }
    const useWeekData =
      definiteWeekDef || (normalized.weekday && !containsGregor);
    let units,
      defaultValues,
      objNow = tsToObj(tsNow, offsetProvis);
    if (useWeekData) {
      units = orderedWeekUnits;
      defaultValues = defaultWeekUnitValues;
      objNow = gregorianToWeek(objNow);
    } else if (containsOrdinal) {
      units = orderedOrdinalUnits;
      defaultValues = defaultOrdinalUnitValues;
      objNow = gregorianToOrdinal(objNow);
    } else {
      units = orderedUnits2;
      defaultValues = defaultUnitValues;
    }
    let foundFirst = false;
    for (const u of units) {
      const v = normalized[u];
      if (!isUndefined(v)) {
        foundFirst = true;
      } else if (foundFirst) {
        normalized[u] = defaultValues[u];
      } else {
        normalized[u] = objNow[u];
      }
    }
    const higherOrderInvalid = useWeekData
        ? hasInvalidWeekData(normalized)
        : containsOrdinal
        ? hasInvalidOrdinalData(normalized)
        : hasInvalidGregorianData(normalized),
      invalid = higherOrderInvalid || hasInvalidTimeData(normalized);
    if (invalid) {
      return _DateTime.invalid(invalid);
    }
    const gregorian = useWeekData
        ? weekToGregorian(normalized)
        : containsOrdinal
        ? ordinalToGregorian(normalized)
        : normalized,
      [tsFinal, offsetFinal] = objToTS(gregorian, offsetProvis, zoneToUse),
      inst = new _DateTime({
        ts: tsFinal,
        zone: zoneToUse,
        o: offsetFinal,
        loc,
      });
    if (normalized.weekday && containsGregor && obj.weekday !== inst.weekday) {
      return _DateTime.invalid(
        "mismatched weekday",
        `you can't specify both a weekday of ${
          normalized.weekday
        } and a date of ${inst.toISO()}`
      );
    }
    return inst;
  }
  /**
   * Create a DateTime from an ISO 8601 string
   * @param {string} text - the ISO string
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the time to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} [opts.outputCalendar] - the output calendar to set on the resulting DateTime instance
   * @param {string} [opts.numberingSystem] - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromISO('2016-05-25T09:08:34.123')
   * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00')
   * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00', {setZone: true})
   * @example DateTime.fromISO('2016-05-25T09:08:34.123', {zone: 'utc'})
   * @example DateTime.fromISO('2016-W05-4')
   * @return {DateTime}
   */
  static fromISO(text, opts = {}) {
    const [vals, parsedZone] = parseISODate(text);
    return parseDataToDateTime(vals, parsedZone, opts, "ISO 8601", text);
  }
  /**
   * Create a DateTime from an RFC 2822 string
   * @param {string} text - the RFC 2822 string
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since the offset is always specified in the string itself, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
   * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromRFC2822('25 Nov 2016 13:23:12 GMT')
   * @example DateTime.fromRFC2822('Fri, 25 Nov 2016 13:23:12 +0600')
   * @example DateTime.fromRFC2822('25 Nov 2016 13:23 Z')
   * @return {DateTime}
   */
  static fromRFC2822(text, opts = {}) {
    const [vals, parsedZone] = parseRFC2822Date(text);
    return parseDataToDateTime(vals, parsedZone, opts, "RFC 2822", text);
  }
  /**
   * Create a DateTime from an HTTP header date
   * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
   * @param {string} text - the HTTP header date
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since HTTP dates are always in UTC, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
   * @param {boolean} [opts.setZone=false] - override the zone with the fixed-offset zone specified in the string. For HTTP dates, this is always UTC, so this option is equivalent to setting the `zone` option to 'utc', but this option is included for consistency with similar methods.
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromHTTP('Sun, 06 Nov 1994 08:49:37 GMT')
   * @example DateTime.fromHTTP('Sunday, 06-Nov-94 08:49:37 GMT')
   * @example DateTime.fromHTTP('Sun Nov  6 08:49:37 1994')
   * @return {DateTime}
   */
  static fromHTTP(text, opts = {}) {
    const [vals, parsedZone] = parseHTTPDate(text);
    return parseDataToDateTime(vals, parsedZone, opts, "HTTP", opts);
  }
  /**
   * Create a DateTime from an input string and format string.
   * Defaults to en-US if no locale has been specified, regardless of the system's locale. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/parsing?id=table-of-tokens).
   * @param {string} text - the string to parse
   * @param {string} fmt - the format the string is expected to be in (see the link below for the formats)
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
   * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromFormat(text, fmt, opts = {}) {
    if (isUndefined(text) || isUndefined(fmt)) {
      throw new InvalidArgumentError(
        "fromFormat requires an input string and a format"
      );
    }
    const { locale = null, numberingSystem = null } = opts,
      localeToUse = Locale.fromOpts({
        locale,
        numberingSystem,
        defaultToEN: true,
      }),
      [vals, parsedZone, specificOffset, invalid] = parseFromTokens(
        localeToUse,
        text,
        fmt
      );
    if (invalid) {
      return _DateTime.invalid(invalid);
    } else {
      return parseDataToDateTime(
        vals,
        parsedZone,
        opts,
        `format ${fmt}`,
        text,
        specificOffset
      );
    }
  }
  /**
   * @deprecated use fromFormat instead
   */
  static fromString(text, fmt, opts = {}) {
    return _DateTime.fromFormat(text, fmt, opts);
  }
  /**
   * Create a DateTime from a SQL date, time, or datetime
   * Defaults to en-US if no locale has been specified, regardless of the system's locale
   * @param {string} text - the string to parse
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
   * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @example DateTime.fromSQL('2017-05-15')
   * @example DateTime.fromSQL('2017-05-15 09:12:34')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342+06:00')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles', { setZone: true })
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342', { zone: 'America/Los_Angeles' })
   * @example DateTime.fromSQL('09:12:34.342')
   * @return {DateTime}
   */
  static fromSQL(text, opts = {}) {
    const [vals, parsedZone] = parseSQL(text);
    return parseDataToDateTime(vals, parsedZone, opts, "SQL", text);
  }
  /**
   * Create an invalid DateTime.
   * @param {string} reason - simple string of why this DateTime is invalid. Should not contain parameters or anything else data-dependent
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {DateTime}
   */
  static invalid(reason, explanation = null) {
    if (!reason) {
      throw new InvalidArgumentError(
        "need to specify a reason the DateTime is invalid"
      );
    }
    const invalid =
      reason instanceof Invalid ? reason : new Invalid(reason, explanation);
    if (Settings.throwOnInvalid) {
      throw new InvalidDateTimeError(invalid);
    } else {
      return new _DateTime({ invalid });
    }
  }
  /**
   * Check if an object is a DateTime. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isDateTime(o) {
    return (o && o.isLuxonDateTime) || false;
  }
  // INFO
  /**
   * Get the value of unit.
   * @param {string} unit - a unit such as 'minute' or 'day'
   * @example DateTime.local(2017, 7, 4).get('month'); //=> 7
   * @example DateTime.local(2017, 7, 4).get('day'); //=> 4
   * @return {number}
   */
  get(unit) {
    return this[unit];
  }
  /**
   * Returns whether the DateTime is valid. Invalid DateTimes occur when:
   * * The DateTime was created from invalid calendar information, such as the 13th month or February 30
   * * The DateTime was created by an operation on another invalid date
   * @type {boolean}
   */
  get isValid() {
    return this.invalid === null;
  }
  /**
   * Returns an error code if this DateTime is invalid, or null if the DateTime is valid
   * @type {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  /**
   * Returns an explanation of why this DateTime became invalid, or null if the DateTime is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  /**
   * Get the locale of a DateTime, such 'en-GB'. The locale is used when formatting the DateTime
   *
   * @type {string}
   */
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }
  /**
   * Get the numbering system of a DateTime, such 'beng'. The numbering system is used when formatting the DateTime
   *
   * @type {string}
   */
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }
  /**
   * Get the output calendar of a DateTime, such 'islamic'. The output calendar is used when formatting the DateTime
   *
   * @type {string}
   */
  get outputCalendar() {
    return this.isValid ? this.loc.outputCalendar : null;
  }
  /**
   * Get the time zone associated with this DateTime.
   * @type {Zone}
   */
  get zone() {
    return this._zone;
  }
  /**
   * Get the name of the time zone.
   * @type {string}
   */
  get zoneName() {
    return this.isValid ? this.zone.name : null;
  }
  /**
   * Get the year
   * @example DateTime.local(2017, 5, 25).year //=> 2017
   * @type {number}
   */
  get year() {
    return this.isValid ? this.c.year : NaN;
  }
  /**
   * Get the quarter
   * @example DateTime.local(2017, 5, 25).quarter //=> 2
   * @type {number}
   */
  get quarter() {
    return this.isValid ? Math.ceil(this.c.month / 3) : NaN;
  }
  /**
   * Get the month (1-12).
   * @example DateTime.local(2017, 5, 25).month //=> 5
   * @type {number}
   */
  get month() {
    return this.isValid ? this.c.month : NaN;
  }
  /**
   * Get the day of the month (1-30ish).
   * @example DateTime.local(2017, 5, 25).day //=> 25
   * @type {number}
   */
  get day() {
    return this.isValid ? this.c.day : NaN;
  }
  /**
   * Get the hour of the day (0-23).
   * @example DateTime.local(2017, 5, 25, 9).hour //=> 9
   * @type {number}
   */
  get hour() {
    return this.isValid ? this.c.hour : NaN;
  }
  /**
   * Get the minute of the hour (0-59).
   * @example DateTime.local(2017, 5, 25, 9, 30).minute //=> 30
   * @type {number}
   */
  get minute() {
    return this.isValid ? this.c.minute : NaN;
  }
  /**
   * Get the second of the minute (0-59).
   * @example DateTime.local(2017, 5, 25, 9, 30, 52).second //=> 52
   * @type {number}
   */
  get second() {
    return this.isValid ? this.c.second : NaN;
  }
  /**
   * Get the millisecond of the second (0-999).
   * @example DateTime.local(2017, 5, 25, 9, 30, 52, 654).millisecond //=> 654
   * @type {number}
   */
  get millisecond() {
    return this.isValid ? this.c.millisecond : NaN;
  }
  /**
   * Get the week year
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2014, 12, 31).weekYear //=> 2015
   * @type {number}
   */
  get weekYear() {
    return this.isValid ? possiblyCachedWeekData(this).weekYear : NaN;
  }
  /**
   * Get the week number of the week year (1-52ish).
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2017, 5, 25).weekNumber //=> 21
   * @type {number}
   */
  get weekNumber() {
    return this.isValid ? possiblyCachedWeekData(this).weekNumber : NaN;
  }
  /**
   * Get the day of the week.
   * 1 is Monday and 7 is Sunday
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2014, 11, 31).weekday //=> 4
   * @type {number}
   */
  get weekday() {
    return this.isValid ? possiblyCachedWeekData(this).weekday : NaN;
  }
  /**
   * Get the ordinal (meaning the day of the year)
   * @example DateTime.local(2017, 5, 25).ordinal //=> 145
   * @type {number|DateTime}
   */
  get ordinal() {
    return this.isValid ? gregorianToOrdinal(this.c).ordinal : NaN;
  }
  /**
   * Get the human readable short month name, such as 'Oct'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).monthShort //=> Oct
   * @type {string}
   */
  get monthShort() {
    return this.isValid
      ? Info.months("short", { locObj: this.loc })[this.month - 1]
      : null;
  }
  /**
   * Get the human readable long month name, such as 'October'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).monthLong //=> October
   * @type {string}
   */
  get monthLong() {
    return this.isValid
      ? Info.months("long", { locObj: this.loc })[this.month - 1]
      : null;
  }
  /**
   * Get the human readable short weekday, such as 'Mon'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).weekdayShort //=> Mon
   * @type {string}
   */
  get weekdayShort() {
    return this.isValid
      ? Info.weekdays("short", { locObj: this.loc })[this.weekday - 1]
      : null;
  }
  /**
   * Get the human readable long weekday, such as 'Monday'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).weekdayLong //=> Monday
   * @type {string}
   */
  get weekdayLong() {
    return this.isValid
      ? Info.weekdays("long", { locObj: this.loc })[this.weekday - 1]
      : null;
  }
  /**
   * Get the UTC offset of this DateTime in minutes
   * @example DateTime.now().offset //=> -240
   * @example DateTime.utc().offset //=> 0
   * @type {number}
   */
  get offset() {
    return this.isValid ? +this.o : NaN;
  }
  /**
   * Get the short human name for the zone's current offset, for example "EST" or "EDT".
   * Defaults to the system's locale if no locale has been specified
   * @type {string}
   */
  get offsetNameShort() {
    if (this.isValid) {
      return this.zone.offsetName(this.ts, {
        format: "short",
        locale: this.locale,
      });
    } else {
      return null;
    }
  }
  /**
   * Get the long human name for the zone's current offset, for example "Eastern Standard Time" or "Eastern Daylight Time".
   * Defaults to the system's locale if no locale has been specified
   * @type {string}
   */
  get offsetNameLong() {
    if (this.isValid) {
      return this.zone.offsetName(this.ts, {
        format: "long",
        locale: this.locale,
      });
    } else {
      return null;
    }
  }
  /**
   * Get whether this zone's offset ever changes, as in a DST.
   * @type {boolean}
   */
  get isOffsetFixed() {
    return this.isValid ? this.zone.isUniversal : null;
  }
  /**
   * Get whether the DateTime is in a DST.
   * @type {boolean}
   */
  get isInDST() {
    if (this.isOffsetFixed) {
      return false;
    } else {
      return (
        this.offset > this.set({ month: 1 }).offset ||
        this.offset > this.set({ month: 5 }).offset
      );
    }
  }
  /**
   * Returns true if this DateTime is in a leap year, false otherwise
   * @example DateTime.local(2016).isInLeapYear //=> true
   * @example DateTime.local(2013).isInLeapYear //=> false
   * @type {boolean}
   */
  get isInLeapYear() {
    return isLeapYear(this.year);
  }
  /**
   * Returns the number of days in this DateTime's month
   * @example DateTime.local(2016, 2).daysInMonth //=> 29
   * @example DateTime.local(2016, 3).daysInMonth //=> 31
   * @type {number}
   */
  get daysInMonth() {
    return daysInMonth(this.year, this.month);
  }
  /**
   * Returns the number of days in this DateTime's year
   * @example DateTime.local(2016).daysInYear //=> 366
   * @example DateTime.local(2013).daysInYear //=> 365
   * @type {number}
   */
  get daysInYear() {
    return this.isValid ? daysInYear(this.year) : NaN;
  }
  /**
   * Returns the number of weeks in this DateTime's year
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2004).weeksInWeekYear //=> 53
   * @example DateTime.local(2013).weeksInWeekYear //=> 52
   * @type {number}
   */
  get weeksInWeekYear() {
    return this.isValid ? weeksInWeekYear(this.weekYear) : NaN;
  }
  /**
   * Returns the resolved Intl options for this DateTime.
   * This is useful in understanding the behavior of formatting methods
   * @param {Object} opts - the same options as toLocaleString
   * @return {Object}
   */
  resolvedLocaleOptions(opts = {}) {
    const { locale, numberingSystem, calendar } = Formatter.create(
      this.loc.clone(opts),
      opts
    ).resolvedOptions(this);
    return { locale, numberingSystem, outputCalendar: calendar };
  }
  // TRANSFORM
  /**
   * "Set" the DateTime's zone to UTC. Returns a newly-constructed DateTime.
   *
   * Equivalent to {@link DateTime#setZone}('utc')
   * @param {number} [offset=0] - optionally, an offset from UTC in minutes
   * @param {Object} [opts={}] - options to pass to `setZone()`
   * @return {DateTime}
   */
  toUTC(offset2 = 0, opts = {}) {
    return this.setZone(FixedOffsetZone.instance(offset2), opts);
  }
  /**
   * "Set" the DateTime's zone to the host's local zone. Returns a newly-constructed DateTime.
   *
   * Equivalent to `setZone('local')`
   * @return {DateTime}
   */
  toLocal() {
    return this.setZone(Settings.defaultZone);
  }
  /**
   * "Set" the DateTime's zone to specified zone. Returns a newly-constructed DateTime.
   *
   * By default, the setter keeps the underlying time the same (as in, the same timestamp), but the new instance will report different local times and consider DSTs when making computations, as with {@link DateTime#plus}. You may wish to use {@link DateTime#toLocal} and {@link DateTime#toUTC} which provide simple convenience wrappers for commonly used zones.
   * @param {string|Zone} [zone='local'] - a zone identifier. As a string, that can be any IANA zone supported by the host environment, or a fixed-offset name of the form 'UTC+3', or the strings 'local' or 'utc'. You may also supply an instance of a {@link DateTime#Zone} class.
   * @param {Object} opts - options
   * @param {boolean} [opts.keepLocalTime=false] - If true, adjust the underlying time so that the local time stays the same, but in the target zone. You should rarely need this.
   * @return {DateTime}
   */
  setZone(zone, { keepLocalTime = false, keepCalendarTime = false } = {}) {
    zone = normalizeZone(zone, Settings.defaultZone);
    if (zone.equals(this.zone)) {
      return this;
    } else if (!zone.isValid) {
      return _DateTime.invalid(unsupportedZone(zone));
    } else {
      let newTS = this.ts;
      if (keepLocalTime || keepCalendarTime) {
        const offsetGuess = zone.offset(this.ts);
        const asObj = this.toObject();
        [newTS] = objToTS(asObj, offsetGuess, zone);
      }
      return clone2(this, { ts: newTS, zone });
    }
  }
  /**
   * "Set" the locale, numberingSystem, or outputCalendar. Returns a newly-constructed DateTime.
   * @param {Object} properties - the properties to set
   * @example DateTime.local(2017, 5, 25).reconfigure({ locale: 'en-GB' })
   * @return {DateTime}
   */
  reconfigure({ locale, numberingSystem, outputCalendar } = {}) {
    const loc = this.loc.clone({ locale, numberingSystem, outputCalendar });
    return clone2(this, { loc });
  }
  /**
   * "Set" the locale. Returns a newly-constructed DateTime.
   * Just a convenient alias for reconfigure({ locale })
   * @example DateTime.local(2017, 5, 25).setLocale('en-GB')
   * @return {DateTime}
   */
  setLocale(locale) {
    return this.reconfigure({ locale });
  }
  /**
   * "Set" the values of specified units. Returns a newly-constructed DateTime.
   * You can only set units with this method; for "setting" metadata, see {@link DateTime#reconfigure} and {@link DateTime#setZone}.
   * @param {Object} values - a mapping of units to numbers
   * @example dt.set({ year: 2017 })
   * @example dt.set({ hour: 8, minute: 30 })
   * @example dt.set({ weekday: 5 })
   * @example dt.set({ year: 2005, ordinal: 234 })
   * @return {DateTime}
   */
  set(values) {
    if (!this.isValid) return this;
    const normalized = normalizeObject(values, normalizeUnit),
      settingWeekStuff =
        !isUndefined(normalized.weekYear) ||
        !isUndefined(normalized.weekNumber) ||
        !isUndefined(normalized.weekday),
      containsOrdinal = !isUndefined(normalized.ordinal),
      containsGregorYear = !isUndefined(normalized.year),
      containsGregorMD =
        !isUndefined(normalized.month) || !isUndefined(normalized.day),
      containsGregor = containsGregorYear || containsGregorMD,
      definiteWeekDef = normalized.weekYear || normalized.weekNumber;
    if ((containsGregor || containsOrdinal) && definiteWeekDef) {
      throw new ConflictingSpecificationError(
        "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
      );
    }
    if (containsGregorMD && containsOrdinal) {
      throw new ConflictingSpecificationError(
        "Can't mix ordinal dates with month/day"
      );
    }
    let mixed;
    if (settingWeekStuff) {
      mixed = weekToGregorian({ ...gregorianToWeek(this.c), ...normalized });
    } else if (!isUndefined(normalized.ordinal)) {
      mixed = ordinalToGregorian({
        ...gregorianToOrdinal(this.c),
        ...normalized,
      });
    } else {
      mixed = { ...this.toObject(), ...normalized };
      if (isUndefined(normalized.day)) {
        mixed.day = Math.min(daysInMonth(mixed.year, mixed.month), mixed.day);
      }
    }
    const [ts, o] = objToTS(mixed, this.o, this.zone);
    return clone2(this, { ts, o });
  }
  /**
   * Add a period of time to this DateTime and return the resulting DateTime
   *
   * Adding hours, minutes, seconds, or milliseconds increases the timestamp by the right number of milliseconds. Adding days, months, or years shifts the calendar, accounting for DSTs and leap years along the way. Thus, `dt.plus({ hours: 24 })` may result in a different time than `dt.plus({ days: 1 })` if there's a DST shift in between.
   * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @example DateTime.now().plus(123) //~> in 123 milliseconds
   * @example DateTime.now().plus({ minutes: 15 }) //~> in 15 minutes
   * @example DateTime.now().plus({ days: 1 }) //~> this time tomorrow
   * @example DateTime.now().plus({ days: -1 }) //~> this time yesterday
   * @example DateTime.now().plus({ hours: 3, minutes: 13 }) //~> in 3 hr, 13 min
   * @example DateTime.now().plus(Duration.fromObject({ hours: 3, minutes: 13 })) //~> in 3 hr, 13 min
   * @return {DateTime}
   */
  plus(duration) {
    if (!this.isValid) return this;
    const dur = Duration.fromDurationLike(duration);
    return clone2(this, adjustTime(this, dur));
  }
  /**
   * Subtract a period of time to this DateTime and return the resulting DateTime
   * See {@link DateTime#plus}
   * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   @return {DateTime}
   */
  minus(duration) {
    if (!this.isValid) return this;
    const dur = Duration.fromDurationLike(duration).negate();
    return clone2(this, adjustTime(this, dur));
  }
  /**
   * "Set" this DateTime to the beginning of a unit of time.
   * @param {string} unit - The unit to go to the beginning of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
   * @example DateTime.local(2014, 3, 3).startOf('month').toISODate(); //=> '2014-03-01'
   * @example DateTime.local(2014, 3, 3).startOf('year').toISODate(); //=> '2014-01-01'
   * @example DateTime.local(2014, 3, 3).startOf('week').toISODate(); //=> '2014-03-03', weeks always start on Mondays
   * @example DateTime.local(2014, 3, 3, 5, 30).startOf('day').toISOTime(); //=> '00:00.000-05:00'
   * @example DateTime.local(2014, 3, 3, 5, 30).startOf('hour').toISOTime(); //=> '05:00:00.000-05:00'
   * @return {DateTime}
   */
  startOf(unit) {
    if (!this.isValid) return this;
    const o = {},
      normalizedUnit = Duration.normalizeUnit(unit);
    switch (normalizedUnit) {
      case "years":
        o.month = 1;
      case "quarters":
      case "months":
        o.day = 1;
      case "weeks":
      case "days":
        o.hour = 0;
      case "hours":
        o.minute = 0;
      case "minutes":
        o.second = 0;
      case "seconds":
        o.millisecond = 0;
        break;
    }
    if (normalizedUnit === "weeks") {
      o.weekday = 1;
    }
    if (normalizedUnit === "quarters") {
      const q = Math.ceil(this.month / 3);
      o.month = (q - 1) * 3 + 1;
    }
    return this.set(o);
  }
  /**
   * "Set" this DateTime to the end (meaning the last millisecond) of a unit of time
   * @param {string} unit - The unit to go to the end of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
   * @example DateTime.local(2014, 3, 3).endOf('month').toISO(); //=> '2014-03-31T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3).endOf('year').toISO(); //=> '2014-12-31T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3).endOf('week').toISO(); // => '2014-03-09T23:59:59.999-05:00', weeks start on Mondays
   * @example DateTime.local(2014, 3, 3, 5, 30).endOf('day').toISO(); //=> '2014-03-03T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3, 5, 30).endOf('hour').toISO(); //=> '2014-03-03T05:59:59.999-05:00'
   * @return {DateTime}
   */
  endOf(unit) {
    return this.isValid
      ? this.plus({ [unit]: 1 })
          .startOf(unit)
          .minus(1)
      : this;
  }
  // OUTPUT
  /**
   * Returns a string representation of this DateTime formatted according to the specified format string.
   * **You may not want this.** See {@link DateTime#toLocaleString} for a more flexible formatting tool. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/formatting?id=table-of-tokens).
   * Defaults to en-US if no locale has been specified, regardless of the system's locale.
   * @param {string} fmt - the format string
   * @param {Object} opts - opts to override the configuration options on this DateTime
   * @example DateTime.now().toFormat('yyyy LLL dd') //=> '2017 Apr 22'
   * @example DateTime.now().setLocale('fr').toFormat('yyyy LLL dd') //=> '2017 avr. 22'
   * @example DateTime.now().toFormat('yyyy LLL dd', { locale: "fr" }) //=> '2017 avr. 22'
   * @example DateTime.now().toFormat("HH 'hours and' mm 'minutes'") //=> '20 hours and 55 minutes'
   * @return {string}
   */
  toFormat(fmt, opts = {}) {
    return this.isValid
      ? Formatter.create(this.loc.redefaultToEN(opts)).formatDateTimeFromString(
          this,
          fmt
        )
      : INVALID3;
  }
  /**
   * Returns a localized string representing this date. Accepts the same options as the Intl.DateTimeFormat constructor and any presets defined by Luxon, such as `DateTime.DATE_FULL` or `DateTime.TIME_SIMPLE`.
   * The exact behavior of this method is browser-specific, but in general it will return an appropriate representation
   * of the DateTime in the assigned locale.
   * Defaults to the system's locale if no locale has been specified
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param formatOpts {Object} - Intl.DateTimeFormat constructor options and configuration options
   * @param {Object} opts - opts to override the configuration options on this DateTime
   * @example DateTime.now().toLocaleString(); //=> 4/20/2017
   * @example DateTime.now().setLocale('en-gb').toLocaleString(); //=> '20/04/2017'
   * @example DateTime.now().toLocaleString({ locale: 'en-gb' }); //=> '20/04/2017'
   * @example DateTime.now().toLocaleString(DateTime.DATE_FULL); //=> 'April 20, 2017'
   * @example DateTime.now().toLocaleString(DateTime.TIME_SIMPLE); //=> '11:32 AM'
   * @example DateTime.now().toLocaleString(DateTime.DATETIME_SHORT); //=> '4/20/2017, 11:32 AM'
   * @example DateTime.now().toLocaleString({ weekday: 'long', month: 'long', day: '2-digit' }); //=> 'Thursday, April 20'
   * @example DateTime.now().toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> 'Thu, Apr 20, 11:27 AM'
   * @example DateTime.now().toLocaleString({ hour: '2-digit', minute: '2-digit', hourCycle: 'h23' }); //=> '11:32'
   * @return {string}
   */
  toLocaleString(formatOpts = DATE_SHORT, opts = {}) {
    return this.isValid
      ? Formatter.create(this.loc.clone(opts), formatOpts).formatDateTime(this)
      : INVALID3;
  }
  /**
   * Returns an array of format "parts", meaning individual tokens along with metadata. This is allows callers to post-process individual sections of the formatted output.
   * Defaults to the system's locale if no locale has been specified
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat/formatToParts
   * @param opts {Object} - Intl.DateTimeFormat constructor options, same as `toLocaleString`.
   * @example DateTime.now().toLocaleParts(); //=> [
   *                                   //=>   { type: 'day', value: '25' },
   *                                   //=>   { type: 'literal', value: '/' },
   *                                   //=>   { type: 'month', value: '05' },
   *                                   //=>   { type: 'literal', value: '/' },
   *                                   //=>   { type: 'year', value: '1982' }
   *                                   //=> ]
   */
  toLocaleParts(opts = {}) {
    return this.isValid
      ? Formatter.create(this.loc.clone(opts), opts).formatDateTimeParts(this)
      : [];
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc(1983, 5, 25).toISO() //=> '1982-05-25T00:00:00.000Z'
   * @example DateTime.now().toISO() //=> '2017-04-22T20:47:05.335-04:00'
   * @example DateTime.now().toISO({ includeOffset: false }) //=> '2017-04-22T20:47:05.335'
   * @example DateTime.now().toISO({ format: 'basic' }) //=> '20170422T204705.335-0400'
   * @return {string}
   */
  toISO({
    format = "extended",
    suppressSeconds = false,
    suppressMilliseconds = false,
    includeOffset = true,
  } = {}) {
    if (!this.isValid) {
      return null;
    }
    const ext = format === "extended";
    let c = toISODate(this, ext);
    c += "T";
    c += toISOTime(
      this,
      ext,
      suppressSeconds,
      suppressMilliseconds,
      includeOffset
    );
    return c;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's date component
   * @param {Object} opts - options
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc(1982, 5, 25).toISODate() //=> '1982-05-25'
   * @example DateTime.utc(1982, 5, 25).toISODate({ format: 'basic' }) //=> '19820525'
   * @return {string}
   */
  toISODate({ format = "extended" } = {}) {
    if (!this.isValid) {
      return null;
    }
    return toISODate(this, format === "extended");
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's week date
   * @example DateTime.utc(1982, 5, 25).toISOWeekDate() //=> '1982-W21-2'
   * @return {string}
   */
  toISOWeekDate() {
    return toTechFormat(this, "kkkk-'W'WW-c");
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's time component
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime() //=> '07:34:19.361Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34, seconds: 0, milliseconds: 0 }).toISOTime({ suppressSeconds: true }) //=> '07:34Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ format: 'basic' }) //=> '073419.361Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ includePrefix: true }) //=> 'T07:34:19.361Z'
   * @return {string}
   */
  toISOTime({
    suppressMilliseconds = false,
    suppressSeconds = false,
    includeOffset = true,
    includePrefix = false,
    format = "extended",
  } = {}) {
    if (!this.isValid) {
      return null;
    }
    let c = includePrefix ? "T" : "";
    return (
      c +
      toISOTime(
        this,
        format === "extended",
        suppressSeconds,
        suppressMilliseconds,
        includeOffset
      )
    );
  }
  /**
   * Returns an RFC 2822-compatible string representation of this DateTime
   * @example DateTime.utc(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 +0000'
   * @example DateTime.local(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 -0400'
   * @return {string}
   */
  toRFC2822() {
    return toTechFormat(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ", false);
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in HTTP headers. The output is always expressed in GMT.
   * Specifically, the string conforms to RFC 1123.
   * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
   * @example DateTime.utc(2014, 7, 13).toHTTP() //=> 'Sun, 13 Jul 2014 00:00:00 GMT'
   * @example DateTime.utc(2014, 7, 13, 19).toHTTP() //=> 'Sun, 13 Jul 2014 19:00:00 GMT'
   * @return {string}
   */
  toHTTP() {
    return toTechFormat(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'");
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in SQL Date
   * @example DateTime.utc(2014, 7, 13).toSQLDate() //=> '2014-07-13'
   * @return {string}
   */
  toSQLDate() {
    if (!this.isValid) {
      return null;
    }
    return toISODate(this, true);
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in SQL Time
   * @param {Object} opts - options
   * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
   * @example DateTime.utc().toSQL() //=> '05:15:16.345'
   * @example DateTime.now().toSQL() //=> '05:15:16.345 -04:00'
   * @example DateTime.now().toSQL({ includeOffset: false }) //=> '05:15:16.345'
   * @example DateTime.now().toSQL({ includeZone: false }) //=> '05:15:16.345 America/New_York'
   * @return {string}
   */
  toSQLTime({
    includeOffset = true,
    includeZone = false,
    includeOffsetSpace = true,
  } = {}) {
    let fmt = "HH:mm:ss.SSS";
    if (includeZone || includeOffset) {
      if (includeOffsetSpace) {
        fmt += " ";
      }
      if (includeZone) {
        fmt += "z";
      } else if (includeOffset) {
        fmt += "ZZ";
      }
    }
    return toTechFormat(this, fmt, true);
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in SQL DateTime
   * @param {Object} opts - options
   * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
   * @example DateTime.utc(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 Z'
   * @example DateTime.local(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 -04:00'
   * @example DateTime.local(2014, 7, 13).toSQL({ includeOffset: false }) //=> '2014-07-13 00:00:00.000'
   * @example DateTime.local(2014, 7, 13).toSQL({ includeZone: true }) //=> '2014-07-13 00:00:00.000 America/New_York'
   * @return {string}
   */
  toSQL(opts = {}) {
    if (!this.isValid) {
      return null;
    }
    return `${this.toSQLDate()} ${this.toSQLTime(opts)}`;
  }
  /**
   * Returns a string representation of this DateTime appropriate for debugging
   * @return {string}
   */
  toString() {
    return this.isValid ? this.toISO() : INVALID3;
  }
  /**
   * Returns the epoch milliseconds of this DateTime. Alias of {@link DateTime#toMillis}
   * @return {number}
   */
  valueOf() {
    return this.toMillis();
  }
  /**
   * Returns the epoch milliseconds of this DateTime.
   * @return {number}
   */
  toMillis() {
    return this.isValid ? this.ts : NaN;
  }
  /**
   * Returns the epoch seconds of this DateTime.
   * @return {number}
   */
  toSeconds() {
    return this.isValid ? this.ts / 1e3 : NaN;
  }
  /**
   * Returns the epoch seconds (as a whole number) of this DateTime.
   * @return {number}
   */
  toUnixInteger() {
    return this.isValid ? Math.floor(this.ts / 1e3) : NaN;
  }
  /**
   * Returns an ISO 8601 representation of this DateTime appropriate for use in JSON.
   * @return {string}
   */
  toJSON() {
    return this.toISO();
  }
  /**
   * Returns a BSON serializable equivalent to this DateTime.
   * @return {Date}
   */
  toBSON() {
    return this.toJSDate();
  }
  /**
   * Returns a JavaScript object with this DateTime's year, month, day, and so on.
   * @param opts - options for generating the object
   * @param {boolean} [opts.includeConfig=false] - include configuration attributes in the output
   * @example DateTime.now().toObject() //=> { year: 2017, month: 4, day: 22, hour: 20, minute: 49, second: 42, millisecond: 268 }
   * @return {Object}
   */
  toObject(opts = {}) {
    if (!this.isValid) return {};
    const base = { ...this.c };
    if (opts.includeConfig) {
      base.outputCalendar = this.outputCalendar;
      base.numberingSystem = this.loc.numberingSystem;
      base.locale = this.loc.locale;
    }
    return base;
  }
  /**
   * Returns a JavaScript Date equivalent to this DateTime.
   * @return {Date}
   */
  toJSDate() {
    return new Date(this.isValid ? this.ts : NaN);
  }
  // COMPARE
  /**
   * Return the difference between two DateTimes as a Duration.
   * @param {DateTime} otherDateTime - the DateTime to compare this one to
   * @param {string|string[]} [unit=['milliseconds']] - the unit or array of units (such as 'hours' or 'days') to include in the duration.
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @example
   * var i1 = DateTime.fromISO('1982-05-25T09:45'),
   *     i2 = DateTime.fromISO('1983-10-14T10:30');
   * i2.diff(i1).toObject() //=> { milliseconds: 43807500000 }
   * i2.diff(i1, 'hours').toObject() //=> { hours: 12168.75 }
   * i2.diff(i1, ['months', 'days']).toObject() //=> { months: 16, days: 19.03125 }
   * i2.diff(i1, ['months', 'days', 'hours']).toObject() //=> { months: 16, days: 19, hours: 0.75 }
   * @return {Duration}
   */
  diff(otherDateTime, unit = "milliseconds", opts = {}) {
    if (!this.isValid || !otherDateTime.isValid) {
      return Duration.invalid("created by diffing an invalid DateTime");
    }
    const durOpts = {
      locale: this.locale,
      numberingSystem: this.numberingSystem,
      ...opts,
    };
    const units = maybeArray(unit).map(Duration.normalizeUnit),
      otherIsLater = otherDateTime.valueOf() > this.valueOf(),
      earlier = otherIsLater ? this : otherDateTime,
      later = otherIsLater ? otherDateTime : this,
      diffed = diff_default(earlier, later, units, durOpts);
    return otherIsLater ? diffed.negate() : diffed;
  }
  /**
   * Return the difference between this DateTime and right now.
   * See {@link DateTime#diff}
   * @param {string|string[]} [unit=['milliseconds']] - the unit or units units (such as 'hours' or 'days') to include in the duration
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @return {Duration}
   */
  diffNow(unit = "milliseconds", opts = {}) {
    return this.diff(_DateTime.now(), unit, opts);
  }
  /**
   * Return an Interval spanning between this DateTime and another DateTime
   * @param {DateTime} otherDateTime - the other end point of the Interval
   * @return {Interval}
   */
  until(otherDateTime) {
    return this.isValid ? Interval.fromDateTimes(this, otherDateTime) : this;
  }
  /**
   * Return whether this DateTime is in the same unit of time as another DateTime.
   * Higher-order units must also be identical for this function to return `true`.
   * Note that time zones are **ignored** in this comparison, which compares the **local** calendar time. Use {@link DateTime#setZone} to convert one of the dates if needed.
   * @param {DateTime} otherDateTime - the other DateTime
   * @param {string} unit - the unit of time to check sameness on
   * @example DateTime.now().hasSame(otherDT, 'day'); //~> true if otherDT is in the same current calendar day
   * @return {boolean}
   */
  hasSame(otherDateTime, unit) {
    if (!this.isValid) return false;
    const inputMs = otherDateTime.valueOf();
    const adjustedToZone = this.setZone(otherDateTime.zone, {
      keepLocalTime: true,
    });
    return (
      adjustedToZone.startOf(unit) <= inputMs &&
      inputMs <= adjustedToZone.endOf(unit)
    );
  }
  /**
   * Equality check
   * Two DateTimes are equal iff they represent the same millisecond, have the same zone and location, and are both valid.
   * To compare just the millisecond values, use `+dt1 === +dt2`.
   * @param {DateTime} other - the other DateTime
   * @return {boolean}
   */
  equals(other) {
    return (
      this.isValid &&
      other.isValid &&
      this.valueOf() === other.valueOf() &&
      this.zone.equals(other.zone) &&
      this.loc.equals(other.loc)
    );
  }
  /**
   * Returns a string representation of a this time relative to now, such as "in two days". Can only internationalize if your
   * platform supports Intl.RelativeTimeFormat. Rounds down by default.
   * @param {Object} options - options that affect the output
   * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
   * @param {string} [options.style="long"] - the style of units, must be "long", "short", or "narrow"
   * @param {string|string[]} options.unit - use a specific unit or array of units; if omitted, or an array, the method will pick the best unit. Use an array or one of "years", "quarters", "months", "weeks", "days", "hours", "minutes", or "seconds"
   * @param {boolean} [options.round=true] - whether to round the numbers in the output.
   * @param {number} [options.padding=0] - padding in milliseconds. This allows you to round up the result if it fits inside the threshold. Don't use in combination with {round: false} because the decimal output will include the padding.
   * @param {string} options.locale - override the locale of this DateTime
   * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
   * @example DateTime.now().plus({ days: 1 }).toRelative() //=> "in 1 day"
   * @example DateTime.now().setLocale("es").toRelative({ days: 1 }) //=> "dentro de 1 da"
   * @example DateTime.now().plus({ days: 1 }).toRelative({ locale: "fr" }) //=> "dans 23 heures"
   * @example DateTime.now().minus({ days: 2 }).toRelative() //=> "2 days ago"
   * @example DateTime.now().minus({ days: 2 }).toRelative({ unit: "hours" }) //=> "48 hours ago"
   * @example DateTime.now().minus({ hours: 36 }).toRelative({ round: false }) //=> "1.5 days ago"
   */
  toRelative(options = {}) {
    if (!this.isValid) return null;
    const base = options.base || _DateTime.fromObject({}, { zone: this.zone }),
      padding = options.padding
        ? this < base
          ? -options.padding
          : options.padding
        : 0;
    let units = ["years", "months", "days", "hours", "minutes", "seconds"];
    let unit = options.unit;
    if (Array.isArray(options.unit)) {
      units = options.unit;
      unit = void 0;
    }
    return diffRelative(base, this.plus(padding), {
      ...options,
      numeric: "always",
      units,
      unit,
    });
  }
  /**
   * Returns a string representation of this date relative to today, such as "yesterday" or "next month".
   * Only internationalizes on platforms that supports Intl.RelativeTimeFormat.
   * @param {Object} options - options that affect the output
   * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
   * @param {string} options.locale - override the locale of this DateTime
   * @param {string} options.unit - use a specific unit; if omitted, the method will pick the unit. Use one of "years", "quarters", "months", "weeks", or "days"
   * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
   * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar() //=> "tomorrow"
   * @example DateTime.now().setLocale("es").plus({ days: 1 }).toRelative() //=> ""maana"
   * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar({ locale: "fr" }) //=> "demain"
   * @example DateTime.now().minus({ days: 2 }).toRelativeCalendar() //=> "2 days ago"
   */
  toRelativeCalendar(options = {}) {
    if (!this.isValid) return null;
    return diffRelative(
      options.base || _DateTime.fromObject({}, { zone: this.zone }),
      this,
      {
        ...options,
        numeric: "auto",
        units: ["years", "months", "days"],
        calendary: true,
      }
    );
  }
  /**
   * Return the min of several date times
   * @param {...DateTime} dateTimes - the DateTimes from which to choose the minimum
   * @return {DateTime} the min DateTime, or undefined if called with no argument
   */
  static min(...dateTimes) {
    if (!dateTimes.every(_DateTime.isDateTime)) {
      throw new InvalidArgumentError("min requires all arguments be DateTimes");
    }
    return bestBy(dateTimes, (i) => i.valueOf(), Math.min);
  }
  /**
   * Return the max of several date times
   * @param {...DateTime} dateTimes - the DateTimes from which to choose the maximum
   * @return {DateTime} the max DateTime, or undefined if called with no argument
   */
  static max(...dateTimes) {
    if (!dateTimes.every(_DateTime.isDateTime)) {
      throw new InvalidArgumentError("max requires all arguments be DateTimes");
    }
    return bestBy(dateTimes, (i) => i.valueOf(), Math.max);
  }
  // MISC
  /**
   * Explain how a string would be parsed by fromFormat()
   * @param {string} text - the string to parse
   * @param {string} fmt - the format the string is expected to be in (see description)
   * @param {Object} options - options taken by fromFormat()
   * @return {Object}
   */
  static fromFormatExplain(text, fmt, options = {}) {
    const { locale = null, numberingSystem = null } = options,
      localeToUse = Locale.fromOpts({
        locale,
        numberingSystem,
        defaultToEN: true,
      });
    return explainFromTokens(localeToUse, text, fmt);
  }
  /**
   * @deprecated use fromFormatExplain instead
   */
  static fromStringExplain(text, fmt, options = {}) {
    return _DateTime.fromFormatExplain(text, fmt, options);
  }
  // FORMAT PRESETS
  /**
   * {@link DateTime#toLocaleString} format like 10/14/1983
   * @type {Object}
   */
  static get DATE_SHORT() {
    return DATE_SHORT;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983'
   * @type {Object}
   */
  static get DATE_MED() {
    return DATE_MED;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Fri, Oct 14, 1983'
   * @type {Object}
   */
  static get DATE_MED_WITH_WEEKDAY() {
    return DATE_MED_WITH_WEEKDAY;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983'
   * @type {Object}
   */
  static get DATE_FULL() {
    return DATE_FULL;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Tuesday, October 14, 1983'
   * @type {Object}
   */
  static get DATE_HUGE() {
    return DATE_HUGE;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_SIMPLE() {
    return TIME_SIMPLE;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_SECONDS() {
    return TIME_WITH_SECONDS;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_SHORT_OFFSET() {
    return TIME_WITH_SHORT_OFFSET;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_LONG_OFFSET() {
    return TIME_WITH_LONG_OFFSET;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_SIMPLE() {
    return TIME_24_SIMPLE;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_SECONDS() {
    return TIME_24_WITH_SECONDS;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 EDT', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_SHORT_OFFSET() {
    return TIME_24_WITH_SHORT_OFFSET;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 Eastern Daylight Time', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_LONG_OFFSET() {
    return TIME_24_WITH_LONG_OFFSET;
  }
  /**
   * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_SHORT() {
    return DATETIME_SHORT;
  }
  /**
   * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30:33 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_SHORT_WITH_SECONDS() {
    return DATETIME_SHORT_WITH_SECONDS;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED() {
    return DATETIME_MED;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30:33 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED_WITH_SECONDS() {
    return DATETIME_MED_WITH_SECONDS;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Fri, 14 Oct 1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED_WITH_WEEKDAY() {
    return DATETIME_MED_WITH_WEEKDAY;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_FULL() {
    return DATETIME_FULL;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30:33 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_FULL_WITH_SECONDS() {
    return DATETIME_FULL_WITH_SECONDS;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_HUGE() {
    return DATETIME_HUGE;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30:33 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_HUGE_WITH_SECONDS() {
    return DATETIME_HUGE_WITH_SECONDS;
  }
};
function friendlyDateTime(dateTimeish) {
  if (DateTime.isDateTime(dateTimeish)) {
    return dateTimeish;
  } else if (
    dateTimeish &&
    dateTimeish.valueOf &&
    isNumber(dateTimeish.valueOf())
  ) {
    return DateTime.fromJSDate(dateTimeish);
  } else if (dateTimeish && typeof dateTimeish === "object") {
    return DateTime.fromObject(dateTimeish);
  } else {
    throw new InvalidArgumentError(
      `Unknown datetime argument: ${dateTimeish}, of type ${typeof dateTimeish}`
    );
  }
}

// node_modules/component-emitter/index.js
var require_component_emitter = __commonJS({
  "node_modules/component-emitter/index.js"(exports, module) {
    if (typeof module !== "undefined") {
      module.exports = Emitter;
    }
    function Emitter(obj) {
      if (obj) return mixin(obj);
    }
    function mixin(obj) {
      for (var key in Emitter.prototype) {
        obj[key] = Emitter.prototype[key];
      }
      return obj;
    }
    Emitter.prototype.on = Emitter.prototype.addEventListener = function (
      event,
      fn
    ) {
      this._callbacks = this._callbacks || {};
      (this._callbacks["$" + event] = this._callbacks["$" + event] || []).push(
        fn
      );
      return this;
    };
    Emitter.prototype.once = function (event, fn) {
      function on() {
        this.off(event, on);
        fn.apply(this, arguments);
      }
      on.fn = fn;
      this.on(event, on);
      return this;
    };
    Emitter.prototype.off =
      Emitter.prototype.removeListener =
      Emitter.prototype.removeAllListeners =
      Emitter.prototype.removeEventListener =
        function (event, fn) {
          this._callbacks = this._callbacks || {};
          if (0 == arguments.length) {
            this._callbacks = {};
            return this;
          }
          var callbacks = this._callbacks["$" + event];
          if (!callbacks) return this;
          if (1 == arguments.length) {
            delete this._callbacks["$" + event];
            return this;
          }
          var cb;
          for (var i = 0; i < callbacks.length; i++) {
            cb = callbacks[i];
            if (cb === fn || cb.fn === fn) {
              callbacks.splice(i, 1);
              break;
            }
          }
          if (callbacks.length === 0) {
            delete this._callbacks["$" + event];
          }
          return this;
        };
    Emitter.prototype.emit = function (event) {
      this._callbacks = this._callbacks || {};
      var args = new Array(arguments.length - 1),
        callbacks = this._callbacks["$" + event];
      for (var i = 1; i < arguments.length; i++) {
        args[i - 1] = arguments[i];
      }
      if (callbacks) {
        callbacks = callbacks.slice(0);
        for (var i = 0, len = callbacks.length; i < len; ++i) {
          callbacks[i].apply(this, args);
        }
      }
      return this;
    };
    Emitter.prototype.listeners = function (event) {
      this._callbacks = this._callbacks || {};
      return this._callbacks["$" + event] || [];
    };
    Emitter.prototype.hasListeners = function (event) {
      return !!this.listeners(event).length;
    };
  },
});

// node_modules/fast-safe-stringify/index.js
var require_fast_safe_stringify = __commonJS({
  "node_modules/fast-safe-stringify/index.js"(exports, module) {
    module.exports = stringify;
    stringify.default = stringify;
    stringify.stable = deterministicStringify;
    stringify.stableStringify = deterministicStringify;
    var LIMIT_REPLACE_NODE = "[...]";
    var CIRCULAR_REPLACE_NODE = "[Circular]";
    var arr = [];
    var replacerStack = [];
    function defaultOptions() {
      return {
        depthLimit: Number.MAX_SAFE_INTEGER,
        edgesLimit: Number.MAX_SAFE_INTEGER,
      };
    }
    function stringify(obj, replacer, spacer, options) {
      if (typeof options === "undefined") {
        options = defaultOptions();
      }
      decirc(obj, "", 0, [], void 0, 0, options);
      var res;
      try {
        if (replacerStack.length === 0) {
          res = JSON.stringify(obj, replacer, spacer);
        } else {
          res = JSON.stringify(obj, replaceGetterValues(replacer), spacer);
        }
      } catch (_) {
        return JSON.stringify(
          "[unable to serialize, circular reference is too complex to analyze]"
        );
      } finally {
        while (arr.length !== 0) {
          var part = arr.pop();
          if (part.length === 4) {
            Object.defineProperty(part[0], part[1], part[3]);
          } else {
            part[0][part[1]] = part[2];
          }
        }
      }
      return res;
    }
    function setReplace(replace, val, k, parent) {
      var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k);
      if (propertyDescriptor.get !== void 0) {
        if (propertyDescriptor.configurable) {
          Object.defineProperty(parent, k, { value: replace });
          arr.push([parent, k, val, propertyDescriptor]);
        } else {
          replacerStack.push([val, k, replace]);
        }
      } else {
        parent[k] = replace;
        arr.push([parent, k, val]);
      }
    }
    function decirc(val, k, edgeIndex, stack, parent, depth, options) {
      depth += 1;
      var i;
      if (typeof val === "object" && val !== null) {
        for (i = 0; i < stack.length; i++) {
          if (stack[i] === val) {
            setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);
            return;
          }
        }
        if (
          typeof options.depthLimit !== "undefined" &&
          depth > options.depthLimit
        ) {
          setReplace(LIMIT_REPLACE_NODE, val, k, parent);
          return;
        }
        if (
          typeof options.edgesLimit !== "undefined" &&
          edgeIndex + 1 > options.edgesLimit
        ) {
          setReplace(LIMIT_REPLACE_NODE, val, k, parent);
          return;
        }
        stack.push(val);
        if (Array.isArray(val)) {
          for (i = 0; i < val.length; i++) {
            decirc(val[i], i, i, stack, val, depth, options);
          }
        } else {
          var keys = Object.keys(val);
          for (i = 0; i < keys.length; i++) {
            var key = keys[i];
            decirc(val[key], key, i, stack, val, depth, options);
          }
        }
        stack.pop();
      }
    }
    function compareFunction(a, b) {
      if (a < b) {
        return -1;
      }
      if (a > b) {
        return 1;
      }
      return 0;
    }
    function deterministicStringify(obj, replacer, spacer, options) {
      if (typeof options === "undefined") {
        options = defaultOptions();
      }
      var tmp = deterministicDecirc(obj, "", 0, [], void 0, 0, options) || obj;
      var res;
      try {
        if (replacerStack.length === 0) {
          res = JSON.stringify(tmp, replacer, spacer);
        } else {
          res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer);
        }
      } catch (_) {
        return JSON.stringify(
          "[unable to serialize, circular reference is too complex to analyze]"
        );
      } finally {
        while (arr.length !== 0) {
          var part = arr.pop();
          if (part.length === 4) {
            Object.defineProperty(part[0], part[1], part[3]);
          } else {
            part[0][part[1]] = part[2];
          }
        }
      }
      return res;
    }
    function deterministicDecirc(
      val,
      k,
      edgeIndex,
      stack,
      parent,
      depth,
      options
    ) {
      depth += 1;
      var i;
      if (typeof val === "object" && val !== null) {
        for (i = 0; i < stack.length; i++) {
          if (stack[i] === val) {
            setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);
            return;
          }
        }
        try {
          if (typeof val.toJSON === "function") {
            return;
          }
        } catch (_) {
          return;
        }
        if (
          typeof options.depthLimit !== "undefined" &&
          depth > options.depthLimit
        ) {
          setReplace(LIMIT_REPLACE_NODE, val, k, parent);
          return;
        }
        if (
          typeof options.edgesLimit !== "undefined" &&
          edgeIndex + 1 > options.edgesLimit
        ) {
          setReplace(LIMIT_REPLACE_NODE, val, k, parent);
          return;
        }
        stack.push(val);
        if (Array.isArray(val)) {
          for (i = 0; i < val.length; i++) {
            deterministicDecirc(val[i], i, i, stack, val, depth, options);
          }
        } else {
          var tmp = {};
          var keys = Object.keys(val).sort(compareFunction);
          for (i = 0; i < keys.length; i++) {
            var key = keys[i];
            deterministicDecirc(val[key], key, i, stack, val, depth, options);
            tmp[key] = val[key];
          }
          if (typeof parent !== "undefined") {
            arr.push([parent, k, val]);
            parent[k] = tmp;
          } else {
            return tmp;
          }
        }
        stack.pop();
      }
    }
    function replaceGetterValues(replacer) {
      replacer =
        typeof replacer !== "undefined"
          ? replacer
          : function (k, v) {
              return v;
            };
      return function (key, val) {
        if (replacerStack.length > 0) {
          for (var i = 0; i < replacerStack.length; i++) {
            var part = replacerStack[i];
            if (part[1] === key && part[0] === val) {
              val = part[2];
              replacerStack.splice(i, 1);
              break;
            }
          }
        }
        return replacer.call(this, key, val);
      };
    }
  },
});

// node_modules/has-symbols/shams.js
var require_shams = __commonJS({
  "node_modules/has-symbols/shams.js"(exports, module) {
    module.exports = function hasSymbols() {
      if (
        typeof Symbol !== "function" ||
        typeof Object.getOwnPropertySymbols !== "function"
      ) {
        return false;
      }
      if (typeof Symbol.iterator === "symbol") {
        return true;
      }
      var obj = {};
      var sym = Symbol("test");
      var symObj = Object(sym);
      if (typeof sym === "string") {
        return false;
      }
      if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
        return false;
      }
      if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
        return false;
      }
      var symVal = 42;
      obj[sym] = symVal;
      for (sym in obj) {
        return false;
      }
      if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
        return false;
      }
      if (
        typeof Object.getOwnPropertyNames === "function" &&
        Object.getOwnPropertyNames(obj).length !== 0
      ) {
        return false;
      }
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym) {
        return false;
      }
      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
          return false;
        }
      }
      return true;
    };
  },
});

// node_modules/has-symbols/index.js
var require_has_symbols = __commonJS({
  "node_modules/has-symbols/index.js"(exports, module) {
    var origSymbol = typeof Symbol !== "undefined" && Symbol;
    var hasSymbolSham = require_shams();
    module.exports = function hasNativeSymbols() {
      if (typeof origSymbol !== "function") {
        return false;
      }
      if (typeof Symbol !== "function") {
        return false;
      }
      if (typeof origSymbol("foo") !== "symbol") {
        return false;
      }
      if (typeof Symbol("bar") !== "symbol") {
        return false;
      }
      return hasSymbolSham();
    };
  },
});

// node_modules/function-bind/implementation.js
var require_implementation = __commonJS({
  "node_modules/function-bind/implementation.js"(exports, module) {
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var toStr = Object.prototype.toString;
    var max = Math.max;
    var funcType = "[object Function]";
    var concatty = function concatty2(a, b) {
      var arr = [];
      for (var i = 0; i < a.length; i += 1) {
        arr[i] = a[i];
      }
      for (var j = 0; j < b.length; j += 1) {
        arr[j + a.length] = b[j];
      }
      return arr;
    };
    var slicy = function slicy2(arrLike, offset) {
      var arr = [];
      for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
        arr[j] = arrLike[i];
      }
      return arr;
    };
    var joiny = function (arr, joiner) {
      var str = "";
      for (var i = 0; i < arr.length; i += 1) {
        str += arr[i];
        if (i + 1 < arr.length) {
          str += joiner;
        }
      }
      return str;
    };
    module.exports = function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slicy(arguments, 1);
      var bound;
      var binder = function () {
        if (this instanceof bound) {
          var result = target.apply(this, concatty(args, arguments));
          if (Object(result) === result) {
            return result;
          }
          return this;
        }
        return target.apply(that, concatty(args, arguments));
      };
      var boundLength = max(0, target.length - args.length);
      var boundArgs = [];
      for (var i = 0; i < boundLength; i++) {
        boundArgs[i] = "$" + i;
      }
      bound = Function(
        "binder",
        "return function (" +
          joiny(boundArgs, ",") +
          "){ return binder.apply(this,arguments); }"
      )(binder);
      if (target.prototype) {
        var Empty = function Empty2() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  },
});

// node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "node_modules/function-bind/index.js"(exports, module) {
    var implementation = require_implementation();
    module.exports = Function.prototype.bind || implementation;
  },
});

// node_modules/has/src/index.js
var require_src$1 = __commonJS({
  "node_modules/has/src/index.js"(exports, module) {
    var bind = require_function_bind();
    module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);
  },
});

// node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS({
  "node_modules/get-intrinsic/index.js"(exports, module) {
    var undefined2;
    var $SyntaxError = SyntaxError;
    var $Function = Function;
    var $TypeError = TypeError;
    var getEvalledConstructor = function (expressionSyntax) {
      try {
        return $Function(
          '"use strict"; return (' + expressionSyntax + ").constructor;"
        )();
      } catch (e) {}
    };
    var $gOPD = Object.getOwnPropertyDescriptor;
    if ($gOPD) {
      try {
        $gOPD({}, "");
      } catch (e) {
        $gOPD = null;
      }
    }
    var throwTypeError = function () {
      throw new $TypeError();
    };
    var ThrowTypeError = $gOPD
      ? (function () {
          try {
            arguments.callee;
            return throwTypeError;
          } catch (calleeThrows) {
            try {
              return $gOPD(arguments, "callee").get;
            } catch (gOPDthrows) {
              return throwTypeError;
            }
          }
        })()
      : throwTypeError;
    var hasSymbols = require_has_symbols()();
    var getProto =
      Object.getPrototypeOf ||
      function (x) {
        return x.__proto__;
      };
    var needsEval = {};
    var TypedArray =
      typeof Uint8Array === "undefined" ? undefined2 : getProto(Uint8Array);
    var INTRINSICS = {
      "%AggregateError%":
        typeof AggregateError === "undefined" ? undefined2 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%":
        typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols
        ? getProto([][Symbol.iterator]())
        : undefined2,
      "%AsyncFromSyncIteratorPrototype%": undefined2,
      "%AsyncFunction%": needsEval,
      "%AsyncGenerator%": needsEval,
      "%AsyncGeneratorFunction%": needsEval,
      "%AsyncIteratorPrototype%": needsEval,
      "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
      "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": Error,
      "%eval%": eval,
      // eslint-disable-line no-eval
      "%EvalError%": EvalError,
      "%Float32Array%":
        typeof Float32Array === "undefined" ? undefined2 : Float32Array,
      "%Float64Array%":
        typeof Float64Array === "undefined" ? undefined2 : Float64Array,
      "%FinalizationRegistry%":
        typeof FinalizationRegistry === "undefined"
          ? undefined2
          : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": needsEval,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
      "%Int16Array%":
        typeof Int16Array === "undefined" ? undefined2 : Int16Array,
      "%Int32Array%":
        typeof Int32Array === "undefined" ? undefined2 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols
        ? getProto(getProto([][Symbol.iterator]()))
        : undefined2,
      "%JSON%": typeof JSON === "object" ? JSON : undefined2,
      "%Map%": typeof Map === "undefined" ? undefined2 : Map,
      "%MapIteratorPrototype%":
        typeof Map === "undefined" || !hasSymbols
          ? undefined2
          : getProto(/* @__PURE__ */ new Map()[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": Object,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
      "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
      "%RangeError%": RangeError,
      "%ReferenceError%": ReferenceError,
      "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? undefined2 : Set,
      "%SetIteratorPrototype%":
        typeof Set === "undefined" || !hasSymbols
          ? undefined2
          : getProto(/* @__PURE__ */ new Set()[Symbol.iterator]()),
      "%SharedArrayBuffer%":
        typeof SharedArrayBuffer === "undefined"
          ? undefined2
          : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols
        ? getProto(""[Symbol.iterator]())
        : undefined2,
      "%Symbol%": hasSymbols ? Symbol : undefined2,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypeError%": $TypeError,
      "%Uint8Array%":
        typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
      "%Uint8ClampedArray%":
        typeof Uint8ClampedArray === "undefined"
          ? undefined2
          : Uint8ClampedArray,
      "%Uint16Array%":
        typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
      "%Uint32Array%":
        typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
      "%URIError%": URIError,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
      "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet,
    };
    var doEval = function doEval2(name) {
      var value;
      if (name === "%AsyncFunction%") {
        value = getEvalledConstructor("async function () {}");
      } else if (name === "%GeneratorFunction%") {
        value = getEvalledConstructor("function* () {}");
      } else if (name === "%AsyncGeneratorFunction%") {
        value = getEvalledConstructor("async function* () {}");
      } else if (name === "%AsyncGenerator%") {
        var fn = doEval2("%AsyncGeneratorFunction%");
        if (fn) {
          value = fn.prototype;
        }
      } else if (name === "%AsyncIteratorPrototype%") {
        var gen = doEval2("%AsyncGenerator%");
        if (gen) {
          value = getProto(gen.prototype);
        }
      }
      INTRINSICS[name] = value;
      return value;
    };
    var LEGACY_ALIASES = {
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": [
        "AsyncGeneratorFunction",
        "prototype",
        "prototype",
      ],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"],
    };
    var bind = require_function_bind();
    var hasOwn = require_src$1();
    var $concat = bind.call(Function.call, Array.prototype.concat);
    var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
    var $replace = bind.call(Function.call, String.prototype.replace);
    var $strSlice = bind.call(Function.call, String.prototype.slice);
    var rePropName =
      /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = function stringToPath2(string) {
      var first = $strSlice(string, 0, 1);
      var last = $strSlice(string, -1);
      if (first === "%" && last !== "%") {
        throw new $SyntaxError(
          "invalid intrinsic syntax, expected closing `%`"
        );
      } else if (last === "%" && first !== "%") {
        throw new $SyntaxError(
          "invalid intrinsic syntax, expected opening `%`"
        );
      }
      var result = [];
      $replace(string, rePropName, function (match, number, quote, subString) {
        result[result.length] = quote
          ? $replace(subString, reEscapeChar, "$1")
          : number || match;
      });
      return result;
    };
    var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
      var intrinsicName = name;
      var alias;
      if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
      }
      if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
          value = doEval(intrinsicName);
        }
        if (typeof value === "undefined" && !allowMissing) {
          throw new $TypeError(
            "intrinsic " +
              name +
              " exists, but is not available. Please file an issue!"
          );
        }
        return {
          alias,
          name: intrinsicName,
          value,
        };
      }
      throw new $SyntaxError("intrinsic " + name + " does not exist!");
    };
    module.exports = function GetIntrinsic(name, allowMissing) {
      if (typeof name !== "string" || name.length === 0) {
        throw new $TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new $TypeError('"allowMissing" argument must be a boolean');
      }
      var parts = stringToPath(name);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
      var intrinsic = getBaseIntrinsic(
        "%" + intrinsicBaseName + "%",
        allowMissing
      );
      var intrinsicRealName = intrinsic.name;
      var value = intrinsic.value;
      var skipFurtherCaching = false;
      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
      }
      for (var i = 1, isOwn = true; i < parts.length; i += 1) {
        var part = parts[i];
        var first = $strSlice(part, 0, 1);
        var last = $strSlice(part, -1);
        if (
          (first === '"' ||
            first === "'" ||
            first === "`" ||
            last === '"' ||
            last === "'" ||
            last === "`") &&
          first !== last
        ) {
          throw new $SyntaxError(
            "property names with quotes must have matching quotes"
          );
        }
        if (part === "constructor" || !isOwn) {
          skipFurtherCaching = true;
        }
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
          value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
          if (!(part in value)) {
            if (!allowMissing) {
              throw new $TypeError(
                "base intrinsic for " +
                  name +
                  " exists, but the property is not available."
              );
            }
            return void 0;
          }
          if ($gOPD && i + 1 >= parts.length) {
            var desc = $gOPD(value, part);
            isOwn = !!desc;
            if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
              value = desc.get;
            } else {
              value = value[part];
            }
          } else {
            isOwn = hasOwn(value, part);
            value = value[part];
          }
          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value;
          }
        }
      }
      return value;
    };
  },
});

// node_modules/call-bind/index.js
var require_call_bind = __commonJS({
  "node_modules/call-bind/index.js"(exports, module) {
    var bind = require_function_bind();
    var GetIntrinsic = require_get_intrinsic();
    var $apply = GetIntrinsic("%Function.prototype.apply%");
    var $call = GetIntrinsic("%Function.prototype.call%");
    var $reflectApply =
      GetIntrinsic("%Reflect.apply%", true) || bind.call($call, $apply);
    var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
    var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
    var $max = GetIntrinsic("%Math.max%");
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e) {
        $defineProperty = null;
      }
    }
    module.exports = function callBind(originalFunction) {
      var func = $reflectApply(bind, $call, arguments);
      if ($gOPD && $defineProperty) {
        var desc = $gOPD(func, "length");
        if (desc.configurable) {
          $defineProperty(func, "length", {
            value:
              1 + $max(0, originalFunction.length - (arguments.length - 1)),
          });
        }
      }
      return func;
    };
    var applyBind = function applyBind2() {
      return $reflectApply(bind, $apply, arguments);
    };
    if ($defineProperty) {
      $defineProperty(module.exports, "apply", { value: applyBind });
    } else {
      module.exports.apply = applyBind;
    }
  },
});

// node_modules/call-bind/callBound.js
var require_callBound = __commonJS({
  "node_modules/call-bind/callBound.js"(exports, module) {
    var GetIntrinsic = require_get_intrinsic();
    var callBind = require_call_bind();
    var $indexOf = callBind(GetIntrinsic("String.prototype.indexOf"));
    module.exports = function callBoundIntrinsic(name, allowMissing) {
      var intrinsic = GetIntrinsic(name, !!allowMissing);
      if (
        typeof intrinsic === "function" &&
        $indexOf(name, ".prototype.") > -1
      ) {
        return callBind(intrinsic);
      }
      return intrinsic;
    };
  },
});

// (disabled):node_modules/object-inspect/util.inspect
var require_util$1 = __commonJS({
  "(disabled):node_modules/object-inspect/util.inspect"() {},
});

// node_modules/object-inspect/index.js
var require_object_inspect = __commonJS({
  "node_modules/object-inspect/index.js"(exports, module) {
    var hasMap = typeof Map === "function" && Map.prototype;
    var mapSizeDescriptor =
      Object.getOwnPropertyDescriptor && hasMap
        ? Object.getOwnPropertyDescriptor(Map.prototype, "size")
        : null;
    var mapSize =
      hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function"
        ? mapSizeDescriptor.get
        : null;
    var mapForEach = hasMap && Map.prototype.forEach;
    var hasSet = typeof Set === "function" && Set.prototype;
    var setSizeDescriptor =
      Object.getOwnPropertyDescriptor && hasSet
        ? Object.getOwnPropertyDescriptor(Set.prototype, "size")
        : null;
    var setSize =
      hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function"
        ? setSizeDescriptor.get
        : null;
    var setForEach = hasSet && Set.prototype.forEach;
    var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
    var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
    var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
    var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
    var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
    var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
    var booleanValueOf = Boolean.prototype.valueOf;
    var objectToString = Object.prototype.toString;
    var functionToString = Function.prototype.toString;
    var $match = String.prototype.match;
    var $slice = String.prototype.slice;
    var $replace = String.prototype.replace;
    var $toUpperCase = String.prototype.toUpperCase;
    var $toLowerCase = String.prototype.toLowerCase;
    var $test = RegExp.prototype.test;
    var $concat = Array.prototype.concat;
    var $join = Array.prototype.join;
    var $arrSlice = Array.prototype.slice;
    var $floor = Math.floor;
    var bigIntValueOf =
      typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
    var gOPS = Object.getOwnPropertySymbols;
    var symToString =
      typeof Symbol === "function" && typeof Symbol.iterator === "symbol"
        ? Symbol.prototype.toString
        : null;
    var hasShammedSymbols =
      typeof Symbol === "function" && typeof Symbol.iterator === "object";
    var toStringTag =
      typeof Symbol === "function" &&
      Symbol.toStringTag &&
      (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol")
        ? Symbol.toStringTag
        : null;
    var isEnumerable = Object.prototype.propertyIsEnumerable;
    var gPO =
      (typeof Reflect === "function"
        ? Reflect.getPrototypeOf
        : Object.getPrototypeOf) ||
      ([].__proto__ === Array.prototype
        ? function (O) {
            return O.__proto__;
          }
        : null);
    function addNumericSeparator(num, str) {
      if (
        num === Infinity ||
        num === -Infinity ||
        num !== num ||
        (num && num > -1e3 && num < 1e3) ||
        $test.call(/e/, str)
      ) {
        return str;
      }
      var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
      if (typeof num === "number") {
        var int = num < 0 ? -$floor(-num) : $floor(num);
        if (int !== num) {
          var intStr = String(int);
          var dec = $slice.call(str, intStr.length + 1);
          return (
            $replace.call(intStr, sepRegex, "$&_") +
            "." +
            $replace.call($replace.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "")
          );
        }
      }
      return $replace.call(str, sepRegex, "$&_");
    }
    var inspectCustom = require_util$1().custom;
    var inspectSymbol =
      inspectCustom && isSymbol(inspectCustom) ? inspectCustom : null;
    module.exports = function inspect_(obj, options, depth, seen) {
      var opts = options || {};
      if (
        has(opts, "quoteStyle") &&
        opts.quoteStyle !== "single" &&
        opts.quoteStyle !== "double"
      ) {
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
      }
      if (
        has(opts, "maxStringLength") &&
        (typeof opts.maxStringLength === "number"
          ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity
          : opts.maxStringLength !== null)
      ) {
        throw new TypeError(
          'option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`'
        );
      }
      var customInspect = has(opts, "customInspect")
        ? opts.customInspect
        : true;
      if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
        throw new TypeError(
          "option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`"
        );
      }
      if (
        has(opts, "indent") &&
        opts.indent !== null &&
        opts.indent !== "	" &&
        !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)
      ) {
        throw new TypeError(
          'option "indent" must be "\\t", an integer > 0, or `null`'
        );
      }
      if (
        has(opts, "numericSeparator") &&
        typeof opts.numericSeparator !== "boolean"
      ) {
        throw new TypeError(
          'option "numericSeparator", if provided, must be `true` or `false`'
        );
      }
      var numericSeparator = opts.numericSeparator;
      if (typeof obj === "undefined") {
        return "undefined";
      }
      if (obj === null) {
        return "null";
      }
      if (typeof obj === "boolean") {
        return obj ? "true" : "false";
      }
      if (typeof obj === "string") {
        return inspectString(obj, opts);
      }
      if (typeof obj === "number") {
        if (obj === 0) {
          return Infinity / obj > 0 ? "0" : "-0";
        }
        var str = String(obj);
        return numericSeparator ? addNumericSeparator(obj, str) : str;
      }
      if (typeof obj === "bigint") {
        var bigIntStr = String(obj) + "n";
        return numericSeparator
          ? addNumericSeparator(obj, bigIntStr)
          : bigIntStr;
      }
      var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
      if (typeof depth === "undefined") {
        depth = 0;
      }
      if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
        return isArray(obj) ? "[Array]" : "[Object]";
      }
      var indent = getIndent(opts, depth);
      if (typeof seen === "undefined") {
        seen = [];
      } else if (indexOf(seen, obj) >= 0) {
        return "[Circular]";
      }
      function inspect(value, from, noIndent) {
        if (from) {
          seen = $arrSlice.call(seen);
          seen.push(from);
        }
        if (noIndent) {
          var newOpts = {
            depth: opts.depth,
          };
          if (has(opts, "quoteStyle")) {
            newOpts.quoteStyle = opts.quoteStyle;
          }
          return inspect_(value, newOpts, depth + 1, seen);
        }
        return inspect_(value, opts, depth + 1, seen);
      }
      if (typeof obj === "function") {
        var name = nameOf(obj);
        var keys = arrObjKeys(obj, inspect);
        return (
          "[Function" +
          (name ? ": " + name : " (anonymous)") +
          "]" +
          (keys.length > 0 ? " { " + $join.call(keys, ", ") + " }" : "")
        );
      }
      if (isSymbol(obj)) {
        var symString = hasShammedSymbols
          ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1")
          : symToString.call(obj);
        return typeof obj === "object" && !hasShammedSymbols
          ? markBoxed(symString)
          : symString;
      }
      if (isElement(obj)) {
        var s = "<" + $toLowerCase.call(String(obj.nodeName));
        var attrs = obj.attributes || [];
        for (var i = 0; i < attrs.length; i++) {
          s +=
            " " +
            attrs[i].name +
            "=" +
            wrapQuotes(quote(attrs[i].value), "double", opts);
        }
        s += ">";
        if (obj.childNodes && obj.childNodes.length) {
          s += "...";
        }
        s += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
        return s;
      }
      if (isArray(obj)) {
        if (obj.length === 0) {
          return "[]";
        }
        var xs = arrObjKeys(obj, inspect);
        if (indent && !singleLineValues(xs)) {
          return "[" + indentedJoin(xs, indent) + "]";
        }
        return "[ " + $join.call(xs, ", ") + " ]";
      }
      if (isError(obj)) {
        var parts = arrObjKeys(obj, inspect);
        if ("cause" in obj && !isEnumerable.call(obj, "cause")) {
          return (
            "{ [" +
            String(obj) +
            "] " +
            $join.call(
              $concat.call("[cause]: " + inspect(obj.cause), parts),
              ", "
            ) +
            " }"
          );
        }
        if (parts.length === 0) {
          return "[" + String(obj) + "]";
        }
        return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
      }
      if (typeof obj === "object" && customInspect) {
        if (inspectSymbol && typeof obj[inspectSymbol] === "function") {
          return obj[inspectSymbol]();
        } else if (
          customInspect !== "symbol" &&
          typeof obj.inspect === "function"
        ) {
          return obj.inspect();
        }
      }
      if (isMap(obj)) {
        var mapParts = [];
        mapForEach.call(obj, function (value, key) {
          mapParts.push(inspect(key, obj, true) + " => " + inspect(value, obj));
        });
        return collectionOf("Map", mapSize.call(obj), mapParts, indent);
      }
      if (isSet(obj)) {
        var setParts = [];
        setForEach.call(obj, function (value) {
          setParts.push(inspect(value, obj));
        });
        return collectionOf("Set", setSize.call(obj), setParts, indent);
      }
      if (isWeakMap(obj)) {
        return weakCollectionOf("WeakMap");
      }
      if (isWeakSet(obj)) {
        return weakCollectionOf("WeakSet");
      }
      if (isWeakRef(obj)) {
        return weakCollectionOf("WeakRef");
      }
      if (isNumber(obj)) {
        return markBoxed(inspect(Number(obj)));
      }
      if (isBigInt(obj)) {
        return markBoxed(inspect(bigIntValueOf.call(obj)));
      }
      if (isBoolean(obj)) {
        return markBoxed(booleanValueOf.call(obj));
      }
      if (isString(obj)) {
        return markBoxed(inspect(String(obj)));
      }
      if (!isDate(obj) && !isRegExp(obj)) {
        var ys = arrObjKeys(obj, inspect);
        var isPlainObject = gPO
          ? gPO(obj) === Object.prototype
          : obj instanceof Object || obj.constructor === Object;
        var protoTag = obj instanceof Object ? "" : "null prototype";
        var stringTag =
          !isPlainObject &&
          toStringTag &&
          Object(obj) === obj &&
          toStringTag in obj
            ? $slice.call(toStr(obj), 8, -1)
            : protoTag
            ? "Object"
            : "";
        var constructorTag =
          isPlainObject || typeof obj.constructor !== "function"
            ? ""
            : obj.constructor.name
            ? obj.constructor.name + " "
            : "";
        var tag =
          constructorTag +
          (stringTag || protoTag
            ? "[" +
              $join.call(
                $concat.call([], stringTag || [], protoTag || []),
                ": "
              ) +
              "] "
            : "");
        if (ys.length === 0) {
          return tag + "{}";
        }
        if (indent) {
          return tag + "{" + indentedJoin(ys, indent) + "}";
        }
        return tag + "{ " + $join.call(ys, ", ") + " }";
      }
      return String(obj);
    };
    function wrapQuotes(s, defaultStyle, opts) {
      var quoteChar =
        (opts.quoteStyle || defaultStyle) === "double" ? '"' : "'";
      return quoteChar + s + quoteChar;
    }
    function quote(s) {
      return $replace.call(String(s), /"/g, "&quot;");
    }
    function isArray(obj) {
      return (
        toStr(obj) === "[object Array]" &&
        (!toStringTag || !(typeof obj === "object" && toStringTag in obj))
      );
    }
    function isDate(obj) {
      return (
        toStr(obj) === "[object Date]" &&
        (!toStringTag || !(typeof obj === "object" && toStringTag in obj))
      );
    }
    function isRegExp(obj) {
      return (
        toStr(obj) === "[object RegExp]" &&
        (!toStringTag || !(typeof obj === "object" && toStringTag in obj))
      );
    }
    function isError(obj) {
      return (
        toStr(obj) === "[object Error]" &&
        (!toStringTag || !(typeof obj === "object" && toStringTag in obj))
      );
    }
    function isString(obj) {
      return (
        toStr(obj) === "[object String]" &&
        (!toStringTag || !(typeof obj === "object" && toStringTag in obj))
      );
    }
    function isNumber(obj) {
      return (
        toStr(obj) === "[object Number]" &&
        (!toStringTag || !(typeof obj === "object" && toStringTag in obj))
      );
    }
    function isBoolean(obj) {
      return (
        toStr(obj) === "[object Boolean]" &&
        (!toStringTag || !(typeof obj === "object" && toStringTag in obj))
      );
    }
    function isSymbol(obj) {
      if (hasShammedSymbols) {
        return obj && typeof obj === "object" && obj instanceof Symbol;
      }
      if (typeof obj === "symbol") {
        return true;
      }
      if (!obj || typeof obj !== "object" || !symToString) {
        return false;
      }
      try {
        symToString.call(obj);
        return true;
      } catch (e) {}
      return false;
    }
    function isBigInt(obj) {
      if (!obj || typeof obj !== "object" || !bigIntValueOf) {
        return false;
      }
      try {
        bigIntValueOf.call(obj);
        return true;
      } catch (e) {}
      return false;
    }
    var hasOwn =
      Object.prototype.hasOwnProperty ||
      function (key) {
        return key in this;
      };
    function has(obj, key) {
      return hasOwn.call(obj, key);
    }
    function toStr(obj) {
      return objectToString.call(obj);
    }
    function nameOf(f) {
      if (f.name) {
        return f.name;
      }
      var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
      if (m) {
        return m[1];
      }
      return null;
    }
    function indexOf(xs, x) {
      if (xs.indexOf) {
        return xs.indexOf(x);
      }
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) {
          return i;
        }
      }
      return -1;
    }
    function isMap(x) {
      if (!mapSize || !x || typeof x !== "object") {
        return false;
      }
      try {
        mapSize.call(x);
        try {
          setSize.call(x);
        } catch (s) {
          return true;
        }
        return x instanceof Map;
      } catch (e) {}
      return false;
    }
    function isWeakMap(x) {
      if (!weakMapHas || !x || typeof x !== "object") {
        return false;
      }
      try {
        weakMapHas.call(x, weakMapHas);
        try {
          weakSetHas.call(x, weakSetHas);
        } catch (s) {
          return true;
        }
        return x instanceof WeakMap;
      } catch (e) {}
      return false;
    }
    function isWeakRef(x) {
      if (!weakRefDeref || !x || typeof x !== "object") {
        return false;
      }
      try {
        weakRefDeref.call(x);
        return true;
      } catch (e) {}
      return false;
    }
    function isSet(x) {
      if (!setSize || !x || typeof x !== "object") {
        return false;
      }
      try {
        setSize.call(x);
        try {
          mapSize.call(x);
        } catch (m) {
          return true;
        }
        return x instanceof Set;
      } catch (e) {}
      return false;
    }
    function isWeakSet(x) {
      if (!weakSetHas || !x || typeof x !== "object") {
        return false;
      }
      try {
        weakSetHas.call(x, weakSetHas);
        try {
          weakMapHas.call(x, weakMapHas);
        } catch (s) {
          return true;
        }
        return x instanceof WeakSet;
      } catch (e) {}
      return false;
    }
    function isElement(x) {
      if (!x || typeof x !== "object") {
        return false;
      }
      if (typeof HTMLElement !== "undefined" && x instanceof HTMLElement) {
        return true;
      }
      return (
        typeof x.nodeName === "string" && typeof x.getAttribute === "function"
      );
    }
    function inspectString(str, opts) {
      if (str.length > opts.maxStringLength) {
        var remaining = str.length - opts.maxStringLength;
        var trailer =
          "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
        return (
          inspectString($slice.call(str, 0, opts.maxStringLength), opts) +
          trailer
        );
      }
      var s = $replace.call(
        $replace.call(str, /(['\\])/g, "\\$1"),
        /[\x00-\x1f]/g,
        lowbyte
      );
      return wrapQuotes(s, "single", opts);
    }
    function lowbyte(c) {
      var n = c.charCodeAt(0);
      var x = {
        8: "b",
        9: "t",
        10: "n",
        12: "f",
        13: "r",
      }[n];
      if (x) {
        return "\\" + x;
      }
      return "\\x" + (n < 16 ? "0" : "") + $toUpperCase.call(n.toString(16));
    }
    function markBoxed(str) {
      return "Object(" + str + ")";
    }
    function weakCollectionOf(type) {
      return type + " { ? }";
    }
    function collectionOf(type, size, entries, indent) {
      var joinedEntries = indent
        ? indentedJoin(entries, indent)
        : $join.call(entries, ", ");
      return type + " (" + size + ") {" + joinedEntries + "}";
    }
    function singleLineValues(xs) {
      for (var i = 0; i < xs.length; i++) {
        if (indexOf(xs[i], "\n") >= 0) {
          return false;
        }
      }
      return true;
    }
    function getIndent(opts, depth) {
      var baseIndent;
      if (opts.indent === "	") {
        baseIndent = "	";
      } else if (typeof opts.indent === "number" && opts.indent > 0) {
        baseIndent = $join.call(Array(opts.indent + 1), " ");
      } else {
        return null;
      }
      return {
        base: baseIndent,
        prev: $join.call(Array(depth + 1), baseIndent),
      };
    }
    function indentedJoin(xs, indent) {
      if (xs.length === 0) {
        return "";
      }
      var lineJoiner = "\n" + indent.prev + indent.base;
      return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent.prev;
    }
    function arrObjKeys(obj, inspect) {
      var isArr = isArray(obj);
      var xs = [];
      if (isArr) {
        xs.length = obj.length;
        for (var i = 0; i < obj.length; i++) {
          xs[i] = has(obj, i) ? inspect(obj[i], obj) : "";
        }
      }
      var syms = typeof gOPS === "function" ? gOPS(obj) : [];
      var symMap;
      if (hasShammedSymbols) {
        symMap = {};
        for (var k = 0; k < syms.length; k++) {
          symMap["$" + syms[k]] = syms[k];
        }
      }
      for (var key in obj) {
        if (!has(obj, key)) {
          continue;
        }
        if (isArr && String(Number(key)) === key && key < obj.length) {
          continue;
        }
        if (hasShammedSymbols && symMap["$" + key] instanceof Symbol) {
          continue;
        } else if ($test.call(/[^\w$]/, key)) {
          xs.push(inspect(key, obj) + ": " + inspect(obj[key], obj));
        } else {
          xs.push(key + ": " + inspect(obj[key], obj));
        }
      }
      if (typeof gOPS === "function") {
        for (var j = 0; j < syms.length; j++) {
          if (isEnumerable.call(obj, syms[j])) {
            xs.push(
              "[" + inspect(syms[j]) + "]: " + inspect(obj[syms[j]], obj)
            );
          }
        }
      }
      return xs;
    }
  },
});

// node_modules/side-channel/index.js
var require_side_channel = __commonJS({
  "node_modules/side-channel/index.js"(exports, module) {
    var GetIntrinsic = require_get_intrinsic();
    var callBound = require_callBound();
    var inspect = require_object_inspect();
    var $TypeError = GetIntrinsic("%TypeError%");
    var $WeakMap = GetIntrinsic("%WeakMap%", true);
    var $Map = GetIntrinsic("%Map%", true);
    var $weakMapGet = callBound("WeakMap.prototype.get", true);
    var $weakMapSet = callBound("WeakMap.prototype.set", true);
    var $weakMapHas = callBound("WeakMap.prototype.has", true);
    var $mapGet = callBound("Map.prototype.get", true);
    var $mapSet = callBound("Map.prototype.set", true);
    var $mapHas = callBound("Map.prototype.has", true);
    var listGetNode = function (list, key) {
      for (var prev = list, curr; (curr = prev.next) !== null; prev = curr) {
        if (curr.key === key) {
          prev.next = curr.next;
          curr.next = list.next;
          list.next = curr;
          return curr;
        }
      }
    };
    var listGet = function (objects, key) {
      var node = listGetNode(objects, key);
      return node && node.value;
    };
    var listSet = function (objects, key, value) {
      var node = listGetNode(objects, key);
      if (node) {
        node.value = value;
      } else {
        objects.next = {
          // eslint-disable-line no-param-reassign
          key,
          next: objects.next,
          value,
        };
      }
    };
    var listHas = function (objects, key) {
      return !!listGetNode(objects, key);
    };
    module.exports = function getSideChannel() {
      var $wm;
      var $m;
      var $o;
      var channel = {
        assert: function (key) {
          if (!channel.has(key)) {
            throw new $TypeError(
              "Side channel does not contain " + inspect(key)
            );
          }
        },
        get: function (key) {
          if (
            $WeakMap &&
            key &&
            (typeof key === "object" || typeof key === "function")
          ) {
            if ($wm) {
              return $weakMapGet($wm, key);
            }
          } else if ($Map) {
            if ($m) {
              return $mapGet($m, key);
            }
          } else {
            if ($o) {
              return listGet($o, key);
            }
          }
        },
        has: function (key) {
          if (
            $WeakMap &&
            key &&
            (typeof key === "object" || typeof key === "function")
          ) {
            if ($wm) {
              return $weakMapHas($wm, key);
            }
          } else if ($Map) {
            if ($m) {
              return $mapHas($m, key);
            }
          } else {
            if ($o) {
              return listHas($o, key);
            }
          }
          return false;
        },
        set: function (key, value) {
          if (
            $WeakMap &&
            key &&
            (typeof key === "object" || typeof key === "function")
          ) {
            if (!$wm) {
              $wm = new $WeakMap();
            }
            $weakMapSet($wm, key, value);
          } else if ($Map) {
            if (!$m) {
              $m = new $Map();
            }
            $mapSet($m, key, value);
          } else {
            if (!$o) {
              $o = { key: {}, next: null };
            }
            listSet($o, key, value);
          }
        },
      };
      return channel;
    };
  },
});

// node_modules/qs/lib/formats.js
var require_formats$1 = __commonJS({
  "node_modules/qs/lib/formats.js"(exports, module) {
    var replace = String.prototype.replace;
    var percentTwenties = /%20/g;
    var Format = {
      RFC1738: "RFC1738",
      RFC3986: "RFC3986",
    };
    module.exports = {
      default: Format.RFC3986,
      formatters: {
        RFC1738: function (value) {
          return replace.call(value, percentTwenties, "+");
        },
        RFC3986: function (value) {
          return String(value);
        },
      },
      RFC1738: Format.RFC1738,
      RFC3986: Format.RFC3986,
    };
  },
});

// node_modules/qs/lib/utils.js
var require_utils$2 = __commonJS({
  "node_modules/qs/lib/utils.js"(exports, module) {
    var formats = require_formats$1();
    var has = Object.prototype.hasOwnProperty;
    var isArray = Array.isArray;
    var hexTable = (function () {
      var array = [];
      for (var i = 0; i < 256; ++i) {
        array.push("%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
      }
      return array;
    })();
    var compactQueue = function compactQueue2(queue) {
      while (queue.length > 1) {
        var item = queue.pop();
        var obj = item.obj[item.prop];
        if (isArray(obj)) {
          var compacted = [];
          for (var j = 0; j < obj.length; ++j) {
            if (typeof obj[j] !== "undefined") {
              compacted.push(obj[j]);
            }
          }
          item.obj[item.prop] = compacted;
        }
      }
    };
    var arrayToObject = function arrayToObject2(source, options) {
      var obj =
        options && options.plainObjects
          ? /* @__PURE__ */ Object.create(null)
          : {};
      for (var i = 0; i < source.length; ++i) {
        if (typeof source[i] !== "undefined") {
          obj[i] = source[i];
        }
      }
      return obj;
    };
    var merge = function merge2(target, source, options) {
      if (!source) {
        return target;
      }
      if (typeof source !== "object") {
        if (isArray(target)) {
          target.push(source);
        } else if (target && typeof target === "object") {
          if (
            (options && (options.plainObjects || options.allowPrototypes)) ||
            !has.call(Object.prototype, source)
          ) {
            target[source] = true;
          }
        } else {
          return [target, source];
        }
        return target;
      }
      if (!target || typeof target !== "object") {
        return [target].concat(source);
      }
      var mergeTarget = target;
      if (isArray(target) && !isArray(source)) {
        mergeTarget = arrayToObject(target, options);
      }
      if (isArray(target) && isArray(source)) {
        source.forEach(function (item, i) {
          if (has.call(target, i)) {
            var targetItem = target[i];
            if (
              targetItem &&
              typeof targetItem === "object" &&
              item &&
              typeof item === "object"
            ) {
              target[i] = merge2(targetItem, item, options);
            } else {
              target.push(item);
            }
          } else {
            target[i] = item;
          }
        });
        return target;
      }
      return Object.keys(source).reduce(function (acc, key) {
        var value = source[key];
        if (has.call(acc, key)) {
          acc[key] = merge2(acc[key], value, options);
        } else {
          acc[key] = value;
        }
        return acc;
      }, mergeTarget);
    };
    var assign = function assignSingleSource(target, source) {
      return Object.keys(source).reduce(function (acc, key) {
        acc[key] = source[key];
        return acc;
      }, target);
    };
    var decode = function (str, decoder, charset) {
      var strWithoutPlus = str.replace(/\+/g, " ");
      if (charset === "iso-8859-1") {
        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
      }
      try {
        return decodeURIComponent(strWithoutPlus);
      } catch (e) {
        return strWithoutPlus;
      }
    };
    var encode = function encode2(str, defaultEncoder, charset, kind, format) {
      if (str.length === 0) {
        return str;
      }
      var string = str;
      if (typeof str === "symbol") {
        string = Symbol.prototype.toString.call(str);
      } else if (typeof str !== "string") {
        string = String(str);
      }
      if (charset === "iso-8859-1") {
        return escape(string).replace(/%u[0-9a-f]{4}/gi, function ($0) {
          return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
        });
      }
      var out = "";
      for (var i = 0; i < string.length; ++i) {
        var c = string.charCodeAt(i);
        if (
          c === 45 ||
          c === 46 ||
          c === 95 ||
          c === 126 ||
          (c >= 48 && c <= 57) ||
          (c >= 65 && c <= 90) ||
          (c >= 97 && c <= 122) ||
          (format === formats.RFC1738 && (c === 40 || c === 41))
        ) {
          out += string.charAt(i);
          continue;
        }
        if (c < 128) {
          out = out + hexTable[c];
          continue;
        }
        if (c < 2048) {
          out = out + (hexTable[192 | (c >> 6)] + hexTable[128 | (c & 63)]);
          continue;
        }
        if (c < 55296 || c >= 57344) {
          out =
            out +
            (hexTable[224 | (c >> 12)] +
              hexTable[128 | ((c >> 6) & 63)] +
              hexTable[128 | (c & 63)]);
          continue;
        }
        i += 1;
        c = 65536 + (((c & 1023) << 10) | (string.charCodeAt(i) & 1023));
        out +=
          hexTable[240 | (c >> 18)] +
          hexTable[128 | ((c >> 12) & 63)] +
          hexTable[128 | ((c >> 6) & 63)] +
          hexTable[128 | (c & 63)];
      }
      return out;
    };
    var compact = function compact2(value) {
      var queue = [{ obj: { o: value }, prop: "o" }];
      var refs = [];
      for (var i = 0; i < queue.length; ++i) {
        var item = queue[i];
        var obj = item.obj[item.prop];
        var keys = Object.keys(obj);
        for (var j = 0; j < keys.length; ++j) {
          var key = keys[j];
          var val = obj[key];
          if (
            typeof val === "object" &&
            val !== null &&
            refs.indexOf(val) === -1
          ) {
            queue.push({ obj, prop: key });
            refs.push(val);
          }
        }
      }
      compactQueue(queue);
      return value;
    };
    var isRegExp = function isRegExp2(obj) {
      return Object.prototype.toString.call(obj) === "[object RegExp]";
    };
    var isBuffer = function isBuffer2(obj) {
      if (!obj || typeof obj !== "object") {
        return false;
      }
      return !!(
        obj.constructor &&
        obj.constructor.isBuffer &&
        obj.constructor.isBuffer(obj)
      );
    };
    var combine = function combine2(a, b) {
      return [].concat(a, b);
    };
    var maybeMap = function maybeMap2(val, fn) {
      if (isArray(val)) {
        var mapped = [];
        for (var i = 0; i < val.length; i += 1) {
          mapped.push(fn(val[i]));
        }
        return mapped;
      }
      return fn(val);
    };
    module.exports = {
      arrayToObject,
      assign,
      combine,
      compact,
      decode,
      encode,
      isBuffer,
      isRegExp,
      maybeMap,
      merge,
    };
  },
});

// node_modules/qs/lib/stringify.js
var require_stringify = __commonJS({
  "node_modules/qs/lib/stringify.js"(exports, module) {
    var getSideChannel = require_side_channel();
    var utils = require_utils$2();
    var formats = require_formats$1();
    var has = Object.prototype.hasOwnProperty;
    var arrayPrefixGenerators = {
      brackets: function brackets(prefix) {
        return prefix + "[]";
      },
      comma: "comma",
      indices: function indices(prefix, key) {
        return prefix + "[" + key + "]";
      },
      repeat: function repeat(prefix) {
        return prefix;
      },
    };
    var isArray = Array.isArray;
    var split = String.prototype.split;
    var push = Array.prototype.push;
    var pushToArray = function (arr, valueOrArray) {
      push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
    };
    var toISO = Date.prototype.toISOString;
    var defaultFormat = formats["default"];
    var defaults = {
      addQueryPrefix: false,
      allowDots: false,
      charset: "utf-8",
      charsetSentinel: false,
      delimiter: "&",
      encode: true,
      encoder: utils.encode,
      encodeValuesOnly: false,
      format: defaultFormat,
      formatter: formats.formatters[defaultFormat],
      // deprecated
      indices: false,
      serializeDate: function serializeDate(date) {
        return toISO.call(date);
      },
      skipNulls: false,
      strictNullHandling: false,
    };
    var isNonNullishPrimitive = function isNonNullishPrimitive2(v) {
      return (
        typeof v === "string" ||
        typeof v === "number" ||
        typeof v === "boolean" ||
        typeof v === "symbol" ||
        typeof v === "bigint"
      );
    };
    var sentinel = {};
    var stringify = function stringify2(
      object,
      prefix,
      generateArrayPrefix,
      strictNullHandling,
      skipNulls,
      encoder,
      filter,
      sort,
      allowDots,
      serializeDate,
      format,
      formatter,
      encodeValuesOnly,
      charset,
      sideChannel
    ) {
      var obj = object;
      var tmpSc = sideChannel;
      var step = 0;
      var findFlag = false;
      while ((tmpSc = tmpSc.get(sentinel)) !== void 0 && !findFlag) {
        var pos = tmpSc.get(object);
        step += 1;
        if (typeof pos !== "undefined") {
          if (pos === step) {
            throw new RangeError("Cyclic object value");
          } else {
            findFlag = true;
          }
        }
        if (typeof tmpSc.get(sentinel) === "undefined") {
          step = 0;
        }
      }
      if (typeof filter === "function") {
        obj = filter(prefix, obj);
      } else if (obj instanceof Date) {
        obj = serializeDate(obj);
      } else if (generateArrayPrefix === "comma" && isArray(obj)) {
        obj = utils.maybeMap(obj, function (value2) {
          if (value2 instanceof Date) {
            return serializeDate(value2);
          }
          return value2;
        });
      }
      if (obj === null) {
        if (strictNullHandling) {
          return encoder && !encodeValuesOnly
            ? encoder(prefix, defaults.encoder, charset, "key", format)
            : prefix;
        }
        obj = "";
      }
      if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
        if (encoder) {
          var keyValue = encodeValuesOnly
            ? prefix
            : encoder(prefix, defaults.encoder, charset, "key", format);
          if (generateArrayPrefix === "comma" && encodeValuesOnly) {
            var valuesArray = split.call(String(obj), ",");
            var valuesJoined = "";
            for (var i = 0; i < valuesArray.length; ++i) {
              valuesJoined +=
                (i === 0 ? "" : ",") +
                formatter(
                  encoder(
                    valuesArray[i],
                    defaults.encoder,
                    charset,
                    "value",
                    format
                  )
                );
            }
            return [formatter(keyValue) + "=" + valuesJoined];
          }
          return [
            formatter(keyValue) +
              "=" +
              formatter(
                encoder(obj, defaults.encoder, charset, "value", format)
              ),
          ];
        }
        return [formatter(prefix) + "=" + formatter(String(obj))];
      }
      var values = [];
      if (typeof obj === "undefined") {
        return values;
      }
      var objKeys;
      if (generateArrayPrefix === "comma" && isArray(obj)) {
        objKeys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
      } else if (isArray(filter)) {
        objKeys = filter;
      } else {
        var keys = Object.keys(obj);
        objKeys = sort ? keys.sort(sort) : keys;
      }
      for (var j = 0; j < objKeys.length; ++j) {
        var key = objKeys[j];
        var value =
          typeof key === "object" && typeof key.value !== "undefined"
            ? key.value
            : obj[key];
        if (skipNulls && value === null) {
          continue;
        }
        var keyPrefix = isArray(obj)
          ? typeof generateArrayPrefix === "function"
            ? generateArrayPrefix(prefix, key)
            : prefix
          : prefix + (allowDots ? "." + key : "[" + key + "]");
        sideChannel.set(object, step);
        var valueSideChannel = getSideChannel();
        valueSideChannel.set(sentinel, sideChannel);
        pushToArray(
          values,
          stringify2(
            value,
            keyPrefix,
            generateArrayPrefix,
            strictNullHandling,
            skipNulls,
            encoder,
            filter,
            sort,
            allowDots,
            serializeDate,
            format,
            formatter,
            encodeValuesOnly,
            charset,
            valueSideChannel
          )
        );
      }
      return values;
    };
    var normalizeStringifyOptions = function normalizeStringifyOptions2(opts) {
      if (!opts) {
        return defaults;
      }
      if (
        opts.encoder !== null &&
        typeof opts.encoder !== "undefined" &&
        typeof opts.encoder !== "function"
      ) {
        throw new TypeError("Encoder has to be a function.");
      }
      var charset = opts.charset || defaults.charset;
      if (
        typeof opts.charset !== "undefined" &&
        opts.charset !== "utf-8" &&
        opts.charset !== "iso-8859-1"
      ) {
        throw new TypeError(
          "The charset option must be either utf-8, iso-8859-1, or undefined"
        );
      }
      var format = formats["default"];
      if (typeof opts.format !== "undefined") {
        if (!has.call(formats.formatters, opts.format)) {
          throw new TypeError("Unknown format option provided.");
        }
        format = opts.format;
      }
      var formatter = formats.formatters[format];
      var filter = defaults.filter;
      if (typeof opts.filter === "function" || isArray(opts.filter)) {
        filter = opts.filter;
      }
      return {
        addQueryPrefix:
          typeof opts.addQueryPrefix === "boolean"
            ? opts.addQueryPrefix
            : defaults.addQueryPrefix,
        allowDots:
          typeof opts.allowDots === "undefined"
            ? defaults.allowDots
            : !!opts.allowDots,
        charset,
        charsetSentinel:
          typeof opts.charsetSentinel === "boolean"
            ? opts.charsetSentinel
            : defaults.charsetSentinel,
        delimiter:
          typeof opts.delimiter === "undefined"
            ? defaults.delimiter
            : opts.delimiter,
        encode:
          typeof opts.encode === "boolean" ? opts.encode : defaults.encode,
        encoder:
          typeof opts.encoder === "function" ? opts.encoder : defaults.encoder,
        encodeValuesOnly:
          typeof opts.encodeValuesOnly === "boolean"
            ? opts.encodeValuesOnly
            : defaults.encodeValuesOnly,
        filter,
        format,
        formatter,
        serializeDate:
          typeof opts.serializeDate === "function"
            ? opts.serializeDate
            : defaults.serializeDate,
        skipNulls:
          typeof opts.skipNulls === "boolean"
            ? opts.skipNulls
            : defaults.skipNulls,
        sort: typeof opts.sort === "function" ? opts.sort : null,
        strictNullHandling:
          typeof opts.strictNullHandling === "boolean"
            ? opts.strictNullHandling
            : defaults.strictNullHandling,
      };
    };
    module.exports = function (object, opts) {
      var obj = object;
      var options = normalizeStringifyOptions(opts);
      var objKeys;
      var filter;
      if (typeof options.filter === "function") {
        filter = options.filter;
        obj = filter("", obj);
      } else if (isArray(options.filter)) {
        filter = options.filter;
        objKeys = filter;
      }
      var keys = [];
      if (typeof obj !== "object" || obj === null) {
        return "";
      }
      var arrayFormat;
      if (opts && opts.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = opts.arrayFormat;
      } else if (opts && "indices" in opts) {
        arrayFormat = opts.indices ? "indices" : "repeat";
      } else {
        arrayFormat = "indices";
      }
      var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];
      if (!objKeys) {
        objKeys = Object.keys(obj);
      }
      if (options.sort) {
        objKeys.sort(options.sort);
      }
      var sideChannel = getSideChannel();
      for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];
        if (options.skipNulls && obj[key] === null) {
          continue;
        }
        pushToArray(
          keys,
          stringify(
            obj[key],
            key,
            generateArrayPrefix,
            options.strictNullHandling,
            options.skipNulls,
            options.encode ? options.encoder : null,
            options.filter,
            options.sort,
            options.allowDots,
            options.serializeDate,
            options.format,
            options.formatter,
            options.encodeValuesOnly,
            options.charset,
            sideChannel
          )
        );
      }
      var joined = keys.join(options.delimiter);
      var prefix = options.addQueryPrefix === true ? "?" : "";
      if (options.charsetSentinel) {
        if (options.charset === "iso-8859-1") {
          prefix += "utf8=%26%2310003%3B&";
        } else {
          prefix += "utf8=%E2%9C%93&";
        }
      }
      return joined.length > 0 ? prefix + joined : "";
    };
  },
});

// node_modules/qs/lib/parse.js
var require_parse = __commonJS({
  "node_modules/qs/lib/parse.js"(exports, module) {
    var utils = require_utils$2();
    var has = Object.prototype.hasOwnProperty;
    var isArray = Array.isArray;
    var defaults = {
      allowDots: false,
      allowPrototypes: false,
      allowSparse: false,
      arrayLimit: 20,
      charset: "utf-8",
      charsetSentinel: false,
      comma: false,
      decoder: utils.decode,
      delimiter: "&",
      depth: 5,
      ignoreQueryPrefix: false,
      interpretNumericEntities: false,
      parameterLimit: 1e3,
      parseArrays: true,
      plainObjects: false,
      strictNullHandling: false,
    };
    var interpretNumericEntities = function (str) {
      return str.replace(/&#(\d+);/g, function ($0, numberStr) {
        return String.fromCharCode(parseInt(numberStr, 10));
      });
    };
    var parseArrayValue = function (val, options) {
      if (
        val &&
        typeof val === "string" &&
        options.comma &&
        val.indexOf(",") > -1
      ) {
        return val.split(",");
      }
      return val;
    };
    var isoSentinel = "utf8=%26%2310003%3B";
    var charsetSentinel = "utf8=%E2%9C%93";
    var parseValues = function parseQueryStringValues(str, options) {
      var obj = {};
      var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
      var limit =
        options.parameterLimit === Infinity ? void 0 : options.parameterLimit;
      var parts = cleanStr.split(options.delimiter, limit);
      var skipIndex = -1;
      var i;
      var charset = options.charset;
      if (options.charsetSentinel) {
        for (i = 0; i < parts.length; ++i) {
          if (parts[i].indexOf("utf8=") === 0) {
            if (parts[i] === charsetSentinel) {
              charset = "utf-8";
            } else if (parts[i] === isoSentinel) {
              charset = "iso-8859-1";
            }
            skipIndex = i;
            i = parts.length;
          }
        }
      }
      for (i = 0; i < parts.length; ++i) {
        if (i === skipIndex) {
          continue;
        }
        var part = parts[i];
        var bracketEqualsPos = part.indexOf("]=");
        var pos =
          bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
        var key, val;
        if (pos === -1) {
          key = options.decoder(part, defaults.decoder, charset, "key");
          val = options.strictNullHandling ? null : "";
        } else {
          key = options.decoder(
            part.slice(0, pos),
            defaults.decoder,
            charset,
            "key"
          );
          val = utils.maybeMap(
            parseArrayValue(part.slice(pos + 1), options),
            function (encodedVal) {
              return options.decoder(
                encodedVal,
                defaults.decoder,
                charset,
                "value"
              );
            }
          );
        }
        if (
          val &&
          options.interpretNumericEntities &&
          charset === "iso-8859-1"
        ) {
          val = interpretNumericEntities(val);
        }
        if (part.indexOf("[]=") > -1) {
          val = isArray(val) ? [val] : val;
        }
        if (has.call(obj, key)) {
          obj[key] = utils.combine(obj[key], val);
        } else {
          obj[key] = val;
        }
      }
      return obj;
    };
    var parseObject = function (chain, val, options, valuesParsed) {
      var leaf = valuesParsed ? val : parseArrayValue(val, options);
      for (var i = chain.length - 1; i >= 0; --i) {
        var obj;
        var root = chain[i];
        if (root === "[]" && options.parseArrays) {
          obj = [].concat(leaf);
        } else {
          obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
          var cleanRoot =
            root.charAt(0) === "[" && root.charAt(root.length - 1) === "]"
              ? root.slice(1, -1)
              : root;
          var index = parseInt(cleanRoot, 10);
          if (!options.parseArrays && cleanRoot === "") {
            obj = { 0: leaf };
          } else if (
            !isNaN(index) &&
            root !== cleanRoot &&
            String(index) === cleanRoot &&
            index >= 0 &&
            options.parseArrays &&
            index <= options.arrayLimit
          ) {
            obj = [];
            obj[index] = leaf;
          } else if (cleanRoot !== "__proto__") {
            obj[cleanRoot] = leaf;
          }
        }
        leaf = obj;
      }
      return leaf;
    };
    var parseKeys = function parseQueryStringKeys(
      givenKey,
      val,
      options,
      valuesParsed
    ) {
      if (!givenKey) {
        return;
      }
      var key = options.allowDots
        ? givenKey.replace(/\.([^.[]+)/g, "[$1]")
        : givenKey;
      var brackets = /(\[[^[\]]*])/;
      var child = /(\[[^[\]]*])/g;
      var segment = options.depth > 0 && brackets.exec(key);
      var parent = segment ? key.slice(0, segment.index) : key;
      var keys = [];
      if (parent) {
        if (!options.plainObjects && has.call(Object.prototype, parent)) {
          if (!options.allowPrototypes) {
            return;
          }
        }
        keys.push(parent);
      }
      var i = 0;
      while (
        options.depth > 0 &&
        (segment = child.exec(key)) !== null &&
        i < options.depth
      ) {
        i += 1;
        if (
          !options.plainObjects &&
          has.call(Object.prototype, segment[1].slice(1, -1))
        ) {
          if (!options.allowPrototypes) {
            return;
          }
        }
        keys.push(segment[1]);
      }
      if (segment) {
        keys.push("[" + key.slice(segment.index) + "]");
      }
      return parseObject(keys, val, options, valuesParsed);
    };
    var normalizeParseOptions = function normalizeParseOptions2(opts) {
      if (!opts) {
        return defaults;
      }
      if (
        opts.decoder !== null &&
        opts.decoder !== void 0 &&
        typeof opts.decoder !== "function"
      ) {
        throw new TypeError("Decoder has to be a function.");
      }
      if (
        typeof opts.charset !== "undefined" &&
        opts.charset !== "utf-8" &&
        opts.charset !== "iso-8859-1"
      ) {
        throw new TypeError(
          "The charset option must be either utf-8, iso-8859-1, or undefined"
        );
      }
      var charset =
        typeof opts.charset === "undefined" ? defaults.charset : opts.charset;
      return {
        allowDots:
          typeof opts.allowDots === "undefined"
            ? defaults.allowDots
            : !!opts.allowDots,
        allowPrototypes:
          typeof opts.allowPrototypes === "boolean"
            ? opts.allowPrototypes
            : defaults.allowPrototypes,
        allowSparse:
          typeof opts.allowSparse === "boolean"
            ? opts.allowSparse
            : defaults.allowSparse,
        arrayLimit:
          typeof opts.arrayLimit === "number"
            ? opts.arrayLimit
            : defaults.arrayLimit,
        charset,
        charsetSentinel:
          typeof opts.charsetSentinel === "boolean"
            ? opts.charsetSentinel
            : defaults.charsetSentinel,
        comma: typeof opts.comma === "boolean" ? opts.comma : defaults.comma,
        decoder:
          typeof opts.decoder === "function" ? opts.decoder : defaults.decoder,
        delimiter:
          typeof opts.delimiter === "string" || utils.isRegExp(opts.delimiter)
            ? opts.delimiter
            : defaults.delimiter,
        // eslint-disable-next-line no-implicit-coercion, no-extra-parens
        depth:
          typeof opts.depth === "number" || opts.depth === false
            ? +opts.depth
            : defaults.depth,
        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
        interpretNumericEntities:
          typeof opts.interpretNumericEntities === "boolean"
            ? opts.interpretNumericEntities
            : defaults.interpretNumericEntities,
        parameterLimit:
          typeof opts.parameterLimit === "number"
            ? opts.parameterLimit
            : defaults.parameterLimit,
        parseArrays: opts.parseArrays !== false,
        plainObjects:
          typeof opts.plainObjects === "boolean"
            ? opts.plainObjects
            : defaults.plainObjects,
        strictNullHandling:
          typeof opts.strictNullHandling === "boolean"
            ? opts.strictNullHandling
            : defaults.strictNullHandling,
      };
    };
    module.exports = function (str, opts) {
      var options = normalizeParseOptions(opts);
      if (str === "" || str === null || typeof str === "undefined") {
        return options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      }
      var tempObj = typeof str === "string" ? parseValues(str, options) : str;
      var obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      var keys = Object.keys(tempObj);
      for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        var newObj = parseKeys(
          key,
          tempObj[key],
          options,
          typeof str === "string"
        );
        obj = utils.merge(obj, newObj, options);
      }
      if (options.allowSparse === true) {
        return obj;
      }
      return utils.compact(obj);
    };
  },
});

// node_modules/qs/lib/index.js
var require_lib$1 = __commonJS({
  "node_modules/qs/lib/index.js"(exports, module) {
    var stringify = require_stringify();
    var parse = require_parse();
    var formats = require_formats$1();
    module.exports = {
      formats,
      parse,
      stringify,
    };
  },
});

// browser-external:semver
var require_semver = __commonJS({
  "browser-external:semver"(exports, module) {
    module.exports = {};
  },
});

// node_modules/superagent/lib/utils.js
var require_utils2$1 = __commonJS({
  "node_modules/superagent/lib/utils.js"(exports) {
    function _typeof(obj) {
      "@babel/helpers - typeof";
      return (
        (_typeof =
          "function" == typeof Symbol && "symbol" == typeof Symbol.iterator
            ? function (obj2) {
                return typeof obj2;
              }
            : function (obj2) {
                return obj2 &&
                  "function" == typeof Symbol &&
                  obj2.constructor === Symbol &&
                  obj2 !== Symbol.prototype
                  ? "symbol"
                  : typeof obj2;
              }),
        _typeof(obj)
      );
    }
    function _createForOfIteratorHelper(o, allowArrayLike) {
      var it =
        (typeof Symbol !== "undefined" && o[Symbol.iterator]) ||
        o["@@iterator"];
      if (!it) {
        if (
          Array.isArray(o) ||
          (it = _unsupportedIterableToArray(o)) ||
          (allowArrayLike && o && typeof o.length === "number")
        ) {
          if (it) o = it;
          var i = 0;
          var F = function F2() {};
          return {
            s: F,
            n: function n() {
              if (i >= o.length) return { done: true };
              return { done: false, value: o[i++] };
            },
            e: function e(_e) {
              throw _e;
            },
            f: F,
          };
        }
        throw new TypeError(
          "Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
        );
      }
      var normalCompletion = true,
        didErr = false,
        err;
      return {
        s: function s() {
          it = it.call(o);
        },
        n: function n() {
          var step = it.next();
          normalCompletion = step.done;
          return step;
        },
        e: function e(_e2) {
          didErr = true;
          err = _e2;
        },
        f: function f() {
          try {
            if (!normalCompletion && it.return != null) it.return();
          } finally {
            if (didErr) throw err;
          }
        },
      };
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (
        n === "Arguments" ||
        /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
      )
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    exports.type = function (string_) {
      return string_.split(/ *; */).shift();
    };
    exports.params = function (value) {
      var object = {};
      var _iterator = _createForOfIteratorHelper(value.split(/ *; */)),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var string_ = _step.value;
          var parts = string_.split(/ *= */);
          var key = parts.shift();
          var _value = parts.shift();
          if (key && _value) object[key] = _value;
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return object;
    };
    exports.parseLinks = function (value) {
      var object = {};
      var _iterator2 = _createForOfIteratorHelper(value.split(/ *, */)),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
          var string_ = _step2.value;
          var parts = string_.split(/ *; */);
          var url = parts[0].slice(1, -1);
          var rel = parts[1].split(/ *= */)[1].slice(1, -1);
          object[rel] = url;
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      return object;
    };
    exports.cleanHeader = function (header, changesOrigin) {
      delete header["content-type"];
      delete header["content-length"];
      delete header["transfer-encoding"];
      delete header.host;
      if (changesOrigin) {
        delete header.authorization;
        delete header.cookie;
      }
      return header;
    };
    exports.isObject = function (object) {
      return object !== null && _typeof(object) === "object";
    };
    exports.hasOwn =
      Object.hasOwn ||
      function (object, property) {
        if (object == null) {
          throw new TypeError("Cannot convert undefined or null to object");
        }
        return Object.prototype.hasOwnProperty.call(
          new Object(object),
          property
        );
      };
    exports.mixin = function (target, source) {
      for (var key in source) {
        if (exports.hasOwn(source, key)) {
          target[key] = source[key];
        }
      }
    };
  },
});

// node_modules/superagent/lib/request-base.js
var require_request_base = __commonJS({
  "node_modules/superagent/lib/request-base.js"(exports, module) {
    function _typeof(obj) {
      "@babel/helpers - typeof";
      return (
        (_typeof =
          "function" == typeof Symbol && "symbol" == typeof Symbol.iterator
            ? function (obj2) {
                return typeof obj2;
              }
            : function (obj2) {
                return obj2 &&
                  "function" == typeof Symbol &&
                  obj2.constructor === Symbol &&
                  obj2 !== Symbol.prototype
                  ? "symbol"
                  : typeof obj2;
              }),
        _typeof(obj)
      );
    }
    var semver = require_semver();
    var _require = require_utils2$1();
    var isObject = _require.isObject;
    var hasOwn = _require.hasOwn;
    module.exports = RequestBase;
    function RequestBase() {}
    RequestBase.prototype.clearTimeout = function () {
      clearTimeout(this._timer);
      clearTimeout(this._responseTimeoutTimer);
      clearTimeout(this._uploadTimeoutTimer);
      delete this._timer;
      delete this._responseTimeoutTimer;
      delete this._uploadTimeoutTimer;
      return this;
    };
    RequestBase.prototype.parse = function (fn) {
      this._parser = fn;
      return this;
    };
    RequestBase.prototype.responseType = function (value) {
      this._responseType = value;
      return this;
    };
    RequestBase.prototype.serialize = function (fn) {
      this._serializer = fn;
      return this;
    };
    RequestBase.prototype.timeout = function (options) {
      if (!options || _typeof(options) !== "object") {
        this._timeout = options;
        this._responseTimeout = 0;
        this._uploadTimeout = 0;
        return this;
      }
      for (var option in options) {
        if (hasOwn(options, option)) {
          switch (option) {
            case "deadline":
              this._timeout = options.deadline;
              break;
            case "response":
              this._responseTimeout = options.response;
              break;
            case "upload":
              this._uploadTimeout = options.upload;
              break;
            default:
              console.warn("Unknown timeout option", option);
          }
        }
      }
      return this;
    };
    RequestBase.prototype.retry = function (count, fn) {
      if (arguments.length === 0 || count === true) count = 1;
      if (count <= 0) count = 0;
      this._maxRetries = count;
      this._retries = 0;
      this._retryCallback = fn;
      return this;
    };
    var ERROR_CODES = /* @__PURE__ */ new Set([
      "ETIMEDOUT",
      "ECONNRESET",
      "EADDRINUSE",
      "ECONNREFUSED",
      "EPIPE",
      "ENOTFOUND",
      "ENETUNREACH",
      "EAI_AGAIN",
    ]);
    var STATUS_CODES = /* @__PURE__ */ new Set([
      408, 413, 429, 500, 502, 503, 504, 521, 522, 524,
    ]);
    RequestBase.prototype._shouldRetry = function (error, res) {
      if (!this._maxRetries || this._retries++ >= this._maxRetries) {
        return false;
      }
      if (this._retryCallback) {
        try {
          var override = this._retryCallback(error, res);
          if (override === true) return true;
          if (override === false) return false;
        } catch (error_) {
          console.error(error_);
        }
      }
      if (res && res.status && STATUS_CODES.has(res.status)) return true;
      if (error) {
        if (error.code && ERROR_CODES.has(error.code)) return true;
        if (error.timeout && error.code === "ECONNABORTED") return true;
        if (error.crossDomain) return true;
      }
      return false;
    };
    RequestBase.prototype._retry = function () {
      this.clearTimeout();
      if (this.req) {
        this.req = null;
        this.req = this.request();
      }
      this._aborted = false;
      this.timedout = false;
      this.timedoutError = null;
      return this._end();
    };
    RequestBase.prototype.then = function (resolve, reject) {
      var _this = this;
      if (!this._fullfilledPromise) {
        var self2 = this;
        if (this._endCalled) {
          console.warn(
            "Warning: superagent request was sent twice, because both .end() and .then() were called. Never call .end() if you use promises"
          );
        }
        this._fullfilledPromise = new Promise(function (resolve2, reject2) {
          self2.on("abort", function () {
            if (_this._maxRetries && _this._maxRetries > _this._retries) {
              return;
            }
            if (_this.timedout && _this.timedoutError) {
              reject2(_this.timedoutError);
              return;
            }
            var error = new Error("Aborted");
            error.code = "ABORTED";
            error.status = _this.status;
            error.method = _this.method;
            error.url = _this.url;
            reject2(error);
          });
          self2.end(function (error, res) {
            if (error) reject2(error);
            else resolve2(res);
          });
        });
      }
      return this._fullfilledPromise.then(resolve, reject);
    };
    RequestBase.prototype.catch = function (cb) {
      return this.then(void 0, cb);
    };
    RequestBase.prototype.use = function (fn) {
      fn(this);
      return this;
    };
    RequestBase.prototype.ok = function (cb) {
      if (typeof cb !== "function") throw new Error("Callback required");
      this._okCallback = cb;
      return this;
    };
    RequestBase.prototype._isResponseOK = function (res) {
      if (!res) {
        return false;
      }
      if (this._okCallback) {
        return this._okCallback(res);
      }
      return res.status >= 200 && res.status < 300;
    };
    RequestBase.prototype.get = function (field) {
      return this._header[field.toLowerCase()];
    };
    RequestBase.prototype.getHeader = RequestBase.prototype.get;
    RequestBase.prototype.set = function (field, value) {
      if (isObject(field)) {
        for (var key in field) {
          if (hasOwn(field, key)) this.set(key, field[key]);
        }
        return this;
      }
      this._header[field.toLowerCase()] = value;
      this.header[field] = value;
      return this;
    };
    RequestBase.prototype.unset = function (field) {
      delete this._header[field.toLowerCase()];
      delete this.header[field];
      return this;
    };
    RequestBase.prototype.field = function (name, value, options) {
      if (name === null || void 0 === name) {
        throw new Error(".field(name, val) name can not be empty");
      }
      if (this._data) {
        throw new Error(
          ".field() can't be used if .send() is used. Please use only .send() or only .field() & .attach()"
        );
      }
      if (isObject(name)) {
        for (var key in name) {
          if (hasOwn(name, key)) this.field(key, name[key]);
        }
        return this;
      }
      if (Array.isArray(value)) {
        for (var i in value) {
          if (hasOwn(value, i)) this.field(name, value[i]);
        }
        return this;
      }
      if (value === null || void 0 === value) {
        throw new Error(".field(name, val) val can not be empty");
      }
      if (typeof value === "boolean") {
        value = String(value);
      }
      this._getFormData().append(name, value, options);
      return this;
    };
    RequestBase.prototype.abort = function () {
      if (this._aborted) {
        return this;
      }
      this._aborted = true;
      if (this.xhr) this.xhr.abort();
      if (this.req) {
        if (
          semver.gte(process.version, "v13.0.0") &&
          semver.lt(process.version, "v14.0.0")
        ) {
          throw new Error(
            "Superagent does not work in v13 properly with abort() due to Node.js core changes"
          );
        } else if (semver.gte(process.version, "v14.0.0")) {
          this.req.destroyed = true;
        }
        this.req.abort();
      }
      this.clearTimeout();
      this.emit("abort");
      return this;
    };
    RequestBase.prototype._auth = function (
      user,
      pass,
      options,
      base64Encoder
    ) {
      switch (options.type) {
        case "basic":
          this.set(
            "Authorization",
            "Basic ".concat(base64Encoder("".concat(user, ":").concat(pass)))
          );
          break;
        case "auto":
          this.username = user;
          this.password = pass;
          break;
        case "bearer":
          this.set("Authorization", "Bearer ".concat(user));
          break;
      }
      return this;
    };
    RequestBase.prototype.withCredentials = function (on) {
      if (on === void 0) on = true;
      this._withCredentials = on;
      return this;
    };
    RequestBase.prototype.redirects = function (n) {
      this._maxRedirects = n;
      return this;
    };
    RequestBase.prototype.maxResponseSize = function (n) {
      if (typeof n !== "number") {
        throw new TypeError("Invalid argument");
      }
      this._maxResponseSize = n;
      return this;
    };
    RequestBase.prototype.toJSON = function () {
      return {
        method: this.method,
        url: this.url,
        data: this._data,
        headers: this._header,
      };
    };
    RequestBase.prototype.send = function (data) {
      var isObject_ = isObject(data);
      var type = this._header["content-type"];
      if (this._formData) {
        throw new Error(
          ".send() can't be used if .attach() or .field() is used. Please use only .send() or only .field() & .attach()"
        );
      }
      if (isObject_ && !this._data) {
        if (Array.isArray(data)) {
          this._data = [];
        } else if (!this._isHost(data)) {
          this._data = {};
        }
      } else if (data && this._data && this._isHost(this._data)) {
        throw new Error("Can't merge these send calls");
      }
      if (isObject_ && isObject(this._data)) {
        for (var key in data) {
          if (hasOwn(data, key)) this._data[key] = data[key];
        }
      } else if (typeof data === "string") {
        if (!type) this.type("form");
        type = this._header["content-type"];
        if (type) type = type.toLowerCase().trim();
        if (type === "application/x-www-form-urlencoded") {
          this._data = this._data
            ? "".concat(this._data, "&").concat(data)
            : data;
        } else {
          this._data = (this._data || "") + data;
        }
      } else {
        this._data = data;
      }
      if (!isObject_ || this._isHost(data)) {
        return this;
      }
      if (!type) this.type("json");
      return this;
    };
    RequestBase.prototype.sortQuery = function (sort) {
      this._sort = typeof sort === "undefined" ? true : sort;
      return this;
    };
    RequestBase.prototype._finalizeQueryString = function () {
      var query = this._query.join("&");
      if (query) {
        this.url += (this.url.includes("?") ? "&" : "?") + query;
      }
      this._query.length = 0;
      if (this._sort) {
        var index = this.url.indexOf("?");
        if (index >= 0) {
          var queryArray = this.url.slice(index + 1).split("&");
          if (typeof this._sort === "function") {
            queryArray.sort(this._sort);
          } else {
            queryArray.sort();
          }
          this.url = this.url.slice(0, index) + "?" + queryArray.join("&");
        }
      }
    };
    RequestBase.prototype._appendQueryString = function () {
      console.warn("Unsupported");
    };
    RequestBase.prototype._timeoutError = function (reason, timeout, errno) {
      if (this._aborted) {
        return;
      }
      var error = new Error("".concat(reason + timeout, "ms exceeded"));
      error.timeout = timeout;
      error.code = "ECONNABORTED";
      error.errno = errno;
      this.timedout = true;
      this.timedoutError = error;
      this.abort();
      this.callback(error);
    };
    RequestBase.prototype._setTimeouts = function () {
      var self2 = this;
      if (this._timeout && !this._timer) {
        this._timer = setTimeout(function () {
          self2._timeoutError("Timeout of ", self2._timeout, "ETIME");
        }, this._timeout);
      }
      if (this._responseTimeout && !this._responseTimeoutTimer) {
        this._responseTimeoutTimer = setTimeout(function () {
          self2._timeoutError(
            "Response timeout of ",
            self2._responseTimeout,
            "ETIMEDOUT"
          );
        }, this._responseTimeout);
      }
    };
  },
});

// node_modules/superagent/lib/response-base.js
var require_response_base = __commonJS({
  "node_modules/superagent/lib/response-base.js"(exports, module) {
    var utils = require_utils2$1();
    module.exports = ResponseBase;
    function ResponseBase() {}
    ResponseBase.prototype.get = function (field) {
      return this.header[field.toLowerCase()];
    };
    ResponseBase.prototype._setHeaderProperties = function (header) {
      var ct = header["content-type"] || "";
      this.type = utils.type(ct);
      var parameters = utils.params(ct);
      for (var key in parameters) {
        if (Object.prototype.hasOwnProperty.call(parameters, key))
          this[key] = parameters[key];
      }
      this.links = {};
      try {
        if (header.link) {
          this.links = utils.parseLinks(header.link);
        }
      } catch (_unused) {}
    };
    ResponseBase.prototype._setStatusProperties = function (status) {
      var type = Math.trunc(status / 100);
      this.statusCode = status;
      this.status = this.statusCode;
      this.statusType = type;
      this.info = type === 1;
      this.ok = type === 2;
      this.redirect = type === 3;
      this.clientError = type === 4;
      this.serverError = type === 5;
      this.error = type === 4 || type === 5 ? this.toError() : false;
      this.created = status === 201;
      this.accepted = status === 202;
      this.noContent = status === 204;
      this.badRequest = status === 400;
      this.unauthorized = status === 401;
      this.notAcceptable = status === 406;
      this.forbidden = status === 403;
      this.notFound = status === 404;
      this.unprocessableEntity = status === 422;
    };
  },
});

// node_modules/superagent/lib/agent-base.js
var require_agent_base = __commonJS({
  "node_modules/superagent/lib/agent-base.js"(exports, module) {
    function _toConsumableArray(arr) {
      return (
        _arrayWithoutHoles(arr) ||
        _iterableToArray(arr) ||
        _unsupportedIterableToArray(arr) ||
        _nonIterableSpread()
      );
    }
    function _nonIterableSpread() {
      throw new TypeError(
        "Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
      );
    }
    function _iterableToArray(iter) {
      if (
        (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null) ||
        iter["@@iterator"] != null
      )
        return Array.from(iter);
    }
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr)) return _arrayLikeToArray(arr);
    }
    function _createForOfIteratorHelper(o, allowArrayLike) {
      var it =
        (typeof Symbol !== "undefined" && o[Symbol.iterator]) ||
        o["@@iterator"];
      if (!it) {
        if (
          Array.isArray(o) ||
          (it = _unsupportedIterableToArray(o)) ||
          (allowArrayLike && o && typeof o.length === "number")
        ) {
          if (it) o = it;
          var i = 0;
          var F = function F2() {};
          return {
            s: F,
            n: function n() {
              if (i >= o.length) return { done: true };
              return { done: false, value: o[i++] };
            },
            e: function e(_e) {
              throw _e;
            },
            f: F,
          };
        }
        throw new TypeError(
          "Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
        );
      }
      var normalCompletion = true,
        didErr = false,
        err;
      return {
        s: function s() {
          it = it.call(o);
        },
        n: function n() {
          var step = it.next();
          normalCompletion = step.done;
          return step;
        },
        e: function e(_e2) {
          didErr = true;
          err = _e2;
        },
        f: function f() {
          try {
            if (!normalCompletion && it.return != null) it.return();
          } finally {
            if (didErr) throw err;
          }
        },
      };
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (
        n === "Arguments" ||
        /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
      )
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    function Agent() {
      this._defaults = [];
    }
    var _loop = function _loop2() {
      var fn = _arr[_i];
      Agent.prototype[fn] = function () {
        for (
          var _len = arguments.length, args = new Array(_len), _key = 0;
          _key < _len;
          _key++
        ) {
          args[_key] = arguments[_key];
        }
        this._defaults.push({
          fn,
          args,
        });
        return this;
      };
    };
    for (
      _i = 0,
        _arr = [
          "use",
          "on",
          "once",
          "set",
          "query",
          "type",
          "accept",
          "auth",
          "withCredentials",
          "sortQuery",
          "retry",
          "ok",
          "redirects",
          "timeout",
          "buffer",
          "serialize",
          "parse",
          "ca",
          "key",
          "pfx",
          "cert",
          "disableTLSCerts",
        ];
      _i < _arr.length;
      _i++
    ) {
      _loop();
    }
    var _i;
    var _arr;
    Agent.prototype._setDefaults = function (request) {
      var _iterator = _createForOfIteratorHelper(this._defaults),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var def = _step.value;
          request[def.fn].apply(request, _toConsumableArray(def.args));
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    };
    module.exports = Agent;
  },
});

// node_modules/superagent/lib/client.js
var require_client$1 = __commonJS({
  "node_modules/superagent/lib/client.js"(exports, module) {
    function _typeof(obj) {
      "@babel/helpers - typeof";
      return (
        (_typeof =
          "function" == typeof Symbol && "symbol" == typeof Symbol.iterator
            ? function (obj2) {
                return typeof obj2;
              }
            : function (obj2) {
                return obj2 &&
                  "function" == typeof Symbol &&
                  obj2.constructor === Symbol &&
                  obj2 !== Symbol.prototype
                  ? "symbol"
                  : typeof obj2;
              }),
        _typeof(obj)
      );
    }
    function _createForOfIteratorHelper(o, allowArrayLike) {
      var it =
        (typeof Symbol !== "undefined" && o[Symbol.iterator]) ||
        o["@@iterator"];
      if (!it) {
        if (
          Array.isArray(o) ||
          (it = _unsupportedIterableToArray(o)) ||
          (allowArrayLike && o && typeof o.length === "number")
        ) {
          if (it) o = it;
          var i = 0;
          var F = function F2() {};
          return {
            s: F,
            n: function n() {
              if (i >= o.length) return { done: true };
              return { done: false, value: o[i++] };
            },
            e: function e(_e) {
              throw _e;
            },
            f: F,
          };
        }
        throw new TypeError(
          "Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
        );
      }
      var normalCompletion = true,
        didErr = false,
        err;
      return {
        s: function s() {
          it = it.call(o);
        },
        n: function n() {
          var step = it.next();
          normalCompletion = step.done;
          return step;
        },
        e: function e(_e2) {
          didErr = true;
          err = _e2;
        },
        f: function f() {
          try {
            if (!normalCompletion && it.return != null) it.return();
          } finally {
            if (didErr) throw err;
          }
        },
      };
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (
        n === "Arguments" ||
        /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
      )
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    var root;
    if (typeof window !== "undefined") {
      root = window;
    } else if (typeof self === "undefined") {
      console.warn(
        "Using browser-only version of superagent in non-browser environment"
      );
      root = void 0;
    } else {
      root = self;
    }
    var Emitter = require_component_emitter();
    var safeStringify = require_fast_safe_stringify();
    var qs = require_lib$1();
    var RequestBase = require_request_base();
    var _require = require_utils2$1();
    var isObject = _require.isObject;
    var mixin = _require.mixin;
    var hasOwn = _require.hasOwn;
    var ResponseBase = require_response_base();
    var Agent = require_agent_base();
    function noop() {}
    module.exports = function (method, url) {
      if (typeof url === "function") {
        return new exports.Request("GET", method).end(url);
      }
      if (arguments.length === 1) {
        return new exports.Request("GET", method);
      }
      return new exports.Request(method, url);
    };
    exports = module.exports;
    var request = exports;
    exports.Request = Request;
    request.getXHR = function () {
      if (
        root.XMLHttpRequest &&
        (!root.location ||
          root.location.protocol !== "file:" ||
          !root.ActiveXObject)
      ) {
        return new XMLHttpRequest();
      }
      try {
        return new ActiveXObject("Microsoft.XMLHTTP");
      } catch (_unused) {}
      try {
        return new ActiveXObject("Msxml2.XMLHTTP.6.0");
      } catch (_unused2) {}
      try {
        return new ActiveXObject("Msxml2.XMLHTTP.3.0");
      } catch (_unused3) {}
      try {
        return new ActiveXObject("Msxml2.XMLHTTP");
      } catch (_unused4) {}
      throw new Error("Browser-only version of superagent could not find XHR");
    };
    var trim = "".trim
      ? function (s) {
          return s.trim();
        }
      : function (s) {
          return s.replace(/(^\s*|\s*$)/g, "");
        };
    function serialize(object) {
      if (!isObject(object)) return object;
      var pairs = [];
      for (var key in object) {
        if (hasOwn(object, key))
          pushEncodedKeyValuePair(pairs, key, object[key]);
      }
      return pairs.join("&");
    }
    function pushEncodedKeyValuePair(pairs, key, value) {
      if (value === void 0) return;
      if (value === null) {
        pairs.push(encodeURI(key));
        return;
      }
      if (Array.isArray(value)) {
        var _iterator = _createForOfIteratorHelper(value),
          _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var v = _step.value;
            pushEncodedKeyValuePair(pairs, key, v);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      } else if (isObject(value)) {
        for (var subkey in value) {
          if (hasOwn(value, subkey))
            pushEncodedKeyValuePair(
              pairs,
              "".concat(key, "[").concat(subkey, "]"),
              value[subkey]
            );
        }
      } else {
        pairs.push(encodeURI(key) + "=" + encodeURIComponent(value));
      }
    }
    request.serializeObject = serialize;
    function parseString(string_) {
      var object = {};
      var pairs = string_.split("&");
      var pair;
      var pos;
      for (var i = 0, length_ = pairs.length; i < length_; ++i) {
        pair = pairs[i];
        pos = pair.indexOf("=");
        if (pos === -1) {
          object[decodeURIComponent(pair)] = "";
        } else {
          object[decodeURIComponent(pair.slice(0, pos))] = decodeURIComponent(
            pair.slice(pos + 1)
          );
        }
      }
      return object;
    }
    request.parseString = parseString;
    request.types = {
      html: "text/html",
      json: "application/json",
      xml: "text/xml",
      urlencoded: "application/x-www-form-urlencoded",
      form: "application/x-www-form-urlencoded",
      "form-data": "application/x-www-form-urlencoded",
    };
    request.serialize = {
      "application/x-www-form-urlencoded": qs.stringify,
      "application/json": safeStringify,
    };
    request.parse = {
      "application/x-www-form-urlencoded": parseString,
      "application/json": JSON.parse,
    };
    function parseHeader(string_) {
      var lines = string_.split(/\r?\n/);
      var fields = {};
      var index;
      var line;
      var field;
      var value;
      for (var i = 0, length_ = lines.length; i < length_; ++i) {
        line = lines[i];
        index = line.indexOf(":");
        if (index === -1) {
          continue;
        }
        field = line.slice(0, index).toLowerCase();
        value = trim(line.slice(index + 1));
        fields[field] = value;
      }
      return fields;
    }
    function isJSON(mime) {
      return /[/+]json($|[^-\w])/i.test(mime);
    }
    function Response(request_) {
      this.req = request_;
      this.xhr = this.req.xhr;
      this.text =
        (this.req.method !== "HEAD" &&
          (this.xhr.responseType === "" || this.xhr.responseType === "text")) ||
        typeof this.xhr.responseType === "undefined"
          ? this.xhr.responseText
          : null;
      this.statusText = this.req.xhr.statusText;
      var status = this.xhr.status;
      if (status === 1223) {
        status = 204;
      }
      this._setStatusProperties(status);
      this.headers = parseHeader(this.xhr.getAllResponseHeaders());
      this.header = this.headers;
      this.header["content-type"] = this.xhr.getResponseHeader("content-type");
      this._setHeaderProperties(this.header);
      if (this.text === null && request_._responseType) {
        this.body = this.xhr.response;
      } else {
        this.body =
          this.req.method === "HEAD"
            ? null
            : this._parseBody(this.text ? this.text : this.xhr.response);
      }
    }
    mixin(Response.prototype, ResponseBase.prototype);
    Response.prototype._parseBody = function (string_) {
      var parse = request.parse[this.type];
      if (this.req._parser) {
        return this.req._parser(this, string_);
      }
      if (!parse && isJSON(this.type)) {
        parse = request.parse["application/json"];
      }
      return parse &&
        string_ &&
        (string_.length > 0 || string_ instanceof Object)
        ? parse(string_)
        : null;
    };
    Response.prototype.toError = function () {
      var req = this.req;
      var method = req.method;
      var url = req.url;
      var message = "cannot "
        .concat(method, " ")
        .concat(url, " (")
        .concat(this.status, ")");
      var error = new Error(message);
      error.status = this.status;
      error.method = method;
      error.url = url;
      return error;
    };
    request.Response = Response;
    function Request(method, url) {
      var self2 = this;
      this._query = this._query || [];
      this.method = method;
      this.url = url;
      this.header = {};
      this._header = {};
      this.on("end", function () {
        var error = null;
        var res = null;
        try {
          res = new Response(self2);
        } catch (error_) {
          error = new Error("Parser is unable to parse the response");
          error.parse = true;
          error.original = error_;
          if (self2.xhr) {
            error.rawResponse =
              typeof self2.xhr.responseType === "undefined"
                ? self2.xhr.responseText
                : self2.xhr.response;
            error.status = self2.xhr.status ? self2.xhr.status : null;
            error.statusCode = error.status;
          } else {
            error.rawResponse = null;
            error.status = null;
          }
          return self2.callback(error);
        }
        self2.emit("response", res);
        var new_error;
        try {
          if (!self2._isResponseOK(res)) {
            new_error = new Error(
              res.statusText || res.text || "Unsuccessful HTTP response"
            );
          }
        } catch (err) {
          new_error = err;
        }
        if (new_error) {
          new_error.original = error;
          new_error.response = res;
          new_error.status = res.status;
          self2.callback(new_error, res);
        } else {
          self2.callback(null, res);
        }
      });
    }
    Emitter(Request.prototype);
    mixin(Request.prototype, RequestBase.prototype);
    Request.prototype.type = function (type) {
      this.set("Content-Type", request.types[type] || type);
      return this;
    };
    Request.prototype.accept = function (type) {
      this.set("Accept", request.types[type] || type);
      return this;
    };
    Request.prototype.auth = function (user, pass, options) {
      if (arguments.length === 1) pass = "";
      if (_typeof(pass) === "object" && pass !== null) {
        options = pass;
        pass = "";
      }
      if (!options) {
        options = {
          type: typeof btoa === "function" ? "basic" : "auto",
        };
      }
      var encoder = function encoder2(string) {
        if (typeof btoa === "function") {
          return btoa(string);
        }
        throw new Error("Cannot use basic auth, btoa is not a function");
      };
      return this._auth(user, pass, options, encoder);
    };
    Request.prototype.query = function (value) {
      if (typeof value !== "string") value = serialize(value);
      if (value) this._query.push(value);
      return this;
    };
    Request.prototype.attach = function (field, file, options) {
      if (file) {
        if (this._data) {
          throw new Error("superagent can't mix .send() and .attach()");
        }
        this._getFormData().append(field, file, options || file.name);
      }
      return this;
    };
    Request.prototype._getFormData = function () {
      if (!this._formData) {
        this._formData = new root.FormData();
      }
      return this._formData;
    };
    Request.prototype.callback = function (error, res) {
      if (this._shouldRetry(error, res)) {
        return this._retry();
      }
      var fn = this._callback;
      this.clearTimeout();
      if (error) {
        if (this._maxRetries) error.retries = this._retries - 1;
        this.emit("error", error);
      }
      fn(error, res);
    };
    Request.prototype.crossDomainError = function () {
      var error = new Error(
        "Request has been terminated\nPossible causes: the network is offline, Origin is not allowed by Access-Control-Allow-Origin, the page is being unloaded, etc."
      );
      error.crossDomain = true;
      error.status = this.status;
      error.method = this.method;
      error.url = this.url;
      this.callback(error);
    };
    Request.prototype.agent = function () {
      console.warn("This is not supported in browser version of superagent");
      return this;
    };
    Request.prototype.ca = Request.prototype.agent;
    Request.prototype.buffer = Request.prototype.ca;
    Request.prototype.write = function () {
      throw new Error(
        "Streaming is not supported in browser version of superagent"
      );
    };
    Request.prototype.pipe = Request.prototype.write;
    Request.prototype._isHost = function (object) {
      return (
        object &&
        _typeof(object) === "object" &&
        !Array.isArray(object) &&
        Object.prototype.toString.call(object) !== "[object Object]"
      );
    };
    Request.prototype.end = function (fn) {
      if (this._endCalled) {
        console.warn(
          "Warning: .end() was called twice. This is not supported in superagent"
        );
      }
      this._endCalled = true;
      this._callback = fn || noop;
      this._finalizeQueryString();
      this._end();
    };
    Request.prototype._setUploadTimeout = function () {
      var self2 = this;
      if (this._uploadTimeout && !this._uploadTimeoutTimer) {
        this._uploadTimeoutTimer = setTimeout(function () {
          self2._timeoutError(
            "Upload timeout of ",
            self2._uploadTimeout,
            "ETIMEDOUT"
          );
        }, this._uploadTimeout);
      }
    };
    Request.prototype._end = function () {
      if (this._aborted)
        return this.callback(
          new Error(
            "The request has been aborted even before .end() was called"
          )
        );
      var self2 = this;
      this.xhr = request.getXHR();
      var xhr = this.xhr;
      var data = this._formData || this._data;
      this._setTimeouts();
      xhr.addEventListener("readystatechange", function () {
        var readyState = xhr.readyState;
        if (readyState >= 2 && self2._responseTimeoutTimer) {
          clearTimeout(self2._responseTimeoutTimer);
        }
        if (readyState !== 4) {
          return;
        }
        var status;
        try {
          status = xhr.status;
        } catch (_unused5) {
          status = 0;
        }
        if (!status) {
          if (self2.timedout || self2._aborted) return;
          return self2.crossDomainError();
        }
        self2.emit("end");
      });
      var handleProgress = function handleProgress2(direction, e) {
        if (e.total > 0) {
          e.percent = (e.loaded / e.total) * 100;
          if (e.percent === 100) {
            clearTimeout(self2._uploadTimeoutTimer);
          }
        }
        e.direction = direction;
        self2.emit("progress", e);
      };
      if (this.hasListeners("progress")) {
        try {
          xhr.addEventListener(
            "progress",
            handleProgress.bind(null, "download")
          );
          if (xhr.upload) {
            xhr.upload.addEventListener(
              "progress",
              handleProgress.bind(null, "upload")
            );
          }
        } catch (_unused6) {}
      }
      if (xhr.upload) {
        this._setUploadTimeout();
      }
      try {
        if (this.username && this.password) {
          xhr.open(this.method, this.url, true, this.username, this.password);
        } else {
          xhr.open(this.method, this.url, true);
        }
      } catch (err) {
        return this.callback(err);
      }
      if (this._withCredentials) xhr.withCredentials = true;
      if (
        !this._formData &&
        this.method !== "GET" &&
        this.method !== "HEAD" &&
        typeof data !== "string" &&
        !this._isHost(data)
      ) {
        var contentType = this._header["content-type"];
        var _serialize =
          this._serializer ||
          request.serialize[contentType ? contentType.split(";")[0] : ""];
        if (!_serialize && isJSON(contentType)) {
          _serialize = request.serialize["application/json"];
        }
        if (_serialize) data = _serialize(data);
      }
      for (var field in this.header) {
        if (this.header[field] === null) continue;
        if (hasOwn(this.header, field))
          xhr.setRequestHeader(field, this.header[field]);
      }
      if (this._responseType) {
        xhr.responseType = this._responseType;
      }
      this.emit("request", this);
      xhr.send(typeof data === "undefined" ? null : data);
    };
    request.agent = function () {
      return new Agent();
    };
    var _loop = function _loop2() {
      var method = _arr[_i];
      Agent.prototype[method.toLowerCase()] = function (url, fn) {
        var request_ = new request.Request(method, url);
        this._setDefaults(request_);
        if (fn) {
          request_.end(fn);
        }
        return request_;
      };
    };
    for (
      _i = 0, _arr = ["GET", "POST", "OPTIONS", "PATCH", "PUT", "DELETE"];
      _i < _arr.length;
      _i++
    ) {
      _loop();
    }
    var _i;
    var _arr;
    Agent.prototype.del = Agent.prototype.delete;
    request.get = function (url, data, fn) {
      var request_ = request("GET", url);
      if (typeof data === "function") {
        fn = data;
        data = null;
      }
      if (data) request_.query(data);
      if (fn) request_.end(fn);
      return request_;
    };
    request.head = function (url, data, fn) {
      var request_ = request("HEAD", url);
      if (typeof data === "function") {
        fn = data;
        data = null;
      }
      if (data) request_.query(data);
      if (fn) request_.end(fn);
      return request_;
    };
    request.options = function (url, data, fn) {
      var request_ = request("OPTIONS", url);
      if (typeof data === "function") {
        fn = data;
        data = null;
      }
      if (data) request_.send(data);
      if (fn) request_.end(fn);
      return request_;
    };
    function del(url, data, fn) {
      var request_ = request("DELETE", url);
      if (typeof data === "function") {
        fn = data;
        data = null;
      }
      if (data) request_.send(data);
      if (fn) request_.end(fn);
      return request_;
    }
    request.del = del;
    request.delete = del;
    request.patch = function (url, data, fn) {
      var request_ = request("PATCH", url);
      if (typeof data === "function") {
        fn = data;
        data = null;
      }
      if (data) request_.send(data);
      if (fn) request_.end(fn);
      return request_;
    };
    request.post = function (url, data, fn) {
      var request_ = request("POST", url);
      if (typeof data === "function") {
        fn = data;
        data = null;
      }
      if (data) request_.send(data);
      if (fn) request_.end(fn);
      return request_;
    };
    request.put = function (url, data, fn) {
      var request_ = request("PUT", url);
      if (typeof data === "function") {
        fn = data;
        data = null;
      }
      if (data) request_.send(data);
      if (fn) request_.end(fn);
      return request_;
    };
  },
});
const __vite__cjsImport0_superagent = require_client$1();

const querystring = {};

/**
 * Inferix Manager
 * Inferix Rendering Manager API
 *
 * The version of the OpenAPI document: 0.2.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

const superagent = __vite__cjsImport0_superagent.__esModule
  ? __vite__cjsImport0_superagent.default
  : __vite__cjsImport0_superagent;

/**
 * @module ApiClient
 * @version 0.0.0
 */

/**
 * Manages low level client-server communications, parameter marshalling, etc. There should not be any need for an
 * application to use this class directly - the *Api and model classes provide the public API for the service. The
 * contents of this file should be regarded as internal but are documented for completeness.
 * @alias module:ApiClient
 * @class
 */
class ApiClient {
  /**
   * The base URL against which to resolve every API call's (relative) path.
   * Overrides the default value set in spec file if present
   * @param {String} basePath
   */
  constructor(basePath = "http://localhost") {
    /**
     * The base URL against which to resolve every API call's (relative) path.
     * @type {String}
     * @default http://localhost
     */
    this.basePath = basePath.replace(/\/+$/, "");

    /**
     * The authentication methods to be included for all API calls.
     * @type {Array.<String>}
     */
    this.authentications = {
      worker_auth: { type: "basic" },
    };

    /**
     * The default HTTP headers to be included for all API calls.
     * @type {Array.<String>}
     * @default {}
     */
    this.defaultHeaders = {
      "User-Agent": "Inferix/0.1-alpha0 / webbrowser",
    };

    /**
     * The default HTTP timeout for all API calls.
     * @type {Number}
     * @default 60000
     */
    this.timeout = 60000;

    /**
     * If set to false an additional timestamp parameter is added to all API GET calls to
     * prevent browser caching
     * @type {Boolean}
     * @default true
     */
    this.cache = true;

    /**
     * If set to true, the client will save the cookies from each server
     * response, and return them in the next request.
     * @default false
     */
    this.enableCookies = false;

    /*
     * Used to save and return cookies in a node.js (non-browser) setting,
     * if this.enableCookies is set to true.
     */
    if (typeof window === "undefined") {
      this.agent = new superagent.agent();
    }

    /*
     * Allow user to override superagent agent
     */
    this.requestAgent = null;

    /*
     * Allow user to add superagent plugins
     */
    this.plugins = null;
  }

  /**
   * Returns a string representation for an actual parameter.
   * @param param The actual parameter.
   * @returns {String} The string representation of <code>param</code>.
   */
  paramToString(param) {
    if (param == undefined || param == null) {
      return "";
    }
    if (param instanceof Date) {
      return param.toJSON();
    }
    if (ApiClient.canBeJsonified(param)) {
      return JSON.stringify(param);
    }

    return param.toString();
  }

  /**
   * Returns a boolean indicating if the parameter could be JSON.stringified
   * @param param The actual parameter
   * @returns {Boolean} Flag indicating if <code>param</code> can be JSON.stringified
   */
  static canBeJsonified(str) {
    if (typeof str !== "string" && typeof str !== "object") return false;
    try {
      const type = str.toString();
      return type === "[object Object]" || type === "[object Array]";
    } catch (err) {
      return false;
    }
  }

  /**
   * Builds full URL by appending the given path to the base URL and replacing path parameter place-holders with parameter values.
   * NOTE: query parameters are not handled here.
   * @param {String} path The path to append to the base URL.
   * @param {Object} pathParams The parameter values to append.
   * @param {String} apiBasePath Base path defined in the path, operation level to override the default one
   * @returns {String} The encoded path with parameter values substituted.
   */
  buildUrl(path, pathParams, apiBasePath) {
    if (!path.match(/^\//)) {
      path = "/" + path;
    }

    var url = this.basePath + path;

    // use API (operation, path) base path if defined
    if (apiBasePath !== null && apiBasePath !== undefined) {
      url = apiBasePath + path;
    }

    url = url.replace(/\{([\w-\.]+)\}/g, (fullMatch, key) => {
      var value;
      if (pathParams.hasOwnProperty(key)) {
        value = this.paramToString(pathParams[key]);
      } else {
        value = fullMatch;
      }

      return encodeURIComponent(value);
    });

    return url;
  }

  /**
   * Checks whether the given content type represents JSON.<br>
   * JSON content type examples:<br>
   * <ul>
   * <li>application/json</li>
   * <li>application/json; charset=UTF8</li>
   * <li>APPLICATION/JSON</li>
   * </ul>
   * @param {String} contentType The MIME content type to check.
   * @returns {Boolean} <code>true</code> if <code>contentType</code> represents JSON, otherwise <code>false</code>.
   */
  isJsonMime(contentType) {
    return Boolean(
      contentType != null && contentType.match(/^application\/json(;.*)?$/i)
    );
  }

  /**
   * Chooses a content type from the given array, with JSON preferred; i.e. return JSON if included, otherwise return the first.
   * @param {Array.<String>} contentTypes
   * @returns {String} The chosen content type, preferring JSON.
   */
  jsonPreferredMime(contentTypes) {
    for (var i = 0; i < contentTypes.length; i++) {
      if (this.isJsonMime(contentTypes[i])) {
        return contentTypes[i];
      }
    }

    return contentTypes[0];
  }

  /**
   * Checks whether the given parameter value represents file-like content.
   * @param param The parameter to check.
   * @returns {Boolean} <code>true</code> if <code>param</code> represents a file.
   */
  isFileParam(param) {
    // fs.ReadStream in Node.js and Electron (but not in runtime like browserify)
    if (typeof require === "function") {
      let fs;
      try {
        fs = require("fs");
      } catch (err) {}
      if (fs && fs.ReadStream && param instanceof fs.ReadStream) {
        return true;
      }
    }

    // Buffer in Node.js
    if (typeof Buffer === "function" && param instanceof Buffer) {
      return true;
    }

    // Blob in browser
    if (typeof Blob === "function" && param instanceof Blob) {
      return true;
    }

    // File in browser (it seems File object is also instance of Blob, but keep this for safe)
    if (typeof File === "function" && param instanceof File) {
      return true;
    }

    return false;
  }

  /**
   * Normalizes parameter values:
   * <ul>
   * <li>remove nils</li>
   * <li>keep files and arrays</li>
   * <li>format to string with `paramToString` for other cases</li>
   * </ul>
   * @param {Object.<String, Object>} params The parameters as object properties.
   * @returns {Object.<String, Object>} normalized parameters.
   */
  normalizeParams(params) {
    var newParams = {};
    for (var key in params) {
      if (
        params.hasOwnProperty(key) &&
        params[key] != undefined &&
        params[key] != null
      ) {
        var value = params[key];
        if (this.isFileParam(value) || Array.isArray(value)) {
          newParams[key] = value;
        } else {
          newParams[key] = this.paramToString(value);
        }
      }
    }

    return newParams;
  }

  /**
   * Builds a string representation of an array-type actual parameter, according to the given collection format.
   * @param {Array} param An array parameter.
   * @param {module:ApiClient.CollectionFormatEnum} collectionFormat The array element separator strategy.
   * @returns {String|Array} A string representation of the supplied collection, using the specified delimiter. Returns
   * <code>param</code> as is if <code>collectionFormat</code> is <code>multi</code>.
   */
  buildCollectionParam(param, collectionFormat) {
    if (param == null) {
      return null;
    }
    switch (collectionFormat) {
      case "csv":
        return param.map(this.paramToString, this).join(",");
      case "ssv":
        return param.map(this.paramToString, this).join(" ");
      case "tsv":
        return param.map(this.paramToString, this).join("\t");
      case "pipes":
        return param.map(this.paramToString, this).join("|");
      case "multi":
        //return the array directly as SuperAgent will handle it as expected
        return param.map(this.paramToString, this);
      case "passthrough":
        return param;
      default:
        throw new Error("Unknown collection format: " + collectionFormat);
    }
  }

  /**
   * Applies authentication headers to the request.
   * @param {Object} request The request object created by a <code>superagent()</code> call.
   * @param {Array.<String>} authNames An array of authentication method names.
   */
  applyAuthToRequest(request, authNames) {
    authNames.forEach((authName) => {
      var auth = this.authentications[authName];
      switch (auth.type) {
        case "basic":
          if (auth.username || auth.password) {
            request.auth(auth.username || "", auth.password || "");
          }

          break;
        case "bearer":
          if (auth.accessToken) {
            var localVarBearerToken =
              typeof auth.accessToken === "function"
                ? auth.accessToken()
                : auth.accessToken;
            request.set({ Authorization: "Bearer " + localVarBearerToken });
          }

          break;
        case "apiKey":
          if (auth.apiKey) {
            var data = {};
            if (auth.apiKeyPrefix) {
              data[auth.name] = auth.apiKeyPrefix + " " + auth.apiKey;
            } else {
              data[auth.name] = auth.apiKey;
            }

            if (auth["in"] === "header") {
              request.set(data);
            } else {
              request.query(data);
            }
          }

          break;
        case "oauth2":
          if (auth.accessToken) {
            request.set({ Authorization: "Bearer " + auth.accessToken });
          }

          break;
        default:
          throw new Error("Unknown authentication type: " + auth.type);
      }
    });
  }

  /**
   * Deserializes an HTTP response body into a value of the specified type.
   * @param {Object} response A SuperAgent response object.
   * @param {(String|Array.<String>|Object.<String, Object>|Function)} returnType The type to return. Pass a string for simple types
   * or the constructor function for a complex type. Pass an array containing the type name to return an array of that type. To
   * return an object, pass an object with one property whose name is the key type and whose value is the corresponding value type:
   * all properties on <code>data<code> will be converted to this type.
   * @returns A value of the specified type.
   */
  deserialize(response, returnType) {
    if (response == null || returnType == null || response.status == 204) {
      return null;
    }

    // Rely on SuperAgent for parsing response body.
    // See http://visionmedia.github.io/superagent/#parsing-response-bodies
    var data = response.body;
    if (
      data == null ||
      (typeof data === "object" &&
        typeof data.length === "undefined" &&
        !Object.keys(data).length)
    ) {
      // SuperAgent does not always produce a body; use the unparsed response as a fallback
      data = response.text;
    }

    return ApiClient.convertToType(data, returnType);
  }

  /**
   * Invokes the REST service using the supplied settings and parameters.
   * @param {String} path The base URL to invoke.
   * @param {String} httpMethod The HTTP method to use.
   * @param {Object.<String, String>} pathParams A map of path parameters and their values.
   * @param {Object.<String, Object>} queryParams A map of query parameters and their values.
   * @param {Object.<String, Object>} headerParams A map of header parameters and their values.
   * @param {Object.<String, Object>} formParams A map of form parameters and their values.
   * @param {Object} bodyParam The value to pass as the request body.
   * @param {Array.<String>} authNames An array of authentication type names.
   * @param {Array.<String>} contentTypes An array of request MIME types.
   * @param {Array.<String>} accepts An array of acceptable response MIME types.
   * @param {(String|Array|ObjectFunction)} returnType The required type to return; can be a string for simple types or the
   * constructor for a complex type.
   * @param {String} apiBasePath base path defined in the operation/path level to override the default one
   * @returns {Promise} A {@link https://www.promisejs.org/|Promise} object.
   */
  callApi(
    path,
    httpMethod,
    pathParams,
    queryParams,
    headerParams,
    formParams,
    bodyParam,
    authNames,
    contentTypes,
    accepts,
    returnType,
    apiBasePath
  ) {
    var url = this.buildUrl(path, pathParams, apiBasePath);
    var request = superagent(httpMethod, url);

    if (this.plugins !== null) {
      for (var index in this.plugins) {
        if (this.plugins.hasOwnProperty(index)) {
          request.use(this.plugins[index]);
        }
      }
    }

    // apply authentications
    this.applyAuthToRequest(request, authNames);

    // set query parameters
    if (httpMethod.toUpperCase() === "GET" && this.cache === false) {
      queryParams["_"] = new Date().getTime();
    }

    request.query(this.normalizeParams(queryParams));

    // set header parameters
    request.set(this.defaultHeaders).set(this.normalizeParams(headerParams));

    // set requestAgent if it is set by user
    if (this.requestAgent) {
      request.agent(this.requestAgent);
    }

    // set request timeout
    request.timeout(this.timeout);

    var contentType = this.jsonPreferredMime(contentTypes);
    if (contentType) {
      // Issue with superagent and multipart/form-data (https://github.com/visionmedia/superagent/issues/746)
      if (contentType != "multipart/form-data") {
        request.type(contentType);
      }
    }

    if (contentType === "application/x-www-form-urlencoded") {
      request.send(querystring.stringify(this.normalizeParams(formParams)));
    } else if (contentType == "multipart/form-data") {
      var _formParams = this.normalizeParams(formParams);
      for (var key in _formParams) {
        if (_formParams.hasOwnProperty(key)) {
          let _formParamsValue = _formParams[key];
          if (this.isFileParam(_formParamsValue)) {
            // file field
            request.attach(key, _formParamsValue);
          } else if (
            Array.isArray(_formParamsValue) &&
            _formParamsValue.length &&
            this.isFileParam(_formParamsValue[0])
          ) {
            // multiple files
            _formParamsValue.forEach((file) => request.attach(key, file));
          } else {
            request.field(key, _formParamsValue);
          }
        }
      }
    } else if (bodyParam !== null && bodyParam !== undefined) {
      if (!request.header["Content-Type"]) {
        request.type("application/json");
      }
      request.send(bodyParam);
    }

    var accept = this.jsonPreferredMime(accepts);
    if (accept) {
      request.accept(accept);
    }

    if (returnType === "Blob") {
      request.responseType("blob");
    } else if (returnType === "String") {
      request.responseType("string");
    }

    // Attach previously saved cookies, if enabled
    if (this.enableCookies) {
      if (typeof window === "undefined") {
        this.agent._attachCookies(request);
      } else {
        request.withCredentials();
      }
    }

    return new Promise((resolve, reject) => {
      request.end((error, response) => {
        if (error) {
          var err = {};
          if (response) {
            err.status = response.status;
            err.statusText = response.statusText;
            err.body = response.body;
            err.response = response;
          }
          err.error = error;

          reject(err);
        } else {
          try {
            var data = this.deserialize(response, returnType);
            if (this.enableCookies && typeof window === "undefined") {
              this.agent._saveCookies(response);
            }

            resolve({ data, response });
          } catch (err) {
            reject(err);
          }
        }
      });
    });
  }

  /**
   * Parses an ISO-8601 string representation or epoch representation of a date value.
   * @param {String} str The date value as a string.
   * @returns {Date} The parsed date object.
   */
  static parseDate(str) {
    if (isNaN(str)) {
      return new Date(str.replace(/(\d)(T)(\d)/i, "$1 $3"));
    }
    return new Date(+str);
  }

  /**
   * Converts a value to the specified type.
   * @param {(String|Object)} data The data to convert, as a string or object.
   * @param {(String|Array.<String>|Object.<String, Object>|Function)} type The type to return. Pass a string for simple types
   * or the constructor function for a complex type. Pass an array containing the type name to return an array of that type. To
   * return an object, pass an object with one property whose name is the key type and whose value is the corresponding value type:
   * all properties on <code>data<code> will be converted to this type.
   * @returns An instance of the specified type or null or undefined if data is null or undefined.
   */
  static convertToType(data, type) {
    if (data === null || data === undefined) return data;

    switch (type) {
      case "Boolean":
        return Boolean(data);
      case "Integer":
        return parseInt(data, 10);
      case "Number":
        return parseFloat(data);
      case "String":
        return String(data);
      case "Date":
        return ApiClient.parseDate(String(data));
      case "Blob":
        return data;
      default:
        if (type === Object) {
          // generic object, return directly
          return data;
        } else if (typeof type.constructFromObject === "function") {
          // for model type like User and enum class
          return type.constructFromObject(data);
        } else if (Array.isArray(type)) {
          // for array type like: ['String']
          var itemType = type[0];

          return data.map((item) => {
            return ApiClient.convertToType(item, itemType);
          });
        } else if (typeof type === "object") {
          // for plain object type like: {'String': 'Integer'}
          var keyType, valueType;
          for (var k in type) {
            if (type.hasOwnProperty(k)) {
              keyType = k;
              valueType = type[k];
              break;
            }
          }

          var result = {};
          for (var k in data) {
            if (data.hasOwnProperty(k)) {
              var key = ApiClient.convertToType(k, keyType);
              var value = ApiClient.convertToType(data[k], valueType);
              result[key] = value;
            }
          }

          return result;
        } else {
          // for unknown type, return the data directly
          return data;
        }
    }
  }

  /**
   * Gets an array of host settings
   * @returns An array of host settings
   */
  hostSettings() {
    return [
      {
        url: "",
        description: "No description provided",
      },
    ];
  }

  getBasePathFromSettings(index, variables = {}) {
    var servers = this.hostSettings();

    // check array index out of bound
    if (index < 0 || index >= servers.length) {
      throw new Error(
        "Invalid index " +
          index +
          " when selecting the host settings. Must be less than " +
          servers.length
      );
    }

    var server = servers[index];
    var url = server["url"];

    // go through variable and assign a value
    for (var variable_name in server["variables"]) {
      if (variable_name in variables) {
        let variable = server["variables"][variable_name];
        if (
          !("enum_values" in variable) ||
          variable["enum_values"].includes(variables[variable_name])
        ) {
          url = url.replace(
            "{" + variable_name + "}",
            variables[variable_name]
          );
        } else {
          throw new Error(
            "The variable `" +
              variable_name +
              "` in the host URL has invalid value " +
              variables[variable_name] +
              ". Must be " +
              server["variables"][variable_name]["enum_values"] +
              "."
          );
        }
      } else {
        // use default value
        url = url.replace(
          "{" + variable_name + "}",
          server["variables"][variable_name]["default_value"]
        );
      }
    }
    return url;
  }

  /**
   * Constructs a new map or array model from REST data.
   * @param data {Object|Array} The REST data.
   * @param obj {Object|Array} The target object or array.
   */
  static constructFromObject(data, obj, itemType) {
    if (Array.isArray(data)) {
      for (var i = 0; i < data.length; i++) {
        if (data.hasOwnProperty(i))
          obj[i] = ApiClient.convertToType(data[i], itemType);
      }
    } else {
      for (var k in data) {
        if (data.hasOwnProperty(k))
          obj[k] = ApiClient.convertToType(data[k], itemType);
      }
    }
  }
}

/**
 * Enumeration of collection format separator strategies.
 * @enum {String}
 * @readonly
 */
ApiClient.CollectionFormatEnum = {
  /**
   * Comma-separated values. Value: <code>csv</code>
   * @const
   */
  CSV: ",",

  /**
   * Space-separated values. Value: <code>ssv</code>
   * @const
   */
  SSV: " ",

  /**
   * Tab-separated values. Value: <code>tsv</code>
   * @const
   */
  TSV: "\t",

  /**
   * Pipe(|)-separated values. Value: <code>pipes</code>
   * @const
   */
  PIPES: "|",

  /**
   * Native array. Value: <code>multi</code>
   * @const
   */
  MULTI: "multi",
};

/**
 * The default API client implementation.
 * @type {module:ApiClient}
 */
ApiClient.instance = new ApiClient();

/**
 * Inferix Manager
 * Inferix Rendering Manager API
 *
 * The version of the OpenAPI document: 0.2.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

/**
 * The Command model module.
 * @module model/Command
 * @version 0.0.0
 */
class Command {
  /**
   * Constructs a new <code>Command</code>.
   * Command represents a single command to execute by the Worker.
   * @alias module:model/Command
   * @param name {String}
   * @param parameters {Object}
   */
  constructor(name, parameters) {
    Command.initialize(this, name, parameters);
  }

  /**
   * Initializes the fields of this object.
   * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
   * Only for internal use.
   */
  static initialize(obj, name, parameters) {
    obj["name"] = name;
    obj["parameters"] = parameters;
  }

  /**
   * Constructs a <code>Command</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/Command} obj Optional instance to populate.
   * @return {module:model/Command} The populated <code>Command</code> instance.
   */
  static constructFromObject(data, obj) {
    if (data) {
      obj = obj || new Command();

      if (data.hasOwnProperty("name")) {
        obj["name"] = ApiClient.convertToType(data["name"], "String");
      }
      if (data.hasOwnProperty("parameters")) {
        obj["parameters"] = ApiClient.convertToType(data["parameters"], Object);
      }
    }
    return obj;
  }
}

/**
 * @member {String} name
 */
Command.prototype["name"] = undefined;

/**
 * @member {Object} parameters
 */
Command.prototype["parameters"] = undefined;

/**
 * Inferix Manager
 * Inferix Rendering Manager API
 *
 * The version of the OpenAPI document: 0.2.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

/**
 * Enum class TaskStatus.
 * @enum {}
 * @readonly
 */
class TaskStatus {
  /**
   * value: "active"
   * @const
   */
  active = "active";

  /**
   * value: "canceled"
   * @const
   */
  canceled = "canceled";

  /**
   * value: "completed"
   * @const
   */
  completed = "completed";

  /**
   * value: "failed"
   * @const
   */
  failed = "failed";

  /**
   * value: "queued"
   * @const
   */
  queued = "queued";

  /**
   * value: "soft-failed"
   * @const
   */
  "soft-failed" = "soft-failed";

  /**
   * value: "paused"
   * @const
   */
  paused = "paused";

  /**
   * Returns a <code>TaskStatus</code> enum value from a Javascript object name.
   * @param {Object} data The plain JavaScript object containing the name of the enum value.
   * @return {module:model/TaskStatus} The enum <code>TaskStatus</code> value.
   */
  static constructFromObject(object) {
    return object;
  }
}

/**
 * Inferix Manager
 * Inferix Rendering Manager API
 *
 * The version of the OpenAPI document: 0.2.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

/**
 * The AvailableJobSettingEvalInfo model module.
 * @module model/AvailableJobSettingEvalInfo
 * @version 0.0.0
 */
class AvailableJobSettingEvalInfo {
  /**
   * Constructs a new <code>AvailableJobSettingEvalInfo</code>.
   * Meta-data for the &#39;eval&#39; expression.
   * @alias module:model/AvailableJobSettingEvalInfo
   * @param showLinkButton {Boolean} Enables the 'eval on submit' toggle button behavior for this setting. A toggle button will be shown in Blender's submission interface. When toggled on, the `eval` expression will determine the setting's value. Manually editing the setting is then no longer possible, and instead of an input field, the 'description' string is shown. An example use is the to-be-rendered frame range, which by default automatically follows the scene range, but can be overridden manually when desired.
   * @param description {String} Description of what the 'eval' expression is doing. It is also used as placeholder text to show when the manual input field is hidden (because eval-on-submit has been toggled on by the user).
   */
  constructor(showLinkButton, description) {
    AvailableJobSettingEvalInfo.initialize(this, showLinkButton, description);
  }

  /**
   * Initializes the fields of this object.
   * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
   * Only for internal use.
   */
  static initialize(obj, showLinkButton, description) {
    obj["showLinkButton"] = showLinkButton || false;
    obj["description"] = description || "";
  }

  /**
   * Constructs a <code>AvailableJobSettingEvalInfo</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/AvailableJobSettingEvalInfo} obj Optional instance to populate.
   * @return {module:model/AvailableJobSettingEvalInfo} The populated <code>AvailableJobSettingEvalInfo</code> instance.
   */
  static constructFromObject(data, obj) {
    if (data) {
      obj = obj || new AvailableJobSettingEvalInfo();

      if (data.hasOwnProperty("showLinkButton")) {
        obj["showLinkButton"] = ApiClient.convertToType(
          data["showLinkButton"],
          "Boolean"
        );
      }
      if (data.hasOwnProperty("description")) {
        obj["description"] = ApiClient.convertToType(
          data["description"],
          "String"
        );
      }
    }
    return obj;
  }
}

/**
 * Enables the 'eval on submit' toggle button behavior for this setting. A toggle button will be shown in Blender's submission interface. When toggled on, the `eval` expression will determine the setting's value. Manually editing the setting is then no longer possible, and instead of an input field, the 'description' string is shown. An example use is the to-be-rendered frame range, which by default automatically follows the scene range, but can be overridden manually when desired.
 * @member {Boolean} showLinkButton
 * @default false
 */
AvailableJobSettingEvalInfo.prototype["showLinkButton"] = false;

/**
 * Description of what the 'eval' expression is doing. It is also used as placeholder text to show when the manual input field is hidden (because eval-on-submit has been toggled on by the user).
 * @member {String} description
 * @default ''
 */
AvailableJobSettingEvalInfo.prototype["description"] = "";

/**
 * Inferix Manager
 * Inferix Rendering Manager API
 *
 * The version of the OpenAPI document: 0.2.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

/**
 * Enum class AvailableJobSettingSubtype.
 * @enum {}
 * @readonly
 */
class AvailableJobSettingSubtype {
  /**
   * value: "file_path"
   * @const
   */
  file_path = "file_path";

  /**
   * value: "dir_path"
   * @const
   */
  dir_path = "dir_path";

  /**
   * value: "file_name"
   * @const
   */
  file_name = "file_name";

  /**
   * value: "hashed_file_path"
   * @const
   */
  hashed_file_path = "hashed_file_path";

  /**
   * Returns a <code>AvailableJobSettingSubtype</code> enum value from a Javascript object name.
   * @param {Object} data The plain JavaScript object containing the name of the enum value.
   * @return {module:model/AvailableJobSettingSubtype} The enum <code>AvailableJobSettingSubtype</code> value.
   */
  static constructFromObject(object) {
    return object;
  }
}

/**
 * Inferix Manager
 * Inferix Rendering Manager API
 *
 * The version of the OpenAPI document: 0.2.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

/**
 * Enum class AvailableJobSettingType.
 * @enum {}
 * @readonly
 */
class AvailableJobSettingType {
  /**
   * value: "string"
   * @const
   */
  string = "string";

  /**
   * value: "int32"
   * @const
   */
  int32 = "int32";

  /**
   * value: "float"
   * @const
   */
  float = "float";

  /**
   * value: "bool"
   * @const
   */
  bool = "bool";

  /**
   * Returns a <code>AvailableJobSettingType</code> enum value from a Javascript object name.
   * @param {Object} data The plain JavaScript object containing the name of the enum value.
   * @return {module:model/AvailableJobSettingType} The enum <code>AvailableJobSettingType</code> value.
   */
  static constructFromObject(object) {
    return object;
  }
}

/**
 * Inferix Manager
 * Inferix Rendering Manager API
 *
 * The version of the OpenAPI document: 0.2.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

/**
 * Enum class AvailableJobSettingVisibility.
 * @enum {}
 * @readonly
 */
class AvailableJobSettingVisibility {
  /**
   * value: "visible"
   * @const
   */
  visible = "visible";

  /**
   * value: "hidden"
   * @const
   */
  hidden = "hidden";

  /**
   * value: "submission"
   * @const
   */
  submission = "submission";

  /**
   * value: "web"
   * @const
   */
  web = "web";

  /**
   * Returns a <code>AvailableJobSettingVisibility</code> enum value from a Javascript object name.
   * @param {Object} data The plain JavaScript object containing the name of the enum value.
   * @return {module:model/AvailableJobSettingVisibility} The enum <code>AvailableJobSettingVisibility</code> value.
   */
  static constructFromObject(object) {
    return object;
  }
}

/**
 * Inferix Manager
 * Inferix Rendering Manager API
 *
 * The version of the OpenAPI document: 0.2.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

/**
 * The AvailableJobSetting model module.
 * @module model/AvailableJobSetting
 * @version 0.0.0
 */
class AvailableJobSetting {
  /**
   * Constructs a new <code>AvailableJobSetting</code>.
   * Single setting of a Job types.
   * @alias module:model/AvailableJobSetting
   * @param key {String} Identifier for the setting, must be unique within the job type.
   * @param type {module:model/AvailableJobSettingType}
   */
  constructor(key, type) {
    AvailableJobSetting.initialize(this, key, type);
  }

  /**
   * Initializes the fields of this object.
   * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
   * Only for internal use.
   */
  static initialize(obj, key, type) {
    obj["key"] = key;
    obj["type"] = type;
  }

  /**
   * Constructs a <code>AvailableJobSetting</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/AvailableJobSetting} obj Optional instance to populate.
   * @return {module:model/AvailableJobSetting} The populated <code>AvailableJobSetting</code> instance.
   */
  static constructFromObject(data, obj) {
    if (data) {
      obj = obj || new AvailableJobSetting();

      if (data.hasOwnProperty("key")) {
        obj["key"] = ApiClient.convertToType(data["key"], "String");
      }
      if (data.hasOwnProperty("type")) {
        obj["type"] = AvailableJobSettingType.constructFromObject(data["type"]);
      }
      if (data.hasOwnProperty("subtype")) {
        obj["subtype"] = AvailableJobSettingSubtype.constructFromObject(
          data["subtype"]
        );
      }
      if (data.hasOwnProperty("choices")) {
        obj["choices"] = ApiClient.convertToType(data["choices"], ["String"]);
      }
      if (data.hasOwnProperty("propargs")) {
        obj["propargs"] = ApiClient.convertToType(data["propargs"], Object);
      }
      if (data.hasOwnProperty("description")) {
        obj["description"] = ApiClient.convertToType(
          data["description"],
          Object
        );
      }
      if (data.hasOwnProperty("default")) {
        obj["default"] = ApiClient.convertToType(data["default"], Object);
      }
      if (data.hasOwnProperty("eval")) {
        obj["eval"] = ApiClient.convertToType(data["eval"], "String");
      }
      if (data.hasOwnProperty("evalInfo")) {
        obj["evalInfo"] = AvailableJobSettingEvalInfo.constructFromObject(
          data["evalInfo"]
        );
      }
      if (data.hasOwnProperty("visible")) {
        obj["visible"] = AvailableJobSettingVisibility.constructFromObject(
          data["visible"]
        );
      }
      if (data.hasOwnProperty("required")) {
        obj["required"] = ApiClient.convertToType(data["required"], "Boolean");
      }
      if (data.hasOwnProperty("editable")) {
        obj["editable"] = ApiClient.convertToType(data["editable"], "Boolean");
      }
    }
    return obj;
  }
}

/**
 * Identifier for the setting, must be unique within the job type.
 * @member {String} key
 */
AvailableJobSetting.prototype["key"] = undefined;

/**
 * @member {module:model/AvailableJobSettingType} type
 */
AvailableJobSetting.prototype["type"] = undefined;

/**
 * @member {module:model/AvailableJobSettingSubtype} subtype
 */
AvailableJobSetting.prototype["subtype"] = undefined;

/**
 * When given, limit the valid values to these choices. Only usable with string type.
 * @member {Array.<String>} choices
 */
AvailableJobSetting.prototype["choices"] = undefined;

/**
 * Any extra arguments to the bpy.props.SomeProperty() call used to create this property.
 * @member {Object} propargs
 */
AvailableJobSetting.prototype["propargs"] = undefined;

/**
 * The description/tooltip shown in the user interface.
 * @member {Object} description
 */
AvailableJobSetting.prototype["description"] = undefined;

/**
 * The default value shown to the user when determining this setting.
 * @member {Object} default
 */
AvailableJobSetting.prototype["default"] = undefined;

/**
 * Python expression to be evaluated in order to determine the default value for this setting.
 * @member {String} eval
 */
AvailableJobSetting.prototype["eval"] = undefined;

/**
 * @member {module:model/AvailableJobSettingEvalInfo} evalInfo
 */
AvailableJobSetting.prototype["evalInfo"] = undefined;

/**
 * @member {module:model/AvailableJobSettingVisibility} visible
 */
AvailableJobSetting.prototype["visible"] = undefined;

/**
 * Whether to immediately reject a job definition, of this type, without this particular setting.
 * @member {Boolean} required
 * @default false
 */
AvailableJobSetting.prototype["required"] = false;

/**
 * Whether to allow editing this setting after the job has been submitted. Would imply deleting all existing tasks for this job, and recompiling it.
 * @member {Boolean} editable
 * @default false
 */
AvailableJobSetting.prototype["editable"] = false;

/**
 * Inferix Manager
 * Inferix Rendering Manager API
 *
 * The version of the OpenAPI document: 0.2.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

/**
 * The AvailableJobType model module.
 * @module model/AvailableJobType
 * @version 0.0.0
 */
class AvailableJobType {
  /**
   * Constructs a new <code>AvailableJobType</code>.
   * Job type supported by this Manager, and its parameters.
   * @alias module:model/AvailableJobType
   * @param name {String}
   * @param label {String}
   * @param settings {Array.<module:model/AvailableJobSetting>}
   * @param etag {String} Hash of the job type. If the job settings or the label change, this etag will change. This is used on job submission to ensure that the submitted job settings are up to date.
   */
  constructor(name, label, settings, etag) {
    AvailableJobType.initialize(this, name, label, settings, etag);
  }

  /**
   * Initializes the fields of this object.
   * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
   * Only for internal use.
   */
  static initialize(obj, name, label, settings, etag) {
    obj["name"] = name;
    obj["label"] = label;
    obj["settings"] = settings;
    obj["etag"] = etag;
  }

  /**
   * Constructs a <code>AvailableJobType</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/AvailableJobType} obj Optional instance to populate.
   * @return {module:model/AvailableJobType} The populated <code>AvailableJobType</code> instance.
   */
  static constructFromObject(data, obj) {
    if (data) {
      obj = obj || new AvailableJobType();

      if (data.hasOwnProperty("name")) {
        obj["name"] = ApiClient.convertToType(data["name"], "String");
      }
      if (data.hasOwnProperty("label")) {
        obj["label"] = ApiClient.convertToType(data["label"], "String");
      }
      if (data.hasOwnProperty("settings")) {
        obj["settings"] = ApiClient.convertToType(data["settings"], [
          AvailableJobSetting,
        ]);
      }
      if (data.hasOwnProperty("etag")) {
        obj["etag"] = ApiClient.convertToType(data["etag"], "String");
      }
    }
    return obj;
  }
}

/**
 * @member {String} name
 */
AvailableJobType.prototype["name"] = undefined;

/**
 * @member {String} label
 */
AvailableJobType.prototype["label"] = undefined;

/**
 * @member {Array.<module:model/AvailableJobSetting>} settings
 */
AvailableJobType.prototype["settings"] = undefined;

/**
 * Hash of the job type. If the job settings or the label change, this etag will change. This is used on job submission to ensure that the submitted job settings are up to date.
 * @member {String} etag
 */
AvailableJobType.prototype["etag"] = undefined;

/**
 * Inferix Manager
 * Inferix Rendering Manager API
 *
 * The version of the OpenAPI document: 0.2.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

/**
 * The AvailableJobTypes model module.
 * @module model/AvailableJobTypes
 * @version 0.0.0
 */
class AvailableJobTypes {
  /**
   * Constructs a new <code>AvailableJobTypes</code>.
   * List of job types supported by this Manager.
   * @alias module:model/AvailableJobTypes
   * @param jobTypes {Array.<module:model/AvailableJobType>}
   */
  constructor(jobTypes) {
    AvailableJobTypes.initialize(this, jobTypes);
  }

  /**
   * Initializes the fields of this object.
   * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
   * Only for internal use.
   */
  static initialize(obj, jobTypes) {
    obj["job_types"] = jobTypes;
  }

  /**
   * Constructs a <code>AvailableJobTypes</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/AvailableJobTypes} obj Optional instance to populate.
   * @return {module:model/AvailableJobTypes} The populated <code>AvailableJobTypes</code> instance.
   */
  static constructFromObject(data, obj) {
    if (data) {
      obj = obj || new AvailableJobTypes();

      if (data.hasOwnProperty("job_types")) {
        obj["job_types"] = ApiClient.convertToType(data["job_types"], [
          AvailableJobType,
        ]);
      }
    }
    return obj;
  }
}

/**
 * @member {Array.<module:model/AvailableJobType>} job_types
 */
AvailableJobTypes.prototype["job_types"] = undefined;

/**
 * Inferix Manager
 * Inferix Rendering Manager API
 *
 * The version of the OpenAPI document: 0.2.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

/**
 * Enum class BlenderPathSource.
 * @enum {}
 * @readonly
 */
class BlenderPathSource {
  /**
   * value: "file_association"
   * @const
   */
  file_association = "file_association";

  /**
   * value: "path_envvar"
   * @const
   */
  path_envvar = "path_envvar";

  /**
   * value: "input_path"
   * @const
   */
  input_path = "input_path";

  /**
   * Returns a <code>BlenderPathSource</code> enum value from a Javascript object name.
   * @param {Object} data The plain JavaScript object containing the name of the enum value.
   * @return {module:model/BlenderPathSource} The enum <code>BlenderPathSource</code> value.
   */
  static constructFromObject(object) {
    return object;
  }
}

/**
 * Inferix Manager
 * Inferix Rendering Manager API
 *
 * The version of the OpenAPI document: 0.2.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

/**
 * The BlenderPathCheckResult model module.
 * @module model/BlenderPathCheckResult
 * @version 0.0.0
 */
class BlenderPathCheckResult {
  /**
   * Constructs a new <code>BlenderPathCheckResult</code>.
   * @alias module:model/BlenderPathCheckResult
   * @param input {String} The input that was given to find this Blender.
   * @param path {String} The path that was found.
   * @param source {module:model/BlenderPathSource}
   * @param isUsable {Boolean} Whether the path is usable or not.
   * @param cause {String} Description of why this path is (not) usable.
   */
  constructor(input, path, source, isUsable, cause) {
    BlenderPathCheckResult.initialize(
      this,
      input,
      path,
      source,
      isUsable,
      cause
    );
  }

  /**
   * Initializes the fields of this object.
   * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
   * Only for internal use.
   */
  static initialize(obj, input, path, source, isUsable, cause) {
    obj["input"] = input;
    obj["path"] = path;
    obj["source"] = source;
    obj["is_usable"] = isUsable;
    obj["cause"] = cause;
  }

  /**
   * Constructs a <code>BlenderPathCheckResult</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/BlenderPathCheckResult} obj Optional instance to populate.
   * @return {module:model/BlenderPathCheckResult} The populated <code>BlenderPathCheckResult</code> instance.
   */
  static constructFromObject(data, obj) {
    if (data) {
      obj = obj || new BlenderPathCheckResult();

      if (data.hasOwnProperty("input")) {
        obj["input"] = ApiClient.convertToType(data["input"], "String");
      }
      if (data.hasOwnProperty("path")) {
        obj["path"] = ApiClient.convertToType(data["path"], "String");
      }
      if (data.hasOwnProperty("source")) {
        obj["source"] = BlenderPathSource.constructFromObject(data["source"]);
      }
      if (data.hasOwnProperty("is_usable")) {
        obj["is_usable"] = ApiClient.convertToType(
          data["is_usable"],
          "Boolean"
        );
      }
      if (data.hasOwnProperty("cause")) {
        obj["cause"] = ApiClient.convertToType(data["cause"], "String");
      }
    }
    return obj;
  }
}

/**
 * The input that was given to find this Blender.
 * @member {String} input
 */
BlenderPathCheckResult.prototype["input"] = undefined;

/**
 * The path that was found.
 * @member {String} path
 */
BlenderPathCheckResult.prototype["path"] = undefined;

/**
 * @member {module:model/BlenderPathSource} source
 */
BlenderPathCheckResult.prototype["source"] = undefined;

/**
 * Whether the path is usable or not.
 * @member {Boolean} is_usable
 */
BlenderPathCheckResult.prototype["is_usable"] = undefined;

/**
 * Description of why this path is (not) usable.
 * @member {String} cause
 */
BlenderPathCheckResult.prototype["cause"] = undefined;

/**
 * Inferix Manager
 * Inferix Rendering Manager API
 *
 * The version of the OpenAPI document: 0.2.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

/**
 * The Error model module.
 * @module model/Error
 * @version 0.0.0
 */
let Error$1 = class Error {
  /**
   * Constructs a new <code>Error</code>.
   * Generic error response.
   * @alias module:model/Error
   * @param code {Number} HTTP status code of this response. Is included in the payload so that a single object represents all error information. Code 503 is used when the database is busy. The HTTP response will contain a 'Retry-After' HTTP header that indicates after which time the request can be retried. Following the header is not mandatory, and it's up to the client to do something reasonable like exponential backoff.
   * @param message {String}
   */
  constructor(code, message) {
    Error.initialize(this, code, message);
  }

  /**
   * Initializes the fields of this object.
   * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
   * Only for internal use.
   */
  static initialize(obj, code, message) {
    obj["code"] = code;
    obj["message"] = message;
  }

  /**
   * Constructs a <code>Error</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/Error} obj Optional instance to populate.
   * @return {module:model/Error} The populated <code>Error</code> instance.
   */
  static constructFromObject(data, obj) {
    if (data) {
      obj = obj || new Error();

      if (data.hasOwnProperty("code")) {
        obj["code"] = ApiClient.convertToType(data["code"], "Number");
      }
      if (data.hasOwnProperty("message")) {
        obj["message"] = ApiClient.convertToType(data["message"], "String");
      }
    }
    return obj;
  }
};

/**
 * HTTP status code of this response. Is included in the payload so that a single object represents all error information. Code 503 is used when the database is busy. The HTTP response will contain a 'Retry-After' HTTP header that indicates after which time the request can be retried. Following the header is not mandatory, and it's up to the client to do something reasonable like exponential backoff.
 * @member {Number} code
 */
Error$1.prototype["code"] = undefined;

/**
 * @member {String} message
 */
Error$1.prototype["message"] = undefined;

/**
 * Inferix Manager
 * Inferix Rendering Manager API
 *
 * The version of the OpenAPI document: 0.2.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

/**
 * The FlamencoVersion model module.
 * @module model/FlamencoVersion
 * @version 0.0.0
 */
class FlamencoVersion {
  /**
   * Constructs a new <code>FlamencoVersion</code>.
   * @alias module:model/FlamencoVersion
   * @param version {String} Version of this Manager, meant for human consumption. For release builds it is the same as `shortversion`, for other builds it also includes the `git` version info.
   * @param shortversion {String}
   * @param name {String}
   * @param git {String}
   */
  constructor(version, shortversion, name, git) {
    FlamencoVersion.initialize(this, version, shortversion, name, git);
  }

  /**
   * Initializes the fields of this object.
   * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
   * Only for internal use.
   */
  static initialize(obj, version, shortversion, name, git) {
    obj["version"] = version;
    obj["shortversion"] = shortversion;
    obj["name"] = name;
    obj["git"] = git;
  }

  /**
   * Constructs a <code>FlamencoVersion</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/FlamencoVersion} obj Optional instance to populate.
   * @return {module:model/FlamencoVersion} The populated <code>FlamencoVersion</code> instance.
   */
  static constructFromObject(data, obj) {
    if (data) {
      obj = obj || new FlamencoVersion();

      if (data.hasOwnProperty("version")) {
        obj["version"] = ApiClient.convertToType(data["version"], "String");
      }
      if (data.hasOwnProperty("shortversion")) {
        obj["shortversion"] = ApiClient.convertToType(
          data["shortversion"],
          "String"
        );
      }
      if (data.hasOwnProperty("name")) {
        obj["name"] = ApiClient.convertToType(data["name"], "String");
      }
      if (data.hasOwnProperty("git")) {
        obj["git"] = ApiClient.convertToType(data["git"], "String");
      }
    }
    return obj;
  }
}

/**
 * Version of this Manager, meant for human consumption. For release builds it is the same as `shortversion`, for other builds it also includes the `git` version info.
 * @member {String} version
 */
FlamencoVersion.prototype["version"] = undefined;

/**
 * @member {String} shortversion
 */
FlamencoVersion.prototype["shortversion"] = undefined;

/**
 * @member {String} name
 */
FlamencoVersion.prototype["name"] = undefined;

/**
 * @member {String} git
 */
FlamencoVersion.prototype["git"] = undefined;

/**
 * Inferix Manager
 * Inferix Rendering Manager API
 *
 * The version of the OpenAPI document: 0.2.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

/**
 * Enum class JobStatus.
 * @enum {}
 * @readonly
 */
class JobStatus {
  /**
   * value: "active"
   * @const
   */
  active = "active";

  /**
   * value: "canceled"
   * @const
   */
  canceled = "canceled";

  /**
   * value: "completed"
   * @const
   */
  completed = "completed";

  /**
   * value: "failed"
   * @const
   */
  failed = "failed";

  /**
   * value: "paused"
   * @const
   */
  paused = "paused";

  /**
   * value: "queued"
   * @const
   */
  queued = "queued";

  /**
   * value: "cancel-requested"
   * @const
   */
  "cancel-requested" = "cancel-requested";

  /**
   * value: "requeueing"
   * @const
   */
  requeueing = "requeueing";

  /**
   * value: "under-construction"
   * @const
   */
  "under-construction" = "under-construction";

  /**
   * Returns a <code>JobStatus</code> enum value from a Javascript object name.
   * @param {Object} data The plain JavaScript object containing the name of the enum value.
   * @return {module:model/JobStatus} The enum <code>JobStatus</code> value.
   */
  static constructFromObject(object) {
    return object;
  }
}

/**
 * Inferix Manager
 * Inferix Rendering Manager API
 *
 * The version of the OpenAPI document: 0.2.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

/**
 * The JobAllOf model module.
 * @module model/JobAllOf
 * @version 0.0.0
 */
class JobAllOf {
  /**
   * Constructs a new <code>JobAllOf</code>.
   * @alias module:model/JobAllOf
   * @param id {String} UUID of the Job
   * @param created {Date} Creation timestamp
   * @param updated {Date} Timestamp of last update.
   * @param status {module:model/JobStatus}
   * @param activity {String} Description of the last activity on this job.
   */
  constructor(id, created, updated, status, activity) {
    JobAllOf.initialize(this, id, created, updated, status, activity);
  }

  /**
   * Initializes the fields of this object.
   * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
   * Only for internal use.
   */
  static initialize(obj, id, created, updated, status, activity) {
    obj["id"] = id;
    obj["created"] = created;
    obj["updated"] = updated;
    obj["status"] = status;
    obj["activity"] = activity;
  }

  /**
   * Constructs a <code>JobAllOf</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/JobAllOf} obj Optional instance to populate.
   * @return {module:model/JobAllOf} The populated <code>JobAllOf</code> instance.
   */
  static constructFromObject(data, obj) {
    if (data) {
      obj = obj || new JobAllOf();

      if (data.hasOwnProperty("id")) {
        obj["id"] = ApiClient.convertToType(data["id"], "String");
      }
      if (data.hasOwnProperty("created")) {
        obj["created"] = ApiClient.convertToType(data["created"], "Date");
      }
      if (data.hasOwnProperty("updated")) {
        obj["updated"] = ApiClient.convertToType(data["updated"], "Date");
      }
      if (data.hasOwnProperty("status")) {
        obj["status"] = JobStatus.constructFromObject(data["status"]);
      }
      if (data.hasOwnProperty("activity")) {
        obj["activity"] = ApiClient.convertToType(data["activity"], "String");
      }
      if (data.hasOwnProperty("delete_requested_at")) {
        obj["delete_requested_at"] = ApiClient.convertToType(
          data["delete_requested_at"],
          "Date"
        );
      }
    }
    return obj;
  }
}

/**
 * UUID of the Job
 * @member {String} id
 */
JobAllOf.prototype["id"] = undefined;

/**
 * Creation timestamp
 * @member {Date} created
 */
JobAllOf.prototype["created"] = undefined;

/**
 * Timestamp of last update.
 * @member {Date} updated
 */
JobAllOf.prototype["updated"] = undefined;

/**
 * @member {module:model/JobStatus} status
 */
JobAllOf.prototype["status"] = undefined;

/**
 * Description of the last activity on this job.
 * @member {String} activity
 */
JobAllOf.prototype["activity"] = undefined;

/**
 * If job deletion was requested, this is the timestamp at which that request was stored on Inferix Manager.
 * @member {Date} delete_requested_at
 */
JobAllOf.prototype["delete_requested_at"] = undefined;

/**
 * Inferix Manager
 * Inferix Rendering Manager API
 *
 * The version of the OpenAPI document: 0.2.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

/**
 * The JobStorageInfo model module.
 * @module model/JobStorageInfo
 * @version 0.0.0
 */
class JobStorageInfo {
  /**
   * Constructs a new <code>JobStorageInfo</code>.
   * Storage info of a job, which Inferix can use to remove job-related files when necessary.
   * @alias module:model/JobStorageInfo
   */
  constructor() {}

  /**
   * Initializes the fields of this object.
   * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
   * Only for internal use.
   */
  static initialize(obj) {}

  /**
   * Constructs a <code>JobStorageInfo</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/JobStorageInfo} obj Optional instance to populate.
   * @return {module:model/JobStorageInfo} The populated <code>JobStorageInfo</code> instance.
   */
  static constructFromObject(data, obj) {
    if (data) {
      obj = obj || new JobStorageInfo();

      if (data.hasOwnProperty("shaman_checkout_id")) {
        obj["shaman_checkout_id"] = ApiClient.convertToType(
          data["shaman_checkout_id"],
          "String"
        );
      }
    }
    return obj;
  }
}

/**
 * 'Checkout ID' used when creating the Shaman checkout for this job. Aids in removing the checkout directory when the job is removed from Inferix.
 * @member {String} shaman_checkout_id
 */
JobStorageInfo.prototype["shaman_checkout_id"] = undefined;

/**
 * Inferix Manager
 * Inferix Rendering Manager API
 *
 * The version of the OpenAPI document: 0.2.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

/**
 * The SubmittedJob model module.
 * @module model/SubmittedJob
 * @version 0.0.0
 */
class SubmittedJob {
  /**
   * Constructs a new <code>SubmittedJob</code>.
   * Job definition submitted to Inferix.
   * @alias module:model/SubmittedJob
   * @param name {String}
   * @param type {String}
   * @param priority {Number}
   * @param submitterPlatform {String} Operating system of the submitter. This is used to recognise two-way variables. This should be a lower-case version of the platform, like \"linux\", \"windows\", \"darwin\", \"openbsd\", etc. Should be ompatible with Go's `runtime.GOOS`; run `go tool dist list` to get a list of possible platforms. As a special case, the platform \"manager\" can be given, which will be interpreted as \"the Manager's platform\". This is mostly to make test/debug scripts easier, as they can use a static document on all platforms.
   */
  constructor(name, type, priority, submitterPlatform) {
    SubmittedJob.initialize(this, name, type, priority, submitterPlatform);
  }

  /**
   * Initializes the fields of this object.
   * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
   * Only for internal use.
   */
  static initialize(obj, name, type, priority, submitterPlatform) {
    obj["name"] = name;
    obj["type"] = type;
    obj["priority"] = priority || 50;
    obj["submitter_platform"] = submitterPlatform;
  }

  /**
   * Constructs a <code>SubmittedJob</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/SubmittedJob} obj Optional instance to populate.
   * @return {module:model/SubmittedJob} The populated <code>SubmittedJob</code> instance.
   */
  static constructFromObject(data, obj) {
    if (data) {
      obj = obj || new SubmittedJob();

      if (data.hasOwnProperty("name")) {
        obj["name"] = ApiClient.convertToType(data["name"], "String");
      }
      if (data.hasOwnProperty("type")) {
        obj["type"] = ApiClient.convertToType(data["type"], "String");
      }
      if (data.hasOwnProperty("type_etag")) {
        obj["type_etag"] = ApiClient.convertToType(data["type_etag"], "String");
      }
      if (data.hasOwnProperty("priority")) {
        obj["priority"] = ApiClient.convertToType(data["priority"], "Number");
      }
      if (data.hasOwnProperty("settings")) {
        obj["settings"] = ApiClient.convertToType(data["settings"], {
          String: Object,
        });
      }
      if (data.hasOwnProperty("metadata")) {
        obj["metadata"] = ApiClient.convertToType(data["metadata"], {
          String: "String",
        });
      }
      if (data.hasOwnProperty("submitter_platform")) {
        obj["submitter_platform"] = ApiClient.convertToType(
          data["submitter_platform"],
          "String"
        );
      }
      if (data.hasOwnProperty("storage")) {
        obj["storage"] = JobStorageInfo.constructFromObject(data["storage"]);
      }
      if (data.hasOwnProperty("worker_tag")) {
        obj["worker_tag"] = ApiClient.convertToType(
          data["worker_tag"],
          "String"
        );
      }
    }
    return obj;
  }
}

/**
 * @member {String} name
 */
SubmittedJob.prototype["name"] = undefined;

/**
 * @member {String} type
 */
SubmittedJob.prototype["type"] = undefined;

/**
 * Hash of the job type, copied from the `AvailableJobType.etag` property of the job type. The job will be rejected if this field doesn't match the actual job type on the Manager. This prevents job submission with old settings, after the job compiler script has been updated. If this field is ommitted, the check is bypassed.
 * @member {String} type_etag
 */
SubmittedJob.prototype["type_etag"] = undefined;

/**
 * @member {Number} priority
 * @default 50
 */
SubmittedJob.prototype["priority"] = 50;

/**
 * @member {Object.<String, Object>} settings
 */
SubmittedJob.prototype["settings"] = undefined;

/**
 * Arbitrary metadata strings. More complex structures can be modeled by using `a.b.c` notation for the key.
 * @member {Object.<String, String>} metadata
 */
SubmittedJob.prototype["metadata"] = undefined;

/**
 * Operating system of the submitter. This is used to recognise two-way variables. This should be a lower-case version of the platform, like \"linux\", \"windows\", \"darwin\", \"openbsd\", etc. Should be ompatible with Go's `runtime.GOOS`; run `go tool dist list` to get a list of possible platforms. As a special case, the platform \"manager\" can be given, which will be interpreted as \"the Manager's platform\". This is mostly to make test/debug scripts easier, as they can use a static document on all platforms.
 * @member {String} submitter_platform
 */
SubmittedJob.prototype["submitter_platform"] = undefined;

/**
 * @member {module:model/JobStorageInfo} storage
 */
SubmittedJob.prototype["storage"] = undefined;

/**
 * Worker tag that should execute this job. When a tag ID is given, only Workers in that tag will be scheduled to work on it. If empty or ommitted, all workers can work on this job.
 * @member {String} worker_tag
 */
SubmittedJob.prototype["worker_tag"] = undefined;

/**
 * Inferix Manager
 * Inferix Rendering Manager API
 *
 * The version of the OpenAPI document: 0.2.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

/**
 * The Job model module.
 * @module model/Job
 * @version 0.0.0
 */
class Job {
  /**
   * Constructs a new <code>Job</code>.
   * @alias module:model/Job
   * @implements module:model/SubmittedJob
   * @implements module:model/JobAllOf
   * @param name {String}
   * @param type {String}
   * @param priority {Number}
   * @param submitterPlatform {String} Operating system of the submitter. This is used to recognise two-way variables. This should be a lower-case version of the platform, like \"linux\", \"windows\", \"darwin\", \"openbsd\", etc. Should be ompatible with Go's `runtime.GOOS`; run `go tool dist list` to get a list of possible platforms. As a special case, the platform \"manager\" can be given, which will be interpreted as \"the Manager's platform\". This is mostly to make test/debug scripts easier, as they can use a static document on all platforms.
   * @param id {String} UUID of the Job
   * @param created {Date} Creation timestamp
   * @param updated {Date} Timestamp of last update.
   * @param status {module:model/JobStatus}
   * @param activity {String} Description of the last activity on this job.
   */
  constructor(
    name,
    type,
    priority,
    submitterPlatform,
    id,
    created,
    updated,
    status,
    activity
  ) {
    SubmittedJob.initialize(this, name, type, priority, submitterPlatform);
    JobAllOf.initialize(this, id, created, updated, status, activity);
    Job.initialize(
      this,
      name,
      type,
      priority,
      submitterPlatform,
      id,
      created,
      updated,
      status,
      activity
    );
  }

  /**
   * Initializes the fields of this object.
   * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
   * Only for internal use.
   */
  static initialize(
    obj,
    name,
    type,
    priority,
    submitterPlatform,
    id,
    created,
    updated,
    status,
    activity
  ) {
    obj["name"] = name;
    obj["type"] = type;
    obj["priority"] = priority || 50;
    obj["submitter_platform"] = submitterPlatform;
    obj["id"] = id;
    obj["created"] = created;
    obj["updated"] = updated;
    obj["status"] = status;
    obj["activity"] = activity;
  }

  /**
   * Constructs a <code>Job</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/Job} obj Optional instance to populate.
   * @return {module:model/Job} The populated <code>Job</code> instance.
   */
  static constructFromObject(data, obj) {
    if (data) {
      obj = obj || new Job();
      SubmittedJob.constructFromObject(data, obj);
      JobAllOf.constructFromObject(data, obj);

      if (data.hasOwnProperty("name")) {
        obj["name"] = ApiClient.convertToType(data["name"], "String");
      }
      if (data.hasOwnProperty("type")) {
        obj["type"] = ApiClient.convertToType(data["type"], "String");
      }
      if (data.hasOwnProperty("type_etag")) {
        obj["type_etag"] = ApiClient.convertToType(data["type_etag"], "String");
      }
      if (data.hasOwnProperty("priority")) {
        obj["priority"] = ApiClient.convertToType(data["priority"], "Number");
      }
      if (data.hasOwnProperty("settings")) {
        obj["settings"] = ApiClient.convertToType(data["settings"], {
          String: Object,
        });
      }
      if (data.hasOwnProperty("metadata")) {
        obj["metadata"] = ApiClient.convertToType(data["metadata"], {
          String: "String",
        });
      }
      if (data.hasOwnProperty("submitter_platform")) {
        obj["submitter_platform"] = ApiClient.convertToType(
          data["submitter_platform"],
          "String"
        );
      }
      if (data.hasOwnProperty("storage")) {
        obj["storage"] = JobStorageInfo.constructFromObject(data["storage"]);
      }
      if (data.hasOwnProperty("worker_tag")) {
        obj["worker_tag"] = ApiClient.convertToType(
          data["worker_tag"],
          "String"
        );
      }
      if (data.hasOwnProperty("id")) {
        obj["id"] = ApiClient.convertToType(data["id"], "String");
      }
      if (data.hasOwnProperty("created")) {
        obj["created"] = ApiClient.convertToType(data["created"], "Date");
      }
      if (data.hasOwnProperty("updated")) {
        obj["updated"] = ApiClient.convertToType(data["updated"], "Date");
      }
      if (data.hasOwnProperty("status")) {
        obj["status"] = JobStatus.constructFromObject(data["status"]);
      }
      if (data.hasOwnProperty("activity")) {
        obj["activity"] = ApiClient.convertToType(data["activity"], "String");
      }
      if (data.hasOwnProperty("delete_requested_at")) {
        obj["delete_requested_at"] = ApiClient.convertToType(
          data["delete_requested_at"],
          "Date"
        );
      }
    }
    return obj;
  }
}

/**
 * @member {String} name
 */
Job.prototype["name"] = undefined;

/**
 * @member {String} type
 */
Job.prototype["type"] = undefined;

/**
 * Hash of the job type, copied from the `AvailableJobType.etag` property of the job type. The job will be rejected if this field doesn't match the actual job type on the Manager. This prevents job submission with old settings, after the job compiler script has been updated. If this field is ommitted, the check is bypassed.
 * @member {String} type_etag
 */
Job.prototype["type_etag"] = undefined;

/**
 * @member {Number} priority
 * @default 50
 */
Job.prototype["priority"] = 50;

/**
 * @member {Object.<String, Object>} settings
 */
Job.prototype["settings"] = undefined;

/**
 * Arbitrary metadata strings. More complex structures can be modeled by using `a.b.c` notation for the key.
 * @member {Object.<String, String>} metadata
 */
Job.prototype["metadata"] = undefined;

/**
 * Operating system of the submitter. This is used to recognise two-way variables. This should be a lower-case version of the platform, like \"linux\", \"windows\", \"darwin\", \"openbsd\", etc. Should be ompatible with Go's `runtime.GOOS`; run `go tool dist list` to get a list of possible platforms. As a special case, the platform \"manager\" can be given, which will be interpreted as \"the Manager's platform\". This is mostly to make test/debug scripts easier, as they can use a static document on all platforms.
 * @member {String} submitter_platform
 */
Job.prototype["submitter_platform"] = undefined;

/**
 * @member {module:model/JobStorageInfo} storage
 */
Job.prototype["storage"] = undefined;

/**
 * Worker tag that should execute this job. When a tag ID is given, only Workers in that tag will be scheduled to work on it. If empty or ommitted, all workers can work on this job.
 * @member {String} worker_tag
 */
Job.prototype["worker_tag"] = undefined;

/**
 * UUID of the Job
 * @member {String} id
 */
Job.prototype["id"] = undefined;

/**
 * Creation timestamp
 * @member {Date} created
 */
Job.prototype["created"] = undefined;

/**
 * Timestamp of last update.
 * @member {Date} updated
 */
Job.prototype["updated"] = undefined;

/**
 * @member {module:model/JobStatus} status
 */
Job.prototype["status"] = undefined;

/**
 * Description of the last activity on this job.
 * @member {String} activity
 */
Job.prototype["activity"] = undefined;

/**
 * If job deletion was requested, this is the timestamp at which that request was stored on Inferix Manager.
 * @member {Date} delete_requested_at
 */
Job.prototype["delete_requested_at"] = undefined;

// Implement SubmittedJob interface:
/**
 * @member {String} name
 */
SubmittedJob.prototype["name"] = undefined;
/**
 * @member {String} type
 */
SubmittedJob.prototype["type"] = undefined;
/**
 * Hash of the job type, copied from the `AvailableJobType.etag` property of the job type. The job will be rejected if this field doesn't match the actual job type on the Manager. This prevents job submission with old settings, after the job compiler script has been updated. If this field is ommitted, the check is bypassed.
 * @member {String} type_etag
 */
SubmittedJob.prototype["type_etag"] = undefined;
/**
 * @member {Number} priority
 * @default 50
 */
SubmittedJob.prototype["priority"] = 50;
/**
 * @member {Object.<String, Object>} settings
 */
SubmittedJob.prototype["settings"] = undefined;
/**
 * Arbitrary metadata strings. More complex structures can be modeled by using `a.b.c` notation for the key.
 * @member {Object.<String, String>} metadata
 */
SubmittedJob.prototype["metadata"] = undefined;
/**
 * Operating system of the submitter. This is used to recognise two-way variables. This should be a lower-case version of the platform, like \"linux\", \"windows\", \"darwin\", \"openbsd\", etc. Should be ompatible with Go's `runtime.GOOS`; run `go tool dist list` to get a list of possible platforms. As a special case, the platform \"manager\" can be given, which will be interpreted as \"the Manager's platform\". This is mostly to make test/debug scripts easier, as they can use a static document on all platforms.
 * @member {String} submitter_platform
 */
SubmittedJob.prototype["submitter_platform"] = undefined;
/**
 * @member {module:model/JobStorageInfo} storage
 */
SubmittedJob.prototype["storage"] = undefined;
/**
 * Worker tag that should execute this job. When a tag ID is given, only Workers in that tag will be scheduled to work on it. If empty or ommitted, all workers can work on this job.
 * @member {String} worker_tag
 */
SubmittedJob.prototype["worker_tag"] = undefined;
// Implement JobAllOf interface:
/**
 * UUID of the Job
 * @member {String} id
 */
JobAllOf.prototype["id"] = undefined;
/**
 * Creation timestamp
 * @member {Date} created
 */
JobAllOf.prototype["created"] = undefined;
/**
 * Timestamp of last update.
 * @member {Date} updated
 */
JobAllOf.prototype["updated"] = undefined;
/**
 * @member {module:model/JobStatus} status
 */
JobAllOf.prototype["status"] = undefined;
/**
 * Description of the last activity on this job.
 * @member {String} activity
 */
JobAllOf.prototype["activity"] = undefined;
/**
 * If job deletion was requested, this is the timestamp at which that request was stored on Inferix Manager.
 * @member {Date} delete_requested_at
 */
JobAllOf.prototype["delete_requested_at"] = undefined;

/**
 * Inferix Manager
 * Inferix Rendering Manager API
 *
 * The version of the OpenAPI document: 0.2.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

/**
 * The JobBlocklistEntry model module.
 * @module model/JobBlocklistEntry
 * @version 0.0.0
 */
class JobBlocklistEntry {
  /**
   * Constructs a new <code>JobBlocklistEntry</code>.
   * @alias module:model/JobBlocklistEntry
   * @param workerId {String}
   * @param taskType {String}
   */
  constructor(workerId, taskType) {
    JobBlocklistEntry.initialize(this, workerId, taskType);
  }

  /**
   * Initializes the fields of this object.
   * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
   * Only for internal use.
   */
  static initialize(obj, workerId, taskType) {
    obj["worker_id"] = workerId;
    obj["task_type"] = taskType;
  }

  /**
   * Constructs a <code>JobBlocklistEntry</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/JobBlocklistEntry} obj Optional instance to populate.
   * @return {module:model/JobBlocklistEntry} The populated <code>JobBlocklistEntry</code> instance.
   */
  static constructFromObject(data, obj) {
    if (data) {
      obj = obj || new JobBlocklistEntry();

      if (data.hasOwnProperty("worker_id")) {
        obj["worker_id"] = ApiClient.convertToType(data["worker_id"], "String");
      }
      if (data.hasOwnProperty("task_type")) {
        obj["task_type"] = ApiClient.convertToType(data["task_type"], "String");
      }
      if (data.hasOwnProperty("worker_name")) {
        obj["worker_name"] = ApiClient.convertToType(
          data["worker_name"],
          "String"
        );
      }
    }
    return obj;
  }
}

/**
 * @member {String} worker_id
 */
JobBlocklistEntry.prototype["worker_id"] = undefined;

/**
 * @member {String} task_type
 */
JobBlocklistEntry.prototype["task_type"] = undefined;

/**
 * @member {String} worker_name
 */
JobBlocklistEntry.prototype["worker_name"] = undefined;

/**
 * Inferix Manager
 * Inferix Rendering Manager API
 *
 * The version of the OpenAPI document: 0.2.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

/**
 * The JobDeletionInfo model module.
 * @module model/JobDeletionInfo
 * @version 0.0.0
 */
class JobDeletionInfo {
  /**
   * Constructs a new <code>JobDeletionInfo</code>.
   * Info about what will be deleted when this job is deleted.
   * @alias module:model/JobDeletionInfo
   * @param shamanCheckout {Boolean} Whether the Shaman checkout directory will be removed along with the job.
   */
  constructor(shamanCheckout) {
    JobDeletionInfo.initialize(this, shamanCheckout);
  }

  /**
   * Initializes the fields of this object.
   * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
   * Only for internal use.
   */
  static initialize(obj, shamanCheckout) {
    obj["shaman_checkout"] = shamanCheckout;
  }

  /**
   * Constructs a <code>JobDeletionInfo</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/JobDeletionInfo} obj Optional instance to populate.
   * @return {module:model/JobDeletionInfo} The populated <code>JobDeletionInfo</code> instance.
   */
  static constructFromObject(data, obj) {
    if (data) {
      obj = obj || new JobDeletionInfo();

      if (data.hasOwnProperty("shaman_checkout")) {
        obj["shaman_checkout"] = ApiClient.convertToType(
          data["shaman_checkout"],
          "Boolean"
        );
      }
    }
    return obj;
  }
}

/**
 * Whether the Shaman checkout directory will be removed along with the job.
 * @member {Boolean} shaman_checkout
 */
JobDeletionInfo.prototype["shaman_checkout"] = undefined;

/**
 * Inferix Manager
 * Inferix Rendering Manager API
 *
 * The version of the OpenAPI document: 0.2.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

/**
 * The JobLastRenderedImageInfo model module.
 * @module model/JobLastRenderedImageInfo
 * @version 0.0.0
 */
class JobLastRenderedImageInfo {
  /**
   * Constructs a new <code>JobLastRenderedImageInfo</code>.
   * Enough information for a client to piece together different strings to form a host-relative URL to the last-rendered image. To construct the URL, concatenate \&quot;{base}/{one of the suffixes}\&quot;.
   * @alias module:model/JobLastRenderedImageInfo
   * @param base {String}
   * @param suffixes {Array.<String>}
   */
  constructor(base, suffixes) {
    JobLastRenderedImageInfo.initialize(this, base, suffixes);
  }

  /**
   * Initializes the fields of this object.
   * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
   * Only for internal use.
   */
  static initialize(obj, base, suffixes) {
    obj["base"] = base;
    obj["suffixes"] = suffixes;
  }

  /**
   * Constructs a <code>JobLastRenderedImageInfo</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/JobLastRenderedImageInfo} obj Optional instance to populate.
   * @return {module:model/JobLastRenderedImageInfo} The populated <code>JobLastRenderedImageInfo</code> instance.
   */
  static constructFromObject(data, obj) {
    if (data) {
      obj = obj || new JobLastRenderedImageInfo();

      if (data.hasOwnProperty("base")) {
        obj["base"] = ApiClient.convertToType(data["base"], "String");
      }
      if (data.hasOwnProperty("suffixes")) {
        obj["suffixes"] = ApiClient.convertToType(data["suffixes"], ["String"]);
      }
    }
    return obj;
  }
}

/**
 * @member {String} base
 */
JobLastRenderedImageInfo.prototype["base"] = undefined;

/**
 * @member {Array.<String>} suffixes
 */
JobLastRenderedImageInfo.prototype["suffixes"] = undefined;

/**
 * Inferix Manager
 * Inferix Rendering Manager API
 *
 * The version of the OpenAPI document: 0.2.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

/**
 * The JobStatusChange model module.
 * @module model/JobStatusChange
 * @version 0.0.0
 */
class JobStatusChange {
  /**
   * Constructs a new <code>JobStatusChange</code>.
   * @alias module:model/JobStatusChange
   * @param status {module:model/JobStatus}
   * @param reason {String} The reason for this status change.
   */
  constructor(status, reason) {
    JobStatusChange.initialize(this, status, reason);
  }

  /**
   * Initializes the fields of this object.
   * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
   * Only for internal use.
   */
  static initialize(obj, status, reason) {
    obj["status"] = status;
    obj["reason"] = reason;
  }

  /**
   * Constructs a <code>JobStatusChange</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/JobStatusChange} obj Optional instance to populate.
   * @return {module:model/JobStatusChange} The populated <code>JobStatusChange</code> instance.
   */
  static constructFromObject(data, obj) {
    if (data) {
      obj = obj || new JobStatusChange();

      if (data.hasOwnProperty("status")) {
        obj["status"] = JobStatus.constructFromObject(data["status"]);
      }
      if (data.hasOwnProperty("reason")) {
        obj["reason"] = ApiClient.convertToType(data["reason"], "String");
      }
    }
    return obj;
  }
}

/**
 * @member {module:model/JobStatus} status
 */
JobStatusChange.prototype["status"] = undefined;

/**
 * The reason for this status change.
 * @member {String} reason
 */
JobStatusChange.prototype["reason"] = undefined;

/**
 * Inferix Manager
 * Inferix Rendering Manager API
 *
 * The version of the OpenAPI document: 0.2.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

/**
 * The TaskSummary model module.
 * @module model/TaskSummary
 * @version 0.0.0
 */
class TaskSummary {
  /**
   * Constructs a new <code>TaskSummary</code>.
   * Just enough information about the task to show in the job&#39;s task list.
   * @alias module:model/TaskSummary
   * @param id {String}
   * @param name {String}
   * @param status {module:model/TaskStatus}
   * @param priority {Number}
   * @param taskType {String}
   * @param updated {Date}
   */
  constructor(id, name, status, priority, taskType, updated) {
    TaskSummary.initialize(this, id, name, status, priority, taskType, updated);
  }

  /**
   * Initializes the fields of this object.
   * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
   * Only for internal use.
   */
  static initialize(obj, id, name, status, priority, taskType, updated) {
    obj["id"] = id;
    obj["name"] = name;
    obj["status"] = status;
    obj["priority"] = priority;
    obj["task_type"] = taskType;
    obj["updated"] = updated;
  }

  /**
   * Constructs a <code>TaskSummary</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/TaskSummary} obj Optional instance to populate.
   * @return {module:model/TaskSummary} The populated <code>TaskSummary</code> instance.
   */
  static constructFromObject(data, obj) {
    if (data) {
      obj = obj || new TaskSummary();

      if (data.hasOwnProperty("id")) {
        obj["id"] = ApiClient.convertToType(data["id"], "String");
      }
      if (data.hasOwnProperty("name")) {
        obj["name"] = ApiClient.convertToType(data["name"], "String");
      }
      if (data.hasOwnProperty("status")) {
        obj["status"] = TaskStatus.constructFromObject(data["status"]);
      }
      if (data.hasOwnProperty("priority")) {
        obj["priority"] = ApiClient.convertToType(data["priority"], "Number");
      }
      if (data.hasOwnProperty("task_type")) {
        obj["task_type"] = ApiClient.convertToType(data["task_type"], "String");
      }
      if (data.hasOwnProperty("updated")) {
        obj["updated"] = ApiClient.convertToType(data["updated"], "Date");
      }
    }
    return obj;
  }
}

/**
 * @member {String} id
 */
TaskSummary.prototype["id"] = undefined;

/**
 * @member {String} name
 */
TaskSummary.prototype["name"] = undefined;

/**
 * @member {module:model/TaskStatus} status
 */
TaskSummary.prototype["status"] = undefined;

/**
 * @member {Number} priority
 */
TaskSummary.prototype["priority"] = undefined;

/**
 * @member {String} task_type
 */
TaskSummary.prototype["task_type"] = undefined;

/**
 * @member {Date} updated
 */
TaskSummary.prototype["updated"] = undefined;

/**
 * Inferix Manager
 * Inferix Rendering Manager API
 *
 * The version of the OpenAPI document: 0.2.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

/**
 * The JobTasksSummary model module.
 * @module model/JobTasksSummary
 * @version 0.0.0
 */
class JobTasksSummary {
  /**
   * Constructs a new <code>JobTasksSummary</code>.
   * Simplified list of tasks of a job. Contains all tasks, but not all info of each task.
   * @alias module:model/JobTasksSummary
   */
  constructor() {
    JobTasksSummary.initialize(this);
  }

  /**
   * Initializes the fields of this object.
   * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
   * Only for internal use.
   */
  static initialize(obj) {}

  /**
   * Constructs a <code>JobTasksSummary</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/JobTasksSummary} obj Optional instance to populate.
   * @return {module:model/JobTasksSummary} The populated <code>JobTasksSummary</code> instance.
   */
  static constructFromObject(data, obj) {
    if (data) {
      obj = obj || new JobTasksSummary();

      if (data.hasOwnProperty("tasks")) {
        obj["tasks"] = ApiClient.convertToType(data["tasks"], [TaskSummary]);
      }
    }
    return obj;
  }
}

/**
 * @member {Array.<module:model/TaskSummary>} tasks
 */
JobTasksSummary.prototype["tasks"] = undefined;

/**
 * Inferix Manager
 * Inferix Rendering Manager API
 *
 * The version of the OpenAPI document: 0.2.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

/**
 * The JobsQueryResult model module.
 * @module model/JobsQueryResult
 * @version 0.0.0
 */
class JobsQueryResult {
  /**
   * Constructs a new <code>JobsQueryResult</code>.
   * @alias module:model/JobsQueryResult
   * @param jobs {Array.<module:model/Job>}
   */
  constructor(jobs) {
    JobsQueryResult.initialize(this, jobs);
  }

  /**
   * Initializes the fields of this object.
   * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
   * Only for internal use.
   */
  static initialize(obj, jobs) {
    obj["jobs"] = jobs;
  }

  /**
   * Constructs a <code>JobsQueryResult</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/JobsQueryResult} obj Optional instance to populate.
   * @return {module:model/JobsQueryResult} The populated <code>JobsQueryResult</code> instance.
   */
  static constructFromObject(data, obj) {
    if (data) {
      obj = obj || new JobsQueryResult();

      if (data.hasOwnProperty("jobs")) {
        obj["jobs"] = ApiClient.convertToType(data["jobs"], [Job]);
      }
    }
    return obj;
  }
}

/**
 * @member {Array.<module:model/Job>} jobs
 */
JobsQueryResult.prototype["jobs"] = undefined;

/**
 * Inferix Manager
 * Inferix Rendering Manager API
 *
 * The version of the OpenAPI document: 0.2.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

/**
 * The ManagerConfiguration model module.
 * @module model/ManagerConfiguration
 * @version 0.0.0
 */
class ManagerConfiguration {
  /**
   * Constructs a new <code>ManagerConfiguration</code>.
   * @alias module:model/ManagerConfiguration
   * @param storageLocation {String} Directory used for job file storage.
   * @param shamanEnabled {Boolean} Whether the Shaman file transfer API is available.
   * @param isFirstRun {Boolean} Whether this is considered the first time the Manager runs. This is determined by a few factors, like a non-existent configuration file or certain settings being empty while they shouldn't be.
   */
  constructor(storageLocation, shamanEnabled, isFirstRun) {
    ManagerConfiguration.initialize(
      this,
      storageLocation,
      shamanEnabled,
      isFirstRun
    );
  }

  /**
   * Initializes the fields of this object.
   * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
   * Only for internal use.
   */
  static initialize(obj, storageLocation, shamanEnabled, isFirstRun) {
    obj["storageLocation"] = storageLocation;
    obj["shamanEnabled"] = shamanEnabled;
    obj["isFirstRun"] = isFirstRun;
  }

  /**
   * Constructs a <code>ManagerConfiguration</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/ManagerConfiguration} obj Optional instance to populate.
   * @return {module:model/ManagerConfiguration} The populated <code>ManagerConfiguration</code> instance.
   */
  static constructFromObject(data, obj) {
    if (data) {
      obj = obj || new ManagerConfiguration();

      if (data.hasOwnProperty("storageLocation")) {
        obj["storageLocation"] = ApiClient.convertToType(
          data["storageLocation"],
          "String"
        );
      }
      if (data.hasOwnProperty("shamanEnabled")) {
        obj["shamanEnabled"] = ApiClient.convertToType(
          data["shamanEnabled"],
          "Boolean"
        );
      }
      if (data.hasOwnProperty("isFirstRun")) {
        obj["isFirstRun"] = ApiClient.convertToType(
          data["isFirstRun"],
          "Boolean"
        );
      }
    }
    return obj;
  }
}

/**
 * Directory used for job file storage.
 * @member {String} storageLocation
 */
ManagerConfiguration.prototype["storageLocation"] = undefined;

/**
 * Whether the Shaman file transfer API is available.
 * @member {Boolean} shamanEnabled
 */
ManagerConfiguration.prototype["shamanEnabled"] = undefined;

/**
 * Whether this is considered the first time the Manager runs. This is determined by a few factors, like a non-existent configuration file or certain settings being empty while they shouldn't be.
 * @member {Boolean} isFirstRun
 */
ManagerConfiguration.prototype["isFirstRun"] = undefined;

/**
 * Inferix Manager
 * Inferix Rendering Manager API
 *
 * The version of the OpenAPI document: 0.2.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

/**
 * The ManagerVariable model module.
 * @module model/ManagerVariable
 * @version 0.0.0
 */
class ManagerVariable {
  /**
   * Constructs a new <code>ManagerVariable</code>.
   * @alias module:model/ManagerVariable
   * @param value {String}
   * @param isTwoway {Boolean} One-way variables are the most common one, and are simple replacement from `{name}` to their value, which happens when a Task is given to a Worker. Two-way variables are also replaced when submitting a job, where the platform-specific value is replaced by `{name}`.
   */
  constructor(value, isTwoway) {
    ManagerVariable.initialize(this, value, isTwoway);
  }

  /**
   * Initializes the fields of this object.
   * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
   * Only for internal use.
   */
  static initialize(obj, value, isTwoway) {
    obj["value"] = value;
    obj["is_twoway"] = isTwoway;
  }

  /**
   * Constructs a <code>ManagerVariable</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/ManagerVariable} obj Optional instance to populate.
   * @return {module:model/ManagerVariable} The populated <code>ManagerVariable</code> instance.
   */
  static constructFromObject(data, obj) {
    if (data) {
      obj = obj || new ManagerVariable();

      if (data.hasOwnProperty("value")) {
        obj["value"] = ApiClient.convertToType(data["value"], "String");
      }
      if (data.hasOwnProperty("is_twoway")) {
        obj["is_twoway"] = ApiClient.convertToType(
          data["is_twoway"],
          "Boolean"
        );
      }
    }
    return obj;
  }
}

/**
 * @member {String} value
 */
ManagerVariable.prototype["value"] = undefined;

/**
 * One-way variables are the most common one, and are simple replacement from `{name}` to their value, which happens when a Task is given to a Worker. Two-way variables are also replaced when submitting a job, where the platform-specific value is replaced by `{name}`.
 * @member {Boolean} is_twoway
 */
ManagerVariable.prototype["is_twoway"] = undefined;

/**
 * Inferix Manager
 * Inferix Rendering Manager API
 *
 * The version of the OpenAPI document: 0.2.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

/**
 * Enum class ManagerVariableAudience.
 * @enum {}
 * @readonly
 */
class ManagerVariableAudience {
  /**
   * value: "workers"
   * @const
   */
  workers = "workers";

  /**
   * value: "users"
   * @const
   */
  users = "users";

  /**
   * Returns a <code>ManagerVariableAudience</code> enum value from a Javascript object name.
   * @param {Object} data The plain JavaScript object containing the name of the enum value.
   * @return {module:model/ManagerVariableAudience} The enum <code>ManagerVariableAudience</code> value.
   */
  static constructFromObject(object) {
    return object;
  }
}

/**
 * Inferix Manager
 * Inferix Rendering Manager API
 *
 * The version of the OpenAPI document: 0.2.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

/**
 * The PathCheckInput model module.
 * @module model/PathCheckInput
 * @version 0.0.0
 */
class PathCheckInput {
  /**
   * Constructs a new <code>PathCheckInput</code>.
   * @alias module:model/PathCheckInput
   * @param path {String}
   */
  constructor(path) {
    PathCheckInput.initialize(this, path);
  }

  /**
   * Initializes the fields of this object.
   * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
   * Only for internal use.
   */
  static initialize(obj, path) {
    obj["path"] = path;
  }

  /**
   * Constructs a <code>PathCheckInput</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/PathCheckInput} obj Optional instance to populate.
   * @return {module:model/PathCheckInput} The populated <code>PathCheckInput</code> instance.
   */
  static constructFromObject(data, obj) {
    if (data) {
      obj = obj || new PathCheckInput();

      if (data.hasOwnProperty("path")) {
        obj["path"] = ApiClient.convertToType(data["path"], "String");
      }
    }
    return obj;
  }
}

/**
 * @member {String} path
 */
PathCheckInput.prototype["path"] = undefined;

/**
 * Inferix Manager
 * Inferix Rendering Manager API
 *
 * The version of the OpenAPI document: 0.2.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

/**
 * The PathCheckResult model module.
 * @module model/PathCheckResult
 * @version 0.0.0
 */
class PathCheckResult {
  /**
   * Constructs a new <code>PathCheckResult</code>.
   * @alias module:model/PathCheckResult
   * @param path {String} The path that was checked.
   * @param isUsable {Boolean} Whether the path is usable or not.
   * @param cause {String} Description of why this path is (not) usable.
   */
  constructor(path, isUsable, cause) {
    PathCheckResult.initialize(this, path, isUsable, cause);
  }

  /**
   * Initializes the fields of this object.
   * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
   * Only for internal use.
   */
  static initialize(obj, path, isUsable, cause) {
    obj["path"] = path;
    obj["is_usable"] = isUsable;
    obj["cause"] = cause;
  }

  /**
   * Constructs a <code>PathCheckResult</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/PathCheckResult} obj Optional instance to populate.
   * @return {module:model/PathCheckResult} The populated <code>PathCheckResult</code> instance.
   */
  static constructFromObject(data, obj) {
    if (data) {
      obj = obj || new PathCheckResult();

      if (data.hasOwnProperty("path")) {
        obj["path"] = ApiClient.convertToType(data["path"], "String");
      }
      if (data.hasOwnProperty("is_usable")) {
        obj["is_usable"] = ApiClient.convertToType(
          data["is_usable"],
          "Boolean"
        );
      }
      if (data.hasOwnProperty("cause")) {
        obj["cause"] = ApiClient.convertToType(data["cause"], "String");
      }
    }
    return obj;
  }
}

/**
 * The path that was checked.
 * @member {String} path
 */
PathCheckResult.prototype["path"] = undefined;

/**
 * Whether the path is usable or not.
 * @member {Boolean} is_usable
 */
PathCheckResult.prototype["is_usable"] = undefined;

/**
 * Description of why this path is (not) usable.
 * @member {String} cause
 */
PathCheckResult.prototype["cause"] = undefined;

/**
 * Inferix Manager
 * Inferix Rendering Manager API
 *
 * The version of the OpenAPI document: 0.2.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

/**
 * Enum class WorkerStatus.
 * @enum {}
 * @readonly
 */
class WorkerStatus {
  /**
   * value: "starting"
   * @const
   */
  starting = "starting";

  /**
   * value: "awake"
   * @const
   */
  awake = "awake";

  /**
   * value: "asleep"
   * @const
   */
  asleep = "asleep";

  /**
   * value: "error"
   * @const
   */
  error = "error";

  /**
   * value: "testing"
   * @const
   */
  testing = "testing";

  /**
   * value: "offline"
   * @const
   */
  offline = "offline";

  /**
   * Returns a <code>WorkerStatus</code> enum value from a Javascript object name.
   * @param {Object} data The plain JavaScript object containing the name of the enum value.
   * @return {module:model/WorkerStatus} The enum <code>WorkerStatus</code> value.
   */
  static constructFromObject(object) {
    return object;
  }
}

/**
 * Inferix Manager
 * Inferix Rendering Manager API
 *
 * The version of the OpenAPI document: 0.2.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

/**
 * The SetupAssistantConfig model module.
 * @module model/SetupAssistantConfig
 * @version 0.0.0
 */
class SetupAssistantConfig {
  /**
   * Constructs a new <code>SetupAssistantConfig</code>.
   * Configuration obtained from the Setup Assistant.
   * @alias module:model/SetupAssistantConfig
   * @param storageLocation {String} Directory used for job file storage.
   * @param blenderExecutable {module:model/BlenderPathCheckResult}
   */
  constructor(storageLocation, blenderExecutable) {
    SetupAssistantConfig.initialize(this, storageLocation, blenderExecutable);
  }

  /**
   * Initializes the fields of this object.
   * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
   * Only for internal use.
   */
  static initialize(obj, storageLocation, blenderExecutable) {
    obj["storageLocation"] = storageLocation;
    obj["blenderExecutable"] = blenderExecutable;
  }

  /**
   * Constructs a <code>SetupAssistantConfig</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/SetupAssistantConfig} obj Optional instance to populate.
   * @return {module:model/SetupAssistantConfig} The populated <code>SetupAssistantConfig</code> instance.
   */
  static constructFromObject(data, obj) {
    if (data) {
      obj = obj || new SetupAssistantConfig();

      if (data.hasOwnProperty("storageLocation")) {
        obj["storageLocation"] = ApiClient.convertToType(
          data["storageLocation"],
          "String"
        );
      }
      if (data.hasOwnProperty("blenderExecutable")) {
        obj["blenderExecutable"] = BlenderPathCheckResult.constructFromObject(
          data["blenderExecutable"]
        );
      }
    }
    return obj;
  }
}

/**
 * Directory used for job file storage.
 * @member {String} storageLocation
 */
SetupAssistantConfig.prototype["storageLocation"] = undefined;

/**
 * @member {module:model/BlenderPathCheckResult} blenderExecutable
 */
SetupAssistantConfig.prototype["blenderExecutable"] = undefined;

/**
 * Inferix Manager
 * Inferix Rendering Manager API
 *
 * The version of the OpenAPI document: 0.2.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

/**
 * The SharedStorageLocation model module.
 * @module model/SharedStorageLocation
 * @version 0.0.0
 */
class SharedStorageLocation {
  /**
   * Constructs a new <code>SharedStorageLocation</code>.
   * Location of the shared storage, adjusted for a specific audience &amp; platform. This uses two-way variables to adjust the shared storage path from the Manager&#39;s configuration.
   * @alias module:model/SharedStorageLocation
   * @param location {String}
   * @param audience {module:model/ManagerVariableAudience}
   * @param platform {String}
   * @param shamanEnabled {Boolean} Whether the Shaman file transfer API is available.
   */
  constructor(location, audience, platform, shamanEnabled) {
    SharedStorageLocation.initialize(
      this,
      location,
      audience,
      platform,
      shamanEnabled
    );
  }

  /**
   * Initializes the fields of this object.
   * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
   * Only for internal use.
   */
  static initialize(obj, location, audience, platform, shamanEnabled) {
    obj["location"] = location;
    obj["audience"] = audience;
    obj["platform"] = platform;
    obj["shamanEnabled"] = shamanEnabled;
  }

  /**
   * Constructs a <code>SharedStorageLocation</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/SharedStorageLocation} obj Optional instance to populate.
   * @return {module:model/SharedStorageLocation} The populated <code>SharedStorageLocation</code> instance.
   */
  static constructFromObject(data, obj) {
    if (data) {
      obj = obj || new SharedStorageLocation();

      if (data.hasOwnProperty("location")) {
        obj["location"] = ApiClient.convertToType(data["location"], "String");
      }
      if (data.hasOwnProperty("audience")) {
        obj["audience"] = ManagerVariableAudience.constructFromObject(
          data["audience"]
        );
      }
      if (data.hasOwnProperty("platform")) {
        obj["platform"] = ApiClient.convertToType(data["platform"], "String");
      }
      if (data.hasOwnProperty("shamanEnabled")) {
        obj["shamanEnabled"] = ApiClient.convertToType(
          data["shamanEnabled"],
          "Boolean"
        );
      }
    }
    return obj;
  }
}

/**
 * @member {String} location
 */
SharedStorageLocation.prototype["location"] = undefined;

/**
 * @member {module:model/ManagerVariableAudience} audience
 */
SharedStorageLocation.prototype["audience"] = undefined;

/**
 * @member {String} platform
 */
SharedStorageLocation.prototype["platform"] = undefined;

/**
 * Whether the Shaman file transfer API is available.
 * @member {Boolean} shamanEnabled
 */
SharedStorageLocation.prototype["shamanEnabled"] = undefined;

/**
 * Inferix Manager
 * Inferix Rendering Manager API
 *
 * The version of the OpenAPI document: 0.2.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

/**
 * The SocketIOJobUpdate model module.
 * @module model/SocketIOJobUpdate
 * @version 0.0.0
 */
class SocketIOJobUpdate {
  /**
   * Constructs a new <code>SocketIOJobUpdate</code>.
   * Subset of a Job, sent over SocketIO when a job changes. For new jobs, &#x60;previous_status&#x60; will be excluded.
   * @alias module:model/SocketIOJobUpdate
   * @param id {String} UUID of the Job
   * @param updated {Date} Timestamp of last update
   * @param status {module:model/JobStatus}
   * @param type {String}
   * @param priority {Number}
   * @param refreshTasks {Boolean} Indicates that the client should refresh all the job's tasks. This is sent for mass updates, where updating each individual task would generate too many updates to be practical.
   */
  constructor(id, updated, status, type, priority, refreshTasks) {
    SocketIOJobUpdate.initialize(
      this,
      id,
      updated,
      status,
      type,
      priority,
      refreshTasks
    );
  }

  /**
   * Initializes the fields of this object.
   * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
   * Only for internal use.
   */
  static initialize(obj, id, updated, status, type, priority, refreshTasks) {
    obj["id"] = id;
    obj["updated"] = updated;
    obj["status"] = status;
    obj["type"] = type;
    obj["priority"] = priority || 50;
    obj["refresh_tasks"] = refreshTasks;
  }

  /**
   * Constructs a <code>SocketIOJobUpdate</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/SocketIOJobUpdate} obj Optional instance to populate.
   * @return {module:model/SocketIOJobUpdate} The populated <code>SocketIOJobUpdate</code> instance.
   */
  static constructFromObject(data, obj) {
    if (data) {
      obj = obj || new SocketIOJobUpdate();

      if (data.hasOwnProperty("id")) {
        obj["id"] = ApiClient.convertToType(data["id"], "String");
      }
      if (data.hasOwnProperty("name")) {
        obj["name"] = ApiClient.convertToType(data["name"], "String");
      }
      if (data.hasOwnProperty("updated")) {
        obj["updated"] = ApiClient.convertToType(data["updated"], "Date");
      }
      if (data.hasOwnProperty("status")) {
        obj["status"] = JobStatus.constructFromObject(data["status"]);
      }
      if (data.hasOwnProperty("previous_status")) {
        obj["previous_status"] = JobStatus.constructFromObject(
          data["previous_status"]
        );
      }
      if (data.hasOwnProperty("type")) {
        obj["type"] = ApiClient.convertToType(data["type"], "String");
      }
      if (data.hasOwnProperty("priority")) {
        obj["priority"] = ApiClient.convertToType(data["priority"], "Number");
      }
      if (data.hasOwnProperty("refresh_tasks")) {
        obj["refresh_tasks"] = ApiClient.convertToType(
          data["refresh_tasks"],
          "Boolean"
        );
      }
      if (data.hasOwnProperty("delete_requested_at")) {
        obj["delete_requested_at"] = ApiClient.convertToType(
          data["delete_requested_at"],
          "Date"
        );
      }
      if (data.hasOwnProperty("was_deleted")) {
        obj["was_deleted"] = ApiClient.convertToType(
          data["was_deleted"],
          "Boolean"
        );
      }
    }
    return obj;
  }
}

/**
 * UUID of the Job
 * @member {String} id
 */
SocketIOJobUpdate.prototype["id"] = undefined;

/**
 * Name of the job
 * @member {String} name
 */
SocketIOJobUpdate.prototype["name"] = undefined;

/**
 * Timestamp of last update
 * @member {Date} updated
 */
SocketIOJobUpdate.prototype["updated"] = undefined;

/**
 * @member {module:model/JobStatus} status
 */
SocketIOJobUpdate.prototype["status"] = undefined;

/**
 * @member {module:model/JobStatus} previous_status
 */
SocketIOJobUpdate.prototype["previous_status"] = undefined;

/**
 * @member {String} type
 */
SocketIOJobUpdate.prototype["type"] = undefined;

/**
 * @member {Number} priority
 * @default 50
 */
SocketIOJobUpdate.prototype["priority"] = 50;

/**
 * Indicates that the client should refresh all the job's tasks. This is sent for mass updates, where updating each individual task would generate too many updates to be practical.
 * @member {Boolean} refresh_tasks
 */
SocketIOJobUpdate.prototype["refresh_tasks"] = undefined;

/**
 * If job deletion was requested, this is the timestamp at which that request was stored on Inferix Manager.
 * @member {Date} delete_requested_at
 */
SocketIOJobUpdate.prototype["delete_requested_at"] = undefined;

/**
 * When a job was just deleted, this is set to `true`. If this is specified, only the 'id' field is set, the rest will be empty.
 * @member {Boolean} was_deleted
 */
SocketIOJobUpdate.prototype["was_deleted"] = undefined;

/**
 * Inferix Manager
 * Inferix Rendering Manager API
 *
 * The version of the OpenAPI document: 0.2.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

/**
 * The SocketIOLastRenderedUpdate model module.
 * @module model/SocketIOLastRenderedUpdate
 * @version 0.0.0
 */
class SocketIOLastRenderedUpdate {
  /**
   * Constructs a new <code>SocketIOLastRenderedUpdate</code>.
   * Indicator that the last-rendered image of this job was updated.
   * @alias module:model/SocketIOLastRenderedUpdate
   * @param jobId {String}
   * @param thumbnail {module:model/JobLastRenderedImageInfo}
   */
  constructor(jobId, thumbnail) {
    SocketIOLastRenderedUpdate.initialize(this, jobId, thumbnail);
  }

  /**
   * Initializes the fields of this object.
   * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
   * Only for internal use.
   */
  static initialize(obj, jobId, thumbnail) {
    obj["job_id"] = jobId;
    obj["thumbnail"] = thumbnail;
  }

  /**
   * Constructs a <code>SocketIOLastRenderedUpdate</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/SocketIOLastRenderedUpdate} obj Optional instance to populate.
   * @return {module:model/SocketIOLastRenderedUpdate} The populated <code>SocketIOLastRenderedUpdate</code> instance.
   */
  static constructFromObject(data, obj) {
    if (data) {
      obj = obj || new SocketIOLastRenderedUpdate();

      if (data.hasOwnProperty("job_id")) {
        obj["job_id"] = ApiClient.convertToType(data["job_id"], "String");
      }
      if (data.hasOwnProperty("thumbnail")) {
        obj["thumbnail"] = JobLastRenderedImageInfo.constructFromObject(
          data["thumbnail"]
        );
      }
    }
    return obj;
  }
}

/**
 * @member {String} job_id
 */
SocketIOLastRenderedUpdate.prototype["job_id"] = undefined;

/**
 * @member {module:model/JobLastRenderedImageInfo} thumbnail
 */
SocketIOLastRenderedUpdate.prototype["thumbnail"] = undefined;

/**
 * Inferix Manager
 * Inferix Rendering Manager API
 *
 * The version of the OpenAPI document: 0.2.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

/**
 * Enum class SocketIOSubscriptionOperation.
 * @enum {}
 * @readonly
 */
class SocketIOSubscriptionOperation {
  /**
   * value: "subscribe"
   * @const
   */
  subscribe = "subscribe";

  /**
   * value: "unsubscribe"
   * @const
   */
  unsubscribe = "unsubscribe";

  /**
   * Returns a <code>SocketIOSubscriptionOperation</code> enum value from a Javascript object name.
   * @param {Object} data The plain JavaScript object containing the name of the enum value.
   * @return {module:model/SocketIOSubscriptionOperation} The enum <code>SocketIOSubscriptionOperation</code> value.
   */
  static constructFromObject(object) {
    return object;
  }
}

/**
 * Inferix Manager
 * Inferix Rendering Manager API
 *
 * The version of the OpenAPI document: 0.2.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

/**
 * Enum class SocketIOSubscriptionType.
 * @enum {}
 * @readonly
 */
class SocketIOSubscriptionType {
  /**
   * value: "allJobs"
   * @const
   */
  allJobs = "allJobs";

  /**
   * value: "allWorkers"
   * @const
   */
  allWorkers = "allWorkers";

  /**
   * value: "job"
   * @const
   */
  job = "job";

  /**
   * value: "tasklog"
   * @const
   */
  tasklog = "tasklog";

  /**
   * value: "allLastRendered"
   * @const
   */
  allLastRendered = "allLastRendered";

  /**
   * Returns a <code>SocketIOSubscriptionType</code> enum value from a Javascript object name.
   * @param {Object} data The plain JavaScript object containing the name of the enum value.
   * @return {module:model/SocketIOSubscriptionType} The enum <code>SocketIOSubscriptionType</code> value.
   */
  static constructFromObject(object) {
    return object;
  }
}

/**
 * Inferix Manager
 * Inferix Rendering Manager API
 *
 * The version of the OpenAPI document: 0.2.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

/**
 * The SocketIOSubscription model module.
 * @module model/SocketIOSubscription
 * @version 0.0.0
 */
class SocketIOSubscription {
  /**
   * Constructs a new <code>SocketIOSubscription</code>.
   * Send by SocketIO clients as &#x60;/subscription&#x60; event type, to manage their subscription to job updates. Clients always get job updates, but for task updates or task logs they need to explicitly subscribe. For simplicity, clients can only subscribe to one job (to get task updates for that job) and one task&#39;s log at a time.
   * @alias module:model/SocketIOSubscription
   * @param op {module:model/SocketIOSubscriptionOperation}
   * @param type {module:model/SocketIOSubscriptionType}
   */
  constructor(op, type) {
    SocketIOSubscription.initialize(this, op, type);
  }

  /**
   * Initializes the fields of this object.
   * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
   * Only for internal use.
   */
  static initialize(obj, op, type) {
    obj["op"] = op;
    obj["type"] = type;
  }

  /**
   * Constructs a <code>SocketIOSubscription</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/SocketIOSubscription} obj Optional instance to populate.
   * @return {module:model/SocketIOSubscription} The populated <code>SocketIOSubscription</code> instance.
   */
  static constructFromObject(data, obj) {
    if (data) {
      obj = obj || new SocketIOSubscription();

      if (data.hasOwnProperty("op")) {
        obj["op"] = SocketIOSubscriptionOperation.constructFromObject(
          data["op"]
        );
      }
      if (data.hasOwnProperty("type")) {
        obj["type"] = SocketIOSubscriptionType.constructFromObject(
          data["type"]
        );
      }
      if (data.hasOwnProperty("uuid")) {
        obj["uuid"] = ApiClient.convertToType(data["uuid"], "String");
      }
    }
    return obj;
  }
}

/**
 * @member {module:model/SocketIOSubscriptionOperation} op
 */
SocketIOSubscription.prototype["op"] = undefined;

/**
 * @member {module:model/SocketIOSubscriptionType} type
 */
SocketIOSubscription.prototype["type"] = undefined;

/**
 * UUID of the thing to subscribe to / unsubscribe from.
 * @member {String} uuid
 */
SocketIOSubscription.prototype["uuid"] = undefined;

/**
 * Inferix Manager
 * Inferix Rendering Manager API
 *
 * The version of the OpenAPI document: 0.2.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

/**
 * The SocketIOTaskLogUpdate model module.
 * @module model/SocketIOTaskLogUpdate
 * @version 0.0.0
 */
class SocketIOTaskLogUpdate {
  /**
   * Constructs a new <code>SocketIOTaskLogUpdate</code>.
   * Task log chunk, sent to a SocketIO room dedicated to a single task, to avoid sending too many updates.
   * @alias module:model/SocketIOTaskLogUpdate
   * @param taskId {String} UUID of the Task
   * @param log {String} Chunk of the task log. May contain multiple lines of text.
   */
  constructor(taskId, log) {
    SocketIOTaskLogUpdate.initialize(this, taskId, log);
  }

  /**
   * Initializes the fields of this object.
   * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
   * Only for internal use.
   */
  static initialize(obj, taskId, log) {
    obj["task_id"] = taskId;
    obj["log"] = log;
  }

  /**
   * Constructs a <code>SocketIOTaskLogUpdate</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/SocketIOTaskLogUpdate} obj Optional instance to populate.
   * @return {module:model/SocketIOTaskLogUpdate} The populated <code>SocketIOTaskLogUpdate</code> instance.
   */
  static constructFromObject(data, obj) {
    if (data) {
      obj = obj || new SocketIOTaskLogUpdate();

      if (data.hasOwnProperty("task_id")) {
        obj["task_id"] = ApiClient.convertToType(data["task_id"], "String");
      }
      if (data.hasOwnProperty("log")) {
        obj["log"] = ApiClient.convertToType(data["log"], "String");
      }
    }
    return obj;
  }
}

/**
 * UUID of the Task
 * @member {String} task_id
 */
SocketIOTaskLogUpdate.prototype["task_id"] = undefined;

/**
 * Chunk of the task log. May contain multiple lines of text.
 * @member {String} log
 */
SocketIOTaskLogUpdate.prototype["log"] = undefined;

/**
 * Inferix Manager
 * Inferix Rendering Manager API
 *
 * The version of the OpenAPI document: 0.2.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

/**
 * The SocketIOTaskUpdate model module.
 * @module model/SocketIOTaskUpdate
 * @version 0.0.0
 */
class SocketIOTaskUpdate {
  /**
   * Constructs a new <code>SocketIOTaskUpdate</code>.
   * Subset of a Task, sent over SocketIO when a task changes. For new tasks, &#x60;previous_status&#x60; will be excluded.
   * @alias module:model/SocketIOTaskUpdate
   * @param id {String} UUID of the Task
   * @param jobId {String}
   * @param name {String} Name of the task
   * @param updated {Date} Timestamp of last update
   * @param status {module:model/TaskStatus}
   * @param activity {String}
   */
  constructor(id, jobId, name, updated, status, activity) {
    SocketIOTaskUpdate.initialize(
      this,
      id,
      jobId,
      name,
      updated,
      status,
      activity
    );
  }

  /**
   * Initializes the fields of this object.
   * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
   * Only for internal use.
   */
  static initialize(obj, id, jobId, name, updated, status, activity) {
    obj["id"] = id;
    obj["job_id"] = jobId;
    obj["name"] = name;
    obj["updated"] = updated;
    obj["status"] = status;
    obj["activity"] = activity;
  }

  /**
   * Constructs a <code>SocketIOTaskUpdate</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/SocketIOTaskUpdate} obj Optional instance to populate.
   * @return {module:model/SocketIOTaskUpdate} The populated <code>SocketIOTaskUpdate</code> instance.
   */
  static constructFromObject(data, obj) {
    if (data) {
      obj = obj || new SocketIOTaskUpdate();

      if (data.hasOwnProperty("id")) {
        obj["id"] = ApiClient.convertToType(data["id"], "String");
      }
      if (data.hasOwnProperty("job_id")) {
        obj["job_id"] = ApiClient.convertToType(data["job_id"], "String");
      }
      if (data.hasOwnProperty("name")) {
        obj["name"] = ApiClient.convertToType(data["name"], "String");
      }
      if (data.hasOwnProperty("updated")) {
        obj["updated"] = ApiClient.convertToType(data["updated"], "Date");
      }
      if (data.hasOwnProperty("status")) {
        obj["status"] = TaskStatus.constructFromObject(data["status"]);
      }
      if (data.hasOwnProperty("previous_status")) {
        obj["previous_status"] = TaskStatus.constructFromObject(
          data["previous_status"]
        );
      }
      if (data.hasOwnProperty("activity")) {
        obj["activity"] = ApiClient.convertToType(data["activity"], "String");
      }
    }
    return obj;
  }
}

/**
 * UUID of the Task
 * @member {String} id
 */
SocketIOTaskUpdate.prototype["id"] = undefined;

/**
 * @member {String} job_id
 */
SocketIOTaskUpdate.prototype["job_id"] = undefined;

/**
 * Name of the task
 * @member {String} name
 */
SocketIOTaskUpdate.prototype["name"] = undefined;

/**
 * Timestamp of last update
 * @member {Date} updated
 */
SocketIOTaskUpdate.prototype["updated"] = undefined;

/**
 * @member {module:model/TaskStatus} status
 */
SocketIOTaskUpdate.prototype["status"] = undefined;

/**
 * @member {module:model/TaskStatus} previous_status
 */
SocketIOTaskUpdate.prototype["previous_status"] = undefined;

/**
 * @member {String} activity
 */
SocketIOTaskUpdate.prototype["activity"] = undefined;

/**
 * Inferix Manager
 * Inferix Rendering Manager API
 *
 * The version of the OpenAPI document: 0.2.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

/**
 * The WorkerStatusChangeRequest model module.
 * @module model/WorkerStatusChangeRequest
 * @version 0.0.0
 */
class WorkerStatusChangeRequest {
  /**
   * Constructs a new <code>WorkerStatusChangeRequest</code>.
   * Request for a Worker to change its status to &#x60;status&#x60;.
   * @alias module:model/WorkerStatusChangeRequest
   * @param status {module:model/WorkerStatus}
   * @param isLazy {Boolean} Whether the status change should happen immediately, or after the worker's current task is finished.
   */
  constructor(status, isLazy) {
    WorkerStatusChangeRequest.initialize(this, status, isLazy);
  }

  /**
   * Initializes the fields of this object.
   * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
   * Only for internal use.
   */
  static initialize(obj, status, isLazy) {
    obj["status"] = status;
    obj["is_lazy"] = isLazy;
  }

  /**
   * Constructs a <code>WorkerStatusChangeRequest</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/WorkerStatusChangeRequest} obj Optional instance to populate.
   * @return {module:model/WorkerStatusChangeRequest} The populated <code>WorkerStatusChangeRequest</code> instance.
   */
  static constructFromObject(data, obj) {
    if (data) {
      obj = obj || new WorkerStatusChangeRequest();

      if (data.hasOwnProperty("status")) {
        obj["status"] = WorkerStatus.constructFromObject(data["status"]);
      }
      if (data.hasOwnProperty("is_lazy")) {
        obj["is_lazy"] = ApiClient.convertToType(data["is_lazy"], "Boolean");
      }
    }
    return obj;
  }
}

/**
 * @member {module:model/WorkerStatus} status
 */
WorkerStatusChangeRequest.prototype["status"] = undefined;

/**
 * Whether the status change should happen immediately, or after the worker's current task is finished.
 * @member {Boolean} is_lazy
 */
WorkerStatusChangeRequest.prototype["is_lazy"] = undefined;

/**
 * Inferix Manager
 * Inferix Rendering Manager API
 *
 * The version of the OpenAPI document: 0.2.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

/**
 * The SocketIOWorkerUpdate model module.
 * @module model/SocketIOWorkerUpdate
 * @version 0.0.0
 */
class SocketIOWorkerUpdate {
  /**
   * Constructs a new <code>SocketIOWorkerUpdate</code>.
   * Subset of a Worker, sent over SocketIO when a worker changes.
   * @alias module:model/SocketIOWorkerUpdate
   * @param id {String} UUID of the Worker
   * @param name {String} Name of the worker
   * @param updated {Date} Timestamp of last update
   * @param status {module:model/WorkerStatus}
   * @param version {String}
   */
  constructor(id, name, updated, status, version) {
    SocketIOWorkerUpdate.initialize(this, id, name, updated, status, version);
  }

  /**
   * Initializes the fields of this object.
   * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
   * Only for internal use.
   */
  static initialize(obj, id, name, updated, status, version) {
    obj["id"] = id;
    obj["name"] = name;
    obj["updated"] = updated;
    obj["status"] = status;
    obj["version"] = version;
  }

  /**
   * Constructs a <code>SocketIOWorkerUpdate</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/SocketIOWorkerUpdate} obj Optional instance to populate.
   * @return {module:model/SocketIOWorkerUpdate} The populated <code>SocketIOWorkerUpdate</code> instance.
   */
  static constructFromObject(data, obj) {
    if (data) {
      obj = obj || new SocketIOWorkerUpdate();

      if (data.hasOwnProperty("id")) {
        obj["id"] = ApiClient.convertToType(data["id"], "String");
      }
      if (data.hasOwnProperty("name")) {
        obj["name"] = ApiClient.convertToType(data["name"], "String");
      }
      if (data.hasOwnProperty("updated")) {
        obj["updated"] = ApiClient.convertToType(data["updated"], "Date");
      }
      if (data.hasOwnProperty("last_seen")) {
        obj["last_seen"] = ApiClient.convertToType(data["last_seen"], "Date");
      }
      if (data.hasOwnProperty("status")) {
        obj["status"] = WorkerStatus.constructFromObject(data["status"]);
      }
      if (data.hasOwnProperty("previous_status")) {
        obj["previous_status"] = WorkerStatus.constructFromObject(
          data["previous_status"]
        );
      }
      if (data.hasOwnProperty("status_change")) {
        obj["status_change"] = WorkerStatusChangeRequest.constructFromObject(
          data["status_change"]
        );
      }
      if (data.hasOwnProperty("version")) {
        obj["version"] = ApiClient.convertToType(data["version"], "String");
      }
      if (data.hasOwnProperty("deleted_at")) {
        obj["deleted_at"] = ApiClient.convertToType(data["deleted_at"], "Date");
      }
    }
    return obj;
  }
}

/**
 * UUID of the Worker
 * @member {String} id
 */
SocketIOWorkerUpdate.prototype["id"] = undefined;

/**
 * Name of the worker
 * @member {String} name
 */
SocketIOWorkerUpdate.prototype["name"] = undefined;

/**
 * Timestamp of last update
 * @member {Date} updated
 */
SocketIOWorkerUpdate.prototype["updated"] = undefined;

/**
 * Last time this worker was seen by the Manager.
 * @member {Date} last_seen
 */
SocketIOWorkerUpdate.prototype["last_seen"] = undefined;

/**
 * @member {module:model/WorkerStatus} status
 */
SocketIOWorkerUpdate.prototype["status"] = undefined;

/**
 * @member {module:model/WorkerStatus} previous_status
 */
SocketIOWorkerUpdate.prototype["previous_status"] = undefined;

/**
 * @member {module:model/WorkerStatusChangeRequest} status_change
 */
SocketIOWorkerUpdate.prototype["status_change"] = undefined;

/**
 * @member {String} version
 */
SocketIOWorkerUpdate.prototype["version"] = undefined;

/**
 * This is only set when the worker was deleted.
 * @member {Date} deleted_at
 */
SocketIOWorkerUpdate.prototype["deleted_at"] = undefined;

/**
 * Inferix Manager
 * Inferix Rendering Manager API
 *
 * The version of the OpenAPI document: 0.2.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

/**
 * The TaskWorker model module.
 * @module model/TaskWorker
 * @version 0.0.0
 */
class TaskWorker {
  /**
   * Constructs a new <code>TaskWorker</code>.
   * Worker reference, as used in Task objects.
   * @alias module:model/TaskWorker
   * @param id {String}
   * @param name {String}
   * @param address {String}
   */
  constructor(id, name, address) {
    TaskWorker.initialize(this, id, name, address);
  }

  /**
   * Initializes the fields of this object.
   * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
   * Only for internal use.
   */
  static initialize(obj, id, name, address) {
    obj["id"] = id;
    obj["name"] = name;
    obj["address"] = address;
  }

  /**
   * Constructs a <code>TaskWorker</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/TaskWorker} obj Optional instance to populate.
   * @return {module:model/TaskWorker} The populated <code>TaskWorker</code> instance.
   */
  static constructFromObject(data, obj) {
    if (data) {
      obj = obj || new TaskWorker();

      if (data.hasOwnProperty("id")) {
        obj["id"] = ApiClient.convertToType(data["id"], "String");
      }
      if (data.hasOwnProperty("name")) {
        obj["name"] = ApiClient.convertToType(data["name"], "String");
      }
      if (data.hasOwnProperty("address")) {
        obj["address"] = ApiClient.convertToType(data["address"], "String");
      }
    }
    return obj;
  }
}

/**
 * @member {String} id
 */
TaskWorker.prototype["id"] = undefined;

/**
 * @member {String} name
 */
TaskWorker.prototype["name"] = undefined;

/**
 * @member {String} address
 */
TaskWorker.prototype["address"] = undefined;

/**
 * Inferix Manager
 * Inferix Rendering Manager API
 *
 * The version of the OpenAPI document: 0.2.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

/**
 * The Task model module.
 * @module model/Task
 * @version 0.0.0
 */
class Task {
  /**
   * Constructs a new <code>Task</code>.
   * The task as it exists in the Manager database, i.e. before variable replacement.
   * @alias module:model/Task
   * @param id {String}
   * @param created {Date} Creation timestamp
   * @param updated {Date} Timestamp of last update.
   * @param jobId {String}
   * @param name {String}
   * @param status {module:model/TaskStatus}
   * @param priority {Number}
   * @param taskType {String}
   * @param activity {String}
   * @param commands {Array.<module:model/Command>}
   */
  constructor(
    id,
    created,
    updated,
    jobId,
    name,
    status,
    priority,
    taskType,
    activity,
    commands
  ) {
    Task.initialize(
      this,
      id,
      created,
      updated,
      jobId,
      name,
      status,
      priority,
      taskType,
      activity,
      commands
    );
  }

  /**
   * Initializes the fields of this object.
   * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
   * Only for internal use.
   */
  static initialize(
    obj,
    id,
    created,
    updated,
    jobId,
    name,
    status,
    priority,
    taskType,
    activity,
    commands
  ) {
    obj["id"] = id;
    obj["created"] = created;
    obj["updated"] = updated;
    obj["job_id"] = jobId;
    obj["name"] = name;
    obj["status"] = status;
    obj["priority"] = priority;
    obj["task_type"] = taskType;
    obj["activity"] = activity;
    obj["commands"] = commands;
  }

  /**
   * Constructs a <code>Task</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/Task} obj Optional instance to populate.
   * @return {module:model/Task} The populated <code>Task</code> instance.
   */
  static constructFromObject(data, obj) {
    if (data) {
      obj = obj || new Task();

      if (data.hasOwnProperty("id")) {
        obj["id"] = ApiClient.convertToType(data["id"], "String");
      }
      if (data.hasOwnProperty("created")) {
        obj["created"] = ApiClient.convertToType(data["created"], "Date");
      }
      if (data.hasOwnProperty("updated")) {
        obj["updated"] = ApiClient.convertToType(data["updated"], "Date");
      }
      if (data.hasOwnProperty("job_id")) {
        obj["job_id"] = ApiClient.convertToType(data["job_id"], "String");
      }
      if (data.hasOwnProperty("name")) {
        obj["name"] = ApiClient.convertToType(data["name"], "String");
      }
      if (data.hasOwnProperty("status")) {
        obj["status"] = TaskStatus.constructFromObject(data["status"]);
      }
      if (data.hasOwnProperty("priority")) {
        obj["priority"] = ApiClient.convertToType(data["priority"], "Number");
      }
      if (data.hasOwnProperty("task_type")) {
        obj["task_type"] = ApiClient.convertToType(data["task_type"], "String");
      }
      if (data.hasOwnProperty("activity")) {
        obj["activity"] = ApiClient.convertToType(data["activity"], "String");
      }
      if (data.hasOwnProperty("commands")) {
        obj["commands"] = ApiClient.convertToType(data["commands"], [Command]);
      }
      if (data.hasOwnProperty("worker")) {
        obj["worker"] = TaskWorker.constructFromObject(data["worker"]);
      }
      if (data.hasOwnProperty("last_touched")) {
        obj["last_touched"] = ApiClient.convertToType(
          data["last_touched"],
          "Date"
        );
      }
      if (data.hasOwnProperty("failed_by_workers")) {
        obj["failed_by_workers"] = ApiClient.convertToType(
          data["failed_by_workers"],
          [TaskWorker]
        );
      }
    }
    return obj;
  }
}

/**
 * @member {String} id
 */
Task.prototype["id"] = undefined;

/**
 * Creation timestamp
 * @member {Date} created
 */
Task.prototype["created"] = undefined;

/**
 * Timestamp of last update.
 * @member {Date} updated
 */
Task.prototype["updated"] = undefined;

/**
 * @member {String} job_id
 */
Task.prototype["job_id"] = undefined;

/**
 * @member {String} name
 */
Task.prototype["name"] = undefined;

/**
 * @member {module:model/TaskStatus} status
 */
Task.prototype["status"] = undefined;

/**
 * @member {Number} priority
 */
Task.prototype["priority"] = undefined;

/**
 * @member {String} task_type
 */
Task.prototype["task_type"] = undefined;

/**
 * @member {String} activity
 */
Task.prototype["activity"] = undefined;

/**
 * @member {Array.<module:model/Command>} commands
 */
Task.prototype["commands"] = undefined;

/**
 * @member {module:model/TaskWorker} worker
 */
Task.prototype["worker"] = undefined;

/**
 * Timestamp of when any worker worked on this task.
 * @member {Date} last_touched
 */
Task.prototype["last_touched"] = undefined;

/**
 * @member {Array.<module:model/TaskWorker>} failed_by_workers
 */
Task.prototype["failed_by_workers"] = undefined;

/**
 * Inferix Manager
 * Inferix Rendering Manager API
 *
 * The version of the OpenAPI document: 0.2.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

/**
 * The TaskLogInfo model module.
 * @module model/TaskLogInfo
 * @version 0.0.0
 */
class TaskLogInfo {
  /**
   * Constructs a new <code>TaskLogInfo</code>.
   * Info about the log of a single task.
   * @alias module:model/TaskLogInfo
   * @param taskId {String}
   * @param jobId {String}
   * @param url {String} The URL at which the task log itself can be downloaded.
   * @param size {Number} The size of the task log, in bytes.
   */
  constructor(taskId, jobId, url, size) {
    TaskLogInfo.initialize(this, taskId, jobId, url, size);
  }

  /**
   * Initializes the fields of this object.
   * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
   * Only for internal use.
   */
  static initialize(obj, taskId, jobId, url, size) {
    obj["task_id"] = taskId;
    obj["job_id"] = jobId;
    obj["url"] = url;
    obj["size"] = size;
  }

  /**
   * Constructs a <code>TaskLogInfo</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/TaskLogInfo} obj Optional instance to populate.
   * @return {module:model/TaskLogInfo} The populated <code>TaskLogInfo</code> instance.
   */
  static constructFromObject(data, obj) {
    if (data) {
      obj = obj || new TaskLogInfo();

      if (data.hasOwnProperty("task_id")) {
        obj["task_id"] = ApiClient.convertToType(data["task_id"], "String");
      }
      if (data.hasOwnProperty("job_id")) {
        obj["job_id"] = ApiClient.convertToType(data["job_id"], "String");
      }
      if (data.hasOwnProperty("url")) {
        obj["url"] = ApiClient.convertToType(data["url"], "String");
      }
      if (data.hasOwnProperty("size")) {
        obj["size"] = ApiClient.convertToType(data["size"], "Number");
      }
    }
    return obj;
  }
}

/**
 * @member {String} task_id
 */
TaskLogInfo.prototype["task_id"] = undefined;

/**
 * @member {String} job_id
 */
TaskLogInfo.prototype["job_id"] = undefined;

/**
 * The URL at which the task log itself can be downloaded.
 * @member {String} url
 */
TaskLogInfo.prototype["url"] = undefined;

/**
 * The size of the task log, in bytes.
 * @member {Number} size
 */
TaskLogInfo.prototype["size"] = undefined;

/**
 * Inferix Manager
 * Inferix Rendering Manager API
 *
 * The version of the OpenAPI document: 0.2.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

/**
 * The TaskStatusChange model module.
 * @module model/TaskStatusChange
 * @version 0.0.0
 */
class TaskStatusChange {
  /**
   * Constructs a new <code>TaskStatusChange</code>.
   * @alias module:model/TaskStatusChange
   * @param status {module:model/TaskStatus}
   * @param reason {String} The reason for this status change.
   */
  constructor(status, reason) {
    TaskStatusChange.initialize(this, status, reason);
  }

  /**
   * Initializes the fields of this object.
   * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
   * Only for internal use.
   */
  static initialize(obj, status, reason) {
    obj["status"] = status;
    obj["reason"] = reason;
  }

  /**
   * Constructs a <code>TaskStatusChange</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/TaskStatusChange} obj Optional instance to populate.
   * @return {module:model/TaskStatusChange} The populated <code>TaskStatusChange</code> instance.
   */
  static constructFromObject(data, obj) {
    if (data) {
      obj = obj || new TaskStatusChange();

      if (data.hasOwnProperty("status")) {
        obj["status"] = TaskStatus.constructFromObject(data["status"]);
      }
      if (data.hasOwnProperty("reason")) {
        obj["reason"] = ApiClient.convertToType(data["reason"], "String");
      }
    }
    return obj;
  }
}

/**
 * @member {module:model/TaskStatus} status
 */
TaskStatusChange.prototype["status"] = undefined;

/**
 * The reason for this status change.
 * @member {String} reason
 */
TaskStatusChange.prototype["reason"] = undefined;

/**
 * Inferix Manager
 * Inferix Rendering Manager API
 *
 * The version of the OpenAPI document: 0.2.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

/**
 * The WorkerTag model module.
 * @module model/WorkerTag
 * @version 0.0.0
 */
class WorkerTag {
  /**
   * Constructs a new <code>WorkerTag</code>.
   * Tag of workers. A job can optionally specify which tag it should be limited to. Workers can be part of multiple tags simultaneously.
   * @alias module:model/WorkerTag
   * @param name {String}
   */
  constructor(name) {
    WorkerTag.initialize(this, name);
  }

  /**
   * Initializes the fields of this object.
   * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
   * Only for internal use.
   */
  static initialize(obj, name) {
    obj["name"] = name;
  }

  /**
   * Constructs a <code>WorkerTag</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/WorkerTag} obj Optional instance to populate.
   * @return {module:model/WorkerTag} The populated <code>WorkerTag</code> instance.
   */
  static constructFromObject(data, obj) {
    if (data) {
      obj = obj || new WorkerTag();

      if (data.hasOwnProperty("id")) {
        obj["id"] = ApiClient.convertToType(data["id"], "String");
      }
      if (data.hasOwnProperty("name")) {
        obj["name"] = ApiClient.convertToType(data["name"], "String");
      }
      if (data.hasOwnProperty("description")) {
        obj["description"] = ApiClient.convertToType(
          data["description"],
          "String"
        );
      }
    }
    return obj;
  }
}

/**
 * UUID of the tag. Can be ommitted when creating a new tag, in which case a random UUID will be assigned.
 * @member {String} id
 */
WorkerTag.prototype["id"] = undefined;

/**
 * @member {String} name
 */
WorkerTag.prototype["name"] = undefined;

/**
 * @member {String} description
 */
WorkerTag.prototype["description"] = undefined;

/**
 * Inferix Manager
 * Inferix Rendering Manager API
 *
 * The version of the OpenAPI document: 0.2.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

/**
 * The WorkerTaskAllOf model module.
 * @module model/WorkerTaskAllOf
 * @version 0.0.0
 */
class WorkerTaskAllOf {
  /**
   * Constructs a new <code>WorkerTaskAllOf</code>.
   * @alias module:model/WorkerTaskAllOf
   * @param jobId {String}
   */
  constructor(jobId) {
    WorkerTaskAllOf.initialize(this, jobId);
  }

  /**
   * Initializes the fields of this object.
   * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
   * Only for internal use.
   */
  static initialize(obj, jobId) {
    obj["job_id"] = jobId;
  }

  /**
   * Constructs a <code>WorkerTaskAllOf</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/WorkerTaskAllOf} obj Optional instance to populate.
   * @return {module:model/WorkerTaskAllOf} The populated <code>WorkerTaskAllOf</code> instance.
   */
  static constructFromObject(data, obj) {
    if (data) {
      obj = obj || new WorkerTaskAllOf();

      if (data.hasOwnProperty("job_id")) {
        obj["job_id"] = ApiClient.convertToType(data["job_id"], "String");
      }
    }
    return obj;
  }
}

/**
 * @member {String} job_id
 */
WorkerTaskAllOf.prototype["job_id"] = undefined;

/**
 * Inferix Manager
 * Inferix Rendering Manager API
 *
 * The version of the OpenAPI document: 0.2.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

/**
 * The WorkerTask model module.
 * @module model/WorkerTask
 * @version 0.0.0
 */
class WorkerTask {
  /**
   * Constructs a new <code>WorkerTask</code>.
   * Task assigned to a Worker.
   * @alias module:model/WorkerTask
   * @implements module:model/TaskSummary
   * @implements module:model/WorkerTaskAllOf
   * @param id {String}
   * @param name {String}
   * @param status {module:model/TaskStatus}
   * @param priority {Number}
   * @param taskType {String}
   * @param updated {Date}
   * @param jobId {String}
   */
  constructor(id, name, status, priority, taskType, updated, jobId) {
    TaskSummary.initialize(this, id, name, status, priority, taskType, updated);
    WorkerTaskAllOf.initialize(this, jobId);
    WorkerTask.initialize(
      this,
      id,
      name,
      status,
      priority,
      taskType,
      updated,
      jobId
    );
  }

  /**
   * Initializes the fields of this object.
   * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
   * Only for internal use.
   */
  static initialize(obj, id, name, status, priority, taskType, updated, jobId) {
    obj["id"] = id;
    obj["name"] = name;
    obj["status"] = status;
    obj["priority"] = priority;
    obj["task_type"] = taskType;
    obj["updated"] = updated;
    obj["job_id"] = jobId;
  }

  /**
   * Constructs a <code>WorkerTask</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/WorkerTask} obj Optional instance to populate.
   * @return {module:model/WorkerTask} The populated <code>WorkerTask</code> instance.
   */
  static constructFromObject(data, obj) {
    if (data) {
      obj = obj || new WorkerTask();
      TaskSummary.constructFromObject(data, obj);
      WorkerTaskAllOf.constructFromObject(data, obj);

      if (data.hasOwnProperty("id")) {
        obj["id"] = ApiClient.convertToType(data["id"], "String");
      }
      if (data.hasOwnProperty("name")) {
        obj["name"] = ApiClient.convertToType(data["name"], "String");
      }
      if (data.hasOwnProperty("status")) {
        obj["status"] = TaskStatus.constructFromObject(data["status"]);
      }
      if (data.hasOwnProperty("priority")) {
        obj["priority"] = ApiClient.convertToType(data["priority"], "Number");
      }
      if (data.hasOwnProperty("task_type")) {
        obj["task_type"] = ApiClient.convertToType(data["task_type"], "String");
      }
      if (data.hasOwnProperty("updated")) {
        obj["updated"] = ApiClient.convertToType(data["updated"], "Date");
      }
      if (data.hasOwnProperty("job_id")) {
        obj["job_id"] = ApiClient.convertToType(data["job_id"], "String");
      }
    }
    return obj;
  }
}

/**
 * @member {String} id
 */
WorkerTask.prototype["id"] = undefined;

/**
 * @member {String} name
 */
WorkerTask.prototype["name"] = undefined;

/**
 * @member {module:model/TaskStatus} status
 */
WorkerTask.prototype["status"] = undefined;

/**
 * @member {Number} priority
 */
WorkerTask.prototype["priority"] = undefined;

/**
 * @member {String} task_type
 */
WorkerTask.prototype["task_type"] = undefined;

/**
 * @member {Date} updated
 */
WorkerTask.prototype["updated"] = undefined;

/**
 * @member {String} job_id
 */
WorkerTask.prototype["job_id"] = undefined;

// Implement TaskSummary interface:
/**
 * @member {String} id
 */
TaskSummary.prototype["id"] = undefined;
/**
 * @member {String} name
 */
TaskSummary.prototype["name"] = undefined;
/**
 * @member {module:model/TaskStatus} status
 */
TaskSummary.prototype["status"] = undefined;
/**
 * @member {Number} priority
 */
TaskSummary.prototype["priority"] = undefined;
/**
 * @member {String} task_type
 */
TaskSummary.prototype["task_type"] = undefined;
/**
 * @member {Date} updated
 */
TaskSummary.prototype["updated"] = undefined;
// Implement WorkerTaskAllOf interface:
/**
 * @member {String} job_id
 */
WorkerTaskAllOf.prototype["job_id"] = undefined;

/**
 * Inferix Manager
 * Inferix Rendering Manager API
 *
 * The version of the OpenAPI document: 0.2.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

/**
 * The WorkerAllOf model module.
 * @module model/WorkerAllOf
 * @version 0.0.0
 */
class WorkerAllOf {
  /**
   * Constructs a new <code>WorkerAllOf</code>.
   * @alias module:model/WorkerAllOf
   * @param ipAddress {String} IP address of the Worker
   * @param platform {String} Operating system of the Worker
   * @param supportedTaskTypes {Array.<String>}
   */
  constructor(ipAddress, platform, supportedTaskTypes) {
    WorkerAllOf.initialize(this, ipAddress, platform, supportedTaskTypes);
  }

  /**
   * Initializes the fields of this object.
   * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
   * Only for internal use.
   */
  static initialize(obj, ipAddress, platform, supportedTaskTypes) {
    obj["ip_address"] = ipAddress;
    obj["platform"] = platform;
    obj["supported_task_types"] = supportedTaskTypes;
  }

  /**
   * Constructs a <code>WorkerAllOf</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/WorkerAllOf} obj Optional instance to populate.
   * @return {module:model/WorkerAllOf} The populated <code>WorkerAllOf</code> instance.
   */
  static constructFromObject(data, obj) {
    if (data) {
      obj = obj || new WorkerAllOf();

      if (data.hasOwnProperty("ip_address")) {
        obj["ip_address"] = ApiClient.convertToType(
          data["ip_address"],
          "String"
        );
      }
      if (data.hasOwnProperty("platform")) {
        obj["platform"] = ApiClient.convertToType(data["platform"], "String");
      }
      if (data.hasOwnProperty("supported_task_types")) {
        obj["supported_task_types"] = ApiClient.convertToType(
          data["supported_task_types"],
          ["String"]
        );
      }
      if (data.hasOwnProperty("task")) {
        obj["task"] = WorkerTask.constructFromObject(data["task"]);
      }
      if (data.hasOwnProperty("tags")) {
        obj["tags"] = ApiClient.convertToType(data["tags"], [WorkerTag]);
      }
    }
    return obj;
  }
}

/**
 * IP address of the Worker
 * @member {String} ip_address
 */
WorkerAllOf.prototype["ip_address"] = undefined;

/**
 * Operating system of the Worker
 * @member {String} platform
 */
WorkerAllOf.prototype["platform"] = undefined;

/**
 * @member {Array.<String>} supported_task_types
 */
WorkerAllOf.prototype["supported_task_types"] = undefined;

/**
 * @member {module:model/WorkerTask} task
 */
WorkerAllOf.prototype["task"] = undefined;

/**
 * Tags of which this Worker is a member.
 * @member {Array.<module:model/WorkerTag>} tags
 */
WorkerAllOf.prototype["tags"] = undefined;

/**
 * Inferix Manager
 * Inferix Rendering Manager API
 *
 * The version of the OpenAPI document: 0.2.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

/**
 * The WorkerSummary model module.
 * @module model/WorkerSummary
 * @version 0.0.0
 */
class WorkerSummary {
  /**
   * Constructs a new <code>WorkerSummary</code>.
   * Basic information about a Worker.
   * @alias module:model/WorkerSummary
   * @param id {String}
   * @param name {String}
   * @param status {module:model/WorkerStatus}
   * @param version {String} Version of Inferix this Worker is running
   */
  constructor(id, name, status, version) {
    WorkerSummary.initialize(this, id, name, status, version);
  }

  /**
   * Initializes the fields of this object.
   * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
   * Only for internal use.
   */
  static initialize(obj, id, name, status, version) {
    obj["id"] = id;
    obj["name"] = name;
    obj["status"] = status;
    obj["version"] = version;
  }

  /**
   * Constructs a <code>WorkerSummary</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/WorkerSummary} obj Optional instance to populate.
   * @return {module:model/WorkerSummary} The populated <code>WorkerSummary</code> instance.
   */
  static constructFromObject(data, obj) {
    if (data) {
      obj = obj || new WorkerSummary();

      if (data.hasOwnProperty("id")) {
        obj["id"] = ApiClient.convertToType(data["id"], "String");
      }
      if (data.hasOwnProperty("name")) {
        obj["name"] = ApiClient.convertToType(data["name"], "String");
      }
      if (data.hasOwnProperty("status")) {
        obj["status"] = WorkerStatus.constructFromObject(data["status"]);
      }
      if (data.hasOwnProperty("status_change")) {
        obj["status_change"] = WorkerStatusChangeRequest.constructFromObject(
          data["status_change"]
        );
      }
      if (data.hasOwnProperty("last_seen")) {
        obj["last_seen"] = ApiClient.convertToType(data["last_seen"], "Date");
      }
      if (data.hasOwnProperty("version")) {
        obj["version"] = ApiClient.convertToType(data["version"], "String");
      }
    }
    return obj;
  }
}

/**
 * @member {String} id
 */
WorkerSummary.prototype["id"] = undefined;

/**
 * @member {String} name
 */
WorkerSummary.prototype["name"] = undefined;

/**
 * @member {module:model/WorkerStatus} status
 */
WorkerSummary.prototype["status"] = undefined;

/**
 * @member {module:model/WorkerStatusChangeRequest} status_change
 */
WorkerSummary.prototype["status_change"] = undefined;

/**
 * Last time this worker was seen by the Manager.
 * @member {Date} last_seen
 */
WorkerSummary.prototype["last_seen"] = undefined;

/**
 * Version of Inferix this Worker is running
 * @member {String} version
 */
WorkerSummary.prototype["version"] = undefined;

/**
 * Inferix Manager
 * Inferix Rendering Manager API
 *
 * The version of the OpenAPI document: 0.2.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

/**
 * The Worker model module.
 * @module model/Worker
 * @version 0.0.0
 */
class Worker {
  /**
   * Constructs a new <code>Worker</code>.
   * All information about a Worker
   * @alias module:model/Worker
   * @implements module:model/WorkerSummary
   * @implements module:model/WorkerAllOf
   * @param id {String}
   * @param name {String}
   * @param status {module:model/WorkerStatus}
   * @param version {String} Version of Inferix this Worker is running
   * @param ipAddress {String} IP address of the Worker
   * @param platform {String} Operating system of the Worker
   * @param supportedTaskTypes {Array.<String>}
   */
  constructor(
    id,
    name,
    status,
    version,
    ipAddress,
    platform,
    supportedTaskTypes
  ) {
    WorkerSummary.initialize(this, id, name, status, version);
    WorkerAllOf.initialize(this, ipAddress, platform, supportedTaskTypes);
    Worker.initialize(
      this,
      id,
      name,
      status,
      version,
      ipAddress,
      platform,
      supportedTaskTypes
    );
  }

  /**
   * Initializes the fields of this object.
   * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
   * Only for internal use.
   */
  static initialize(
    obj,
    id,
    name,
    status,
    version,
    ipAddress,
    platform,
    supportedTaskTypes
  ) {
    obj["id"] = id;
    obj["name"] = name;
    obj["status"] = status;
    obj["version"] = version;
    obj["ip_address"] = ipAddress;
    obj["platform"] = platform;
    obj["supported_task_types"] = supportedTaskTypes;
  }

  /**
   * Constructs a <code>Worker</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/Worker} obj Optional instance to populate.
   * @return {module:model/Worker} The populated <code>Worker</code> instance.
   */
  static constructFromObject(data, obj) {
    if (data) {
      obj = obj || new Worker();
      WorkerSummary.constructFromObject(data, obj);
      WorkerAllOf.constructFromObject(data, obj);

      if (data.hasOwnProperty("id")) {
        obj["id"] = ApiClient.convertToType(data["id"], "String");
      }
      if (data.hasOwnProperty("name")) {
        obj["name"] = ApiClient.convertToType(data["name"], "String");
      }
      if (data.hasOwnProperty("status")) {
        obj["status"] = WorkerStatus.constructFromObject(data["status"]);
      }
      if (data.hasOwnProperty("status_change")) {
        obj["status_change"] = WorkerStatusChangeRequest.constructFromObject(
          data["status_change"]
        );
      }
      if (data.hasOwnProperty("last_seen")) {
        obj["last_seen"] = ApiClient.convertToType(data["last_seen"], "Date");
      }
      if (data.hasOwnProperty("version")) {
        obj["version"] = ApiClient.convertToType(data["version"], "String");
      }
      if (data.hasOwnProperty("ip_address")) {
        obj["ip_address"] = ApiClient.convertToType(
          data["ip_address"],
          "String"
        );
      }
      if (data.hasOwnProperty("platform")) {
        obj["platform"] = ApiClient.convertToType(data["platform"], "String");
      }
      if (data.hasOwnProperty("supported_task_types")) {
        obj["supported_task_types"] = ApiClient.convertToType(
          data["supported_task_types"],
          ["String"]
        );
      }
      if (data.hasOwnProperty("task")) {
        obj["task"] = WorkerTask.constructFromObject(data["task"]);
      }
      if (data.hasOwnProperty("tags")) {
        obj["tags"] = ApiClient.convertToType(data["tags"], [WorkerTag]);
      }
    }
    return obj;
  }
}

/**
 * @member {String} id
 */
Worker.prototype["id"] = undefined;

/**
 * @member {String} name
 */
Worker.prototype["name"] = undefined;

/**
 * @member {module:model/WorkerStatus} status
 */
Worker.prototype["status"] = undefined;

/**
 * @member {module:model/WorkerStatusChangeRequest} status_change
 */
Worker.prototype["status_change"] = undefined;

/**
 * Last time this worker was seen by the Manager.
 * @member {Date} last_seen
 */
Worker.prototype["last_seen"] = undefined;

/**
 * Version of Inferix this Worker is running
 * @member {String} version
 */
Worker.prototype["version"] = undefined;

/**
 * IP address of the Worker
 * @member {String} ip_address
 */
Worker.prototype["ip_address"] = undefined;

/**
 * Operating system of the Worker
 * @member {String} platform
 */
Worker.prototype["platform"] = undefined;

/**
 * @member {Array.<String>} supported_task_types
 */
Worker.prototype["supported_task_types"] = undefined;

/**
 * @member {module:model/WorkerTask} task
 */
Worker.prototype["task"] = undefined;

/**
 * Tags of which this Worker is a member.
 * @member {Array.<module:model/WorkerTag>} tags
 */
Worker.prototype["tags"] = undefined;

// Implement WorkerSummary interface:
/**
 * @member {String} id
 */
WorkerSummary.prototype["id"] = undefined;
/**
 * @member {String} name
 */
WorkerSummary.prototype["name"] = undefined;
/**
 * @member {module:model/WorkerStatus} status
 */
WorkerSummary.prototype["status"] = undefined;
/**
 * @member {module:model/WorkerStatusChangeRequest} status_change
 */
WorkerSummary.prototype["status_change"] = undefined;
/**
 * Last time this worker was seen by the Manager.
 * @member {Date} last_seen
 */
WorkerSummary.prototype["last_seen"] = undefined;
/**
 * Version of Inferix this Worker is running
 * @member {String} version
 */
WorkerSummary.prototype["version"] = undefined;
// Implement WorkerAllOf interface:
/**
 * IP address of the Worker
 * @member {String} ip_address
 */
WorkerAllOf.prototype["ip_address"] = undefined;
/**
 * Operating system of the Worker
 * @member {String} platform
 */
WorkerAllOf.prototype["platform"] = undefined;
/**
 * @member {Array.<String>} supported_task_types
 */
WorkerAllOf.prototype["supported_task_types"] = undefined;
/**
 * @member {module:model/WorkerTask} task
 */
WorkerAllOf.prototype["task"] = undefined;
/**
 * Tags of which this Worker is a member.
 * @member {Array.<module:model/WorkerTag>} tags
 */
WorkerAllOf.prototype["tags"] = undefined;

/**
 * Inferix Manager
 * Inferix Rendering Manager API
 *
 * The version of the OpenAPI document: 0.2.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

/**
 * The WorkerList model module.
 * @module model/WorkerList
 * @version 0.0.0
 */
class WorkerList {
  /**
   * Constructs a new <code>WorkerList</code>.
   * List of workers.
   * @alias module:model/WorkerList
   * @param workers {Array.<module:model/WorkerSummary>}
   */
  constructor(workers) {
    WorkerList.initialize(this, workers);
  }

  /**
   * Initializes the fields of this object.
   * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
   * Only for internal use.
   */
  static initialize(obj, workers) {
    obj["workers"] = workers;
  }

  /**
   * Constructs a <code>WorkerList</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/WorkerList} obj Optional instance to populate.
   * @return {module:model/WorkerList} The populated <code>WorkerList</code> instance.
   */
  static constructFromObject(data, obj) {
    if (data) {
      obj = obj || new WorkerList();

      if (data.hasOwnProperty("workers")) {
        obj["workers"] = ApiClient.convertToType(data["workers"], [
          WorkerSummary,
        ]);
      }
    }
    return obj;
  }
}

/**
 * @member {Array.<module:model/WorkerSummary>} workers
 */
WorkerList.prototype["workers"] = undefined;

/**
 * Inferix Manager
 * Inferix Rendering Manager API
 *
 * The version of the OpenAPI document: 0.2.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

/**
 * The WorkerSleepSchedule model module.
 * @module model/WorkerSleepSchedule
 * @version 0.0.0
 */
class WorkerSleepSchedule {
  /**
   * Constructs a new <code>WorkerSleepSchedule</code>.
   * Sleep schedule for a single Worker. Start and end time indicate the time of each day at which the schedule is active. Applies only when today is in &#x60;days_of_week&#x60;, or when &#x60;days_of_week&#x60; is empty. Start and end time are in 24-hour HH:MM notation.
   * @alias module:model/WorkerSleepSchedule
   * @param isActive {Boolean}
   * @param daysOfWeek {String} Space-separated two-letter strings indicating days of week the schedule is active (\"mo\", \"tu\", etc.). Empty means \"every day\".
   * @param startTime {String}
   * @param endTime {String}
   */
  constructor(isActive, daysOfWeek, startTime, endTime) {
    WorkerSleepSchedule.initialize(
      this,
      isActive,
      daysOfWeek,
      startTime,
      endTime
    );
  }

  /**
   * Initializes the fields of this object.
   * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
   * Only for internal use.
   */
  static initialize(obj, isActive, daysOfWeek, startTime, endTime) {
    obj["is_active"] = isActive;
    obj["days_of_week"] = daysOfWeek;
    obj["start_time"] = startTime;
    obj["end_time"] = endTime;
  }

  /**
   * Constructs a <code>WorkerSleepSchedule</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/WorkerSleepSchedule} obj Optional instance to populate.
   * @return {module:model/WorkerSleepSchedule} The populated <code>WorkerSleepSchedule</code> instance.
   */
  static constructFromObject(data, obj) {
    if (data) {
      obj = obj || new WorkerSleepSchedule();

      if (data.hasOwnProperty("is_active")) {
        obj["is_active"] = ApiClient.convertToType(
          data["is_active"],
          "Boolean"
        );
      }
      if (data.hasOwnProperty("days_of_week")) {
        obj["days_of_week"] = ApiClient.convertToType(
          data["days_of_week"],
          "String"
        );
      }
      if (data.hasOwnProperty("start_time")) {
        obj["start_time"] = ApiClient.convertToType(
          data["start_time"],
          "String"
        );
      }
      if (data.hasOwnProperty("end_time")) {
        obj["end_time"] = ApiClient.convertToType(data["end_time"], "String");
      }
    }
    return obj;
  }
}

/**
 * @member {Boolean} is_active
 */
WorkerSleepSchedule.prototype["is_active"] = undefined;

/**
 * Space-separated two-letter strings indicating days of week the schedule is active (\"mo\", \"tu\", etc.). Empty means \"every day\".
 * @member {String} days_of_week
 */
WorkerSleepSchedule.prototype["days_of_week"] = undefined;

/**
 * @member {String} start_time
 */
WorkerSleepSchedule.prototype["start_time"] = undefined;

/**
 * @member {String} end_time
 */
WorkerSleepSchedule.prototype["end_time"] = undefined;

/**
 * Inferix Manager
 * Inferix Rendering Manager API
 *
 * The version of the OpenAPI document: 0.2.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

/**
 * The WorkerTagChangeRequest model module.
 * @module model/WorkerTagChangeRequest
 * @version 0.0.0
 */
class WorkerTagChangeRequest {
  /**
   * Constructs a new <code>WorkerTagChangeRequest</code>.
   * Request to change which tags this Worker is assigned to.
   * @alias module:model/WorkerTagChangeRequest
   * @param tagIds {Array.<String>}
   */
  constructor(tagIds) {
    WorkerTagChangeRequest.initialize(this, tagIds);
  }

  /**
   * Initializes the fields of this object.
   * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
   * Only for internal use.
   */
  static initialize(obj, tagIds) {
    obj["tag_ids"] = tagIds;
  }

  /**
   * Constructs a <code>WorkerTagChangeRequest</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/WorkerTagChangeRequest} obj Optional instance to populate.
   * @return {module:model/WorkerTagChangeRequest} The populated <code>WorkerTagChangeRequest</code> instance.
   */
  static constructFromObject(data, obj) {
    if (data) {
      obj = obj || new WorkerTagChangeRequest();

      if (data.hasOwnProperty("tag_ids")) {
        obj["tag_ids"] = ApiClient.convertToType(data["tag_ids"], ["String"]);
      }
    }
    return obj;
  }
}

/**
 * @member {Array.<String>} tag_ids
 */
WorkerTagChangeRequest.prototype["tag_ids"] = undefined;

/**
 * Inferix Manager
 * Inferix Rendering Manager API
 *
 * The version of the OpenAPI document: 0.2.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

/**
 * The WorkerTagList model module.
 * @module model/WorkerTagList
 * @version 0.0.0
 */
class WorkerTagList {
  /**
   * Constructs a new <code>WorkerTagList</code>.
   * @alias module:model/WorkerTagList
   */
  constructor() {
    WorkerTagList.initialize(this);
  }

  /**
   * Initializes the fields of this object.
   * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
   * Only for internal use.
   */
  static initialize(obj) {}

  /**
   * Constructs a <code>WorkerTagList</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/WorkerTagList} obj Optional instance to populate.
   * @return {module:model/WorkerTagList} The populated <code>WorkerTagList</code> instance.
   */
  static constructFromObject(data, obj) {
    if (data) {
      obj = obj || new WorkerTagList();

      if (data.hasOwnProperty("tags")) {
        obj["tags"] = ApiClient.convertToType(data["tags"], [WorkerTag]);
      }
    }
    return obj;
  }
}

/**
 * @member {Array.<module:model/WorkerTag>} tags
 */
WorkerTagList.prototype["tags"] = undefined;

/**
 * Inferix Manager
 * Inferix Rendering Manager API
 *
 * The version of the OpenAPI document: 0.2.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

/**
 * Meta service.
 * @module manager/MetaApi
 * @version 0.0.0
 */
class MetaApi {
  /**
   * Constructs a new MetaApi.
   * @alias module:manager/MetaApi
   * @class
   * @param {module:ApiClient} [apiClient] Optional API client implementation to use,
   * default to {@link module:ApiClient#instance} if unspecified.
   */
  constructor(apiClient) {
    this.apiClient = apiClient || ApiClient.instance;
  }

  /**
   * Validate a CLI command for use as way to start Blender
   * @param {Object} opts Optional parameters
   * @param {module:model/PathCheckInput} opts.pathCheckInput Command or executable path to check
   * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/BlenderPathCheckResult} and HTTP response
   */
  checkBlenderExePathWithHttpInfo(opts) {
    opts = opts || {};
    let postBody = opts["pathCheckInput"];

    let pathParams = {};
    let queryParams = {};
    let headerParams = {};
    let formParams = {};

    let authNames = [];
    let contentTypes = ["application/json"];
    let accepts = ["application/json"];
    let returnType = BlenderPathCheckResult;
    return this.apiClient.callApi(
      "/api/v3/configuration/check/blender",
      "POST",
      pathParams,
      queryParams,
      headerParams,
      formParams,
      postBody,
      authNames,
      contentTypes,
      accepts,
      returnType,
      null
    );
  }

  /**
   * Validate a CLI command for use as way to start Blender
   * @param {Object} opts Optional parameters
   * @param {module:model/PathCheckInput} opts.pathCheckInput Command or executable path to check
   * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/BlenderPathCheckResult}
   */
  checkBlenderExePath(opts) {
    return this.checkBlenderExePathWithHttpInfo(opts).then(function (
      response_and_data
    ) {
      return response_and_data.data;
    });
  }

  /**
   * Validate a path for use as shared storage.
   * @param {Object} opts Optional parameters
   * @param {module:model/PathCheckInput} opts.pathCheckInput Path to check
   * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/PathCheckResult} and HTTP response
   */
  checkSharedStoragePathWithHttpInfo(opts) {
    opts = opts || {};
    let postBody = opts["pathCheckInput"];

    let pathParams = {};
    let queryParams = {};
    let headerParams = {};
    let formParams = {};

    let authNames = [];
    let contentTypes = ["application/json"];
    let accepts = ["application/json"];
    let returnType = PathCheckResult;
    return this.apiClient.callApi(
      "/api/v3/configuration/check/shared-storage",
      "POST",
      pathParams,
      queryParams,
      headerParams,
      formParams,
      postBody,
      authNames,
      contentTypes,
      accepts,
      returnType,
      null
    );
  }

  /**
   * Validate a path for use as shared storage.
   * @param {Object} opts Optional parameters
   * @param {module:model/PathCheckInput} opts.pathCheckInput Path to check
   * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/PathCheckResult}
   */
  checkSharedStoragePath(opts) {
    return this.checkSharedStoragePathWithHttpInfo(opts).then(function (
      response_and_data
    ) {
      return response_and_data.data;
    });
  }

  /**
   * Find one or more CLI commands for use as way to start Blender
   * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Array.<module:model/BlenderPathCheckResult>} and HTTP response
   */
  findBlenderExePathWithHttpInfo() {
    let postBody = null;

    let pathParams = {};
    let queryParams = {};
    let headerParams = {};
    let formParams = {};

    let authNames = [];
    let contentTypes = [];
    let accepts = ["application/json"];
    let returnType = [BlenderPathCheckResult];
    return this.apiClient.callApi(
      "/api/v3/configuration/check/blender",
      "GET",
      pathParams,
      queryParams,
      headerParams,
      formParams,
      postBody,
      authNames,
      contentTypes,
      accepts,
      returnType,
      null
    );
  }

  /**
   * Find one or more CLI commands for use as way to start Blender
   * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Array.<module:model/BlenderPathCheckResult>}
   */
  findBlenderExePath() {
    return this.findBlenderExePathWithHttpInfo().then(function (
      response_and_data
    ) {
      return response_and_data.data;
    });
  }

  /**
   * Get the configuration of this Manager.
   * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/ManagerConfiguration} and HTTP response
   */
  getConfigurationWithHttpInfo() {
    let postBody = null;

    let pathParams = {};
    let queryParams = {};
    let headerParams = {};
    let formParams = {};

    let authNames = [];
    let contentTypes = [];
    let accepts = ["application/json"];
    let returnType = ManagerConfiguration;
    return this.apiClient.callApi(
      "/api/v3/configuration",
      "GET",
      pathParams,
      queryParams,
      headerParams,
      formParams,
      postBody,
      authNames,
      contentTypes,
      accepts,
      returnType,
      null
    );
  }

  /**
   * Get the configuration of this Manager.
   * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/ManagerConfiguration}
   */
  getConfiguration() {
    return this.getConfigurationWithHttpInfo().then(function (
      response_and_data
    ) {
      return response_and_data.data;
    });
  }

  /**
   * Retrieve the configuration of Inferix Manager.
   * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Object.<String, {String: Object}>} and HTTP response
   */
  getConfigurationFileWithHttpInfo() {
    let postBody = null;

    let pathParams = {};
    let queryParams = {};
    let headerParams = {};
    let formParams = {};

    let authNames = [];
    let contentTypes = [];
    let accepts = ["application/json", "application/yaml"];
    let returnType = { String: Object };
    return this.apiClient.callApi(
      "/api/v3/configuration/file",
      "GET",
      pathParams,
      queryParams,
      headerParams,
      formParams,
      postBody,
      authNames,
      contentTypes,
      accepts,
      returnType,
      null
    );
  }

  /**
   * Retrieve the configuration of Inferix Manager.
   * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Object.<String, {String: Object}>}
   */
  getConfigurationFile() {
    return this.getConfigurationFileWithHttpInfo().then(function (
      response_and_data
    ) {
      return response_and_data.data;
    });
  }

  /**
   * Get the shared storage location of this Manager, adjusted for the given audience and platform.
   * @param {module:model/ManagerVariableAudience} audience
   * @param {String} platform
   * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/SharedStorageLocation} and HTTP response
   */
  getSharedStorageWithHttpInfo(audience, platform) {
    let postBody = null;
    // verify the required parameter 'audience' is set
    if (audience === undefined || audience === null) {
      throw new Error$1(
        "Missing the required parameter 'audience' when calling getSharedStorage"
      );
    }
    // verify the required parameter 'platform' is set
    if (platform === undefined || platform === null) {
      throw new Error$1(
        "Missing the required parameter 'platform' when calling getSharedStorage"
      );
    }

    let pathParams = {
      audience: audience,
      platform: platform,
    };
    let queryParams = {};
    let headerParams = {};
    let formParams = {};

    let authNames = [];
    let contentTypes = [];
    let accepts = ["application/json"];
    let returnType = SharedStorageLocation;
    return this.apiClient.callApi(
      "/api/v3/configuration/shared-storage/{audience}/{platform}",
      "GET",
      pathParams,
      queryParams,
      headerParams,
      formParams,
      postBody,
      authNames,
      contentTypes,
      accepts,
      returnType,
      null
    );
  }

  /**
   * Get the shared storage location of this Manager, adjusted for the given audience and platform.
   * @param {module:model/ManagerVariableAudience} audience
   * @param {String} platform
   * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/SharedStorageLocation}
   */
  getSharedStorage(audience, platform) {
    return this.getSharedStorageWithHttpInfo(audience, platform).then(function (
      response_and_data
    ) {
      return response_and_data.data;
    });
  }

  /**
   * Get the variables of this Manager. Used by the Blender add-on to recognise two-way variables, and for the web interface to do variable replacement based on the browser's platform.
   * @param {module:model/ManagerVariableAudience} audience
   * @param {String} platform
   * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Object.<String, module:model/{String: ManagerVariable}>} and HTTP response
   */
  getVariablesWithHttpInfo(audience, platform) {
    let postBody = null;
    // verify the required parameter 'audience' is set
    if (audience === undefined || audience === null) {
      throw new Error$1(
        "Missing the required parameter 'audience' when calling getVariables"
      );
    }
    // verify the required parameter 'platform' is set
    if (platform === undefined || platform === null) {
      throw new Error$1(
        "Missing the required parameter 'platform' when calling getVariables"
      );
    }

    let pathParams = {
      audience: audience,
      platform: platform,
    };
    let queryParams = {};
    let headerParams = {};
    let formParams = {};

    let authNames = [];
    let contentTypes = [];
    let accepts = ["application/json"];
    let returnType = { String: ManagerVariable };
    return this.apiClient.callApi(
      "/api/v3/configuration/variables/{audience}/{platform}",
      "GET",
      pathParams,
      queryParams,
      headerParams,
      formParams,
      postBody,
      authNames,
      contentTypes,
      accepts,
      returnType,
      null
    );
  }

  /**
   * Get the variables of this Manager. Used by the Blender add-on to recognise two-way variables, and for the web interface to do variable replacement based on the browser's platform.
   * @param {module:model/ManagerVariableAudience} audience
   * @param {String} platform
   * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Object.<String, module:model/{String: ManagerVariable}>}
   */
  getVariables(audience, platform) {
    return this.getVariablesWithHttpInfo(audience, platform).then(function (
      response_and_data
    ) {
      return response_and_data.data;
    });
  }

  /**
   * Get the Inferix version of this Manager
   * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/FlamencoVersion} and HTTP response
   */
  getVersionWithHttpInfo() {
    let postBody = null;

    let pathParams = {};
    let queryParams = {};
    let headerParams = {};
    let formParams = {};

    let authNames = [];
    let contentTypes = [];
    let accepts = ["application/json"];
    let returnType = FlamencoVersion;
    return this.apiClient.callApi(
      "/api/v3/version",
      "GET",
      pathParams,
      queryParams,
      headerParams,
      formParams,
      postBody,
      authNames,
      contentTypes,
      accepts,
      returnType,
      null
    );
  }

  /**
   * Get the Inferix version of this Manager
   * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/FlamencoVersion}
   */
  getVersion() {
    return this.getVersionWithHttpInfo().then(function (response_and_data) {
      return response_and_data.data;
    });
  }

  /**
   * Update the Manager's configuration, and restart it in fully functional mode.
   * @param {Object} opts Optional parameters
   * @param {module:model/SetupAssistantConfig} opts.setupAssistantConfig Configuration to save.
   * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing HTTP response
   */
  saveSetupAssistantConfigWithHttpInfo(opts) {
    opts = opts || {};
    let postBody = opts["setupAssistantConfig"];

    let pathParams = {};
    let queryParams = {};
    let headerParams = {};
    let formParams = {};

    let authNames = [];
    let contentTypes = ["application/json"];
    let accepts = ["application/json"];
    let returnType = null;
    return this.apiClient.callApi(
      "/api/v3/configuration/setup-assistant",
      "POST",
      pathParams,
      queryParams,
      headerParams,
      formParams,
      postBody,
      authNames,
      contentTypes,
      accepts,
      returnType,
      null
    );
  }

  /**
   * Update the Manager's configuration, and restart it in fully functional mode.
   * @param {Object} opts Optional parameters
   * @param {module:model/SetupAssistantConfig} opts.setupAssistantConfig Configuration to save.
   * @return {Promise} a {@link https://www.promisejs.org/|Promise}
   */
  saveSetupAssistantConfig(opts) {
    return this.saveSetupAssistantConfigWithHttpInfo(opts).then(function (
      response_and_data
    ) {
      return response_and_data.data;
    });
  }

  /**
   * Processing when user topup his wallet.
   * @param {Object} opts Optional parameters
   * @param {module:model/TopupRequest} opts.topupRequest Infomation of topup repquest
   * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing HTTP response
   */
  topupWithHttpInfo(opts) {
    opts = opts || {};
    let postBody = opts["topupRequest"];

    let pathParams = {};
    let queryParams = {};
    let headerParams = {};
    let formParams = {};

    let authNames = [];
    let contentTypes = ["application/json"];
    let accepts = ["application/json"];
    let returnType = null;
    return this.apiClient.callApi(
      "/api/v3/topup",
      "POST",
      pathParams,
      queryParams,
      headerParams,
      formParams,
      postBody,
      authNames,
      contentTypes,
      accepts,
      returnType,
      null
    );
  }

  /**
   * Processing when user topup his wallet.
   * @param {Object} opts Optional parameters
   * @param {module:model/TopupRequest} opts.topupRequest Infomation of topup repquest
   * @return {Promise} a {@link https://www.promisejs.org/|Promise}
   */
  topup(opts) {
    return this.topupWithHttpInfo(opts).then(function (response_and_data) {
      return response_and_data.data;
    });
  }

  /**
   * Connecting a new wallet.
   * @param {Object} opts Optional parameters
   * @param {module:model/WalletInfo} opts.walletInfo Infomation of wallet
   * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing HTTP response
   */
  walletConnectWithHttpInfo(opts) {
    opts = opts || {};
    let postBody = opts["walletInfo"];

    let pathParams = {};
    let queryParams = {};
    let headerParams = {};
    let formParams = {};

    let authNames = [];
    let contentTypes = ["application/json"];
    let accepts = ["application/json"];
    let returnType = null;
    return this.apiClient.callApi(
      "/api/v3/wallet-connect",
      "POST",
      pathParams,
      queryParams,
      headerParams,
      formParams,
      postBody,
      authNames,
      contentTypes,
      accepts,
      returnType,
      null
    );
  }

  /**
   * Connecting a new wallet.
   * @param {Object} opts Optional parameters
   * @param {module:model/WalletInfo} opts.walletInfo Infomation of wallet
   * @return {Promise} a {@link https://www.promisejs.org/|Promise}
   */
  walletConnect(opts) {
    return this.walletConnectWithHttpInfo(opts).then(function (
      response_and_data
    ) {
      return response_and_data.data;
    });
  }
}

/**
 * Keep track of running API queries.
 */
const useAPIQueryCount = defineStore("apiQueryCount", {
  state: () => ({
    /**
     * Number of running queries.
     */
    num: 0,
  }),
  actions: {
    /**
     * Track this promise, counting it as a query for the spinner.
     * @param {Promise} promise
     */
    async track(promise) {
      this.num++;
      try {
        return await promise;
      } finally {
        this.num--;
      }
    },
  },
});

class CountingApiClient extends ApiClient {
  callApi(
    path,
    httpMethod,
    pathParams,
    queryParams,
    headerParams,
    formParams,
    bodyParam,
    authNames,
    contentTypes,
    accepts,
    returnType,
    apiBasePath
  ) {
    const apiQueryCount = useAPIQueryCount();
    apiQueryCount.num++;

    return super
      .callApi(
        path,
        httpMethod,
        pathParams,
        queryParams,
        headerParams,
        formParams,
        bodyParam,
        authNames,
        contentTypes,
        accepts,
        returnType,
        apiBasePath
      )
      .finally(() => {
        apiQueryCount.num--;
      });
  }
}

const ApiSpinner_vue_vue_type_style_index_0_scoped_d27be39f_lang = "";

const _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};

const _sfc_main$4 = {
  data: () => ({
    apiQueryCount: useAPIQueryCount(),
  }),
};

const _withScopeId$1 = (n) => (
  pushScopeId("data-v-d27be39f"), (n = n()), popScopeId(), n
);
const _hoisted_1$4 = /*#__PURE__*/ _withScopeId$1(() =>
  /*#__PURE__*/ createBaseVNode(
    "svg",
    {
      class: "spinner",
      viewBox: "0 0 50 50",
    },
    [
      /*#__PURE__*/ createBaseVNode("circle", {
        class: "path",
        cx: "25",
        cy: "25",
        r: "20",
        fill: "none",
        "stroke-width": "5",
      }),
    ],
    -1
  )
);
const _hoisted_2$4 = [_hoisted_1$4];

function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
  return (
    openBlock(),
    createElementBlock(
      "span",
      {
        class: normalizeClass([
          "api-spinner",
          { running: _ctx.apiQueryCount.num > 0 },
        ]),
      },
      _hoisted_2$4,
      2
    )
  );
}
const ApiSpinner = /*#__PURE__*/ _export_sfc(_sfc_main$4, [
  ["render", _sfc_render$4],
  ["__scopeId", "data-v-d27be39f"],
]);

const CONTRACT_ID = "inferix.testnet";
// export const LOCAL_HOST_URL = "18.138.228.159";
const LOCAL_HOST_URL = "ifxapi.noga.vn/api/v3/swagger-ui/#/";
const DEFAULT_TASK_LOG = 2;
const MAP_BOX_ACCESS_TOKEN =
  "pk.eyJ1Ijoia2VuODUiLCJhIjoiY2w0cWI3MmhlMDA3bzNqbzBzbXNoZ251ZSJ9.7Ioy-d_ZH3t7Ib4gOO1x6w";
const MAP_BOX_STYLE = "mapbox://styles/ken85/cl4ql0l78000014mmdmg8vd0w";
const DATA_NODE = [
  {
    Latitude: 20.865139,
    Longitude: 106.68383,
  },
  {
    Latitude: 9.602521,
    Longitude: 105.973907,
  },
  {
    Latitude: 10.7756,
    Longitude: 106.7019,
  },
  {
    Latitude: 21.028511,
    Longitude: 105.804817,
  },
  {
    Latitude: 10.045162,
    Longitude: 105.746857,
  },
  {
    Latitude: 10.924067,
    Longitude: 106.713028,
  },
  {
    Latitude: 20.959902,
    Longitude: 107.042542,
  },
  {
    Latitude: 21.028511,
    Longitude: 105.804817,
  },
  {
    Latitude: 10.045162,
    Longitude: 105.746857,
  },
  {
    Latitude: 16.461109,
    Longitude: 107.570183,
  },
  {
    Latitude: 10.964112,
    Longitude: 10.964112,
  },
  {
    Latitude: 22.679281,
    Longitude: 106.260452,
  },
  {
    Latitude: 20.351387,
    Longitude: 20.351387,
  },
  {
    Latitude: 21.716768,
    Longitude: 104.89859,
  },
  {
    Latitude: 20.962406,
    Longitude: 105.698448,
  },
  {
    Latitude: 11.375031,
    Longitude: 106.131363,
  },
  {
    Latitude: 21.033333,
    Longitude: 105.849998,
  },
  {
    Latitude: 10.95063,
    Longitude: 107.211456,
  },
];

new URL(window.location.href);
// Uncomment this when the web interface is running on a different port than the
// API, for example when using the Vite devserver. Set the API port here.
const env = {
  VITE_API_BASE_URL: "testnet.inferix.io",
  VITE_API_PROTOCAL: "https:",
  VITE_WEB_SOCKET_PROTOCOL: "wss:",
  VITE_AUTHORITY_URI: "https://id-dev.inferix.io/",
  VITE_DOMAIN_URL: "https://dev-dash.inferix.io",
  VITE_USER_NODE_ENV: "production",
  BASE_URL: "/",
  MODE: "production",
  DEV: false,
  PROD: true,
  SSR: false,
};
//api
const flamencoAPIURL = `${env.VITE_API_PROTOCAL}//${env.VITE_API_BASE_URL}`;

// ws
const websocketURL = `${env.VITE_WEB_SOCKET_PROTOCOL}//${env.VITE_API_BASE_URL}`;

const URLs = {
  api: flamencoAPIURL,
  ws: websocketURL,
};

// console.log("Flamenco API:", URLs.api);
// console.log("Websocket   :", URLs.ws);

function ws() {
  return URLs.ws;
}
function api() {
  return URLs.api;
}

// Backend URLs (like task logs, SwaggerUI, etc.) should be relative to the API
// url in order to stay working when the web development server is in use.
function backendURL(path) {
  const url = new URL(path, URLs.api);
  return url.href;
}

/**
 * Scrub the custom User-Agent header from the API client, for those webbrowsers
 * who do not want to have it set.
 *
 * It's actually scrubbed for all webbrowsers, as those privacy-first
 * webbrowsers also make it hard to fingerprint which browser you're using (for
 * good reason).
 *
 * @param {ApiClient} apiClient
 */
function scrubAPIClient(apiClient) {
  delete apiClient.defaultHeaders["User-Agent"];
}

/**
 * @returns {ApiClient} Bare API client that is not connected to the UI in any way.
 */
function newBareAPIClient() {
  const apiClient = new ApiClient(api());
  scrubAPIClient(apiClient);
  return apiClient;
}

let apiClient$1 = null;

/**
 * @returns {ApiClient} API client that updates the UI to show long-running queries.
 */
function getAPIClient() {
  if (apiClient$1 == null) {
    apiClient$1 = new CountingApiClient(api());
    scrubAPIClient(apiClient$1);
  }
  return apiClient$1;
}

const SetupAssistant_vue_vue_type_style_index_0_lang = "";

const DEFAULT_FLAMENCO_NAME$1 = "Inferix.io";
const DEFAULT_FLAMENCO_VERSION$1 = "unknown";

const _sfc_main$3 = {
  name: "SetupAssistant",
  components: {
    ApiSpinner,
  },
  data: () => ({
    flamencoName: DEFAULT_FLAMENCO_NAME$1,
    flamencoVersion: DEFAULT_FLAMENCO_VERSION$1,
  }),
  mounted() {
    window.app = this;
    this.fetchManagerInfo();
  },
  methods: {
    // TODO: also call this when SocketIO reconnects.
    fetchManagerInfo() {
      const metaAPI = new MetaApi(getAPIClient());
      metaAPI.getVersion().then((version) => {
        this.flamencoName = version.name;
        this.flamencoVersion = version.version;
      });
    },
  },
};

const _hoisted_1$3 = /*#__PURE__*/ createBaseVNode("nav", null, null, -1);
const _hoisted_2$3 = { class: "app-version" };
const _hoisted_3$3 = /*#__PURE__*/ createBaseVNode(
  "a",
  { href: "/api/v3/swagger-ui/" },
  "API",
  -1
);

function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_router_link = resolveComponent("router-link");
  const _component_api_spinner = resolveComponent("api-spinner");
  const _component_router_view = resolveComponent("router-view");

  return (
    openBlock(),
    createElementBlock(
      Fragment,
      null,
      [
        createBaseVNode("header", null, [
          createVNode(
            _component_router_link,
            {
              to: { name: "index" },
              class: "navbar-brand",
            },
            {
              default: withCtx(() => [
                createTextVNode(toDisplayString(_ctx.flamencoName), 1),
              ]),
              _: 1,
            }
          ),
          _hoisted_1$3,
          createVNode(_component_api_spinner),
          createBaseVNode("span", _hoisted_2$3, [
            _hoisted_3$3,
            createTextVNode(
              " | version: " + toDisplayString(_ctx.flamencoVersion),
              1
            ),
          ]),
        ]),
        createVNode(_component_router_view),
      ],
      64
    )
  );
}
const SetupAssistant = /*#__PURE__*/ _export_sfc(_sfc_main$3, [
  ["render", _sfc_render$3],
]);

// Do a full refresh once per hour. This is just to make sure that long-lived
// displays (like the TV in the hallway at Blender HQ) pick up on HTML/JS/CSS
// changes eventually.
const reloadAfter = { minute: 60 };

function getReloadDeadline() {
  return DateTime.now().plus(reloadAfter);
}

let reloadAt = getReloadDeadline();

// Every activity (mouse move, keyboard, etc.) defers the reload.
function deferReload() {
  reloadAt = getReloadDeadline();
}

function maybeReload() {
  const now = DateTime.now();
  if (now < reloadAt) return;

  window.location.reload();
}

function autoreload() {
  // Check whether reloading is needed every minute.
  window.setInterval(maybeReload, 60 * 1000);

  window.addEventListener("resize", deferReload);
  window.addEventListener("mousedown", deferReload);
  window.addEventListener("mouseup", deferReload);
  window.addEventListener("mousemove", deferReload);
  window.addEventListener("keydown", deferReload);
  window.addEventListener("keyup", deferReload);
}

const scriptRel = "modulepreload";
const assetsURL = function (dep) {
  return "/" + dep;
};
const seen$2 = {};
const __vitePreload = function preload(baseModule, deps, importerUrl) {
  // @ts-expect-error true will be replaced with boolean later
  if (!true || !deps || deps.length === 0) {
    return baseModule();
  }
  const links = document.getElementsByTagName("link");
  return Promise.all(
    deps.map((dep) => {
      // @ts-expect-error assetsURL is declared before preload.toString()
      dep = assetsURL(dep);
      if (dep in seen$2) return;
      seen$2[dep] = true;
      const isCss = dep.endsWith(".css");
      const cssSelector = isCss ? '[rel="stylesheet"]' : "";
      const isBaseRelative = !!importerUrl;
      // check if the file is already preloaded by SSR markup
      if (isBaseRelative) {
        // When isBaseRelative is true then we have `importerUrl` and `dep` is
        // already converted to an absolute URL by the `assetsURL` function
        for (let i = links.length - 1; i >= 0; i--) {
          const link = links[i];
          // The `links[i].href` is an absolute URL thanks to browser doing the work
          // for us. See https://html.spec.whatwg.org/multipage/common-dom-interfaces.html#reflecting-content-attributes-in-idl-attributes:idl-domstring-5
          if (link.href === dep && (!isCss || link.rel === "stylesheet")) {
            return;
          }
        }
      } else if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
        return;
      }
      const link = document.createElement("link");
      link.rel = isCss ? "stylesheet" : scriptRel;
      if (!isCss) {
        link.as = "script";
        link.crossOrigin = "";
      }
      link.href = dep;
      document.head.appendChild(link);
      if (isCss) {
        return new Promise((res, rej) => {
          link.addEventListener("load", res);
          link.addEventListener("error", () =>
            rej(new Error(`Unable to preload CSS for ${dep}`))
          );
        });
      }
    })
  )
    .then(() => baseModule())
    .catch((err) => {
      const e = new Event("vite:preloadError", { cancelable: true });
      // @ts-expect-error custom payload
      e.payload = err;
      window.dispatchEvent(e);
      if (!e.defaultPrevented) {
        throw err;
      }
    });
};

// node_modules/vue-router/dist/vue-router.esm-bundler.js
var hasSymbol =
  typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol";
var PolySymbol = (name) =>
  // vr = vue router
  hasSymbol ? Symbol(name) : "_vr_" + name;
var matchedRouteKey = /* @__PURE__ */ PolySymbol("rvlm");
var viewDepthKey = /* @__PURE__ */ PolySymbol("rvd");
var routerKey = /* @__PURE__ */ PolySymbol("r");
var routeLocationKey = /* @__PURE__ */ PolySymbol("rl");
var routerViewLocationKey = /* @__PURE__ */ PolySymbol("rvl");
var isBrowser$1 = typeof window !== "undefined";
function isESModule(obj) {
  return obj.__esModule || (hasSymbol && obj[Symbol.toStringTag] === "Module");
}
var assign = Object.assign;
function applyToParams(fn, params) {
  const newParams = {};
  for (const key in params) {
    const value = params[key];
    newParams[key] = Array.isArray(value) ? value.map(fn) : fn(value);
  }
  return newParams;
}
var noop$3 = () => {};
var TRAILING_SLASH_RE = /\/$/;
var removeTrailingSlash = (path) => path.replace(TRAILING_SLASH_RE, "");
function parseURL(parseQuery2, location2, currentLocation = "/") {
  let path,
    query = {},
    searchString = "",
    hash = "";
  const searchPos = location2.indexOf("?");
  const hashPos = location2.indexOf("#", searchPos > -1 ? searchPos : 0);
  if (searchPos > -1) {
    path = location2.slice(0, searchPos);
    searchString = location2.slice(
      searchPos + 1,
      hashPos > -1 ? hashPos : location2.length
    );
    query = parseQuery2(searchString);
  }
  if (hashPos > -1) {
    path = path || location2.slice(0, hashPos);
    hash = location2.slice(hashPos, location2.length);
  }
  path = resolveRelativePath(path != null ? path : location2, currentLocation);
  return {
    fullPath: path + (searchString && "?") + searchString + hash,
    path,
    query,
    hash,
  };
}
function stringifyURL(stringifyQuery2, location2) {
  const query = location2.query ? stringifyQuery2(location2.query) : "";
  return location2.path + (query && "?") + query + (location2.hash || "");
}
function stripBase(pathname, base) {
  if (!base || !pathname.toLowerCase().startsWith(base.toLowerCase()))
    return pathname;
  return pathname.slice(base.length) || "/";
}
function isSameRouteLocation(stringifyQuery2, a, b) {
  const aLastIndex = a.matched.length - 1;
  const bLastIndex = b.matched.length - 1;
  return (
    aLastIndex > -1 &&
    aLastIndex === bLastIndex &&
    isSameRouteRecord(a.matched[aLastIndex], b.matched[bLastIndex]) &&
    isSameRouteLocationParams(a.params, b.params) &&
    stringifyQuery2(a.query) === stringifyQuery2(b.query) &&
    a.hash === b.hash
  );
}
function isSameRouteRecord(a, b) {
  return (a.aliasOf || a) === (b.aliasOf || b);
}
function isSameRouteLocationParams(a, b) {
  if (Object.keys(a).length !== Object.keys(b).length) return false;
  for (const key in a) {
    if (!isSameRouteLocationParamsValue(a[key], b[key])) return false;
  }
  return true;
}
function isSameRouteLocationParamsValue(a, b) {
  return Array.isArray(a)
    ? isEquivalentArray(a, b)
    : Array.isArray(b)
    ? isEquivalentArray(b, a)
    : a === b;
}
function isEquivalentArray(a, b) {
  return Array.isArray(b)
    ? a.length === b.length && a.every((value, i) => value === b[i])
    : a.length === 1 && a[0] === b;
}
function resolveRelativePath(to, from) {
  if (to.startsWith("/")) return to;
  if (!to) return from;
  const fromSegments = from.split("/");
  const toSegments = to.split("/");
  let position = fromSegments.length - 1;
  let toPosition;
  let segment;
  for (toPosition = 0; toPosition < toSegments.length; toPosition++) {
    segment = toSegments[toPosition];
    if (position === 1 || segment === ".") continue;
    if (segment === "..") position--;
    else break;
  }
  return (
    fromSegments.slice(0, position).join("/") +
    "/" +
    toSegments
      .slice(toPosition - (toPosition === toSegments.length ? 1 : 0))
      .join("/")
  );
}
var NavigationType;
(function (NavigationType2) {
  NavigationType2["pop"] = "pop";
  NavigationType2["push"] = "push";
})(NavigationType || (NavigationType = {}));
var NavigationDirection;
(function (NavigationDirection2) {
  NavigationDirection2["back"] = "back";
  NavigationDirection2["forward"] = "forward";
  NavigationDirection2["unknown"] = "";
})(NavigationDirection || (NavigationDirection = {}));
function normalizeBase(base) {
  if (!base) {
    if (isBrowser$1) {
      const baseEl = document.querySelector("base");
      base = (baseEl && baseEl.getAttribute("href")) || "/";
      base = base.replace(/^\w+:\/\/[^\/]+/, "");
    } else {
      base = "/";
    }
  }
  if (base[0] !== "/" && base[0] !== "#") base = "/" + base;
  return removeTrailingSlash(base);
}
var BEFORE_HASH_RE = /^[^#]+#/;
function createHref(base, location2) {
  return base.replace(BEFORE_HASH_RE, "#") + location2;
}
function getElementPosition(el, offset) {
  const docRect = document.documentElement.getBoundingClientRect();
  const elRect = el.getBoundingClientRect();
  return {
    behavior: offset.behavior,
    left: elRect.left - docRect.left - (offset.left || 0),
    top: elRect.top - docRect.top - (offset.top || 0),
  };
}
var computeScrollPosition = () => ({
  left: window.pageXOffset,
  top: window.pageYOffset,
});
function scrollToPosition(position) {
  let scrollToOptions;
  if ("el" in position) {
    const positionEl = position.el;
    const isIdSelector =
      typeof positionEl === "string" && positionEl.startsWith("#");
    const el =
      typeof positionEl === "string"
        ? isIdSelector
          ? document.getElementById(positionEl.slice(1))
          : document.querySelector(positionEl)
        : positionEl;
    if (!el) {
      return;
    }
    scrollToOptions = getElementPosition(el, position);
  } else {
    scrollToOptions = position;
  }
  if ("scrollBehavior" in document.documentElement.style)
    window.scrollTo(scrollToOptions);
  else {
    window.scrollTo(
      scrollToOptions.left != null ? scrollToOptions.left : window.pageXOffset,
      scrollToOptions.top != null ? scrollToOptions.top : window.pageYOffset
    );
  }
}
function getScrollKey(path, delta) {
  const position = history.state ? history.state.position - delta : -1;
  return position + path;
}
var scrollPositions = /* @__PURE__ */ new Map();
function saveScrollPosition(key, scrollPosition) {
  scrollPositions.set(key, scrollPosition);
}
function getSavedScrollPosition(key) {
  const scroll = scrollPositions.get(key);
  scrollPositions.delete(key);
  return scroll;
}
var createBaseLocation = () => location.protocol + "//" + location.host;
function createCurrentLocation(base, location2) {
  const { pathname, search, hash } = location2;
  const hashPos = base.indexOf("#");
  if (hashPos > -1) {
    let slicePos = hash.includes(base.slice(hashPos))
      ? base.slice(hashPos).length
      : 1;
    let pathFromHash = hash.slice(slicePos);
    if (pathFromHash[0] !== "/") pathFromHash = "/" + pathFromHash;
    return stripBase(pathFromHash, "");
  }
  const path = stripBase(pathname, base);
  return path + search + hash;
}
function useHistoryListeners(base, historyState, currentLocation, replace) {
  let listeners = [];
  let teardowns = [];
  let pauseState = null;
  const popStateHandler = ({ state }) => {
    const to = createCurrentLocation(base, location);
    const from = currentLocation.value;
    const fromState = historyState.value;
    let delta = 0;
    if (state) {
      currentLocation.value = to;
      historyState.value = state;
      if (pauseState && pauseState === from) {
        pauseState = null;
        return;
      }
      delta = fromState ? state.position - fromState.position : 0;
    } else {
      replace(to);
    }
    listeners.forEach((listener) => {
      listener(currentLocation.value, from, {
        delta,
        type: NavigationType.pop,
        direction: delta
          ? delta > 0
            ? NavigationDirection.forward
            : NavigationDirection.back
          : NavigationDirection.unknown,
      });
    });
  };
  function pauseListeners() {
    pauseState = currentLocation.value;
  }
  function listen(callback) {
    listeners.push(callback);
    const teardown = () => {
      const index = listeners.indexOf(callback);
      if (index > -1) listeners.splice(index, 1);
    };
    teardowns.push(teardown);
    return teardown;
  }
  function beforeUnloadListener() {
    const { history: history2 } = window;
    if (!history2.state) return;
    history2.replaceState(
      assign({}, history2.state, { scroll: computeScrollPosition() }),
      ""
    );
  }
  function destroy() {
    for (const teardown of teardowns) teardown();
    teardowns = [];
    window.removeEventListener("popstate", popStateHandler);
    window.removeEventListener("beforeunload", beforeUnloadListener);
  }
  window.addEventListener("popstate", popStateHandler);
  window.addEventListener("beforeunload", beforeUnloadListener);
  return {
    pauseListeners,
    listen,
    destroy,
  };
}
function buildState(
  back,
  current,
  forward,
  replaced = false,
  computeScroll = false
) {
  return {
    back,
    current,
    forward,
    replaced,
    position: window.history.length,
    scroll: computeScroll ? computeScrollPosition() : null,
  };
}
function useHistoryStateNavigation(base) {
  const { history: history2, location: location2 } = window;
  const currentLocation = {
    value: createCurrentLocation(base, location2),
  };
  const historyState = { value: history2.state };
  if (!historyState.value) {
    changeLocation(
      currentLocation.value,
      {
        back: null,
        current: currentLocation.value,
        forward: null,
        // the length is off by one, we need to decrease it
        position: history2.length - 1,
        replaced: true,
        // don't add a scroll as the user may have an anchor and we want
        // scrollBehavior to be triggered without a saved position
        scroll: null,
      },
      true
    );
  }
  function changeLocation(to, state, replace2) {
    const hashIndex = base.indexOf("#");
    const url =
      hashIndex > -1
        ? (location2.host && document.querySelector("base")
            ? base
            : base.slice(hashIndex)) + to
        : createBaseLocation() + base + to;
    try {
      history2[replace2 ? "replaceState" : "pushState"](state, "", url);
      historyState.value = state;
    } catch (err) {
      {
        console.error(err);
      }
      location2[replace2 ? "replace" : "assign"](url);
    }
  }
  function replace(to, data) {
    const state = assign(
      {},
      history2.state,
      buildState(
        historyState.value.back,
        // keep back and forward entries but override current position
        to,
        historyState.value.forward,
        true
      ),
      data,
      { position: historyState.value.position }
    );
    changeLocation(to, state, true);
    currentLocation.value = to;
  }
  function push(to, data) {
    const currentState = assign(
      {},
      // use current history state to gracefully handle a wrong call to
      // history.replaceState
      // https://github.com/vuejs/router/issues/366
      historyState.value,
      history2.state,
      {
        forward: to,
        scroll: computeScrollPosition(),
      }
    );
    changeLocation(currentState.current, currentState, true);
    const state = assign(
      {},
      buildState(currentLocation.value, to, null),
      { position: currentState.position + 1 },
      data
    );
    changeLocation(to, state, false);
    currentLocation.value = to;
  }
  return {
    location: currentLocation,
    state: historyState,
    push,
    replace,
  };
}
function createWebHistory(base) {
  base = normalizeBase(base);
  const historyNavigation = useHistoryStateNavigation(base);
  const historyListeners = useHistoryListeners(
    base,
    historyNavigation.state,
    historyNavigation.location,
    historyNavigation.replace
  );
  function go(delta, triggerListeners = true) {
    if (!triggerListeners) historyListeners.pauseListeners();
    history.go(delta);
  }
  const routerHistory = assign(
    {
      // it's overridden right after
      location: "",
      base,
      go,
      createHref: createHref.bind(null, base),
    },
    historyNavigation,
    historyListeners
  );
  Object.defineProperty(routerHistory, "location", {
    enumerable: true,
    get: () => historyNavigation.location.value,
  });
  Object.defineProperty(routerHistory, "state", {
    enumerable: true,
    get: () => historyNavigation.state.value,
  });
  return routerHistory;
}
function isRouteLocation(route) {
  return typeof route === "string" || (route && typeof route === "object");
}
function isRouteName(name) {
  return typeof name === "string" || typeof name === "symbol";
}
var START_LOCATION_NORMALIZED = {
  path: "/",
  name: void 0,
  params: {},
  query: {},
  hash: "",
  fullPath: "/",
  matched: [],
  meta: {},
  redirectedFrom: void 0,
};
var NavigationFailureSymbol = /* @__PURE__ */ PolySymbol("nf");
var NavigationFailureType;
(function (NavigationFailureType2) {
  NavigationFailureType2[(NavigationFailureType2["aborted"] = 4)] = "aborted";
  NavigationFailureType2[(NavigationFailureType2["cancelled"] = 8)] =
    "cancelled";
  NavigationFailureType2[(NavigationFailureType2["duplicated"] = 16)] =
    "duplicated";
})(NavigationFailureType || (NavigationFailureType = {}));
function createRouterError(type, params) {
  {
    return assign(
      new Error(),
      {
        type,
        [NavigationFailureSymbol]: true,
      },
      params
    );
  }
}
function isNavigationFailure(error, type) {
  return (
    error instanceof Error &&
    NavigationFailureSymbol in error &&
    (type == null || !!(error.type & type))
  );
}
var BASE_PARAM_PATTERN = "[^/]+?";
var BASE_PATH_PARSER_OPTIONS = {
  sensitive: false,
  strict: false,
  start: true,
  end: true,
};
var REGEX_CHARS_RE = /[.+*?^${}()[\]/\\]/g;
function tokensToParser(segments, extraOptions) {
  const options = assign({}, BASE_PATH_PARSER_OPTIONS, extraOptions);
  const score = [];
  let pattern = options.start ? "^" : "";
  const keys = [];
  for (const segment of segments) {
    const segmentScores = segment.length
      ? []
      : [
          90,
          /* Root */
        ];
    if (options.strict && !segment.length) pattern += "/";
    for (let tokenIndex = 0; tokenIndex < segment.length; tokenIndex++) {
      const token = segment[tokenIndex];
      let subSegmentScore = 40 + (options.sensitive ? 0.25 : 0);
      if (token.type === 0) {
        if (!tokenIndex) pattern += "/";
        pattern += token.value.replace(REGEX_CHARS_RE, "\\$&");
        subSegmentScore += 40;
      } else if (token.type === 1) {
        const { value, repeatable, optional, regexp } = token;
        keys.push({
          name: value,
          repeatable,
          optional,
        });
        const re2 = regexp ? regexp : BASE_PARAM_PATTERN;
        if (re2 !== BASE_PARAM_PATTERN) {
          subSegmentScore += 10;
          try {
            new RegExp(`(${re2})`);
          } catch (err) {
            throw new Error(
              `Invalid custom RegExp for param "${value}" (${re2}): ` +
                err.message
            );
          }
        }
        let subPattern = repeatable
          ? `((?:${re2})(?:/(?:${re2}))*)`
          : `(${re2})`;
        if (!tokenIndex)
          subPattern = // avoid an optional / if there are more segments e.g. /:p?-static
            // or /:p?-:p2
            optional && segment.length < 2
              ? `(?:/${subPattern})`
              : "/" + subPattern;
        if (optional) subPattern += "?";
        pattern += subPattern;
        subSegmentScore += 20;
        if (optional) subSegmentScore += -8;
        if (repeatable) subSegmentScore += -20;
        if (re2 === ".*") subSegmentScore += -50;
      }
      segmentScores.push(subSegmentScore);
    }
    score.push(segmentScores);
  }
  if (options.strict && options.end) {
    const i = score.length - 1;
    score[i][score[i].length - 1] += 0.7000000000000001;
  }
  if (!options.strict) pattern += "/?";
  if (options.end) pattern += "$";
  else if (options.strict) pattern += "(?:/|$)";
  const re = new RegExp(pattern, options.sensitive ? "" : "i");
  function parse(path) {
    const match = path.match(re);
    const params = {};
    if (!match) return null;
    for (let i = 1; i < match.length; i++) {
      const value = match[i] || "";
      const key = keys[i - 1];
      params[key.name] = value && key.repeatable ? value.split("/") : value;
    }
    return params;
  }
  function stringify(params) {
    let path = "";
    let avoidDuplicatedSlash = false;
    for (const segment of segments) {
      if (!avoidDuplicatedSlash || !path.endsWith("/")) path += "/";
      avoidDuplicatedSlash = false;
      for (const token of segment) {
        if (token.type === 0) {
          path += token.value;
        } else if (token.type === 1) {
          const { value, repeatable, optional } = token;
          const param = value in params ? params[value] : "";
          if (Array.isArray(param) && !repeatable)
            throw new Error(
              `Provided param "${value}" is an array but it is not repeatable (* or + modifiers)`
            );
          const text = Array.isArray(param) ? param.join("/") : param;
          if (!text) {
            if (optional) {
              if (segment.length < 2) {
                if (path.endsWith("/")) path = path.slice(0, -1);
                else avoidDuplicatedSlash = true;
              }
            } else throw new Error(`Missing required param "${value}"`);
          }
          path += text;
        }
      }
    }
    return path;
  }
  return {
    re,
    score,
    keys,
    parse,
    stringify,
  };
}
function compareScoreArray(a, b) {
  let i = 0;
  while (i < a.length && i < b.length) {
    const diff = b[i] - a[i];
    if (diff) return diff;
    i++;
  }
  if (a.length < b.length) {
    return a.length === 1 && a[0] === 40 + 40 ? -1 : 1;
  } else if (a.length > b.length) {
    return b.length === 1 && b[0] === 40 + 40 ? 1 : -1;
  }
  return 0;
}
function comparePathParserScore(a, b) {
  let i = 0;
  const aScore = a.score;
  const bScore = b.score;
  while (i < aScore.length && i < bScore.length) {
    const comp = compareScoreArray(aScore[i], bScore[i]);
    if (comp) return comp;
    i++;
  }
  return bScore.length - aScore.length;
}
var ROOT_TOKEN = {
  type: 0,
  value: "",
};
var VALID_PARAM_RE = /[a-zA-Z0-9_]/;
function tokenizePath(path) {
  if (!path) return [[]];
  if (path === "/") return [[ROOT_TOKEN]];
  if (!path.startsWith("/")) {
    throw new Error(`Invalid path "${path}"`);
  }
  function crash(message) {
    throw new Error(`ERR (${state})/"${buffer}": ${message}`);
  }
  let state = 0;
  let previousState = state;
  const tokens = [];
  let segment;
  function finalizeSegment() {
    if (segment) tokens.push(segment);
    segment = [];
  }
  let i = 0;
  let char;
  let buffer = "";
  let customRe = "";
  function consumeBuffer() {
    if (!buffer) return;
    if (state === 0) {
      segment.push({
        type: 0,
        value: buffer,
      });
    } else if (state === 1 || state === 2 || state === 3) {
      if (segment.length > 1 && (char === "*" || char === "+"))
        crash(
          `A repeatable param (${buffer}) must be alone in its segment. eg: '/:ids+.`
        );
      segment.push({
        type: 1,
        value: buffer,
        regexp: customRe,
        repeatable: char === "*" || char === "+",
        optional: char === "*" || char === "?",
      });
    } else {
      crash("Invalid state to consume buffer");
    }
    buffer = "";
  }
  function addCharToBuffer() {
    buffer += char;
  }
  while (i < path.length) {
    char = path[i++];
    if (char === "\\" && state !== 2) {
      previousState = state;
      state = 4;
      continue;
    }
    switch (state) {
      case 0:
        if (char === "/") {
          if (buffer) {
            consumeBuffer();
          }
          finalizeSegment();
        } else if (char === ":") {
          consumeBuffer();
          state = 1;
        } else {
          addCharToBuffer();
        }
        break;
      case 4:
        addCharToBuffer();
        state = previousState;
        break;
      case 1:
        if (char === "(") {
          state = 2;
        } else if (VALID_PARAM_RE.test(char)) {
          addCharToBuffer();
        } else {
          consumeBuffer();
          state = 0;
          if (char !== "*" && char !== "?" && char !== "+") i--;
        }
        break;
      case 2:
        if (char === ")") {
          if (customRe[customRe.length - 1] == "\\")
            customRe = customRe.slice(0, -1) + char;
          else state = 3;
        } else {
          customRe += char;
        }
        break;
      case 3:
        consumeBuffer();
        state = 0;
        if (char !== "*" && char !== "?" && char !== "+") i--;
        customRe = "";
        break;
      default:
        crash("Unknown state");
        break;
    }
  }
  if (state === 2) crash(`Unfinished custom RegExp for param "${buffer}"`);
  consumeBuffer();
  finalizeSegment();
  return tokens;
}
function createRouteRecordMatcher(record, parent, options) {
  const parser = tokensToParser(tokenizePath(record.path), options);
  const matcher = assign(parser, {
    record,
    parent,
    // these needs to be populated by the parent
    children: [],
    alias: [],
  });
  if (parent) {
    if (!matcher.record.aliasOf === !parent.record.aliasOf)
      parent.children.push(matcher);
  }
  return matcher;
}
function createRouterMatcher(routes, globalOptions) {
  const matchers = [];
  const matcherMap = /* @__PURE__ */ new Map();
  globalOptions = mergeOptions(
    { strict: false, end: true, sensitive: false },
    globalOptions
  );
  function getRecordMatcher(name) {
    return matcherMap.get(name);
  }
  function addRoute(record, parent, originalRecord) {
    const isRootAdd = !originalRecord;
    const mainNormalizedRecord = normalizeRouteRecord(record);
    mainNormalizedRecord.aliasOf = originalRecord && originalRecord.record;
    const options = mergeOptions(globalOptions, record);
    const normalizedRecords = [mainNormalizedRecord];
    if ("alias" in record) {
      const aliases =
        typeof record.alias === "string" ? [record.alias] : record.alias;
      for (const alias of aliases) {
        normalizedRecords.push(
          assign({}, mainNormalizedRecord, {
            // this allows us to hold a copy of the `components` option
            // so that async components cache is hold on the original record
            components: originalRecord
              ? originalRecord.record.components
              : mainNormalizedRecord.components,
            path: alias,
            // we might be the child of an alias
            aliasOf: originalRecord
              ? originalRecord.record
              : mainNormalizedRecord,
            // the aliases are always of the same kind as the original since they
            // are defined on the same record
          })
        );
      }
    }
    let matcher;
    let originalMatcher;
    for (const normalizedRecord of normalizedRecords) {
      const { path } = normalizedRecord;
      if (parent && path[0] !== "/") {
        const parentPath = parent.record.path;
        const connectingSlash =
          parentPath[parentPath.length - 1] === "/" ? "" : "/";
        normalizedRecord.path =
          parent.record.path + (path && connectingSlash + path);
      }
      matcher = createRouteRecordMatcher(normalizedRecord, parent, options);
      if (originalRecord) {
        originalRecord.alias.push(matcher);
      } else {
        originalMatcher = originalMatcher || matcher;
        if (originalMatcher !== matcher) originalMatcher.alias.push(matcher);
        if (isRootAdd && record.name && !isAliasRecord(matcher))
          removeRoute(record.name);
      }
      if ("children" in mainNormalizedRecord) {
        const children = mainNormalizedRecord.children;
        for (let i = 0; i < children.length; i++) {
          addRoute(
            children[i],
            matcher,
            originalRecord && originalRecord.children[i]
          );
        }
      }
      originalRecord = originalRecord || matcher;
      insertMatcher(matcher);
    }
    return originalMatcher
      ? () => {
          removeRoute(originalMatcher);
        }
      : noop$3;
  }
  function removeRoute(matcherRef) {
    if (isRouteName(matcherRef)) {
      const matcher = matcherMap.get(matcherRef);
      if (matcher) {
        matcherMap.delete(matcherRef);
        matchers.splice(matchers.indexOf(matcher), 1);
        matcher.children.forEach(removeRoute);
        matcher.alias.forEach(removeRoute);
      }
    } else {
      const index = matchers.indexOf(matcherRef);
      if (index > -1) {
        matchers.splice(index, 1);
        if (matcherRef.record.name) matcherMap.delete(matcherRef.record.name);
        matcherRef.children.forEach(removeRoute);
        matcherRef.alias.forEach(removeRoute);
      }
    }
  }
  function getRoutes() {
    return matchers;
  }
  function insertMatcher(matcher) {
    let i = 0;
    while (
      i < matchers.length &&
      comparePathParserScore(matcher, matchers[i]) >= 0 && // Adding children with empty path should still appear before the parent
      // https://github.com/vuejs/router/issues/1124
      (matcher.record.path !== matchers[i].record.path ||
        !isRecordChildOf(matcher, matchers[i]))
    )
      i++;
    matchers.splice(i, 0, matcher);
    if (matcher.record.name && !isAliasRecord(matcher))
      matcherMap.set(matcher.record.name, matcher);
  }
  function resolve(location2, currentLocation) {
    let matcher;
    let params = {};
    let path;
    let name;
    if ("name" in location2 && location2.name) {
      matcher = matcherMap.get(location2.name);
      if (!matcher)
        throw createRouterError(1, {
          location: location2,
        });
      name = matcher.record.name;
      params = assign(
        // paramsFromLocation is a new object
        paramsFromLocation(
          currentLocation.params,
          // only keep params that exist in the resolved location
          // TODO: only keep optional params coming from a parent record
          matcher.keys.filter((k) => !k.optional).map((k) => k.name)
        ),
        location2.params
      );
      path = matcher.stringify(params);
    } else if ("path" in location2) {
      path = location2.path;
      matcher = matchers.find((m) => m.re.test(path));
      if (matcher) {
        params = matcher.parse(path);
        name = matcher.record.name;
      }
    } else {
      matcher = currentLocation.name
        ? matcherMap.get(currentLocation.name)
        : matchers.find((m) => m.re.test(currentLocation.path));
      if (!matcher)
        throw createRouterError(1, {
          location: location2,
          currentLocation,
        });
      name = matcher.record.name;
      params = assign({}, currentLocation.params, location2.params);
      path = matcher.stringify(params);
    }
    const matched = [];
    let parentMatcher = matcher;
    while (parentMatcher) {
      matched.unshift(parentMatcher.record);
      parentMatcher = parentMatcher.parent;
    }
    return {
      name,
      path,
      params,
      matched,
      meta: mergeMetaFields(matched),
    };
  }
  routes.forEach((route) => addRoute(route));
  return { addRoute, resolve, removeRoute, getRoutes, getRecordMatcher };
}
function paramsFromLocation(params, keys) {
  const newParams = {};
  for (const key of keys) {
    if (key in params) newParams[key] = params[key];
  }
  return newParams;
}
function normalizeRouteRecord(record) {
  return {
    path: record.path,
    redirect: record.redirect,
    name: record.name,
    meta: record.meta || {},
    aliasOf: void 0,
    beforeEnter: record.beforeEnter,
    props: normalizeRecordProps(record),
    children: record.children || [],
    instances: {},
    leaveGuards: /* @__PURE__ */ new Set(),
    updateGuards: /* @__PURE__ */ new Set(),
    enterCallbacks: {},
    components:
      "components" in record
        ? record.components || {}
        : { default: record.component },
  };
}
function normalizeRecordProps(record) {
  const propsObject = {};
  const props = record.props || false;
  if ("component" in record) {
    propsObject.default = props;
  } else {
    for (const name in record.components)
      propsObject[name] = typeof props === "boolean" ? props : props[name];
  }
  return propsObject;
}
function isAliasRecord(record) {
  while (record) {
    if (record.record.aliasOf) return true;
    record = record.parent;
  }
  return false;
}
function mergeMetaFields(matched) {
  return matched.reduce((meta, record) => assign(meta, record.meta), {});
}
function mergeOptions(defaults, partialOptions) {
  const options = {};
  for (const key in defaults) {
    options[key] = key in partialOptions ? partialOptions[key] : defaults[key];
  }
  return options;
}
function isRecordChildOf(record, parent) {
  return parent.children.some(
    (child) => child === record || isRecordChildOf(record, child)
  );
}
var HASH_RE = /#/g;
var AMPERSAND_RE = /&/g;
var SLASH_RE = /\//g;
var EQUAL_RE = /=/g;
var IM_RE = /\?/g;
var PLUS_RE = /\+/g;
var ENC_BRACKET_OPEN_RE = /%5B/g;
var ENC_BRACKET_CLOSE_RE = /%5D/g;
var ENC_CARET_RE = /%5E/g;
var ENC_BACKTICK_RE = /%60/g;
var ENC_CURLY_OPEN_RE = /%7B/g;
var ENC_PIPE_RE = /%7C/g;
var ENC_CURLY_CLOSE_RE = /%7D/g;
var ENC_SPACE_RE = /%20/g;
function commonEncode(text) {
  return encodeURI("" + text)
    .replace(ENC_PIPE_RE, "|")
    .replace(ENC_BRACKET_OPEN_RE, "[")
    .replace(ENC_BRACKET_CLOSE_RE, "]");
}
function encodeHash(text) {
  return commonEncode(text)
    .replace(ENC_CURLY_OPEN_RE, "{")
    .replace(ENC_CURLY_CLOSE_RE, "}")
    .replace(ENC_CARET_RE, "^");
}
function encodeQueryValue(text) {
  return commonEncode(text)
    .replace(PLUS_RE, "%2B")
    .replace(ENC_SPACE_RE, "+")
    .replace(HASH_RE, "%23")
    .replace(AMPERSAND_RE, "%26")
    .replace(ENC_BACKTICK_RE, "`")
    .replace(ENC_CURLY_OPEN_RE, "{")
    .replace(ENC_CURLY_CLOSE_RE, "}")
    .replace(ENC_CARET_RE, "^");
}
function encodeQueryKey(text) {
  return encodeQueryValue(text).replace(EQUAL_RE, "%3D");
}
function encodePath(text) {
  return commonEncode(text).replace(HASH_RE, "%23").replace(IM_RE, "%3F");
}
function encodeParam(text) {
  return text == null ? "" : encodePath(text).replace(SLASH_RE, "%2F");
}
function decode(text) {
  try {
    return decodeURIComponent("" + text);
  } catch (err) {}
  return "" + text;
}
function parseQuery(search) {
  const query = {};
  if (search === "" || search === "?") return query;
  const hasLeadingIM = search[0] === "?";
  const searchParams = (hasLeadingIM ? search.slice(1) : search).split("&");
  for (let i = 0; i < searchParams.length; ++i) {
    const searchParam = searchParams[i].replace(PLUS_RE, " ");
    const eqPos = searchParam.indexOf("=");
    const key = decode(eqPos < 0 ? searchParam : searchParam.slice(0, eqPos));
    const value = eqPos < 0 ? null : decode(searchParam.slice(eqPos + 1));
    if (key in query) {
      let currentValue = query[key];
      if (!Array.isArray(currentValue)) {
        currentValue = query[key] = [currentValue];
      }
      currentValue.push(value);
    } else {
      query[key] = value;
    }
  }
  return query;
}
function stringifyQuery(query) {
  let search = "";
  for (let key in query) {
    const value = query[key];
    key = encodeQueryKey(key);
    if (value == null) {
      if (value !== void 0) {
        search += (search.length ? "&" : "") + key;
      }
      continue;
    }
    const values = Array.isArray(value)
      ? value.map((v) => v && encodeQueryValue(v))
      : [value && encodeQueryValue(value)];
    values.forEach((value2) => {
      if (value2 !== void 0) {
        search += (search.length ? "&" : "") + key;
        if (value2 != null) search += "=" + value2;
      }
    });
  }
  return search;
}
function normalizeQuery(query) {
  const normalizedQuery = {};
  for (const key in query) {
    const value = query[key];
    if (value !== void 0) {
      normalizedQuery[key] = Array.isArray(value)
        ? value.map((v) => (v == null ? null : "" + v))
        : value == null
        ? value
        : "" + value;
    }
  }
  return normalizedQuery;
}
function useCallbacks() {
  let handlers = [];
  function add(handler) {
    handlers.push(handler);
    return () => {
      const i = handlers.indexOf(handler);
      if (i > -1) handlers.splice(i, 1);
    };
  }
  function reset() {
    handlers = [];
  }
  return {
    add,
    list: () => handlers,
    reset,
  };
}
function guardToPromiseFn(guard, to, from, record, name) {
  const enterCallbackArray =
    record && // name is defined if record is because of the function overload
    (record.enterCallbacks[name] = record.enterCallbacks[name] || []);
  return () =>
    new Promise((resolve, reject) => {
      const next = (valid) => {
        if (valid === false)
          reject(
            createRouterError(4, {
              from,
              to,
            })
          );
        else if (valid instanceof Error) {
          reject(valid);
        } else if (isRouteLocation(valid)) {
          reject(
            createRouterError(2, {
              from: to,
              to: valid,
            })
          );
        } else {
          if (
            enterCallbackArray && // since enterCallbackArray is truthy, both record and name also are
            record.enterCallbacks[name] === enterCallbackArray &&
            typeof valid === "function"
          )
            enterCallbackArray.push(valid);
          resolve();
        }
      };
      const guardReturn = guard.call(
        record && record.instances[name],
        to,
        from,
        next
      );
      let guardCall = Promise.resolve(guardReturn);
      if (guard.length < 3) guardCall = guardCall.then(next);
      guardCall.catch((err) => reject(err));
    });
}
function extractComponentsGuards(matched, guardType, to, from) {
  const guards = [];
  for (const record of matched) {
    for (const name in record.components) {
      let rawComponent = record.components[name];
      if (guardType !== "beforeRouteEnter" && !record.instances[name]) continue;
      if (isRouteComponent(rawComponent)) {
        const options = rawComponent.__vccOpts || rawComponent;
        const guard = options[guardType];
        guard && guards.push(guardToPromiseFn(guard, to, from, record, name));
      } else {
        let componentPromise = rawComponent();
        guards.push(() =>
          componentPromise.then((resolved) => {
            if (!resolved)
              return Promise.reject(
                new Error(
                  `Couldn't resolve component "${name}" at "${record.path}"`
                )
              );
            const resolvedComponent = isESModule(resolved)
              ? resolved.default
              : resolved;
            record.components[name] = resolvedComponent;
            const options = resolvedComponent.__vccOpts || resolvedComponent;
            const guard = options[guardType];
            return guard && guardToPromiseFn(guard, to, from, record, name)();
          })
        );
      }
    }
  }
  return guards;
}
function isRouteComponent(component) {
  return (
    typeof component === "object" ||
    "displayName" in component ||
    "props" in component ||
    "__vccOpts" in component
  );
}
function useLink(props) {
  const router = inject(routerKey);
  const currentRoute = inject(routeLocationKey);
  const route = computed2(() => router.resolve(unref(props.to)));
  const activeRecordIndex = computed2(() => {
    const { matched } = route.value;
    const { length } = matched;
    const routeMatched = matched[length - 1];
    const currentMatched = currentRoute.matched;
    if (!routeMatched || !currentMatched.length) return -1;
    const index = currentMatched.findIndex(
      isSameRouteRecord.bind(null, routeMatched)
    );
    if (index > -1) return index;
    const parentRecordPath = getOriginalPath(matched[length - 2]);
    return (
      // we are dealing with nested routes
      length > 1 && // if the parent and matched route have the same path, this link is
        // referring to the empty child. Or we currently are on a different
        // child of the same parent
        getOriginalPath(routeMatched) === parentRecordPath && // avoid comparing the child with its parent
        currentMatched[currentMatched.length - 1].path !== parentRecordPath
        ? currentMatched.findIndex(
            isSameRouteRecord.bind(null, matched[length - 2])
          )
        : index
    );
  });
  const isActive = computed2(
    () =>
      activeRecordIndex.value > -1 &&
      includesParams(currentRoute.params, route.value.params)
  );
  const isExactActive = computed2(
    () =>
      activeRecordIndex.value > -1 &&
      activeRecordIndex.value === currentRoute.matched.length - 1 &&
      isSameRouteLocationParams(currentRoute.params, route.value.params)
  );
  function navigate(e = {}) {
    if (guardEvent(e)) {
      return router[unref(props.replace) ? "replace" : "push"](
        unref(props.to)
        // avoid uncaught errors are they are logged anyway
      ).catch(noop$3);
    }
    return Promise.resolve();
  }
  return {
    route,
    href: computed2(() => route.value.href),
    isActive,
    isExactActive,
    navigate,
  };
}
var RouterLinkImpl = /* @__PURE__ */ defineComponent({
  name: "RouterLink",
  props: {
    to: {
      type: [String, Object],
      required: true,
    },
    replace: Boolean,
    activeClass: String,
    // inactiveClass: String,
    exactActiveClass: String,
    custom: Boolean,
    ariaCurrentValue: {
      type: String,
      default: "page",
    },
  },
  useLink,
  setup(props, { slots }) {
    const link = reactive(useLink(props));
    const { options } = inject(routerKey);
    const elClass = computed2(() => ({
      [getLinkClass(
        props.activeClass,
        options.linkActiveClass,
        "router-link-active"
      )]: link.isActive,
      // [getLinkClass(
      //   props.inactiveClass,
      //   options.linkInactiveClass,
      //   'router-link-inactive'
      // )]: !link.isExactActive,
      [getLinkClass(
        props.exactActiveClass,
        options.linkExactActiveClass,
        "router-link-exact-active"
      )]: link.isExactActive,
    }));
    return () => {
      const children = slots.default && slots.default(link);
      return props.custom
        ? children
        : h(
            "a",
            {
              "aria-current": link.isExactActive
                ? props.ariaCurrentValue
                : null,
              href: link.href,
              // this would override user added attrs but Vue will still add
              // the listener so we end up triggering both
              onClick: link.navigate,
              class: elClass.value,
            },
            children
          );
    };
  },
});
var RouterLink = RouterLinkImpl;
function guardEvent(e) {
  if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) return;
  if (e.defaultPrevented) return;
  if (e.button !== void 0 && e.button !== 0) return;
  if (e.currentTarget && e.currentTarget.getAttribute) {
    const target = e.currentTarget.getAttribute("target");
    if (/\b_blank\b/i.test(target)) return;
  }
  if (e.preventDefault) e.preventDefault();
  return true;
}
function includesParams(outer, inner) {
  for (const key in inner) {
    const innerValue = inner[key];
    const outerValue = outer[key];
    if (typeof innerValue === "string") {
      if (innerValue !== outerValue) return false;
    } else {
      if (
        !Array.isArray(outerValue) ||
        outerValue.length !== innerValue.length ||
        innerValue.some((value, i) => value !== outerValue[i])
      )
        return false;
    }
  }
  return true;
}
function getOriginalPath(record) {
  return record ? (record.aliasOf ? record.aliasOf.path : record.path) : "";
}
var getLinkClass = (propClass, globalClass, defaultClass) =>
  propClass != null
    ? propClass
    : globalClass != null
    ? globalClass
    : defaultClass;
var RouterViewImpl = /* @__PURE__ */ defineComponent({
  name: "RouterView",
  // #674 we manually inherit them
  inheritAttrs: false,
  props: {
    name: {
      type: String,
      default: "default",
    },
    route: Object,
  },
  setup(props, { attrs, slots }) {
    const injectedRoute = inject(routerViewLocationKey);
    const routeToDisplay = computed2(() => props.route || injectedRoute.value);
    const depth = inject(viewDepthKey, 0);
    const matchedRouteRef = computed2(
      () => routeToDisplay.value.matched[depth]
    );
    provide(viewDepthKey, depth + 1);
    provide(matchedRouteKey, matchedRouteRef);
    provide(routerViewLocationKey, routeToDisplay);
    const viewRef = ref();
    watch(
      () => [viewRef.value, matchedRouteRef.value, props.name],
      ([instance, to, name], [oldInstance, from, oldName]) => {
        if (to) {
          to.instances[name] = instance;
          if (from && from !== to && instance && instance === oldInstance) {
            if (!to.leaveGuards.size) {
              to.leaveGuards = from.leaveGuards;
            }
            if (!to.updateGuards.size) {
              to.updateGuards = from.updateGuards;
            }
          }
        }
        if (
          instance &&
          to && // if there is no instance but to and from are the same this might be
          // the first visit
          (!from || !isSameRouteRecord(to, from) || !oldInstance)
        ) {
          (to.enterCallbacks[name] || []).forEach((callback) =>
            callback(instance)
          );
        }
      },
      { flush: "post" }
    );
    return () => {
      const route = routeToDisplay.value;
      const matchedRoute = matchedRouteRef.value;
      const ViewComponent = matchedRoute && matchedRoute.components[props.name];
      const currentName = props.name;
      if (!ViewComponent) {
        return normalizeSlot(slots.default, {
          Component: ViewComponent,
          route,
        });
      }
      const routePropsOption = matchedRoute.props[props.name];
      const routeProps = routePropsOption
        ? routePropsOption === true
          ? route.params
          : typeof routePropsOption === "function"
          ? routePropsOption(route)
          : routePropsOption
        : null;
      const onVnodeUnmounted = (vnode) => {
        if (vnode.component.isUnmounted) {
          matchedRoute.instances[currentName] = null;
        }
      };
      const component = h(
        ViewComponent,
        assign({}, routeProps, attrs, {
          onVnodeUnmounted,
          ref: viewRef,
        })
      );
      return (
        // pass the vnode to the slot as a prop.
        // h and <component :is="..."> both accept vnodes
        normalizeSlot(slots.default, { Component: component, route }) ||
        component
      );
    };
  },
});
function normalizeSlot(slot, data) {
  if (!slot) return null;
  const slotContent = slot(data);
  return slotContent.length === 1 ? slotContent[0] : slotContent;
}
var RouterView = RouterViewImpl;
function createRouter(options) {
  const matcher = createRouterMatcher(options.routes, options);
  const parseQuery$1 = options.parseQuery || parseQuery;
  const stringifyQuery$1 = options.stringifyQuery || stringifyQuery;
  const routerHistory = options.history;
  const beforeGuards = useCallbacks();
  const beforeResolveGuards = useCallbacks();
  const afterGuards = useCallbacks();
  const currentRoute = shallowRef(START_LOCATION_NORMALIZED);
  let pendingLocation = START_LOCATION_NORMALIZED;
  if (isBrowser$1 && options.scrollBehavior && "scrollRestoration" in history) {
    history.scrollRestoration = "manual";
  }
  const normalizeParams = applyToParams.bind(
    null,
    (paramValue) => "" + paramValue
  );
  const encodeParams = applyToParams.bind(null, encodeParam);
  const decodeParams =
    // @ts-expect-error: intentionally avoid the type check
    applyToParams.bind(null, decode);
  function addRoute(parentOrRoute, route) {
    let parent;
    let record;
    if (isRouteName(parentOrRoute)) {
      parent = matcher.getRecordMatcher(parentOrRoute);
      record = route;
    } else {
      record = parentOrRoute;
    }
    return matcher.addRoute(record, parent);
  }
  function removeRoute(name) {
    const recordMatcher = matcher.getRecordMatcher(name);
    if (recordMatcher) {
      matcher.removeRoute(recordMatcher);
    }
  }
  function getRoutes() {
    return matcher.getRoutes().map((routeMatcher) => routeMatcher.record);
  }
  function hasRoute(name) {
    return !!matcher.getRecordMatcher(name);
  }
  function resolve(rawLocation, currentLocation) {
    currentLocation = assign({}, currentLocation || currentRoute.value);
    if (typeof rawLocation === "string") {
      const locationNormalized = parseURL(
        parseQuery$1,
        rawLocation,
        currentLocation.path
      );
      const matchedRoute2 = matcher.resolve(
        { path: locationNormalized.path },
        currentLocation
      );
      const href2 = routerHistory.createHref(locationNormalized.fullPath);
      return assign(locationNormalized, matchedRoute2, {
        params: decodeParams(matchedRoute2.params),
        hash: decode(locationNormalized.hash),
        redirectedFrom: void 0,
        href: href2,
      });
    }
    let matcherLocation;
    if ("path" in rawLocation) {
      matcherLocation = assign({}, rawLocation, {
        path: parseURL(parseQuery$1, rawLocation.path, currentLocation.path)
          .path,
      });
    } else {
      const targetParams = assign({}, rawLocation.params);
      for (const key in targetParams) {
        if (targetParams[key] == null) {
          delete targetParams[key];
        }
      }
      matcherLocation = assign({}, rawLocation, {
        params: encodeParams(rawLocation.params),
      });
      currentLocation.params = encodeParams(currentLocation.params);
    }
    const matchedRoute = matcher.resolve(matcherLocation, currentLocation);
    const hash = rawLocation.hash || "";
    matchedRoute.params = normalizeParams(decodeParams(matchedRoute.params));
    const fullPath = stringifyURL(
      stringifyQuery$1,
      assign({}, rawLocation, {
        hash: encodeHash(hash),
        path: matchedRoute.path,
      })
    );
    const href = routerHistory.createHref(fullPath);
    return assign(
      {
        fullPath,
        // keep the hash encoded so fullPath is effectively path + encodedQuery +
        // hash
        hash,
        query:
          // if the user is using a custom query lib like qs, we might have
          // nested objects, so we keep the query as is, meaning it can contain
          // numbers at `$route.query`, but at the point, the user will have to
          // use their own type anyway.
          // https://github.com/vuejs/router/issues/328#issuecomment-649481567
          stringifyQuery$1 === stringifyQuery
            ? normalizeQuery(rawLocation.query)
            : rawLocation.query || {},
      },
      matchedRoute,
      {
        redirectedFrom: void 0,
        href,
      }
    );
  }
  function locationAsObject(to) {
    return typeof to === "string"
      ? parseURL(parseQuery$1, to, currentRoute.value.path)
      : assign({}, to);
  }
  function checkCanceledNavigation(to, from) {
    if (pendingLocation !== to) {
      return createRouterError(8, {
        from,
        to,
      });
    }
  }
  function push(to) {
    return pushWithRedirect(to);
  }
  function replace(to) {
    return push(assign(locationAsObject(to), { replace: true }));
  }
  function handleRedirectRecord(to) {
    const lastMatched = to.matched[to.matched.length - 1];
    if (lastMatched && lastMatched.redirect) {
      const { redirect } = lastMatched;
      let newTargetLocation =
        typeof redirect === "function" ? redirect(to) : redirect;
      if (typeof newTargetLocation === "string") {
        newTargetLocation =
          newTargetLocation.includes("?") || newTargetLocation.includes("#")
            ? (newTargetLocation = locationAsObject(newTargetLocation))
            : // force empty params
              { path: newTargetLocation };
        newTargetLocation.params = {};
      }
      return assign(
        {
          query: to.query,
          hash: to.hash,
          params: to.params,
        },
        newTargetLocation
      );
    }
  }
  function pushWithRedirect(to, redirectedFrom) {
    const targetLocation = (pendingLocation = resolve(to));
    const from = currentRoute.value;
    const data = to.state;
    const force = to.force;
    const replace2 = to.replace === true;
    const shouldRedirect = handleRedirectRecord(targetLocation);
    if (shouldRedirect)
      return pushWithRedirect(
        assign(locationAsObject(shouldRedirect), {
          state: data,
          force,
          replace: replace2,
        }),
        // keep original redirectedFrom if it exists
        redirectedFrom || targetLocation
      );
    const toLocation = targetLocation;
    toLocation.redirectedFrom = redirectedFrom;
    let failure;
    if (!force && isSameRouteLocation(stringifyQuery$1, from, targetLocation)) {
      failure = createRouterError(16, { to: toLocation, from });
      handleScroll(
        from,
        from,
        // this is a push, the only way for it to be triggered from a
        // history.listen is with a redirect, which makes it become a push
        true,
        // This cannot be the first navigation because the initial location
        // cannot be manually navigated to
        false
      );
    }
    return (failure ? Promise.resolve(failure) : navigate(toLocation, from))
      .catch((error) =>
        isNavigationFailure(error)
          ? // navigation redirects still mark the router as ready
            isNavigationFailure(
              error,
              2
              /* NAVIGATION_GUARD_REDIRECT */
            )
            ? error
            : markAsReady(error)
          : // reject any unknown error
            triggerError(error, toLocation, from)
      )
      .then((failure2) => {
        if (failure2) {
          if (
            isNavigationFailure(
              failure2,
              2
              /* NAVIGATION_GUARD_REDIRECT */
            )
          ) {
            return pushWithRedirect(
              // keep options
              assign(locationAsObject(failure2.to), {
                state: data,
                force,
                replace: replace2,
              }),
              // preserve the original redirectedFrom if any
              redirectedFrom || toLocation
            );
          }
        } else {
          failure2 = finalizeNavigation(toLocation, from, true, replace2, data);
        }
        triggerAfterEach(toLocation, from, failure2);
        return failure2;
      });
  }
  function checkCanceledNavigationAndReject(to, from) {
    const error = checkCanceledNavigation(to, from);
    return error ? Promise.reject(error) : Promise.resolve();
  }
  function navigate(to, from) {
    let guards;
    const [leavingRecords, updatingRecords, enteringRecords] =
      extractChangingRecords(to, from);
    guards = extractComponentsGuards(
      leavingRecords.reverse(),
      "beforeRouteLeave",
      to,
      from
    );
    for (const record of leavingRecords) {
      record.leaveGuards.forEach((guard) => {
        guards.push(guardToPromiseFn(guard, to, from));
      });
    }
    const canceledNavigationCheck = checkCanceledNavigationAndReject.bind(
      null,
      to,
      from
    );
    guards.push(canceledNavigationCheck);
    return runGuardQueue(guards)
      .then(() => {
        guards = [];
        for (const guard of beforeGuards.list()) {
          guards.push(guardToPromiseFn(guard, to, from));
        }
        guards.push(canceledNavigationCheck);
        return runGuardQueue(guards);
      })
      .then(() => {
        guards = extractComponentsGuards(
          updatingRecords,
          "beforeRouteUpdate",
          to,
          from
        );
        for (const record of updatingRecords) {
          record.updateGuards.forEach((guard) => {
            guards.push(guardToPromiseFn(guard, to, from));
          });
        }
        guards.push(canceledNavigationCheck);
        return runGuardQueue(guards);
      })
      .then(() => {
        guards = [];
        for (const record of to.matched) {
          if (record.beforeEnter && !from.matched.includes(record)) {
            if (Array.isArray(record.beforeEnter)) {
              for (const beforeEnter of record.beforeEnter)
                guards.push(guardToPromiseFn(beforeEnter, to, from));
            } else {
              guards.push(guardToPromiseFn(record.beforeEnter, to, from));
            }
          }
        }
        guards.push(canceledNavigationCheck);
        return runGuardQueue(guards);
      })
      .then(() => {
        to.matched.forEach((record) => (record.enterCallbacks = {}));
        guards = extractComponentsGuards(
          enteringRecords,
          "beforeRouteEnter",
          to,
          from
        );
        guards.push(canceledNavigationCheck);
        return runGuardQueue(guards);
      })
      .then(() => {
        guards = [];
        for (const guard of beforeResolveGuards.list()) {
          guards.push(guardToPromiseFn(guard, to, from));
        }
        guards.push(canceledNavigationCheck);
        return runGuardQueue(guards);
      })
      .catch((err) =>
        isNavigationFailure(
          err,
          8
          /* NAVIGATION_CANCELLED */
        )
          ? err
          : Promise.reject(err)
      );
  }
  function triggerAfterEach(to, from, failure) {
    for (const guard of afterGuards.list()) guard(to, from, failure);
  }
  function finalizeNavigation(toLocation, from, isPush, replace2, data) {
    const error = checkCanceledNavigation(toLocation, from);
    if (error) return error;
    const isFirstNavigation = from === START_LOCATION_NORMALIZED;
    const state = !isBrowser$1 ? {} : history.state;
    if (isPush) {
      if (replace2 || isFirstNavigation)
        routerHistory.replace(
          toLocation.fullPath,
          assign(
            {
              scroll: isFirstNavigation && state && state.scroll,
            },
            data
          )
        );
      else routerHistory.push(toLocation.fullPath, data);
    }
    currentRoute.value = toLocation;
    handleScroll(toLocation, from, isPush, isFirstNavigation);
    markAsReady();
  }
  let removeHistoryListener;
  function setupListeners() {
    removeHistoryListener = routerHistory.listen((to, _from, info) => {
      const toLocation = resolve(to);
      const shouldRedirect = handleRedirectRecord(toLocation);
      if (shouldRedirect) {
        pushWithRedirect(
          assign(shouldRedirect, { replace: true }),
          toLocation
        ).catch(noop$3);
        return;
      }
      pendingLocation = toLocation;
      const from = currentRoute.value;
      if (isBrowser$1) {
        saveScrollPosition(
          getScrollKey(from.fullPath, info.delta),
          computeScrollPosition()
        );
      }
      navigate(toLocation, from)
        .catch((error) => {
          if (
            isNavigationFailure(
              error,
              4 | 8
              /* NAVIGATION_CANCELLED */
            )
          ) {
            return error;
          }
          if (
            isNavigationFailure(
              error,
              2
              /* NAVIGATION_GUARD_REDIRECT */
            )
          ) {
            pushWithRedirect(
              error.to,
              toLocation
              // avoid an uncaught rejection, let push call triggerError
            )
              .then((failure) => {
                if (
                  isNavigationFailure(
                    failure,
                    4 | 16
                    /* NAVIGATION_DUPLICATED */
                  ) &&
                  !info.delta &&
                  info.type === NavigationType.pop
                ) {
                  routerHistory.go(-1, false);
                }
              })
              .catch(noop$3);
            return Promise.reject();
          }
          if (info.delta) routerHistory.go(-info.delta, false);
          return triggerError(error, toLocation, from);
        })
        .then((failure) => {
          failure =
            failure ||
            finalizeNavigation(
              // after navigation, all matched components are resolved
              toLocation,
              from,
              false
            );
          if (failure) {
            if (info.delta) {
              routerHistory.go(-info.delta, false);
            } else if (
              info.type === NavigationType.pop &&
              isNavigationFailure(
                failure,
                4 | 16
                /* NAVIGATION_DUPLICATED */
              )
            ) {
              routerHistory.go(-1, false);
            }
          }
          triggerAfterEach(toLocation, from, failure);
        })
        .catch(noop$3);
    });
  }
  let readyHandlers = useCallbacks();
  let errorHandlers = useCallbacks();
  let ready;
  function triggerError(error, to, from) {
    markAsReady(error);
    const list = errorHandlers.list();
    if (list.length) {
      list.forEach((handler) => handler(error, to, from));
    } else {
      console.error(error);
    }
    return Promise.reject(error);
  }
  function isReady() {
    if (ready && currentRoute.value !== START_LOCATION_NORMALIZED)
      return Promise.resolve();
    return new Promise((resolve2, reject) => {
      readyHandlers.add([resolve2, reject]);
    });
  }
  function markAsReady(err) {
    if (!ready) {
      ready = !err;
      setupListeners();
      readyHandlers
        .list()
        .forEach(([resolve2, reject]) => (err ? reject(err) : resolve2()));
      readyHandlers.reset();
    }
    return err;
  }
  function handleScroll(to, from, isPush, isFirstNavigation) {
    const { scrollBehavior } = options;
    if (!isBrowser$1 || !scrollBehavior) return Promise.resolve();
    const scrollPosition =
      (!isPush && getSavedScrollPosition(getScrollKey(to.fullPath, 0))) ||
      ((isFirstNavigation || !isPush) &&
        history.state &&
        history.state.scroll) ||
      null;
    return nextTick()
      .then(() => scrollBehavior(to, from, scrollPosition))
      .then((position) => position && scrollToPosition(position))
      .catch((err) => triggerError(err, to, from));
  }
  const go = (delta) => routerHistory.go(delta);
  let started;
  const installedApps = /* @__PURE__ */ new Set();
  const router = {
    currentRoute,
    addRoute,
    removeRoute,
    hasRoute,
    getRoutes,
    resolve,
    options,
    push,
    replace,
    go,
    back: () => go(-1),
    forward: () => go(1),
    beforeEach: beforeGuards.add,
    beforeResolve: beforeResolveGuards.add,
    afterEach: afterGuards.add,
    onError: errorHandlers.add,
    isReady,
    install(app) {
      const router2 = this;
      app.component("RouterLink", RouterLink);
      app.component("RouterView", RouterView);
      app.config.globalProperties.$router = router2;
      Object.defineProperty(app.config.globalProperties, "$route", {
        enumerable: true,
        get: () => unref(currentRoute),
      });
      if (
        isBrowser$1 && // used for the initial navigation client side to avoid pushing
        // multiple times when the router is used in multiple apps
        !started &&
        currentRoute.value === START_LOCATION_NORMALIZED
      ) {
        started = true;
        push(routerHistory.location).catch((err) => {});
      }
      const reactiveRoute = {};
      for (const key in START_LOCATION_NORMALIZED) {
        reactiveRoute[key] = computed2(() => currentRoute.value[key]);
      }
      app.provide(routerKey, router2);
      app.provide(routeLocationKey, reactive(reactiveRoute));
      app.provide(routerViewLocationKey, currentRoute);
      const unmountApp = app.unmount;
      installedApps.add(app);
      app.unmount = function () {
        installedApps.delete(app);
        if (installedApps.size < 1) {
          pendingLocation = START_LOCATION_NORMALIZED;
          removeHistoryListener && removeHistoryListener();
          currentRoute.value = START_LOCATION_NORMALIZED;
          started = false;
          ready = false;
        }
        unmountApp();
      };
    },
  };
  return router;
}
function runGuardQueue(guards) {
  return guards.reduce(
    (promise, guard) => promise.then(() => guard()),
    Promise.resolve()
  );
}
function extractChangingRecords(to, from) {
  const leavingRecords = [];
  const updatingRecords = [];
  const enteringRecords = [];
  const len = Math.max(from.matched.length, to.matched.length);
  for (let i = 0; i < len; i++) {
    const recordFrom = from.matched[i];
    if (recordFrom) {
      if (to.matched.find((record) => isSameRouteRecord(record, recordFrom)))
        updatingRecords.push(recordFrom);
      else leavingRecords.push(recordFrom);
    }
    const recordTo = to.matched[i];
    if (recordTo) {
      if (!from.matched.find((record) => isSameRouteRecord(record, recordTo))) {
        enteringRecords.push(recordTo);
      }
    }
  }
  return [leavingRecords, updatingRecords, enteringRecords];
}
/*! Bundled license information:

vue-router/dist/vue-router.esm-bundler.js:
  (*!
    * vue-router v4.0.14
    * (c) 2022 Eduardo San Martin Morote
    * @license MIT
    *)
*/

const router$1 = createRouter({
  history: createWebHistory("/"),
  routes: [
    {
      path: "/",
      name: "index",
      redirect: { name: "workers" },
    },
    {
      path: "/jobs/:jobID?/:taskID?",
      name: "jobs",
      component: () =>
        __vitePreload(
          () => import("./RunningJobsView-4fe7522f.js"),
          true
            ? [
                "assets/RunningJobsView-4fe7522f.js",
                "assets/LastRenderedImage-6d6daeaa.js",
                "assets/LastRenderedImage-6f05823b.css",
                "assets/workers-4d34dda6.js",
                "assets/UpdateListener-0386af97.js",
                "assets/UpdateListener-852c0a59.css",
                "assets/RunningJobsView-e91b4da0.css",
              ]
            : void 0
        ),
      props: true,
    },
    {
      path: "/workers/:workerID?",
      name: "workers",
      component: () =>
        __vitePreload(
          () => import("./WorkersView-65482df4.js"),
          true
            ? [
                "assets/WorkersView-65482df4.js",
                "assets/workers-4d34dda6.js",
                "assets/UpdateListener-0386af97.js",
                "assets/UpdateListener-852c0a59.css",
                "assets/axios-b9696aed.js",
                "assets/WorkersView-3cd2980b.css",
              ]
            : void 0
        ),
      props: true,
    },
    {
      path: "/last-rendered",
      name: "last-rendered",
      component: () =>
        __vitePreload(
          () => import("./LastRenderedView-832a13c0.js"),
          true
            ? [
                "assets/LastRenderedView-832a13c0.js",
                "assets/LastRenderedImage-6d6daeaa.js",
                "assets/LastRenderedImage-6f05823b.css",
                "assets/UpdateListener-0386af97.js",
                "assets/UpdateListener-852c0a59.css",
                "assets/LastRenderedView-d0696551.css",
              ]
            : void 0
        ),
    },
    {
      path: "/connect-inferix",
      name: "connect-inferix-id",
      component: () =>
        __vitePreload(
          () => import("./ConnectInferixIDView-32350f4e.js"),
          true
            ? [
                "assets/ConnectInferixIDView-32350f4e.js",
                "assets/axios-b9696aed.js",
                "assets/ConnectInferixIDView-1422d55d.css",
              ]
            : void 0
        ),
      props: true,
    },

    {
      path: "/top-up",
      name: "top-up",
      component: () =>
        __vitePreload(
          () => import("./TopUpView-e247b93e.js"),
          true
            ? ["assets/TopUpView-e247b93e.js", "assets/TopUpView-6aaa43e1.css"]
            : void 0
        ),
      props: true,
    },
  ],
});

const router = createRouter({
  history: createWebHistory("/"),
  routes: [
    {
      path: "/",
      name: "index",
      component: () =>
        __vitePreload(
          () => import("./SetupAssistantView-d7f7d14f.js"),
          true
            ? [
                "assets/SetupAssistantView-d7f7d14f.js",
                "assets/UpdateListener-0386af97.js",
                "assets/UpdateListener-852c0a59.css",
                "assets/SetupAssistantView-3ab81174.css",
              ]
            : void 0
        ),
    },
    {
      path: "/:pathMatch(.*)*",
      name: "redirect-to-index",
      redirect: "/",
    },
  ],
});

// node_modules/mitt/dist/mitt.mjs
function mitt_default(n) {
  return {
    all: (n = n || /* @__PURE__ */ new Map()),
    on: function (t, e) {
      var i = n.get(t);
      i ? i.push(e) : n.set(t, [e]);
    },
    off: function (t, e) {
      var i = n.get(t);
      i && (e ? i.splice(i.indexOf(e) >>> 0, 1) : n.set(t, []));
    },
    emit: function (t, e) {
      var i = n.get(t);
      i &&
        i.slice().map(function (n2) {
          n2(e);
        }),
        (i = n.get("*")) &&
          i.slice().map(function (n2) {
            n2(t, e);
          });
    },
  };
}

// node_modules/@vue/compiler-core/dist/compiler-core.esm-bundler.js
function defaultOnError(error) {
  throw error;
}
function defaultOnWarn(msg) {}
function createCompilerError(code, loc, messages, additionalMessage) {
  const msg = code;
  const error = new SyntaxError(String(msg));
  error.code = code;
  error.loc = loc;
  return error;
}
function registerRuntimeHelpers(helpers) {
  Object.getOwnPropertySymbols(helpers).forEach((s) => {
    helperNameMap[s] = helpers[s];
  });
}
function createRoot(children, loc = locStub) {
  return {
    type: 0,
    children,
    helpers: [],
    components: [],
    directives: [],
    hoists: [],
    imports: [],
    cached: 0,
    temps: 0,
    codegenNode: void 0,
    loc,
  };
}
function createVNodeCall(
  context,
  tag,
  props,
  children,
  patchFlag,
  dynamicProps,
  directives,
  isBlock = false,
  disableTracking = false,
  isComponent2 = false,
  loc = locStub
) {
  if (context) {
    if (isBlock) {
      context.helper(OPEN_BLOCK);
      context.helper(getVNodeBlockHelper(context.inSSR, isComponent2));
    } else {
      context.helper(getVNodeHelper(context.inSSR, isComponent2));
    }
    if (directives) {
      context.helper(WITH_DIRECTIVES);
    }
  }
  return {
    type: 13,
    tag,
    props,
    children,
    patchFlag,
    dynamicProps,
    directives,
    isBlock,
    disableTracking,
    isComponent: isComponent2,
    loc,
  };
}
function createArrayExpression(elements, loc = locStub) {
  return {
    type: 17,
    loc,
    elements,
  };
}
function createObjectExpression(properties, loc = locStub) {
  return {
    type: 15,
    loc,
    properties,
  };
}
function createObjectProperty(key, value) {
  return {
    type: 16,
    loc: locStub,
    key: isString$1(key) ? createSimpleExpression(key, true) : key,
    value,
  };
}
function createSimpleExpression(
  content,
  isStatic = false,
  loc = locStub,
  constType = 0
) {
  return {
    type: 4,
    loc,
    content,
    isStatic,
    constType: isStatic ? 3 : constType,
  };
}
function createInterpolation(content, loc) {
  return {
    type: 5,
    loc,
    content: isString$1(content)
      ? createSimpleExpression(content, false, loc)
      : content,
  };
}
function createCompoundExpression(children, loc = locStub) {
  return {
    type: 8,
    loc,
    children,
  };
}
function createCallExpression(callee, args = [], loc = locStub) {
  return {
    type: 14,
    loc,
    callee,
    arguments: args,
  };
}
function createFunctionExpression(
  params,
  returns = void 0,
  newline = false,
  isSlot = false,
  loc = locStub
) {
  return {
    type: 18,
    params,
    returns,
    newline,
    isSlot,
    loc,
  };
}
function createConditionalExpression(
  test,
  consequent,
  alternate,
  newline = true
) {
  return {
    type: 19,
    test,
    consequent,
    alternate,
    newline,
    loc: locStub,
  };
}
function createCacheExpression(index, value, isVNode = false) {
  return {
    type: 20,
    index,
    value,
    isVNode,
    loc: locStub,
  };
}
function createBlockStatement(body) {
  return {
    type: 21,
    body,
    loc: locStub,
  };
}
function createTemplateLiteral(elements) {
  return {
    type: 22,
    elements,
    loc: locStub,
  };
}
function createIfStatement(test, consequent, alternate) {
  return {
    type: 23,
    test,
    consequent,
    alternate,
    loc: locStub,
  };
}
function createAssignmentExpression(left, right) {
  return {
    type: 24,
    left,
    right,
    loc: locStub,
  };
}
function createSequenceExpression(expressions) {
  return {
    type: 25,
    expressions,
    loc: locStub,
  };
}
function createReturnStatement(returns) {
  return {
    type: 26,
    returns,
    loc: locStub,
  };
}
function isCoreComponent(tag) {
  if (isBuiltInType(tag, "Teleport")) {
    return TELEPORT;
  } else if (isBuiltInType(tag, "Suspense")) {
    return SUSPENSE;
  } else if (isBuiltInType(tag, "KeepAlive")) {
    return KEEP_ALIVE;
  } else if (isBuiltInType(tag, "BaseTransition")) {
    return BASE_TRANSITION;
  }
}
function getInnerRange(loc, offset, length) {
  const source = loc.source.slice(offset, offset + length);
  const newLoc = {
    source,
    start: advancePositionWithClone(loc.start, loc.source, offset),
    end: loc.end,
  };
  if (length != null) {
    newLoc.end = advancePositionWithClone(
      loc.start,
      loc.source,
      offset + length
    );
  }
  return newLoc;
}
function advancePositionWithClone(
  pos,
  source,
  numberOfCharacters = source.length
) {
  return advancePositionWithMutation(
    extend({}, pos),
    source,
    numberOfCharacters
  );
}
function advancePositionWithMutation(
  pos,
  source,
  numberOfCharacters = source.length
) {
  let linesCount = 0;
  let lastNewLinePos = -1;
  for (let i = 0; i < numberOfCharacters; i++) {
    if (source.charCodeAt(i) === 10) {
      linesCount++;
      lastNewLinePos = i;
    }
  }
  pos.offset += numberOfCharacters;
  pos.line += linesCount;
  pos.column =
    lastNewLinePos === -1
      ? pos.column + numberOfCharacters
      : numberOfCharacters - lastNewLinePos;
  return pos;
}
function assert(condition, msg) {
  if (!condition) {
    throw new Error(msg || `unexpected compiler condition`);
  }
}
function findDir(node, name, allowEmpty = false) {
  for (let i = 0; i < node.props.length; i++) {
    const p = node.props[i];
    if (
      p.type === 7 &&
      (allowEmpty || p.exp) &&
      (isString$1(name) ? p.name === name : name.test(p.name))
    ) {
      return p;
    }
  }
}
function findProp(node, name, dynamicOnly = false, allowEmpty = false) {
  for (let i = 0; i < node.props.length; i++) {
    const p = node.props[i];
    if (p.type === 6) {
      if (dynamicOnly) continue;
      if (p.name === name && (p.value || allowEmpty)) {
        return p;
      }
    } else if (
      p.name === "bind" &&
      (p.exp || allowEmpty) &&
      isStaticArgOf(p.arg, name)
    ) {
      return p;
    }
  }
}
function isStaticArgOf(arg, name) {
  return !!(arg && isStaticExp(arg) && arg.content === name);
}
function hasDynamicKeyVBind(node) {
  return node.props.some(
    (p) =>
      p.type === 7 &&
      p.name === "bind" &&
      (!p.arg || // v-bind="obj"
        p.arg.type !== 4 || // v-bind:[_ctx.foo]
        !p.arg.isStatic)
    // v-bind:[foo]
  );
}
function isText(node) {
  return node.type === 5 || node.type === 2;
}
function isVSlot(p) {
  return p.type === 7 && p.name === "slot";
}
function isTemplateNode(node) {
  return node.type === 1 && node.tagType === 3;
}
function isSlotOutlet(node) {
  return node.type === 1 && node.tagType === 2;
}
function getVNodeHelper(ssr, isComponent2) {
  return ssr || isComponent2 ? CREATE_VNODE : CREATE_ELEMENT_VNODE;
}
function getVNodeBlockHelper(ssr, isComponent2) {
  return ssr || isComponent2 ? CREATE_BLOCK : CREATE_ELEMENT_BLOCK;
}
function getUnnormalizedProps(props, callPath = []) {
  if (props && !isString$1(props) && props.type === 14) {
    const callee = props.callee;
    if (!isString$1(callee) && propsHelperSet.has(callee)) {
      return getUnnormalizedProps(props.arguments[0], callPath.concat(props));
    }
  }
  return [props, callPath];
}
function injectProp(node, prop, context) {
  let propsWithInjection;
  let props = node.type === 13 ? node.props : node.arguments[2];
  let callPath = [];
  let parentCall;
  if (props && !isString$1(props) && props.type === 14) {
    const ret = getUnnormalizedProps(props);
    props = ret[0];
    callPath = ret[1];
    parentCall = callPath[callPath.length - 1];
  }
  if (props == null || isString$1(props)) {
    propsWithInjection = createObjectExpression([prop]);
  } else if (props.type === 14) {
    const first = props.arguments[0];
    if (!isString$1(first) && first.type === 15) {
      first.properties.unshift(prop);
    } else {
      if (props.callee === TO_HANDLERS) {
        propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [
          createObjectExpression([prop]),
          props,
        ]);
      } else {
        props.arguments.unshift(createObjectExpression([prop]));
      }
    }
    !propsWithInjection && (propsWithInjection = props);
  } else if (props.type === 15) {
    let alreadyExists = false;
    if (prop.key.type === 4) {
      const propKeyName = prop.key.content;
      alreadyExists = props.properties.some(
        (p) => p.key.type === 4 && p.key.content === propKeyName
      );
    }
    if (!alreadyExists) {
      props.properties.unshift(prop);
    }
    propsWithInjection = props;
  } else {
    propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [
      createObjectExpression([prop]),
      props,
    ]);
    if (parentCall && parentCall.callee === GUARD_REACTIVE_PROPS) {
      parentCall = callPath[callPath.length - 2];
    }
  }
  if (node.type === 13) {
    if (parentCall) {
      parentCall.arguments[0] = propsWithInjection;
    } else {
      node.props = propsWithInjection;
    }
  } else {
    if (parentCall) {
      parentCall.arguments[0] = propsWithInjection;
    } else {
      node.arguments[2] = propsWithInjection;
    }
  }
}
function toValidAssetId(name, type) {
  return `_${type}_${name.replace(/[^\w]/g, (searchValue, replaceValue) => {
    return searchValue === "-" ? "_" : name.charCodeAt(replaceValue).toString();
  })}`;
}
function hasScopeRef(node, ids) {
  if (!node || Object.keys(ids).length === 0) {
    return false;
  }
  switch (node.type) {
    case 1:
      for (let i = 0; i < node.props.length; i++) {
        const p = node.props[i];
        if (
          p.type === 7 &&
          (hasScopeRef(p.arg, ids) || hasScopeRef(p.exp, ids))
        ) {
          return true;
        }
      }
      return node.children.some((c) => hasScopeRef(c, ids));
    case 11:
      if (hasScopeRef(node.source, ids)) {
        return true;
      }
      return node.children.some((c) => hasScopeRef(c, ids));
    case 9:
      return node.branches.some((b) => hasScopeRef(b, ids));
    case 10:
      if (hasScopeRef(node.condition, ids)) {
        return true;
      }
      return node.children.some((c) => hasScopeRef(c, ids));
    case 4:
      return (
        !node.isStatic &&
        isSimpleIdentifier(node.content) &&
        !!ids[node.content]
      );
    case 8:
      return node.children.some((c) => isObject$f(c) && hasScopeRef(c, ids));
    case 5:
    case 12:
      return hasScopeRef(node.content, ids);
    case 2:
    case 3:
      return false;
    default:
      return false;
  }
}
function getMemoedVNodeCall(node) {
  if (node.type === 14 && node.callee === WITH_MEMO) {
    return node.arguments[1].returns;
  } else {
    return node;
  }
}
function makeBlock(node, { helper, removeHelper, inSSR }) {
  if (!node.isBlock) {
    node.isBlock = true;
    removeHelper(getVNodeHelper(inSSR, node.isComponent));
    helper(OPEN_BLOCK);
    helper(getVNodeBlockHelper(inSSR, node.isComponent));
  }
}
function getCompatValue(key, context) {
  const config = context.options
    ? context.options.compatConfig
    : context.compatConfig;
  const value = config && config[key];
  if (key === "MODE") {
    return value || 3;
  } else {
    return value;
  }
}
function isCompatEnabled(key, context) {
  const mode = getCompatValue("MODE", context);
  const value = getCompatValue(key, context);
  return mode === 3 ? value === true : value !== false;
}
function checkCompatEnabled(key, context, loc, ...args) {
  const enabled = isCompatEnabled(key, context);
  return enabled;
}
function warnDeprecation(key, context, loc, ...args) {
  const val = getCompatValue(key, context);
  if (val === "suppress-warning") {
    return;
  }
  const { message, link } = deprecationData[key];
  const msg = `(deprecation ${key}) ${
    typeof message === "function" ? message(...args) : message
  }${
    link
      ? `
  Details: ${link}`
      : ``
  }`;
  const err = new SyntaxError(msg);
  err.code = key;
  if (loc) err.loc = loc;
  context.onWarn(err);
}
function baseParse(content, options = {}) {
  const context = createParserContext(content, options);
  const start = getCursor(context);
  return createRoot(
    parseChildren(context, 0, []),
    getSelection(context, start)
  );
}
function createParserContext(content, rawOptions) {
  const options = extend({}, defaultParserOptions);
  let key;
  for (key in rawOptions) {
    options[key] =
      rawOptions[key] === void 0 ? defaultParserOptions[key] : rawOptions[key];
  }
  return {
    options,
    column: 1,
    line: 1,
    offset: 0,
    originalSource: content,
    source: content,
    inPre: false,
    inVPre: false,
    onWarn: options.onWarn,
  };
}
function parseChildren(context, mode, ancestors) {
  const parent = last$3(ancestors);
  const ns = parent ? parent.ns : 0;
  const nodes = [];
  while (!isEnd(context, mode, ancestors)) {
    const s = context.source;
    let node = void 0;
    if (mode === 0 || mode === 1) {
      if (!context.inVPre && startsWith(s, context.options.delimiters[0])) {
        node = parseInterpolation(context, mode);
      } else if (mode === 0 && s[0] === "<") {
        if (s.length === 1) {
          emitError(context, 5, 1);
        } else if (s[1] === "!") {
          if (startsWith(s, "<!--")) {
            node = parseComment(context);
          } else if (startsWith(s, "<!DOCTYPE")) {
            node = parseBogusComment(context);
          } else if (startsWith(s, "<![CDATA[")) {
            if (ns !== 0) {
              node = parseCDATA(context, ancestors);
            } else {
              emitError(
                context,
                1
                /* CDATA_IN_HTML_CONTENT */
              );
              node = parseBogusComment(context);
            }
          } else {
            emitError(
              context,
              11
              /* INCORRECTLY_OPENED_COMMENT */
            );
            node = parseBogusComment(context);
          }
        } else if (s[1] === "/") {
          if (s.length === 2) {
            emitError(context, 5, 2);
          } else if (s[2] === ">") {
            emitError(context, 14, 2);
            advanceBy(context, 3);
            continue;
          } else if (/[a-z]/i.test(s[2])) {
            emitError(
              context,
              23
              /* X_INVALID_END_TAG */
            );
            parseTag(context, 1, parent);
            continue;
          } else {
            emitError(context, 12, 2);
            node = parseBogusComment(context);
          }
        } else if (/[a-z]/i.test(s[1])) {
          node = parseElement(context, ancestors);
          if (
            isCompatEnabled("COMPILER_NATIVE_TEMPLATE", context) &&
            node &&
            node.tag === "template" &&
            !node.props.some(
              (p) => p.type === 7 && isSpecialTemplateDirective(p.name)
            )
          ) {
            node = node.children;
          }
        } else if (s[1] === "?") {
          emitError(context, 21, 1);
          node = parseBogusComment(context);
        } else {
          emitError(context, 12, 1);
        }
      }
    }
    if (!node) {
      node = parseText(context, mode);
    }
    if (isArray(node)) {
      for (let i = 0; i < node.length; i++) {
        pushNode(nodes, node[i]);
      }
    } else {
      pushNode(nodes, node);
    }
  }
  let removedWhitespace = false;
  if (mode !== 2 && mode !== 1) {
    const shouldCondense = context.options.whitespace !== "preserve";
    for (let i = 0; i < nodes.length; i++) {
      const node = nodes[i];
      if (!context.inPre && node.type === 2) {
        if (!/[^\t\r\n\f ]/.test(node.content)) {
          const prev = nodes[i - 1];
          const next = nodes[i + 1];
          if (
            !prev ||
            !next ||
            (shouldCondense &&
              (prev.type === 3 ||
                next.type === 3 ||
                (prev.type === 1 &&
                  next.type === 1 &&
                  /[\r\n]/.test(node.content))))
          ) {
            removedWhitespace = true;
            nodes[i] = null;
          } else {
            node.content = " ";
          }
        } else if (shouldCondense) {
          node.content = node.content.replace(/[\t\r\n\f ]+/g, " ");
        }
      } else if (node.type === 3 && !context.options.comments) {
        removedWhitespace = true;
        nodes[i] = null;
      }
    }
    if (context.inPre && parent && context.options.isPreTag(parent.tag)) {
      const first = nodes[0];
      if (first && first.type === 2) {
        first.content = first.content.replace(/^\r?\n/, "");
      }
    }
  }
  return removedWhitespace ? nodes.filter(Boolean) : nodes;
}
function pushNode(nodes, node) {
  if (node.type === 2) {
    const prev = last$3(nodes);
    if (
      prev &&
      prev.type === 2 &&
      prev.loc.end.offset === node.loc.start.offset
    ) {
      prev.content += node.content;
      prev.loc.end = node.loc.end;
      prev.loc.source += node.loc.source;
      return;
    }
  }
  nodes.push(node);
}
function parseCDATA(context, ancestors) {
  advanceBy(context, 9);
  const nodes = parseChildren(context, 3, ancestors);
  if (context.source.length === 0) {
    emitError(
      context,
      6
      /* EOF_IN_CDATA */
    );
  } else {
    advanceBy(context, 3);
  }
  return nodes;
}
function parseComment(context) {
  const start = getCursor(context);
  let content;
  const match = /--(\!)?>/.exec(context.source);
  if (!match) {
    content = context.source.slice(4);
    advanceBy(context, context.source.length);
    emitError(
      context,
      7
      /* EOF_IN_COMMENT */
    );
  } else {
    if (match.index <= 3) {
      emitError(
        context,
        0
        /* ABRUPT_CLOSING_OF_EMPTY_COMMENT */
      );
    }
    if (match[1]) {
      emitError(
        context,
        10
        /* INCORRECTLY_CLOSED_COMMENT */
      );
    }
    content = context.source.slice(4, match.index);
    const s = context.source.slice(0, match.index);
    let prevIndex = 1,
      nestedIndex = 0;
    while ((nestedIndex = s.indexOf("<!--", prevIndex)) !== -1) {
      advanceBy(context, nestedIndex - prevIndex + 1);
      if (nestedIndex + 4 < s.length) {
        emitError(
          context,
          16
          /* NESTED_COMMENT */
        );
      }
      prevIndex = nestedIndex + 1;
    }
    advanceBy(context, match.index + match[0].length - prevIndex + 1);
  }
  return {
    type: 3,
    content,
    loc: getSelection(context, start),
  };
}
function parseBogusComment(context) {
  const start = getCursor(context);
  const contentStart = context.source[1] === "?" ? 1 : 2;
  let content;
  const closeIndex = context.source.indexOf(">");
  if (closeIndex === -1) {
    content = context.source.slice(contentStart);
    advanceBy(context, context.source.length);
  } else {
    content = context.source.slice(contentStart, closeIndex);
    advanceBy(context, closeIndex + 1);
  }
  return {
    type: 3,
    content,
    loc: getSelection(context, start),
  };
}
function parseElement(context, ancestors) {
  const wasInPre = context.inPre;
  const wasInVPre = context.inVPre;
  const parent = last$3(ancestors);
  const element = parseTag(context, 0, parent);
  const isPreBoundary = context.inPre && !wasInPre;
  const isVPreBoundary = context.inVPre && !wasInVPre;
  if (element.isSelfClosing || context.options.isVoidTag(element.tag)) {
    if (isPreBoundary) {
      context.inPre = false;
    }
    if (isVPreBoundary) {
      context.inVPre = false;
    }
    return element;
  }
  ancestors.push(element);
  const mode = context.options.getTextMode(element, parent);
  const children = parseChildren(context, mode, ancestors);
  ancestors.pop();
  {
    const inlineTemplateProp = element.props.find(
      (p) => p.type === 6 && p.name === "inline-template"
    );
    if (
      inlineTemplateProp &&
      checkCompatEnabled(
        "COMPILER_INLINE_TEMPLATE",
        context,
        inlineTemplateProp.loc
      )
    ) {
      const loc = getSelection(context, element.loc.end);
      inlineTemplateProp.value = {
        type: 2,
        content: loc.source,
        loc,
      };
    }
  }
  element.children = children;
  if (startsWithEndTagOpen(context.source, element.tag)) {
    parseTag(context, 1, parent);
  } else {
    emitError(context, 24, 0, element.loc.start);
    if (context.source.length === 0 && element.tag.toLowerCase() === "script") {
      const first = children[0];
      if (first && startsWith(first.loc.source, "<!--")) {
        emitError(
          context,
          8
          /* EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT */
        );
      }
    }
  }
  element.loc = getSelection(context, element.loc.start);
  if (isPreBoundary) {
    context.inPre = false;
  }
  if (isVPreBoundary) {
    context.inVPre = false;
  }
  return element;
}
function parseTag(context, type, parent) {
  const start = getCursor(context);
  const match = /^<\/?([a-z][^\t\r\n\f />]*)/i.exec(context.source);
  const tag = match[1];
  const ns = context.options.getNamespace(tag, parent);
  advanceBy(context, match[0].length);
  advanceSpaces(context);
  const cursor = getCursor(context);
  const currentSource = context.source;
  if (context.options.isPreTag(tag)) {
    context.inPre = true;
  }
  let props = parseAttributes(context, type);
  if (
    type === 0 &&
    !context.inVPre &&
    props.some((p) => p.type === 7 && p.name === "pre")
  ) {
    context.inVPre = true;
    extend(context, cursor);
    context.source = currentSource;
    props = parseAttributes(context, type).filter((p) => p.name !== "v-pre");
  }
  let isSelfClosing = false;
  if (context.source.length === 0) {
    emitError(
      context,
      9
      /* EOF_IN_TAG */
    );
  } else {
    isSelfClosing = startsWith(context.source, "/>");
    if (type === 1 && isSelfClosing) {
      emitError(
        context,
        4
        /* END_TAG_WITH_TRAILING_SOLIDUS */
      );
    }
    advanceBy(context, isSelfClosing ? 2 : 1);
  }
  if (type === 1) {
    return;
  }
  let tagType = 0;
  if (!context.inVPre) {
    if (tag === "slot") {
      tagType = 2;
    } else if (tag === "template") {
      if (
        props.some((p) => p.type === 7 && isSpecialTemplateDirective(p.name))
      ) {
        tagType = 3;
      }
    } else if (isComponent(tag, props, context)) {
      tagType = 1;
    }
  }
  return {
    type: 1,
    ns,
    tag,
    tagType,
    props,
    isSelfClosing,
    children: [],
    loc: getSelection(context, start),
    codegenNode: void 0,
    // to be created during transform phase
  };
}
function isComponent(tag, props, context) {
  const options = context.options;
  if (options.isCustomElement(tag)) {
    return false;
  }
  if (
    tag === "component" ||
    /^[A-Z]/.test(tag) ||
    isCoreComponent(tag) ||
    (options.isBuiltInComponent && options.isBuiltInComponent(tag)) ||
    (options.isNativeTag && !options.isNativeTag(tag))
  ) {
    return true;
  }
  for (let i = 0; i < props.length; i++) {
    const p = props[i];
    if (p.type === 6) {
      if (p.name === "is" && p.value) {
        if (p.value.content.startsWith("vue:")) {
          return true;
        } else if (
          checkCompatEnabled("COMPILER_IS_ON_ELEMENT", context, p.loc)
        ) {
          return true;
        }
      }
    } else {
      if (p.name === "is") {
        return true;
      } else if (
        // :is on plain element - only treat as component in compat mode
        p.name === "bind" &&
        isStaticArgOf(p.arg, "is") &&
        true &&
        checkCompatEnabled("COMPILER_IS_ON_ELEMENT", context, p.loc)
      ) {
        return true;
      }
    }
  }
}
function parseAttributes(context, type) {
  const props = [];
  const attributeNames = /* @__PURE__ */ new Set();
  while (
    context.source.length > 0 &&
    !startsWith(context.source, ">") &&
    !startsWith(context.source, "/>")
  ) {
    if (startsWith(context.source, "/")) {
      emitError(
        context,
        22
        /* UNEXPECTED_SOLIDUS_IN_TAG */
      );
      advanceBy(context, 1);
      advanceSpaces(context);
      continue;
    }
    if (type === 1) {
      emitError(
        context,
        3
        /* END_TAG_WITH_ATTRIBUTES */
      );
    }
    const attr = parseAttribute(context, attributeNames);
    if (attr.type === 6 && attr.value && attr.name === "class") {
      attr.value.content = attr.value.content.replace(/\s+/g, " ").trim();
    }
    if (type === 0) {
      props.push(attr);
    }
    if (/^[^\t\r\n\f />]/.test(context.source)) {
      emitError(
        context,
        15
        /* MISSING_WHITESPACE_BETWEEN_ATTRIBUTES */
      );
    }
    advanceSpaces(context);
  }
  return props;
}
function parseAttribute(context, nameSet) {
  const start = getCursor(context);
  const match = /^[^\t\r\n\f />][^\t\r\n\f />=]*/.exec(context.source);
  const name = match[0];
  if (nameSet.has(name)) {
    emitError(
      context,
      2
      /* DUPLICATE_ATTRIBUTE */
    );
  }
  nameSet.add(name);
  if (name[0] === "=") {
    emitError(
      context,
      19
      /* UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME */
    );
  }
  {
    const pattern = /["'<]/g;
    let m;
    while ((m = pattern.exec(name))) {
      emitError(context, 17, m.index);
    }
  }
  advanceBy(context, name.length);
  let value = void 0;
  if (/^[\t\r\n\f ]*=/.test(context.source)) {
    advanceSpaces(context);
    advanceBy(context, 1);
    advanceSpaces(context);
    value = parseAttributeValue(context);
    if (!value) {
      emitError(
        context,
        13
        /* MISSING_ATTRIBUTE_VALUE */
      );
    }
  }
  const loc = getSelection(context, start);
  if (!context.inVPre && /^(v-[A-Za-z0-9-]|:|\.|@|#)/.test(name)) {
    const match2 =
      /(?:^v-([a-z0-9-]+))?(?:(?::|^\.|^@|^#)(\[[^\]]+\]|[^\.]+))?(.+)?$/i.exec(
        name
      );
    let isPropShorthand = startsWith(name, ".");
    let dirName =
      match2[1] ||
      (isPropShorthand || startsWith(name, ":")
        ? "bind"
        : startsWith(name, "@")
        ? "on"
        : "slot");
    let arg;
    if (match2[2]) {
      const isSlot = dirName === "slot";
      const startOffset = name.lastIndexOf(match2[2]);
      const loc2 = getSelection(
        context,
        getNewPosition(context, start, startOffset),
        getNewPosition(
          context,
          start,
          startOffset + match2[2].length + ((isSlot && match2[3]) || "").length
        )
      );
      let content = match2[2];
      let isStatic = true;
      if (content.startsWith("[")) {
        isStatic = false;
        if (!content.endsWith("]")) {
          emitError(
            context,
            27
            /* X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END */
          );
          content = content.slice(1);
        } else {
          content = content.slice(1, content.length - 1);
        }
      } else if (isSlot) {
        content += match2[3] || "";
      }
      arg = {
        type: 4,
        content,
        isStatic,
        constType: isStatic ? 3 : 0,
        loc: loc2,
      };
    }
    if (value && value.isQuoted) {
      const valueLoc = value.loc;
      valueLoc.start.offset++;
      valueLoc.start.column++;
      valueLoc.end = advancePositionWithClone(valueLoc.start, value.content);
      valueLoc.source = valueLoc.source.slice(1, -1);
    }
    const modifiers = match2[3] ? match2[3].slice(1).split(".") : [];
    if (isPropShorthand) modifiers.push("prop");
    if (dirName === "bind" && arg) {
      if (
        modifiers.includes("sync") &&
        checkCompatEnabled("COMPILER_V_BIND_SYNC", context, loc, arg.loc.source)
      ) {
        dirName = "model";
        modifiers.splice(modifiers.indexOf("sync"), 1);
      }
    }
    return {
      type: 7,
      name: dirName,
      exp: value && {
        type: 4,
        content: value.content,
        isStatic: false,
        // Treat as non-constant by default. This can be potentially set to
        // other values by `transformExpression` to make it eligible for hoisting.
        constType: 0,
        loc: value.loc,
      },
      arg,
      modifiers,
      loc,
    };
  }
  if (!context.inVPre && startsWith(name, "v-")) {
    emitError(
      context,
      26
      /* X_MISSING_DIRECTIVE_NAME */
    );
  }
  return {
    type: 6,
    name,
    value: value && {
      type: 2,
      content: value.content,
      loc: value.loc,
    },
    loc,
  };
}
function parseAttributeValue(context) {
  const start = getCursor(context);
  let content;
  const quote = context.source[0];
  const isQuoted = quote === `"` || quote === `'`;
  if (isQuoted) {
    advanceBy(context, 1);
    const endIndex = context.source.indexOf(quote);
    if (endIndex === -1) {
      content = parseTextData(
        context,
        context.source.length,
        4
        /* ATTRIBUTE_VALUE */
      );
    } else {
      content = parseTextData(
        context,
        endIndex,
        4
        /* ATTRIBUTE_VALUE */
      );
      advanceBy(context, 1);
    }
  } else {
    const match = /^[^\t\r\n\f >]+/.exec(context.source);
    if (!match) {
      return void 0;
    }
    const unexpectedChars = /["'<=`]/g;
    let m;
    while ((m = unexpectedChars.exec(match[0]))) {
      emitError(context, 18, m.index);
    }
    content = parseTextData(
      context,
      match[0].length,
      4
      /* ATTRIBUTE_VALUE */
    );
  }
  return { content, isQuoted, loc: getSelection(context, start) };
}
function parseInterpolation(context, mode) {
  const [open, close] = context.options.delimiters;
  const closeIndex = context.source.indexOf(close, open.length);
  if (closeIndex === -1) {
    emitError(
      context,
      25
      /* X_MISSING_INTERPOLATION_END */
    );
    return void 0;
  }
  const start = getCursor(context);
  advanceBy(context, open.length);
  const innerStart = getCursor(context);
  const innerEnd = getCursor(context);
  const rawContentLength = closeIndex - open.length;
  const rawContent = context.source.slice(0, rawContentLength);
  const preTrimContent = parseTextData(context, rawContentLength, mode);
  const content = preTrimContent.trim();
  const startOffset = preTrimContent.indexOf(content);
  if (startOffset > 0) {
    advancePositionWithMutation(innerStart, rawContent, startOffset);
  }
  const endOffset =
    rawContentLength - (preTrimContent.length - content.length - startOffset);
  advancePositionWithMutation(innerEnd, rawContent, endOffset);
  advanceBy(context, close.length);
  return {
    type: 5,
    content: {
      type: 4,
      isStatic: false,
      // Set `isConstant` to false by default and will decide in transformExpression
      constType: 0,
      content,
      loc: getSelection(context, innerStart, innerEnd),
    },
    loc: getSelection(context, start),
  };
}
function parseText(context, mode) {
  const endTokens = mode === 3 ? ["]]>"] : ["<", context.options.delimiters[0]];
  let endIndex = context.source.length;
  for (let i = 0; i < endTokens.length; i++) {
    const index = context.source.indexOf(endTokens[i], 1);
    if (index !== -1 && endIndex > index) {
      endIndex = index;
    }
  }
  const start = getCursor(context);
  const content = parseTextData(context, endIndex, mode);
  return {
    type: 2,
    content,
    loc: getSelection(context, start),
  };
}
function parseTextData(context, length, mode) {
  const rawText = context.source.slice(0, length);
  advanceBy(context, length);
  if (mode === 2 || mode === 3 || !rawText.includes("&")) {
    return rawText;
  } else {
    return context.options.decodeEntities(
      rawText,
      mode === 4
      /* ATTRIBUTE_VALUE */
    );
  }
}
function getCursor(context) {
  const { column, line, offset } = context;
  return { column, line, offset };
}
function getSelection(context, start, end) {
  end = end || getCursor(context);
  return {
    start,
    end,
    source: context.originalSource.slice(start.offset, end.offset),
  };
}
function last$3(xs) {
  return xs[xs.length - 1];
}
function startsWith(source, searchString) {
  return source.startsWith(searchString);
}
function advanceBy(context, numberOfCharacters) {
  const { source } = context;
  advancePositionWithMutation(context, source, numberOfCharacters);
  context.source = source.slice(numberOfCharacters);
}
function advanceSpaces(context) {
  const match = /^[\t\r\n\f ]+/.exec(context.source);
  if (match) {
    advanceBy(context, match[0].length);
  }
}
function getNewPosition(context, start, numberOfCharacters) {
  return advancePositionWithClone(
    start,
    context.originalSource.slice(start.offset, numberOfCharacters),
    numberOfCharacters
  );
}
function emitError(context, code, offset, loc = getCursor(context)) {
  if (offset) {
    loc.offset += offset;
    loc.column += offset;
  }
  context.options.onError(
    createCompilerError(code, {
      start: loc,
      end: loc,
      source: "",
    })
  );
}
function isEnd(context, mode, ancestors) {
  const s = context.source;
  switch (mode) {
    case 0:
      if (startsWith(s, "</")) {
        for (let i = ancestors.length - 1; i >= 0; --i) {
          if (startsWithEndTagOpen(s, ancestors[i].tag)) {
            return true;
          }
        }
      }
      break;
    case 1:
    case 2: {
      const parent = last$3(ancestors);
      if (parent && startsWithEndTagOpen(s, parent.tag)) {
        return true;
      }
      break;
    }
    case 3:
      if (startsWith(s, "]]>")) {
        return true;
      }
      break;
  }
  return !s;
}
function startsWithEndTagOpen(source, tag) {
  return (
    startsWith(source, "</") &&
    source.slice(2, 2 + tag.length).toLowerCase() === tag.toLowerCase() &&
    /[\t\r\n\f />]/.test(source[2 + tag.length] || ">")
  );
}
function hoistStatic(root, context) {
  walk(
    root,
    context,
    // Root node is unfortunately non-hoistable due to potential parent
    // fallthrough attributes.
    isSingleElementRoot(root, root.children[0])
  );
}
function isSingleElementRoot(root, child) {
  const { children } = root;
  return children.length === 1 && child.type === 1 && !isSlotOutlet(child);
}
function walk(node, context, doNotHoistNode = false) {
  const { children } = node;
  const originalCount = children.length;
  let hoistedCount = 0;
  for (let i = 0; i < children.length; i++) {
    const child = children[i];
    if (child.type === 1 && child.tagType === 0) {
      const constantType = doNotHoistNode ? 0 : getConstantType(child, context);
      if (constantType > 0) {
        if (constantType >= 2) {
          child.codegenNode.patchFlag = -1 + ``;
          child.codegenNode = context.hoist(child.codegenNode);
          hoistedCount++;
          continue;
        }
      } else {
        const codegenNode = child.codegenNode;
        if (codegenNode.type === 13) {
          const flag = getPatchFlag(codegenNode);
          if (
            (!flag || flag === 512 || flag === 1) &&
            getGeneratedPropsConstantType(child, context) >= 2
          ) {
            const props = getNodeProps(child);
            if (props) {
              codegenNode.props = context.hoist(props);
            }
          }
          if (codegenNode.dynamicProps) {
            codegenNode.dynamicProps = context.hoist(codegenNode.dynamicProps);
          }
        }
      }
    } else if (
      child.type === 12 &&
      getConstantType(child.content, context) >= 2
    ) {
      child.codegenNode = context.hoist(child.codegenNode);
      hoistedCount++;
    }
    if (child.type === 1) {
      const isComponent2 = child.tagType === 1;
      if (isComponent2) {
        context.scopes.vSlot++;
      }
      walk(child, context);
      if (isComponent2) {
        context.scopes.vSlot--;
      }
    } else if (child.type === 11) {
      walk(child, context, child.children.length === 1);
    } else if (child.type === 9) {
      for (let i2 = 0; i2 < child.branches.length; i2++) {
        walk(
          child.branches[i2],
          context,
          child.branches[i2].children.length === 1
        );
      }
    }
  }
  if (hoistedCount && context.transformHoist) {
    context.transformHoist(children, context, node);
  }
  if (
    hoistedCount &&
    hoistedCount === originalCount &&
    node.type === 1 &&
    node.tagType === 0 &&
    node.codegenNode &&
    node.codegenNode.type === 13 &&
    isArray(node.codegenNode.children)
  ) {
    node.codegenNode.children = context.hoist(
      createArrayExpression(node.codegenNode.children)
    );
  }
}
function getConstantType(node, context) {
  const { constantCache } = context;
  switch (node.type) {
    case 1:
      if (node.tagType !== 0) {
        return 0;
      }
      const cached = constantCache.get(node);
      if (cached !== void 0) {
        return cached;
      }
      const codegenNode = node.codegenNode;
      if (codegenNode.type !== 13) {
        return 0;
      }
      if (
        codegenNode.isBlock &&
        node.tag !== "svg" &&
        node.tag !== "foreignObject"
      ) {
        return 0;
      }
      const flag = getPatchFlag(codegenNode);
      if (!flag) {
        let returnType2 = 3;
        const generatedPropsType = getGeneratedPropsConstantType(node, context);
        if (generatedPropsType === 0) {
          constantCache.set(
            node,
            0
            /* NOT_CONSTANT */
          );
          return 0;
        }
        if (generatedPropsType < returnType2) {
          returnType2 = generatedPropsType;
        }
        for (let i = 0; i < node.children.length; i++) {
          const childType = getConstantType(node.children[i], context);
          if (childType === 0) {
            constantCache.set(
              node,
              0
              /* NOT_CONSTANT */
            );
            return 0;
          }
          if (childType < returnType2) {
            returnType2 = childType;
          }
        }
        if (returnType2 > 1) {
          for (let i = 0; i < node.props.length; i++) {
            const p = node.props[i];
            if (p.type === 7 && p.name === "bind" && p.exp) {
              const expType = getConstantType(p.exp, context);
              if (expType === 0) {
                constantCache.set(
                  node,
                  0
                  /* NOT_CONSTANT */
                );
                return 0;
              }
              if (expType < returnType2) {
                returnType2 = expType;
              }
            }
          }
        }
        if (codegenNode.isBlock) {
          context.removeHelper(OPEN_BLOCK);
          context.removeHelper(
            getVNodeBlockHelper(context.inSSR, codegenNode.isComponent)
          );
          codegenNode.isBlock = false;
          context.helper(
            getVNodeHelper(context.inSSR, codegenNode.isComponent)
          );
        }
        constantCache.set(node, returnType2);
        return returnType2;
      } else {
        constantCache.set(
          node,
          0
          /* NOT_CONSTANT */
        );
        return 0;
      }
    case 2:
    case 3:
      return 3;
    case 9:
    case 11:
    case 10:
      return 0;
    case 5:
    case 12:
      return getConstantType(node.content, context);
    case 4:
      return node.constType;
    case 8:
      let returnType = 3;
      for (let i = 0; i < node.children.length; i++) {
        const child = node.children[i];
        if (isString$1(child) || isSymbol$6(child)) {
          continue;
        }
        const childType = getConstantType(child, context);
        if (childType === 0) {
          return 0;
        } else if (childType < returnType) {
          returnType = childType;
        }
      }
      return returnType;
    default:
      return 0;
  }
}
function getConstantTypeOfHelperCall(value, context) {
  if (
    value.type === 14 &&
    !isString$1(value.callee) &&
    allowHoistedHelperSet.has(value.callee)
  ) {
    const arg = value.arguments[0];
    if (arg.type === 4) {
      return getConstantType(arg, context);
    } else if (arg.type === 14) {
      return getConstantTypeOfHelperCall(arg, context);
    }
  }
  return 0;
}
function getGeneratedPropsConstantType(node, context) {
  let returnType = 3;
  const props = getNodeProps(node);
  if (props && props.type === 15) {
    const { properties } = props;
    for (let i = 0; i < properties.length; i++) {
      const { key, value } = properties[i];
      const keyType = getConstantType(key, context);
      if (keyType === 0) {
        return keyType;
      }
      if (keyType < returnType) {
        returnType = keyType;
      }
      let valueType;
      if (value.type === 4) {
        valueType = getConstantType(value, context);
      } else if (value.type === 14) {
        valueType = getConstantTypeOfHelperCall(value, context);
      } else {
        valueType = 0;
      }
      if (valueType === 0) {
        return valueType;
      }
      if (valueType < returnType) {
        returnType = valueType;
      }
    }
  }
  return returnType;
}
function getNodeProps(node) {
  const codegenNode = node.codegenNode;
  if (codegenNode.type === 13) {
    return codegenNode.props;
  }
}
function getPatchFlag(node) {
  const flag = node.patchFlag;
  return flag ? parseInt(flag, 10) : void 0;
}
function createTransformContext(
  root,
  {
    filename = "",
    prefixIdentifiers = false,
    hoistStatic: hoistStatic2 = false,
    cacheHandlers = false,
    nodeTransforms = [],
    directiveTransforms = {},
    transformHoist = null,
    isBuiltInComponent = NOOP,
    isCustomElement = NOOP,
    expressionPlugins = [],
    scopeId = null,
    slotted = true,
    ssr = false,
    inSSR = false,
    ssrCssVars = ``,
    bindingMetadata = EMPTY_OBJ,
    inline = false,
    isTS = false,
    onError = defaultOnError,
    onWarn = defaultOnWarn,
    compatConfig,
  }
) {
  const nameMatch = filename.replace(/\?.*$/, "").match(/([^/\\]+)\.\w+$/);
  const context = {
    // options
    selfName: nameMatch && capitalize(camelize(nameMatch[1])),
    prefixIdentifiers,
    hoistStatic: hoistStatic2,
    cacheHandlers,
    nodeTransforms,
    directiveTransforms,
    transformHoist,
    isBuiltInComponent,
    isCustomElement,
    expressionPlugins,
    scopeId,
    slotted,
    ssr,
    inSSR,
    ssrCssVars,
    bindingMetadata,
    inline,
    isTS,
    onError,
    onWarn,
    compatConfig,
    // state
    root,
    helpers: /* @__PURE__ */ new Map(),
    components: /* @__PURE__ */ new Set(),
    directives: /* @__PURE__ */ new Set(),
    hoists: [],
    imports: [],
    constantCache: /* @__PURE__ */ new Map(),
    temps: 0,
    cached: 0,
    identifiers: /* @__PURE__ */ Object.create(null),
    scopes: {
      vFor: 0,
      vSlot: 0,
      vPre: 0,
      vOnce: 0,
    },
    parent: null,
    currentNode: root,
    childIndex: 0,
    inVOnce: false,
    // methods
    helper(name) {
      const count = context.helpers.get(name) || 0;
      context.helpers.set(name, count + 1);
      return name;
    },
    removeHelper(name) {
      const count = context.helpers.get(name);
      if (count) {
        const currentCount = count - 1;
        if (!currentCount) {
          context.helpers.delete(name);
        } else {
          context.helpers.set(name, currentCount);
        }
      }
    },
    helperString(name) {
      return `_${helperNameMap[context.helper(name)]}`;
    },
    replaceNode(node) {
      context.parent.children[context.childIndex] = context.currentNode = node;
    },
    removeNode(node) {
      const list = context.parent.children;
      const removalIndex = node
        ? list.indexOf(node)
        : context.currentNode
        ? context.childIndex
        : -1;
      if (!node || node === context.currentNode) {
        context.currentNode = null;
        context.onNodeRemoved();
      } else {
        if (context.childIndex > removalIndex) {
          context.childIndex--;
          context.onNodeRemoved();
        }
      }
      context.parent.children.splice(removalIndex, 1);
    },
    onNodeRemoved: () => {},
    addIdentifiers(exp) {},
    removeIdentifiers(exp) {},
    hoist(exp) {
      if (isString$1(exp)) exp = createSimpleExpression(exp);
      context.hoists.push(exp);
      const identifier = createSimpleExpression(
        `_hoisted_${context.hoists.length}`,
        false,
        exp.loc,
        2
        /* CAN_HOIST */
      );
      identifier.hoisted = exp;
      return identifier;
    },
    cache(exp, isVNode = false) {
      return createCacheExpression(context.cached++, exp, isVNode);
    },
  };
  {
    context.filters = /* @__PURE__ */ new Set();
  }
  return context;
}
function transform(root, options) {
  const context = createTransformContext(root, options);
  traverseNode(root, context);
  if (options.hoistStatic) {
    hoistStatic(root, context);
  }
  if (!options.ssr) {
    createRootCodegen(root, context);
  }
  root.helpers = [...context.helpers.keys()];
  root.components = [...context.components];
  root.directives = [...context.directives];
  root.imports = context.imports;
  root.hoists = context.hoists;
  root.temps = context.temps;
  root.cached = context.cached;
  {
    root.filters = [...context.filters];
  }
}
function createRootCodegen(root, context) {
  const { helper } = context;
  const { children } = root;
  if (children.length === 1) {
    const child = children[0];
    if (isSingleElementRoot(root, child) && child.codegenNode) {
      const codegenNode = child.codegenNode;
      if (codegenNode.type === 13) {
        makeBlock(codegenNode, context);
      }
      root.codegenNode = codegenNode;
    } else {
      root.codegenNode = child;
    }
  } else if (children.length > 1) {
    let patchFlag = 64;
    PatchFlagNames[64];
    /* STABLE_FRAGMENT */
    root.codegenNode = createVNodeCall(
      context,
      helper(FRAGMENT),
      void 0,
      root.children,
      patchFlag + ``,
      void 0,
      void 0,
      true,
      void 0,
      false
      /* isComponent */
    );
  } else;
}
function traverseChildren(parent, context) {
  let i = 0;
  const nodeRemoved = () => {
    i--;
  };
  for (; i < parent.children.length; i++) {
    const child = parent.children[i];
    if (isString$1(child)) continue;
    context.parent = parent;
    context.childIndex = i;
    context.onNodeRemoved = nodeRemoved;
    traverseNode(child, context);
  }
}
function traverseNode(node, context) {
  context.currentNode = node;
  const { nodeTransforms } = context;
  const exitFns = [];
  for (let i2 = 0; i2 < nodeTransforms.length; i2++) {
    const onExit = nodeTransforms[i2](node, context);
    if (onExit) {
      if (isArray(onExit)) {
        exitFns.push(...onExit);
      } else {
        exitFns.push(onExit);
      }
    }
    if (!context.currentNode) {
      return;
    } else {
      node = context.currentNode;
    }
  }
  switch (node.type) {
    case 3:
      if (!context.ssr) {
        context.helper(CREATE_COMMENT);
      }
      break;
    case 5:
      if (!context.ssr) {
        context.helper(TO_DISPLAY_STRING);
      }
      break;
    case 9:
      for (let i2 = 0; i2 < node.branches.length; i2++) {
        traverseNode(node.branches[i2], context);
      }
      break;
    case 10:
    case 11:
    case 1:
    case 0:
      traverseChildren(node, context);
      break;
  }
  context.currentNode = node;
  let i = exitFns.length;
  while (i--) {
    exitFns[i]();
  }
}
function createStructuralDirectiveTransform(name, fn) {
  const matches = isString$1(name) ? (n) => n === name : (n) => name.test(n);
  return (node, context) => {
    if (node.type === 1) {
      const { props } = node;
      if (node.tagType === 3 && props.some(isVSlot)) {
        return;
      }
      const exitFns = [];
      for (let i = 0; i < props.length; i++) {
        const prop = props[i];
        if (prop.type === 7 && matches(prop.name)) {
          props.splice(i, 1);
          i--;
          const onExit = fn(node, prop, context);
          if (onExit) exitFns.push(onExit);
        }
      }
      return exitFns;
    }
  };
}
function createCodegenContext(
  ast,
  {
    mode = "function",
    prefixIdentifiers = mode === "module",
    sourceMap = false,
    filename = `template.vue.html`,
    scopeId = null,
    optimizeImports = false,
    runtimeGlobalName = `Vue`,
    runtimeModuleName = `vue`,
    ssrRuntimeModuleName = "vue/server-renderer",
    ssr = false,
    isTS = false,
    inSSR = false,
  }
) {
  const context = {
    mode,
    prefixIdentifiers,
    sourceMap,
    filename,
    scopeId,
    optimizeImports,
    runtimeGlobalName,
    runtimeModuleName,
    ssrRuntimeModuleName,
    ssr,
    isTS,
    inSSR,
    source: ast.loc.source,
    code: ``,
    column: 1,
    line: 1,
    offset: 0,
    indentLevel: 0,
    pure: false,
    map: void 0,
    helper(key) {
      return `_${helperNameMap[key]}`;
    },
    push(code, node) {
      context.code += code;
    },
    indent() {
      newline(++context.indentLevel);
    },
    deindent(withoutNewLine = false) {
      if (withoutNewLine) {
        --context.indentLevel;
      } else {
        newline(--context.indentLevel);
      }
    },
    newline() {
      newline(context.indentLevel);
    },
  };
  function newline(n) {
    context.push("\n" + `  `.repeat(n));
  }
  return context;
}
function generate(ast, options = {}) {
  const context = createCodegenContext(ast, options);
  if (options.onContextCreated) options.onContextCreated(context);
  const {
    mode,
    push,
    prefixIdentifiers,
    indent,
    deindent,
    newline,
    scopeId,
    ssr,
  } = context;
  const hasHelpers = ast.helpers.length > 0;
  const useWithBlock = !prefixIdentifiers && mode !== "module";
  const preambleContext = context;
  {
    genFunctionPreamble(ast, preambleContext);
  }
  const functionName = ssr ? `ssrRender` : `render`;
  const args = ssr
    ? ["_ctx", "_push", "_parent", "_attrs"]
    : ["_ctx", "_cache"];
  const signature = args.join(", ");
  {
    push(`function ${functionName}(${signature}) {`);
  }
  indent();
  if (useWithBlock) {
    push(`with (_ctx) {`);
    indent();
    if (hasHelpers) {
      push(
        `const { ${ast.helpers
          .map((s) => `${helperNameMap[s]}: _${helperNameMap[s]}`)
          .join(", ")} } = _Vue`
      );
      push(`
`);
      newline();
    }
  }
  if (ast.components.length) {
    genAssets(ast.components, "component", context);
    if (ast.directives.length || ast.temps > 0) {
      newline();
    }
  }
  if (ast.directives.length) {
    genAssets(ast.directives, "directive", context);
    if (ast.temps > 0) {
      newline();
    }
  }
  if (ast.filters && ast.filters.length) {
    newline();
    genAssets(ast.filters, "filter", context);
    newline();
  }
  if (ast.temps > 0) {
    push(`let `);
    for (let i = 0; i < ast.temps; i++) {
      push(`${i > 0 ? `, ` : ``}_temp${i}`);
    }
  }
  if (ast.components.length || ast.directives.length || ast.temps) {
    push(`
`);
    newline();
  }
  if (!ssr) {
    push(`return `);
  }
  if (ast.codegenNode) {
    genNode(ast.codegenNode, context);
  } else {
    push(`null`);
  }
  if (useWithBlock) {
    deindent();
    push(`}`);
  }
  deindent();
  push(`}`);
  return {
    ast,
    code: context.code,
    preamble: ``,
    // SourceMapGenerator does have toJSON() method but it's not in the types
    map: context.map ? context.map.toJSON() : void 0,
  };
}
function genFunctionPreamble(ast, context) {
  const {
    ssr,
    prefixIdentifiers,
    push,
    newline,
    runtimeModuleName,
    runtimeGlobalName,
    ssrRuntimeModuleName,
  } = context;
  const VueBinding = runtimeGlobalName;
  const aliasHelper = (s) => `${helperNameMap[s]}: _${helperNameMap[s]}`;
  if (ast.helpers.length > 0) {
    {
      push(`const _Vue = ${VueBinding}
`);
      if (ast.hoists.length) {
        const staticHelpers = [
          CREATE_VNODE,
          CREATE_ELEMENT_VNODE,
          CREATE_COMMENT,
          CREATE_TEXT,
          CREATE_STATIC,
        ]
          .filter((helper) => ast.helpers.includes(helper))
          .map(aliasHelper)
          .join(", ");
        push(`const { ${staticHelpers} } = _Vue
`);
      }
    }
  }
  genHoists(ast.hoists, context);
  newline();
  push(`return `);
}
function genAssets(assets, type, { helper, push, newline, isTS }) {
  const resolver = helper(
    type === "filter"
      ? RESOLVE_FILTER
      : type === "component"
      ? RESOLVE_COMPONENT
      : RESOLVE_DIRECTIVE
  );
  for (let i = 0; i < assets.length; i++) {
    let id = assets[i];
    const maybeSelfReference = id.endsWith("__self");
    if (maybeSelfReference) {
      id = id.slice(0, -6);
    }
    push(
      `const ${toValidAssetId(id, type)} = ${resolver}(${JSON.stringify(id)}${
        maybeSelfReference ? `, true` : ``
      })${isTS ? `!` : ``}`
    );
    if (i < assets.length - 1) {
      newline();
    }
  }
}
function genHoists(hoists, context) {
  if (!hoists.length) {
    return;
  }
  context.pure = true;
  const { push, newline, helper, scopeId, mode } = context;
  newline();
  for (let i = 0; i < hoists.length; i++) {
    const exp = hoists[i];
    if (exp) {
      push(`const _hoisted_${i + 1} = ${``}`);
      genNode(exp, context);
      newline();
    }
  }
  context.pure = false;
}
function genNodeListAsArray(nodes, context) {
  const multilines = nodes.length > 3 || "production" !== "production";
  context.push(`[`);
  multilines && context.indent();
  genNodeList(nodes, context, multilines);
  multilines && context.deindent();
  context.push(`]`);
}
function genNodeList(nodes, context, multilines = false, comma = true) {
  const { push, newline } = context;
  for (let i = 0; i < nodes.length; i++) {
    const node = nodes[i];
    if (isString$1(node)) {
      push(node);
    } else if (isArray(node)) {
      genNodeListAsArray(node, context);
    } else {
      genNode(node, context);
    }
    if (i < nodes.length - 1) {
      if (multilines) {
        comma && push(",");
        newline();
      } else {
        comma && push(", ");
      }
    }
  }
}
function genNode(node, context) {
  if (isString$1(node)) {
    context.push(node);
    return;
  }
  if (isSymbol$6(node)) {
    context.push(context.helper(node));
    return;
  }
  switch (node.type) {
    case 1:
    case 9:
    case 11:
      genNode(node.codegenNode, context);
      break;
    case 2:
      genText(node, context);
      break;
    case 4:
      genExpression(node, context);
      break;
    case 5:
      genInterpolation(node, context);
      break;
    case 12:
      genNode(node.codegenNode, context);
      break;
    case 8:
      genCompoundExpression(node, context);
      break;
    case 3:
      genComment(node, context);
      break;
    case 13:
      genVNodeCall(node, context);
      break;
    case 14:
      genCallExpression(node, context);
      break;
    case 15:
      genObjectExpression(node, context);
      break;
    case 17:
      genArrayExpression(node, context);
      break;
    case 18:
      genFunctionExpression(node, context);
      break;
    case 19:
      genConditionalExpression(node, context);
      break;
    case 20:
      genCacheExpression(node, context);
      break;
    case 21:
      genNodeList(node.body, context, true, false);
      break;
  }
}
function genText(node, context) {
  context.push(JSON.stringify(node.content), node);
}
function genExpression(node, context) {
  const { content, isStatic } = node;
  context.push(isStatic ? JSON.stringify(content) : content, node);
}
function genInterpolation(node, context) {
  const { push, helper, pure } = context;
  if (pure) push(PURE_ANNOTATION);
  push(`${helper(TO_DISPLAY_STRING)}(`);
  genNode(node.content, context);
  push(`)`);
}
function genCompoundExpression(node, context) {
  for (let i = 0; i < node.children.length; i++) {
    const child = node.children[i];
    if (isString$1(child)) {
      context.push(child);
    } else {
      genNode(child, context);
    }
  }
}
function genExpressionAsPropertyKey(node, context) {
  const { push } = context;
  if (node.type === 8) {
    push(`[`);
    genCompoundExpression(node, context);
    push(`]`);
  } else if (node.isStatic) {
    const text = isSimpleIdentifier(node.content)
      ? node.content
      : JSON.stringify(node.content);
    push(text, node);
  } else {
    push(`[${node.content}]`, node);
  }
}
function genComment(node, context) {
  const { push, helper, pure } = context;
  if (pure) {
    push(PURE_ANNOTATION);
  }
  push(`${helper(CREATE_COMMENT)}(${JSON.stringify(node.content)})`, node);
}
function genVNodeCall(node, context) {
  const { push, helper, pure } = context;
  const {
    tag,
    props,
    children,
    patchFlag,
    dynamicProps,
    directives,
    isBlock,
    disableTracking,
    isComponent: isComponent2,
  } = node;
  if (directives) {
    push(helper(WITH_DIRECTIVES) + `(`);
  }
  if (isBlock) {
    push(`(${helper(OPEN_BLOCK)}(${disableTracking ? `true` : ``}), `);
  }
  if (pure) {
    push(PURE_ANNOTATION);
  }
  const callHelper = isBlock
    ? getVNodeBlockHelper(context.inSSR, isComponent2)
    : getVNodeHelper(context.inSSR, isComponent2);
  push(helper(callHelper) + `(`, node);
  genNodeList(
    genNullableArgs([tag, props, children, patchFlag, dynamicProps]),
    context
  );
  push(`)`);
  if (isBlock) {
    push(`)`);
  }
  if (directives) {
    push(`, `);
    genNode(directives, context);
    push(`)`);
  }
}
function genNullableArgs(args) {
  let i = args.length;
  while (i--) {
    if (args[i] != null) break;
  }
  return args.slice(0, i + 1).map((arg) => arg || `null`);
}
function genCallExpression(node, context) {
  const { push, helper, pure } = context;
  const callee = isString$1(node.callee) ? node.callee : helper(node.callee);
  if (pure) {
    push(PURE_ANNOTATION);
  }
  push(callee + `(`, node);
  genNodeList(node.arguments, context);
  push(`)`);
}
function genObjectExpression(node, context) {
  const { push, indent, deindent, newline } = context;
  const { properties } = node;
  if (!properties.length) {
    push(`{}`, node);
    return;
  }
  const multilines = properties.length > 1 || "production" !== "production";
  push(multilines ? `{` : `{ `);
  multilines && indent();
  for (let i = 0; i < properties.length; i++) {
    const { key, value } = properties[i];
    genExpressionAsPropertyKey(key, context);
    push(`: `);
    genNode(value, context);
    if (i < properties.length - 1) {
      push(`,`);
      newline();
    }
  }
  multilines && deindent();
  push(multilines ? `}` : ` }`);
}
function genArrayExpression(node, context) {
  genNodeListAsArray(node.elements, context);
}
function genFunctionExpression(node, context) {
  const { push, indent, deindent } = context;
  const { params, returns, body, newline, isSlot } = node;
  if (isSlot) {
    push(`_${helperNameMap[WITH_CTX]}(`);
  }
  push(`(`, node);
  if (isArray(params)) {
    genNodeList(params, context);
  } else if (params) {
    genNode(params, context);
  }
  push(`) => `);
  if (newline || body) {
    push(`{`);
    indent();
  }
  if (returns) {
    if (newline) {
      push(`return `);
    }
    if (isArray(returns)) {
      genNodeListAsArray(returns, context);
    } else {
      genNode(returns, context);
    }
  } else if (body) {
    genNode(body, context);
  }
  if (newline || body) {
    deindent();
    push(`}`);
  }
  if (isSlot) {
    if (node.isNonScopedSlot) {
      push(`, undefined, true`);
    }
    push(`)`);
  }
}
function genConditionalExpression(node, context) {
  const { test, consequent, alternate, newline: needNewline } = node;
  const { push, indent, deindent, newline } = context;
  if (test.type === 4) {
    const needsParens = !isSimpleIdentifier(test.content);
    needsParens && push(`(`);
    genExpression(test, context);
    needsParens && push(`)`);
  } else {
    push(`(`);
    genNode(test, context);
    push(`)`);
  }
  needNewline && indent();
  context.indentLevel++;
  needNewline || push(` `);
  push(`? `);
  genNode(consequent, context);
  context.indentLevel--;
  needNewline && newline();
  needNewline || push(` `);
  push(`: `);
  const isNested = alternate.type === 19;
  if (!isNested) {
    context.indentLevel++;
  }
  genNode(alternate, context);
  if (!isNested) {
    context.indentLevel--;
  }
  needNewline &&
    deindent(
      true
      /* without newline */
    );
}
function genCacheExpression(node, context) {
  const { push, helper, indent, deindent, newline } = context;
  push(`_cache[${node.index}] || (`);
  if (node.isVNode) {
    indent();
    push(`${helper(SET_BLOCK_TRACKING)}(-1),`);
    newline();
  }
  push(`_cache[${node.index}] = `);
  genNode(node.value, context);
  if (node.isVNode) {
    push(`,`);
    newline();
    push(`${helper(SET_BLOCK_TRACKING)}(1),`);
    newline();
    push(`_cache[${node.index}]`);
    deindent();
  }
  push(`)`);
}
function walkIdentifiers(
  root,
  onIdentifier,
  includeAll = false,
  parentStack = [],
  knownIds = /* @__PURE__ */ Object.create(null)
) {
  {
    return;
  }
}
function isReferencedIdentifier(id, parent, parentStack) {
  {
    return false;
  }
}
function isInDestructureAssignment(parent, parentStack) {
  if (
    parent &&
    (parent.type === "ObjectProperty" || parent.type === "ArrayPattern")
  ) {
    let i = parentStack.length;
    while (i--) {
      const p = parentStack[i];
      if (p.type === "AssignmentExpression") {
        return true;
      } else if (p.type !== "ObjectProperty" && !p.type.endsWith("Pattern")) {
        break;
      }
    }
  }
  return false;
}
function walkFunctionParams(node, onIdent) {
  for (const p of node.params) {
    for (const id of extractIdentifiers(p)) {
      onIdent(id);
    }
  }
}
function walkBlockDeclarations(block, onIdent) {
  for (const stmt of block.body) {
    if (stmt.type === "VariableDeclaration") {
      if (stmt.declare) continue;
      for (const decl of stmt.declarations) {
        for (const id of extractIdentifiers(decl.id)) {
          onIdent(id);
        }
      }
    } else if (
      stmt.type === "FunctionDeclaration" ||
      stmt.type === "ClassDeclaration"
    ) {
      if (stmt.declare || !stmt.id) continue;
      onIdent(stmt.id);
    }
  }
}
function extractIdentifiers(param, nodes = []) {
  switch (param.type) {
    case "Identifier":
      nodes.push(param);
      break;
    case "MemberExpression":
      let object = param;
      while (object.type === "MemberExpression") {
        object = object.object;
      }
      nodes.push(object);
      break;
    case "ObjectPattern":
      for (const prop of param.properties) {
        if (prop.type === "RestElement") {
          extractIdentifiers(prop.argument, nodes);
        } else {
          extractIdentifiers(prop.value, nodes);
        }
      }
      break;
    case "ArrayPattern":
      param.elements.forEach((element) => {
        if (element) extractIdentifiers(element, nodes);
      });
      break;
    case "RestElement":
      extractIdentifiers(param.argument, nodes);
      break;
    case "AssignmentPattern":
      extractIdentifiers(param.left, nodes);
      break;
  }
  return nodes;
}
function processExpression(
  node,
  context,
  asParams = false,
  asRawStatements = false,
  localVars = Object.create(context.identifiers)
) {
  {
    return node;
  }
}
function processIf(node, dir, context, processCodegen) {
  if (dir.name !== "else" && (!dir.exp || !dir.exp.content.trim())) {
    const loc = dir.exp ? dir.exp.loc : node.loc;
    context.onError(createCompilerError(28, dir.loc));
    dir.exp = createSimpleExpression(`true`, false, loc);
  }
  if (dir.name === "if") {
    const branch = createIfBranch(node, dir);
    const ifNode = {
      type: 9,
      loc: node.loc,
      branches: [branch],
    };
    context.replaceNode(ifNode);
    if (processCodegen) {
      return processCodegen(ifNode, branch, true);
    }
  } else {
    const siblings = context.parent.children;
    let i = siblings.indexOf(node);
    while (i-- >= -1) {
      const sibling = siblings[i];
      if (sibling && sibling.type === 2 && !sibling.content.trim().length) {
        context.removeNode(sibling);
        continue;
      }
      if (sibling && sibling.type === 9) {
        if (
          dir.name === "else-if" &&
          sibling.branches[sibling.branches.length - 1].condition === void 0
        ) {
          context.onError(createCompilerError(30, node.loc));
        }
        context.removeNode();
        const branch = createIfBranch(node, dir);
        sibling.branches.push(branch);
        const onExit = processCodegen && processCodegen(sibling, branch, false);
        traverseNode(branch, context);
        if (onExit) onExit();
        context.currentNode = null;
      } else {
        context.onError(createCompilerError(30, node.loc));
      }
      break;
    }
  }
}
function createIfBranch(node, dir) {
  return {
    type: 10,
    loc: node.loc,
    condition: dir.name === "else" ? void 0 : dir.exp,
    children:
      node.tagType === 3 && !findDir(node, "for") ? node.children : [node],
    userKey: findProp(node, `key`),
  };
}
function createCodegenNodeForBranch(branch, keyIndex, context) {
  if (branch.condition) {
    return createConditionalExpression(
      branch.condition,
      createChildrenCodegenNode(branch, keyIndex, context),
      // make sure to pass in asBlock: true so that the comment node call
      // closes the current block.
      createCallExpression(context.helper(CREATE_COMMENT), ['""', "true"])
    );
  } else {
    return createChildrenCodegenNode(branch, keyIndex, context);
  }
}
function createChildrenCodegenNode(branch, keyIndex, context) {
  const { helper } = context;
  const keyProperty = createObjectProperty(
    `key`,
    createSimpleExpression(
      `${keyIndex}`,
      false,
      locStub,
      2
      /* CAN_HOIST */
    )
  );
  const { children } = branch;
  const firstChild = children[0];
  const needFragmentWrapper = children.length !== 1 || firstChild.type !== 1;
  if (needFragmentWrapper) {
    if (children.length === 1 && firstChild.type === 11) {
      const vnodeCall = firstChild.codegenNode;
      injectProp(vnodeCall, keyProperty, context);
      return vnodeCall;
    } else {
      let patchFlag = 64;
      PatchFlagNames[64];
      /* STABLE_FRAGMENT */
      return createVNodeCall(
        context,
        helper(FRAGMENT),
        createObjectExpression([keyProperty]),
        children,
        patchFlag + ``,
        void 0,
        void 0,
        true,
        false,
        false,
        branch.loc
      );
    }
  } else {
    const ret = firstChild.codegenNode;
    const vnodeCall = getMemoedVNodeCall(ret);
    if (vnodeCall.type === 13) {
      makeBlock(vnodeCall, context);
    }
    injectProp(vnodeCall, keyProperty, context);
    return ret;
  }
}
function getParentCondition(node) {
  while (true) {
    if (node.type === 19) {
      if (node.alternate.type === 19) {
        node = node.alternate;
      } else {
        return node;
      }
    } else if (node.type === 20) {
      node = node.value;
    }
  }
}
function processFor(node, dir, context, processCodegen) {
  if (!dir.exp) {
    context.onError(createCompilerError(31, dir.loc));
    return;
  }
  const parseResult = parseForExpression(
    // can only be simple expression because vFor transform is applied
    // before expression transform.
    dir.exp
  );
  if (!parseResult) {
    context.onError(createCompilerError(32, dir.loc));
    return;
  }
  const { addIdentifiers, removeIdentifiers, scopes } = context;
  const { source, value, key, index } = parseResult;
  const forNode = {
    type: 11,
    loc: dir.loc,
    source,
    valueAlias: value,
    keyAlias: key,
    objectIndexAlias: index,
    parseResult,
    children: isTemplateNode(node) ? node.children : [node],
  };
  context.replaceNode(forNode);
  scopes.vFor++;
  const onExit = processCodegen && processCodegen(forNode);
  return () => {
    scopes.vFor--;
    if (onExit) onExit();
  };
}
function parseForExpression(input, context) {
  const loc = input.loc;
  const exp = input.content;
  const inMatch = exp.match(forAliasRE);
  if (!inMatch) return;
  const [, LHS, RHS] = inMatch;
  const result = {
    source: createAliasExpression(
      loc,
      RHS.trim(),
      exp.indexOf(RHS, LHS.length)
    ),
    value: void 0,
    key: void 0,
    index: void 0,
  };
  let valueContent = LHS.trim().replace(stripParensRE, "").trim();
  const trimmedOffset = LHS.indexOf(valueContent);
  const iteratorMatch = valueContent.match(forIteratorRE);
  if (iteratorMatch) {
    valueContent = valueContent.replace(forIteratorRE, "").trim();
    const keyContent = iteratorMatch[1].trim();
    let keyOffset;
    if (keyContent) {
      keyOffset = exp.indexOf(keyContent, trimmedOffset + valueContent.length);
      result.key = createAliasExpression(loc, keyContent, keyOffset);
    }
    if (iteratorMatch[2]) {
      const indexContent = iteratorMatch[2].trim();
      if (indexContent) {
        result.index = createAliasExpression(
          loc,
          indexContent,
          exp.indexOf(
            indexContent,
            result.key
              ? keyOffset + keyContent.length
              : trimmedOffset + valueContent.length
          )
        );
      }
    }
  }
  if (valueContent) {
    result.value = createAliasExpression(loc, valueContent, trimmedOffset);
  }
  return result;
}
function createAliasExpression(range, content, offset) {
  return createSimpleExpression(
    content,
    false,
    getInnerRange(range, offset, content.length)
  );
}
function createForLoopParams({ value, key, index }, memoArgs = []) {
  return createParamsList([value, key, index, ...memoArgs]);
}
function createParamsList(args) {
  let i = args.length;
  while (i--) {
    if (args[i]) break;
  }
  return args
    .slice(0, i + 1)
    .map((arg, i2) => arg || createSimpleExpression(`_`.repeat(i2 + 1), false));
}
function buildSlots(node, context, buildSlotFn = buildClientSlotFn) {
  context.helper(WITH_CTX);
  const { children, loc } = node;
  const slotsProperties = [];
  const dynamicSlots = [];
  let hasDynamicSlots = context.scopes.vSlot > 0 || context.scopes.vFor > 0;
  const onComponentSlot = findDir(node, "slot", true);
  if (onComponentSlot) {
    const { arg, exp } = onComponentSlot;
    if (arg && !isStaticExp(arg)) {
      hasDynamicSlots = true;
    }
    slotsProperties.push(
      createObjectProperty(
        arg || createSimpleExpression("default", true),
        buildSlotFn(exp, children, loc)
      )
    );
  }
  let hasTemplateSlots = false;
  let hasNamedDefaultSlot = false;
  const implicitDefaultChildren = [];
  const seenSlotNames = /* @__PURE__ */ new Set();
  for (let i = 0; i < children.length; i++) {
    const slotElement = children[i];
    let slotDir;
    if (
      !isTemplateNode(slotElement) ||
      !(slotDir = findDir(slotElement, "slot", true))
    ) {
      if (slotElement.type !== 3) {
        implicitDefaultChildren.push(slotElement);
      }
      continue;
    }
    if (onComponentSlot) {
      context.onError(createCompilerError(37, slotDir.loc));
      break;
    }
    hasTemplateSlots = true;
    const { children: slotChildren, loc: slotLoc } = slotElement;
    const {
      arg: slotName = createSimpleExpression(`default`, true),
      exp: slotProps,
      loc: dirLoc,
    } = slotDir;
    let staticSlotName;
    if (isStaticExp(slotName)) {
      staticSlotName = slotName ? slotName.content : `default`;
    } else {
      hasDynamicSlots = true;
    }
    const slotFunction = buildSlotFn(slotProps, slotChildren, slotLoc);
    let vIf;
    let vElse;
    let vFor;
    if ((vIf = findDir(slotElement, "if"))) {
      hasDynamicSlots = true;
      dynamicSlots.push(
        createConditionalExpression(
          vIf.exp,
          buildDynamicSlot(slotName, slotFunction),
          defaultFallback
        )
      );
    } else if (
      (vElse = findDir(
        slotElement,
        /^else(-if)?$/,
        true
        /* allowEmpty */
      ))
    ) {
      let j = i;
      let prev;
      while (j--) {
        prev = children[j];
        if (prev.type !== 3) {
          break;
        }
      }
      if (prev && isTemplateNode(prev) && findDir(prev, "if")) {
        children.splice(i, 1);
        i--;
        let conditional = dynamicSlots[dynamicSlots.length - 1];
        while (conditional.alternate.type === 19) {
          conditional = conditional.alternate;
        }
        conditional.alternate = vElse.exp
          ? createConditionalExpression(
              vElse.exp,
              buildDynamicSlot(slotName, slotFunction),
              defaultFallback
            )
          : buildDynamicSlot(slotName, slotFunction);
      } else {
        context.onError(createCompilerError(30, vElse.loc));
      }
    } else if ((vFor = findDir(slotElement, "for"))) {
      hasDynamicSlots = true;
      const parseResult = vFor.parseResult || parseForExpression(vFor.exp);
      if (parseResult) {
        dynamicSlots.push(
          createCallExpression(context.helper(RENDER_LIST), [
            parseResult.source,
            createFunctionExpression(
              createForLoopParams(parseResult),
              buildDynamicSlot(slotName, slotFunction),
              true
              /* force newline */
            ),
          ])
        );
      } else {
        context.onError(createCompilerError(32, vFor.loc));
      }
    } else {
      if (staticSlotName) {
        if (seenSlotNames.has(staticSlotName)) {
          context.onError(createCompilerError(38, dirLoc));
          continue;
        }
        seenSlotNames.add(staticSlotName);
        if (staticSlotName === "default") {
          hasNamedDefaultSlot = true;
        }
      }
      slotsProperties.push(createObjectProperty(slotName, slotFunction));
    }
  }
  if (!onComponentSlot) {
    const buildDefaultSlotProperty = (props, children2) => {
      const fn = buildSlotFn(props, children2, loc);
      if (context.compatConfig) {
        fn.isNonScopedSlot = true;
      }
      return createObjectProperty(`default`, fn);
    };
    if (!hasTemplateSlots) {
      slotsProperties.push(buildDefaultSlotProperty(void 0, children));
    } else if (
      implicitDefaultChildren.length && // #3766
      // with whitespace: 'preserve', whitespaces between slots will end up in
      // implicitDefaultChildren. Ignore if all implicit children are whitespaces.
      implicitDefaultChildren.some((node2) => isNonWhitespaceContent(node2))
    ) {
      if (hasNamedDefaultSlot) {
        context.onError(
          createCompilerError(39, implicitDefaultChildren[0].loc)
        );
      } else {
        slotsProperties.push(
          buildDefaultSlotProperty(void 0, implicitDefaultChildren)
        );
      }
    }
  }
  const slotFlag = hasDynamicSlots
    ? 2
    : hasForwardedSlots(node.children)
    ? 3
    : 1;
  let slots = createObjectExpression(
    slotsProperties.concat(
      createObjectProperty(
        `_`,
        // 2 = compiled but dynamic = can skip normalization, but must run diff
        // 1 = compiled and static = can skip normalization AND diff as optimized
        createSimpleExpression(slotFlag + ``, false)
      )
    ),
    loc
  );
  if (dynamicSlots.length) {
    slots = createCallExpression(context.helper(CREATE_SLOTS), [
      slots,
      createArrayExpression(dynamicSlots),
    ]);
  }
  return {
    slots,
    hasDynamicSlots,
  };
}
function buildDynamicSlot(name, fn) {
  return createObjectExpression([
    createObjectProperty(`name`, name),
    createObjectProperty(`fn`, fn),
  ]);
}
function hasForwardedSlots(children) {
  for (let i = 0; i < children.length; i++) {
    const child = children[i];
    switch (child.type) {
      case 1:
        if (child.tagType === 2 || hasForwardedSlots(child.children)) {
          return true;
        }
        break;
      case 9:
        if (hasForwardedSlots(child.branches)) return true;
        break;
      case 10:
      case 11:
        if (hasForwardedSlots(child.children)) return true;
        break;
    }
  }
  return false;
}
function isNonWhitespaceContent(node) {
  if (node.type !== 2 && node.type !== 12) return true;
  return node.type === 2
    ? !!node.content.trim()
    : isNonWhitespaceContent(node.content);
}
function resolveComponentType(node, context, ssr = false) {
  let { tag } = node;
  const isExplicitDynamic = isComponentTag(tag);
  const isProp = findProp(node, "is");
  if (isProp) {
    if (
      isExplicitDynamic ||
      isCompatEnabled("COMPILER_IS_ON_ELEMENT", context)
    ) {
      const exp =
        isProp.type === 6
          ? isProp.value && createSimpleExpression(isProp.value.content, true)
          : isProp.exp;
      if (exp) {
        return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [
          exp,
        ]);
      }
    } else if (isProp.type === 6 && isProp.value.content.startsWith("vue:")) {
      tag = isProp.value.content.slice(4);
    }
  }
  const isDir = !isExplicitDynamic && findDir(node, "is");
  if (isDir && isDir.exp) {
    return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [
      isDir.exp,
    ]);
  }
  const builtIn = isCoreComponent(tag) || context.isBuiltInComponent(tag);
  if (builtIn) {
    if (!ssr) context.helper(builtIn);
    return builtIn;
  }
  context.helper(RESOLVE_COMPONENT);
  context.components.add(tag);
  return toValidAssetId(tag, `component`);
}
function buildProps(node, context, props = node.props, ssr = false) {
  const { tag, loc: elementLoc, children } = node;
  const isComponent2 = node.tagType === 1;
  let properties = [];
  const mergeArgs = [];
  const runtimeDirectives = [];
  const hasChildren = children.length > 0;
  let shouldUseBlock = false;
  let patchFlag = 0;
  let hasRef = false;
  let hasClassBinding = false;
  let hasStyleBinding = false;
  let hasHydrationEventBinding = false;
  let hasDynamicKeys = false;
  let hasVnodeHook = false;
  const dynamicPropNames = [];
  const analyzePatchFlag = ({ key, value }) => {
    if (isStaticExp(key)) {
      const name = key.content;
      const isEventHandler = isOn(name);
      if (
        !isComponent2 &&
        isEventHandler && // omit the flag for click handlers because hydration gives click
        // dedicated fast path.
        name.toLowerCase() !== "onclick" && // omit v-model handlers
        name !== "onUpdate:modelValue" && // omit onVnodeXXX hooks
        !isReservedProp(name)
      ) {
        hasHydrationEventBinding = true;
      }
      if (isEventHandler && isReservedProp(name)) {
        hasVnodeHook = true;
      }
      if (
        value.type === 20 ||
        ((value.type === 4 || value.type === 8) &&
          getConstantType(value, context) > 0)
      ) {
        return;
      }
      if (name === "ref") {
        hasRef = true;
      } else if (name === "class") {
        hasClassBinding = true;
      } else if (name === "style") {
        hasStyleBinding = true;
      } else if (name !== "key" && !dynamicPropNames.includes(name)) {
        dynamicPropNames.push(name);
      }
      if (
        isComponent2 &&
        (name === "class" || name === "style") &&
        !dynamicPropNames.includes(name)
      ) {
        dynamicPropNames.push(name);
      }
    } else {
      hasDynamicKeys = true;
    }
  };
  for (let i = 0; i < props.length; i++) {
    const prop = props[i];
    if (prop.type === 6) {
      const { loc, name, value } = prop;
      let isStatic = true;
      if (name === "ref") {
        hasRef = true;
        if (context.scopes.vFor > 0) {
          properties.push(
            createObjectProperty(
              createSimpleExpression("ref_for", true),
              createSimpleExpression("true")
            )
          );
        }
      }
      if (
        name === "is" &&
        (isComponentTag(tag) ||
          (value && value.content.startsWith("vue:")) ||
          isCompatEnabled("COMPILER_IS_ON_ELEMENT", context))
      ) {
        continue;
      }
      properties.push(
        createObjectProperty(
          createSimpleExpression(
            name,
            true,
            getInnerRange(loc, 0, name.length)
          ),
          createSimpleExpression(
            value ? value.content : "",
            isStatic,
            value ? value.loc : loc
          )
        )
      );
    } else {
      const { name, arg, exp, loc } = prop;
      const isVBind = name === "bind";
      const isVOn = name === "on";
      if (name === "slot") {
        if (!isComponent2) {
          context.onError(createCompilerError(40, loc));
        }
        continue;
      }
      if (name === "once" || name === "memo") {
        continue;
      }
      if (
        name === "is" ||
        (isVBind &&
          isStaticArgOf(arg, "is") &&
          (isComponentTag(tag) ||
            isCompatEnabled("COMPILER_IS_ON_ELEMENT", context)))
      ) {
        continue;
      }
      if (isVOn && ssr) {
        continue;
      }
      if (
        // #938: elements with dynamic keys should be forced into blocks
        (isVBind && isStaticArgOf(arg, "key")) || // inline before-update hooks need to force block so that it is invoked
        // before children
        (isVOn && hasChildren && isStaticArgOf(arg, "vue:before-update"))
      ) {
        shouldUseBlock = true;
      }
      if (isVBind && isStaticArgOf(arg, "ref") && context.scopes.vFor > 0) {
        properties.push(
          createObjectProperty(
            createSimpleExpression("ref_for", true),
            createSimpleExpression("true")
          )
        );
      }
      if (!arg && (isVBind || isVOn)) {
        hasDynamicKeys = true;
        if (exp) {
          if (properties.length) {
            mergeArgs.push(
              createObjectExpression(dedupeProperties(properties), elementLoc)
            );
            properties = [];
          }
          if (isVBind) {
            {
              if (isCompatEnabled("COMPILER_V_BIND_OBJECT_ORDER", context)) {
                mergeArgs.unshift(exp);
                continue;
              }
            }
            mergeArgs.push(exp);
          } else {
            mergeArgs.push({
              type: 14,
              loc,
              callee: context.helper(TO_HANDLERS),
              arguments: [exp],
            });
          }
        } else {
          context.onError(createCompilerError(isVBind ? 34 : 35, loc));
        }
        continue;
      }
      const directiveTransform = context.directiveTransforms[name];
      if (directiveTransform) {
        const { props: props2, needRuntime } = directiveTransform(
          prop,
          node,
          context
        );
        !ssr && props2.forEach(analyzePatchFlag);
        properties.push(...props2);
        if (needRuntime) {
          runtimeDirectives.push(prop);
          if (isSymbol$6(needRuntime)) {
            directiveImportMap.set(prop, needRuntime);
          }
        }
      } else if (!isBuiltInDirective(name)) {
        runtimeDirectives.push(prop);
        if (hasChildren) {
          shouldUseBlock = true;
        }
      }
    }
  }
  let propsExpression = void 0;
  if (mergeArgs.length) {
    if (properties.length) {
      mergeArgs.push(
        createObjectExpression(dedupeProperties(properties), elementLoc)
      );
    }
    if (mergeArgs.length > 1) {
      propsExpression = createCallExpression(
        context.helper(MERGE_PROPS),
        mergeArgs,
        elementLoc
      );
    } else {
      propsExpression = mergeArgs[0];
    }
  } else if (properties.length) {
    propsExpression = createObjectExpression(
      dedupeProperties(properties),
      elementLoc
    );
  }
  if (hasDynamicKeys) {
    patchFlag |= 16;
  } else {
    if (hasClassBinding && !isComponent2) {
      patchFlag |= 2;
    }
    if (hasStyleBinding && !isComponent2) {
      patchFlag |= 4;
    }
    if (dynamicPropNames.length) {
      patchFlag |= 8;
    }
    if (hasHydrationEventBinding) {
      patchFlag |= 32;
    }
  }
  if (
    !shouldUseBlock &&
    (patchFlag === 0 || patchFlag === 32) &&
    (hasRef || hasVnodeHook || runtimeDirectives.length > 0)
  ) {
    patchFlag |= 512;
  }
  if (!context.inSSR && propsExpression) {
    switch (propsExpression.type) {
      case 15:
        let classKeyIndex = -1;
        let styleKeyIndex = -1;
        let hasDynamicKey = false;
        for (let i = 0; i < propsExpression.properties.length; i++) {
          const key = propsExpression.properties[i].key;
          if (isStaticExp(key)) {
            if (key.content === "class") {
              classKeyIndex = i;
            } else if (key.content === "style") {
              styleKeyIndex = i;
            }
          } else if (!key.isHandlerKey) {
            hasDynamicKey = true;
          }
        }
        const classProp = propsExpression.properties[classKeyIndex];
        const styleProp = propsExpression.properties[styleKeyIndex];
        if (!hasDynamicKey) {
          if (classProp && !isStaticExp(classProp.value)) {
            classProp.value = createCallExpression(
              context.helper(NORMALIZE_CLASS),
              [classProp.value]
            );
          }
          if (
            styleProp &&
            !isStaticExp(styleProp.value) && // the static style is compiled into an object,
            // so use `hasStyleBinding` to ensure that it is a dynamic style binding
            (hasStyleBinding || // v-bind:style and style both exist,
              // v-bind:style with static literal object
              styleProp.value.type === 17)
          ) {
            styleProp.value = createCallExpression(
              context.helper(NORMALIZE_STYLE),
              [styleProp.value]
            );
          }
        } else {
          propsExpression = createCallExpression(
            context.helper(NORMALIZE_PROPS),
            [propsExpression]
          );
        }
        break;
      case 14:
        break;
      default:
        propsExpression = createCallExpression(
          context.helper(NORMALIZE_PROPS),
          [
            createCallExpression(context.helper(GUARD_REACTIVE_PROPS), [
              propsExpression,
            ]),
          ]
        );
        break;
    }
  }
  return {
    props: propsExpression,
    directives: runtimeDirectives,
    patchFlag,
    dynamicPropNames,
    shouldUseBlock,
  };
}
function dedupeProperties(properties) {
  const knownProps = /* @__PURE__ */ new Map();
  const deduped = [];
  for (let i = 0; i < properties.length; i++) {
    const prop = properties[i];
    if (prop.key.type === 8 || !prop.key.isStatic) {
      deduped.push(prop);
      continue;
    }
    const name = prop.key.content;
    const existing = knownProps.get(name);
    if (existing) {
      if (name === "style" || name === "class" || isOn(name)) {
        mergeAsArray(existing, prop);
      }
    } else {
      knownProps.set(name, prop);
      deduped.push(prop);
    }
  }
  return deduped;
}
function mergeAsArray(existing, incoming) {
  if (existing.value.type === 17) {
    existing.value.elements.push(incoming.value);
  } else {
    existing.value = createArrayExpression(
      [existing.value, incoming.value],
      existing.loc
    );
  }
}
function buildDirectiveArgs(dir, context) {
  const dirArgs = [];
  const runtime = directiveImportMap.get(dir);
  if (runtime) {
    dirArgs.push(context.helperString(runtime));
  } else {
    {
      context.helper(RESOLVE_DIRECTIVE);
      context.directives.add(dir.name);
      dirArgs.push(toValidAssetId(dir.name, `directive`));
    }
  }
  const { loc } = dir;
  if (dir.exp) dirArgs.push(dir.exp);
  if (dir.arg) {
    if (!dir.exp) {
      dirArgs.push(`void 0`);
    }
    dirArgs.push(dir.arg);
  }
  if (Object.keys(dir.modifiers).length) {
    if (!dir.arg) {
      if (!dir.exp) {
        dirArgs.push(`void 0`);
      }
      dirArgs.push(`void 0`);
    }
    const trueExpression = createSimpleExpression(`true`, false, loc);
    dirArgs.push(
      createObjectExpression(
        dir.modifiers.map((modifier) =>
          createObjectProperty(modifier, trueExpression)
        ),
        loc
      )
    );
  }
  return createArrayExpression(dirArgs, dir.loc);
}
function stringifyDynamicPropNames(props) {
  let propsNamesString = `[`;
  for (let i = 0, l = props.length; i < l; i++) {
    propsNamesString += JSON.stringify(props[i]);
    if (i < l - 1) propsNamesString += ", ";
  }
  return propsNamesString + `]`;
}
function isComponentTag(tag) {
  return tag === "component" || tag === "Component";
}
function processSlotOutlet(node, context) {
  let slotName = `"default"`;
  let slotProps = void 0;
  const nonNameProps = [];
  for (let i = 0; i < node.props.length; i++) {
    const p = node.props[i];
    if (p.type === 6) {
      if (p.value) {
        if (p.name === "name") {
          slotName = JSON.stringify(p.value.content);
        } else {
          p.name = camelize2(p.name);
          nonNameProps.push(p);
        }
      }
    } else {
      if (p.name === "bind" && isStaticArgOf(p.arg, "name")) {
        if (p.exp) slotName = p.exp;
      } else {
        if (p.name === "bind" && p.arg && isStaticExp(p.arg)) {
          p.arg.content = camelize2(p.arg.content);
        }
        nonNameProps.push(p);
      }
    }
  }
  if (nonNameProps.length > 0) {
    const { props, directives } = buildProps(node, context, nonNameProps);
    slotProps = props;
    if (directives.length) {
      context.onError(createCompilerError(36, directives[0].loc));
    }
  }
  return {
    slotName,
    slotProps,
  };
}
function createTransformProps(props = []) {
  return { props };
}
function rewriteFilter(node, context) {
  if (node.type === 4) {
    parseFilter(node, context);
  } else {
    for (let i = 0; i < node.children.length; i++) {
      const child = node.children[i];
      if (typeof child !== "object") continue;
      if (child.type === 4) {
        parseFilter(child, context);
      } else if (child.type === 8) {
        rewriteFilter(node, context);
      } else if (child.type === 5) {
        rewriteFilter(child.content, context);
      }
    }
  }
}
function parseFilter(node, context) {
  const exp = node.content;
  let inSingle = false;
  let inDouble = false;
  let inTemplateString = false;
  let inRegex = false;
  let curly = 0;
  let square = 0;
  let paren = 0;
  let lastFilterIndex = 0;
  let c,
    prev,
    i,
    expression,
    filters = [];
  for (i = 0; i < exp.length; i++) {
    prev = c;
    c = exp.charCodeAt(i);
    if (inSingle) {
      if (c === 39 && prev !== 92) inSingle = false;
    } else if (inDouble) {
      if (c === 34 && prev !== 92) inDouble = false;
    } else if (inTemplateString) {
      if (c === 96 && prev !== 92) inTemplateString = false;
    } else if (inRegex) {
      if (c === 47 && prev !== 92) inRegex = false;
    } else if (
      c === 124 && // pipe
      exp.charCodeAt(i + 1) !== 124 &&
      exp.charCodeAt(i - 1) !== 124 &&
      !curly &&
      !square &&
      !paren
    ) {
      if (expression === void 0) {
        lastFilterIndex = i + 1;
        expression = exp.slice(0, i).trim();
      } else {
        pushFilter();
      }
    } else {
      switch (c) {
        case 34:
          inDouble = true;
          break;
        case 39:
          inSingle = true;
          break;
        case 96:
          inTemplateString = true;
          break;
        case 40:
          paren++;
          break;
        case 41:
          paren--;
          break;
        case 91:
          square++;
          break;
        case 93:
          square--;
          break;
        case 123:
          curly++;
          break;
        case 125:
          curly--;
          break;
      }
      if (c === 47) {
        let j = i - 1;
        let p;
        for (; j >= 0; j--) {
          p = exp.charAt(j);
          if (p !== " ") break;
        }
        if (!p || !validDivisionCharRE.test(p)) {
          inRegex = true;
        }
      }
    }
  }
  if (expression === void 0) {
    expression = exp.slice(0, i).trim();
  } else if (lastFilterIndex !== 0) {
    pushFilter();
  }
  function pushFilter() {
    filters.push(exp.slice(lastFilterIndex, i).trim());
    lastFilterIndex = i + 1;
  }
  if (filters.length) {
    for (i = 0; i < filters.length; i++) {
      expression = wrapFilter(expression, filters[i], context);
    }
    node.content = expression;
  }
}
function wrapFilter(exp, filter, context) {
  context.helper(RESOLVE_FILTER);
  const i = filter.indexOf("(");
  if (i < 0) {
    context.filters.add(filter);
    return `${toValidAssetId(filter, "filter")}(${exp})`;
  } else {
    const name = filter.slice(0, i);
    const args = filter.slice(i + 1);
    context.filters.add(name);
    return `${toValidAssetId(name, "filter")}(${exp}${
      args !== ")" ? "," + args : args
    }`;
  }
}
function getBaseTransformPreset(prefixIdentifiers) {
  return [
    [
      transformOnce,
      transformIf,
      transformMemo,
      transformFor,
      ...[transformFilter],
      ...[],
      transformSlotOutlet,
      transformElement,
      trackSlotScopes,
      transformText,
    ],
    {
      on: transformOn,
      bind: transformBind,
      model: transformModel,
    },
  ];
}
function baseCompile(template, options = {}) {
  const onError = options.onError || defaultOnError;
  const isModuleMode = options.mode === "module";
  {
    if (options.prefixIdentifiers === true) {
      onError(
        createCompilerError(
          46
          /* X_PREFIX_ID_NOT_SUPPORTED */
        )
      );
    } else if (isModuleMode) {
      onError(
        createCompilerError(
          47
          /* X_MODULE_MODE_NOT_SUPPORTED */
        )
      );
    }
  }
  const prefixIdentifiers = false;
  if (options.cacheHandlers) {
    onError(
      createCompilerError(
        48
        /* X_CACHE_HANDLER_NOT_SUPPORTED */
      )
    );
  }
  if (options.scopeId && !isModuleMode) {
    onError(
      createCompilerError(
        49
        /* X_SCOPE_ID_NOT_SUPPORTED */
      )
    );
  }
  const ast = isString$1(template) ? baseParse(template, options) : template;
  const [nodeTransforms, directiveTransforms] = getBaseTransformPreset();
  transform(
    ast,
    extend({}, options, {
      prefixIdentifiers,
      nodeTransforms: [
        ...nodeTransforms,
        ...(options.nodeTransforms || []),
        // user transforms
      ],
      directiveTransforms: extend(
        {},
        directiveTransforms,
        options.directiveTransforms || {}
        // user transforms
      ),
    })
  );
  return generate(
    ast,
    extend({}, options, {
      prefixIdentifiers,
    })
  );
}
var FRAGMENT,
  TELEPORT,
  SUSPENSE,
  KEEP_ALIVE,
  BASE_TRANSITION,
  OPEN_BLOCK,
  CREATE_BLOCK,
  CREATE_ELEMENT_BLOCK,
  CREATE_VNODE,
  CREATE_ELEMENT_VNODE,
  CREATE_COMMENT,
  CREATE_TEXT,
  CREATE_STATIC,
  RESOLVE_COMPONENT,
  RESOLVE_DYNAMIC_COMPONENT,
  RESOLVE_DIRECTIVE,
  RESOLVE_FILTER,
  WITH_DIRECTIVES,
  RENDER_LIST,
  RENDER_SLOT,
  CREATE_SLOTS,
  TO_DISPLAY_STRING,
  MERGE_PROPS,
  NORMALIZE_CLASS,
  NORMALIZE_STYLE,
  NORMALIZE_PROPS,
  GUARD_REACTIVE_PROPS,
  TO_HANDLERS,
  CAMELIZE,
  CAPITALIZE,
  TO_HANDLER_KEY,
  SET_BLOCK_TRACKING,
  PUSH_SCOPE_ID,
  POP_SCOPE_ID,
  WITH_CTX,
  UNREF,
  IS_REF,
  WITH_MEMO,
  IS_MEMO_SAME,
  helperNameMap,
  locStub,
  isStaticExp,
  isBuiltInType,
  nonIdentifierRE,
  isSimpleIdentifier,
  validFirstIdentCharRE,
  validIdentCharRE,
  whitespaceRE,
  isMemberExpressionBrowser,
  isMemberExpressionNode,
  isMemberExpression,
  propsHelperSet,
  deprecationData,
  decodeRE,
  decodeMap,
  defaultParserOptions,
  isSpecialTemplateDirective,
  allowHoistedHelperSet,
  PURE_ANNOTATION,
  isFunctionType,
  isStaticProperty,
  isStaticPropertyKey,
  transformExpression,
  transformIf,
  transformFor,
  forAliasRE,
  forIteratorRE,
  stripParensRE,
  defaultFallback,
  trackSlotScopes,
  trackVForSlotScopes,
  buildClientSlotFn,
  directiveImportMap,
  transformElement,
  cacheStringFunction,
  camelizeRE,
  camelize2,
  transformSlotOutlet,
  fnExpRE,
  transformOn,
  transformBind,
  injectPrefix,
  transformText,
  seen,
  transformOnce,
  transformModel,
  validDivisionCharRE,
  transformFilter,
  seen$1,
  transformMemo,
  noopDirectiveTransform;
var init_compiler_core_esm_bundler = __esm({
  "node_modules/@vue/compiler-core/dist/compiler-core.esm-bundler.js"() {
    init_shared_esm_bundler();
    init_shared_esm_bundler();
    FRAGMENT = Symbol(``);
    TELEPORT = Symbol(``);
    SUSPENSE = Symbol(``);
    KEEP_ALIVE = Symbol(``);
    BASE_TRANSITION = Symbol(``);
    OPEN_BLOCK = Symbol(``);
    CREATE_BLOCK = Symbol(``);
    CREATE_ELEMENT_BLOCK = Symbol(``);
    CREATE_VNODE = Symbol(``);
    CREATE_ELEMENT_VNODE = Symbol(``);
    CREATE_COMMENT = Symbol(``);
    CREATE_TEXT = Symbol(``);
    CREATE_STATIC = Symbol(``);
    RESOLVE_COMPONENT = Symbol(``);
    RESOLVE_DYNAMIC_COMPONENT = Symbol(``);
    RESOLVE_DIRECTIVE = Symbol(``);
    RESOLVE_FILTER = Symbol(``);
    WITH_DIRECTIVES = Symbol(``);
    RENDER_LIST = Symbol(``);
    RENDER_SLOT = Symbol(``);
    CREATE_SLOTS = Symbol(``);
    TO_DISPLAY_STRING = Symbol(``);
    MERGE_PROPS = Symbol(``);
    NORMALIZE_CLASS = Symbol(``);
    NORMALIZE_STYLE = Symbol(``);
    NORMALIZE_PROPS = Symbol(``);
    GUARD_REACTIVE_PROPS = Symbol(``);
    TO_HANDLERS = Symbol(``);
    CAMELIZE = Symbol(``);
    CAPITALIZE = Symbol(``);
    TO_HANDLER_KEY = Symbol(``);
    SET_BLOCK_TRACKING = Symbol(``);
    PUSH_SCOPE_ID = Symbol(``);
    POP_SCOPE_ID = Symbol(``);
    WITH_CTX = Symbol(``);
    UNREF = Symbol(``);
    IS_REF = Symbol(``);
    WITH_MEMO = Symbol(``);
    IS_MEMO_SAME = Symbol(``);
    helperNameMap = {
      [FRAGMENT]: `Fragment`,
      [TELEPORT]: `Teleport`,
      [SUSPENSE]: `Suspense`,
      [KEEP_ALIVE]: `KeepAlive`,
      [BASE_TRANSITION]: `BaseTransition`,
      [OPEN_BLOCK]: `openBlock`,
      [CREATE_BLOCK]: `createBlock`,
      [CREATE_ELEMENT_BLOCK]: `createElementBlock`,
      [CREATE_VNODE]: `createVNode`,
      [CREATE_ELEMENT_VNODE]: `createElementVNode`,
      [CREATE_COMMENT]: `createCommentVNode`,
      [CREATE_TEXT]: `createTextVNode`,
      [CREATE_STATIC]: `createStaticVNode`,
      [RESOLVE_COMPONENT]: `resolveComponent`,
      [RESOLVE_DYNAMIC_COMPONENT]: `resolveDynamicComponent`,
      [RESOLVE_DIRECTIVE]: `resolveDirective`,
      [RESOLVE_FILTER]: `resolveFilter`,
      [WITH_DIRECTIVES]: `withDirectives`,
      [RENDER_LIST]: `renderList`,
      [RENDER_SLOT]: `renderSlot`,
      [CREATE_SLOTS]: `createSlots`,
      [TO_DISPLAY_STRING]: `toDisplayString`,
      [MERGE_PROPS]: `mergeProps`,
      [NORMALIZE_CLASS]: `normalizeClass`,
      [NORMALIZE_STYLE]: `normalizeStyle`,
      [NORMALIZE_PROPS]: `normalizeProps`,
      [GUARD_REACTIVE_PROPS]: `guardReactiveProps`,
      [TO_HANDLERS]: `toHandlers`,
      [CAMELIZE]: `camelize`,
      [CAPITALIZE]: `capitalize`,
      [TO_HANDLER_KEY]: `toHandlerKey`,
      [SET_BLOCK_TRACKING]: `setBlockTracking`,
      [PUSH_SCOPE_ID]: `pushScopeId`,
      [POP_SCOPE_ID]: `popScopeId`,
      [WITH_CTX]: `withCtx`,
      [UNREF]: `unref`,
      [IS_REF]: `isRef`,
      [WITH_MEMO]: `withMemo`,
      [IS_MEMO_SAME]: `isMemoSame`,
    };
    locStub = {
      source: "",
      start: { line: 1, column: 1, offset: 0 },
      end: { line: 1, column: 1, offset: 0 },
    };
    isStaticExp = (p) => p.type === 4 && p.isStatic;
    isBuiltInType = (tag, expected) =>
      tag === expected || tag === hyphenate(expected);
    nonIdentifierRE = /^\d|[^\$\w]/;
    isSimpleIdentifier = (name) => !nonIdentifierRE.test(name);
    validFirstIdentCharRE = /[A-Za-z_$\xA0-\uFFFF]/;
    validIdentCharRE = /[\.\?\w$\xA0-\uFFFF]/;
    whitespaceRE = /\s+[.[]\s*|\s*[.[]\s+/g;
    isMemberExpressionBrowser = (path) => {
      path = path.trim().replace(whitespaceRE, (s) => s.trim());
      let state = 0;
      let stateStack = [];
      let currentOpenBracketCount = 0;
      let currentOpenParensCount = 0;
      let currentStringType = null;
      for (let i = 0; i < path.length; i++) {
        const char = path.charAt(i);
        switch (state) {
          case 0:
            if (char === "[") {
              stateStack.push(state);
              state = 1;
              currentOpenBracketCount++;
            } else if (char === "(") {
              stateStack.push(state);
              state = 2;
              currentOpenParensCount++;
            } else if (
              !(i === 0 ? validFirstIdentCharRE : validIdentCharRE).test(char)
            ) {
              return false;
            }
            break;
          case 1:
            if (char === `'` || char === `"` || char === "`") {
              stateStack.push(state);
              state = 3;
              currentStringType = char;
            } else if (char === `[`) {
              currentOpenBracketCount++;
            } else if (char === `]`) {
              if (!--currentOpenBracketCount) {
                state = stateStack.pop();
              }
            }
            break;
          case 2:
            if (char === `'` || char === `"` || char === "`") {
              stateStack.push(state);
              state = 3;
              currentStringType = char;
            } else if (char === `(`) {
              currentOpenParensCount++;
            } else if (char === `)`) {
              if (i === path.length - 1) {
                return false;
              }
              if (!--currentOpenParensCount) {
                state = stateStack.pop();
              }
            }
            break;
          case 3:
            if (char === currentStringType) {
              state = stateStack.pop();
              currentStringType = null;
            }
            break;
        }
      }
      return !currentOpenBracketCount && !currentOpenParensCount;
    };
    isMemberExpressionNode = NOOP;
    isMemberExpression = isMemberExpressionBrowser;
    propsHelperSet = /* @__PURE__ */ new Set([
      NORMALIZE_PROPS,
      GUARD_REACTIVE_PROPS,
    ]);
    deprecationData = {
      ["COMPILER_IS_ON_ELEMENT"]:
        /* COMPILER_IS_ON_ELEMENT */
        {
          message: `Platform-native elements with "is" prop will no longer be treated as components in Vue 3 unless the "is" value is explicitly prefixed with "vue:".`,
          link: `https://v3-migration.vuejs.org/breaking-changes/custom-elements-interop.html`,
        },
      ["COMPILER_V_BIND_SYNC"]:
        /* COMPILER_V_BIND_SYNC */
        {
          message: (key) =>
            `.sync modifier for v-bind has been removed. Use v-model with argument instead. \`v-bind:${key}.sync\` should be changed to \`v-model:${key}\`.`,
          link: `https://v3-migration.vuejs.org/breaking-changes/v-model.html`,
        },
      ["COMPILER_V_BIND_PROP"]:
        /* COMPILER_V_BIND_PROP */
        {
          message: `.prop modifier for v-bind has been removed and no longer necessary. Vue 3 will automatically set a binding as DOM property when appropriate.`,
        },
      ["COMPILER_V_BIND_OBJECT_ORDER"]:
        /* COMPILER_V_BIND_OBJECT_ORDER */
        {
          message: `v-bind="obj" usage is now order sensitive and behaves like JavaScript object spread: it will now overwrite an existing non-mergeable attribute that appears before v-bind in the case of conflict. To retain 2.x behavior, move v-bind to make it the first attribute. You can also suppress this warning if the usage is intended.`,
          link: `https://v3-migration.vuejs.org/breaking-changes/v-bind.html`,
        },
      ["COMPILER_V_ON_NATIVE"]:
        /* COMPILER_V_ON_NATIVE */
        {
          message: `.native modifier for v-on has been removed as is no longer necessary.`,
          link: `https://v3-migration.vuejs.org/breaking-changes/v-on-native-modifier-removed.html`,
        },
      ["COMPILER_V_IF_V_FOR_PRECEDENCE"]:
        /* COMPILER_V_IF_V_FOR_PRECEDENCE */
        {
          message: `v-if / v-for precedence when used on the same element has changed in Vue 3: v-if now takes higher precedence and will no longer have access to v-for scope variables. It is best to avoid the ambiguity with <template> tags or use a computed property that filters v-for data source.`,
          link: `https://v3-migration.vuejs.org/breaking-changes/v-if-v-for.html`,
        },
      ["COMPILER_NATIVE_TEMPLATE"]:
        /* COMPILER_NATIVE_TEMPLATE */
        {
          message: `<template> with no special directives will render as a native template element instead of its inner content in Vue 3.`,
        },
      ["COMPILER_INLINE_TEMPLATE"]:
        /* COMPILER_INLINE_TEMPLATE */
        {
          message: `"inline-template" has been removed in Vue 3.`,
          link: `https://v3-migration.vuejs.org/breaking-changes/inline-template-attribute.html`,
        },
      ["COMPILER_FILTER"]:
        /* COMPILER_FILTERS */
        {
          message: `filters have been removed in Vue 3. The "|" symbol will be treated as native JavaScript bitwise OR operator. Use method calls or computed properties instead.`,
          link: `https://v3-migration.vuejs.org/breaking-changes/filters.html`,
        },
    };
    decodeRE = /&(gt|lt|amp|apos|quot);/g;
    decodeMap = {
      gt: ">",
      lt: "<",
      amp: "&",
      apos: "'",
      quot: '"',
    };
    defaultParserOptions = {
      delimiters: [`{{`, `}}`],
      getNamespace: () => 0,
      getTextMode: () => 0,
      isVoidTag: NO,
      isPreTag: NO,
      isCustomElement: NO,
      decodeEntities: (rawText) =>
        rawText.replace(decodeRE, (_, p1) => decodeMap[p1]),
      onError: defaultOnError,
      onWarn: defaultOnWarn,
      comments: "production" !== "production",
    };
    isSpecialTemplateDirective = /* @__PURE__ */ makeMap(
      `if,else,else-if,for,slot`
    );
    allowHoistedHelperSet = /* @__PURE__ */ new Set([
      NORMALIZE_CLASS,
      NORMALIZE_STYLE,
      NORMALIZE_PROPS,
      GUARD_REACTIVE_PROPS,
    ]);
    PURE_ANNOTATION = `/*#__PURE__*/`;
    isFunctionType = (node) => {
      return /Function(?:Expression|Declaration)$|Method$/.test(node.type);
    };
    isStaticProperty = (node) =>
      node &&
      (node.type === "ObjectProperty" || node.type === "ObjectMethod") &&
      !node.computed;
    isStaticPropertyKey = (node, parent) =>
      isStaticProperty(parent) && parent.key === node;
    new RegExp(
      "\\b" +
        "do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,super,throw,while,yield,delete,export,import,return,switch,default,extends,finally,continue,debugger,function,arguments,typeof,void"
          .split(",")
          .join("\\b|\\b") +
        "\\b"
    );
    transformExpression = (node, context) => {
      if (node.type === 5) {
        node.content = processExpression(node.content, context);
      } else if (node.type === 1) {
        for (let i = 0; i < node.props.length; i++) {
          const dir = node.props[i];
          if (dir.type === 7 && dir.name !== "for") {
            const exp = dir.exp;
            const arg = dir.arg;
            if (exp && exp.type === 4 && !(dir.name === "on" && arg)) {
              dir.exp = processExpression(
                exp,
                context,
                // slot args must be processed as function params
                dir.name === "slot"
              );
            }
            if (arg && arg.type === 4 && !arg.isStatic) {
              dir.arg = processExpression(arg, context);
            }
          }
        }
      }
    };
    transformIf = createStructuralDirectiveTransform(
      /^(if|else|else-if)$/,
      (node, dir, context) => {
        return processIf(node, dir, context, (ifNode, branch, isRoot) => {
          const siblings = context.parent.children;
          let i = siblings.indexOf(ifNode);
          let key = 0;
          while (i-- >= 0) {
            const sibling = siblings[i];
            if (sibling && sibling.type === 9) {
              key += sibling.branches.length;
            }
          }
          return () => {
            if (isRoot) {
              ifNode.codegenNode = createCodegenNodeForBranch(
                branch,
                key,
                context
              );
            } else {
              const parentCondition = getParentCondition(ifNode.codegenNode);
              parentCondition.alternate = createCodegenNodeForBranch(
                branch,
                key + ifNode.branches.length - 1,
                context
              );
            }
          };
        });
      }
    );
    transformFor = createStructuralDirectiveTransform(
      "for",
      (node, dir, context) => {
        const { helper, removeHelper } = context;
        return processFor(node, dir, context, (forNode) => {
          const renderExp = createCallExpression(helper(RENDER_LIST), [
            forNode.source,
          ]);
          const isTemplate = isTemplateNode(node);
          const memo = findDir(node, "memo");
          const keyProp = findProp(node, `key`);
          const keyExp =
            keyProp &&
            (keyProp.type === 6
              ? createSimpleExpression(keyProp.value.content, true)
              : keyProp.exp);
          const keyProperty = keyProp
            ? createObjectProperty(`key`, keyExp)
            : null;
          const isStableFragment =
            forNode.source.type === 4 && forNode.source.constType > 0;
          const fragmentFlag = isStableFragment ? 64 : keyProp ? 128 : 256;
          forNode.codegenNode = createVNodeCall(
            context,
            helper(FRAGMENT),
            void 0,
            renderExp,
            fragmentFlag + ``,
            void 0,
            void 0,
            true,
            !isStableFragment,
            false,
            node.loc
          );
          return () => {
            let childBlock;
            const { children } = forNode;
            const needFragmentWrapper =
              children.length !== 1 || children[0].type !== 1;
            const slotOutlet = isSlotOutlet(node)
              ? node
              : isTemplate &&
                node.children.length === 1 &&
                isSlotOutlet(node.children[0])
              ? node.children[0]
              : null;
            if (slotOutlet) {
              childBlock = slotOutlet.codegenNode;
              if (isTemplate && keyProperty) {
                injectProp(childBlock, keyProperty, context);
              }
            } else if (needFragmentWrapper) {
              childBlock = createVNodeCall(
                context,
                helper(FRAGMENT),
                keyProperty ? createObjectExpression([keyProperty]) : void 0,
                node.children,
                64 + ``,
                void 0,
                void 0,
                true,
                void 0,
                false
                /* isComponent */
              );
            } else {
              childBlock = children[0].codegenNode;
              if (isTemplate && keyProperty) {
                injectProp(childBlock, keyProperty, context);
              }
              if (childBlock.isBlock !== !isStableFragment) {
                if (childBlock.isBlock) {
                  removeHelper(OPEN_BLOCK);
                  removeHelper(
                    getVNodeBlockHelper(context.inSSR, childBlock.isComponent)
                  );
                } else {
                  removeHelper(
                    getVNodeHelper(context.inSSR, childBlock.isComponent)
                  );
                }
              }
              childBlock.isBlock = !isStableFragment;
              if (childBlock.isBlock) {
                helper(OPEN_BLOCK);
                helper(
                  getVNodeBlockHelper(context.inSSR, childBlock.isComponent)
                );
              } else {
                helper(getVNodeHelper(context.inSSR, childBlock.isComponent));
              }
            }
            if (memo) {
              const loop = createFunctionExpression(
                createForLoopParams(forNode.parseResult, [
                  createSimpleExpression(`_cached`),
                ])
              );
              loop.body = createBlockStatement([
                createCompoundExpression([`const _memo = (`, memo.exp, `)`]),
                createCompoundExpression([
                  `if (_cached`,
                  ...(keyExp ? [` && _cached.key === `, keyExp] : []),
                  ` && ${context.helperString(
                    IS_MEMO_SAME
                  )}(_cached, _memo)) return _cached`,
                ]),
                createCompoundExpression([`const _item = `, childBlock]),
                createSimpleExpression(`_item.memo = _memo`),
                createSimpleExpression(`return _item`),
              ]);
              renderExp.arguments.push(
                loop,
                createSimpleExpression(`_cache`),
                createSimpleExpression(String(context.cached++))
              );
            } else {
              renderExp.arguments.push(
                createFunctionExpression(
                  createForLoopParams(forNode.parseResult),
                  childBlock,
                  true
                  /* force newline */
                )
              );
            }
          };
        });
      }
    );
    forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;
    forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
    stripParensRE = /^\(|\)$/g;
    defaultFallback = createSimpleExpression(`undefined`, false);
    trackSlotScopes = (node, context) => {
      if (node.type === 1 && (node.tagType === 1 || node.tagType === 3)) {
        const vSlot = findDir(node, "slot");
        if (vSlot) {
          vSlot.exp;
          context.scopes.vSlot++;
          return () => {
            context.scopes.vSlot--;
          };
        }
      }
    };
    trackVForSlotScopes = (node, context) => {
      let vFor;
      if (
        isTemplateNode(node) &&
        node.props.some(isVSlot) &&
        (vFor = findDir(node, "for"))
      ) {
        const result = (vFor.parseResult = parseForExpression(vFor.exp));
        if (result) {
          const { value, key, index } = result;
          const { addIdentifiers, removeIdentifiers } = context;
          value && addIdentifiers(value);
          key && addIdentifiers(key);
          index && addIdentifiers(index);
          return () => {
            value && removeIdentifiers(value);
            key && removeIdentifiers(key);
            index && removeIdentifiers(index);
          };
        }
      }
    };
    buildClientSlotFn = (props, children, loc) =>
      createFunctionExpression(
        props,
        children,
        false,
        true,
        children.length ? children[0].loc : loc
      );
    directiveImportMap = /* @__PURE__ */ new WeakMap();
    transformElement = (node, context) => {
      return function postTransformElement() {
        node = context.currentNode;
        if (!(node.type === 1 && (node.tagType === 0 || node.tagType === 1))) {
          return;
        }
        const { tag, props } = node;
        const isComponent2 = node.tagType === 1;
        let vnodeTag = isComponent2
          ? resolveComponentType(node, context)
          : `"${tag}"`;
        const isDynamicComponent =
          isObject$f(vnodeTag) && vnodeTag.callee === RESOLVE_DYNAMIC_COMPONENT;
        let vnodeProps;
        let vnodeChildren;
        let vnodePatchFlag;
        let patchFlag = 0;
        let vnodeDynamicProps;
        let dynamicPropNames;
        let vnodeDirectives;
        let shouldUseBlock =
          // dynamic component may resolve to plain elements
          isDynamicComponent ||
          vnodeTag === TELEPORT ||
          vnodeTag === SUSPENSE ||
          (!isComponent2 && // <svg> and <foreignObject> must be forced into blocks so that block
            // updates inside get proper isSVG flag at runtime. (#639, #643)
            // This is technically web-specific, but splitting the logic out of core
            // leads to too much unnecessary complexity.
            (tag === "svg" || tag === "foreignObject"));
        if (props.length > 0) {
          const propsBuildResult = buildProps(node, context);
          vnodeProps = propsBuildResult.props;
          patchFlag = propsBuildResult.patchFlag;
          dynamicPropNames = propsBuildResult.dynamicPropNames;
          const directives = propsBuildResult.directives;
          vnodeDirectives =
            directives && directives.length
              ? createArrayExpression(
                  directives.map((dir) => buildDirectiveArgs(dir, context))
                )
              : void 0;
          if (propsBuildResult.shouldUseBlock) {
            shouldUseBlock = true;
          }
        }
        if (node.children.length > 0) {
          if (vnodeTag === KEEP_ALIVE) {
            shouldUseBlock = true;
            patchFlag |= 1024;
          }
          const shouldBuildAsSlots =
            isComponent2 && // Teleport is not a real component and has dedicated runtime handling
            vnodeTag !== TELEPORT && // explained above.
            vnodeTag !== KEEP_ALIVE;
          if (shouldBuildAsSlots) {
            const { slots, hasDynamicSlots } = buildSlots(node, context);
            vnodeChildren = slots;
            if (hasDynamicSlots) {
              patchFlag |= 1024;
            }
          } else if (node.children.length === 1 && vnodeTag !== TELEPORT) {
            const child = node.children[0];
            const type = child.type;
            const hasDynamicTextChild = type === 5 || type === 8;
            if (hasDynamicTextChild && getConstantType(child, context) === 0) {
              patchFlag |= 1;
            }
            if (hasDynamicTextChild || type === 2) {
              vnodeChildren = child;
            } else {
              vnodeChildren = node.children;
            }
          } else {
            vnodeChildren = node.children;
          }
        }
        if (patchFlag !== 0) {
          {
            vnodePatchFlag = String(patchFlag);
          }
          if (dynamicPropNames && dynamicPropNames.length) {
            vnodeDynamicProps = stringifyDynamicPropNames(dynamicPropNames);
          }
        }
        node.codegenNode = createVNodeCall(
          context,
          vnodeTag,
          vnodeProps,
          vnodeChildren,
          vnodePatchFlag,
          vnodeDynamicProps,
          vnodeDirectives,
          !!shouldUseBlock,
          false,
          isComponent2,
          node.loc
        );
      };
    };
    cacheStringFunction = (fn) => {
      const cache = /* @__PURE__ */ Object.create(null);
      return (str) => {
        const hit = cache[str];
        return hit || (cache[str] = fn(str));
      };
    };
    camelizeRE = /-(\w)/g;
    camelize2 = cacheStringFunction((str) => {
      return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ""));
    });
    transformSlotOutlet = (node, context) => {
      if (isSlotOutlet(node)) {
        const { children, loc } = node;
        const { slotName, slotProps } = processSlotOutlet(node, context);
        const slotArgs = [
          context.prefixIdentifiers ? `_ctx.$slots` : `$slots`,
          slotName,
          "{}",
          "undefined",
          "true",
        ];
        let expectedLen = 2;
        if (slotProps) {
          slotArgs[2] = slotProps;
          expectedLen = 3;
        }
        if (children.length) {
          slotArgs[3] = createFunctionExpression(
            [],
            children,
            false,
            false,
            loc
          );
          expectedLen = 4;
        }
        if (context.scopeId && !context.slotted) {
          expectedLen = 5;
        }
        slotArgs.splice(expectedLen);
        node.codegenNode = createCallExpression(
          context.helper(RENDER_SLOT),
          slotArgs,
          loc
        );
      }
    };
    fnExpRE =
      /^\s*([\w$_]+|(async\s*)?\([^)]*?\))\s*=>|^\s*(async\s+)?function(?:\s+[\w$]+)?\s*\(/;
    transformOn = (dir, node, context, augmentor) => {
      const { loc, modifiers, arg } = dir;
      if (!dir.exp && !modifiers.length) {
        context.onError(createCompilerError(35, loc));
      }
      let eventName;
      if (arg.type === 4) {
        if (arg.isStatic) {
          let rawName = arg.content;
          if (rawName.startsWith("vue:")) {
            rawName = `vnode-${rawName.slice(4)}`;
          }
          eventName = createSimpleExpression(
            toHandlerKey(camelize(rawName)),
            true,
            arg.loc
          );
        } else {
          eventName = createCompoundExpression([
            `${context.helperString(TO_HANDLER_KEY)}(`,
            arg,
            `)`,
          ]);
        }
      } else {
        eventName = arg;
        eventName.children.unshift(`${context.helperString(TO_HANDLER_KEY)}(`);
        eventName.children.push(`)`);
      }
      let exp = dir.exp;
      if (exp && !exp.content.trim()) {
        exp = void 0;
      }
      let shouldCache = context.cacheHandlers && !exp && !context.inVOnce;
      if (exp) {
        const isMemberExp = isMemberExpression(exp.content);
        const isInlineStatement = !(isMemberExp || fnExpRE.test(exp.content));
        const hasMultipleStatements = exp.content.includes(`;`);
        if (isInlineStatement || (shouldCache && isMemberExp)) {
          exp = createCompoundExpression([
            `${isInlineStatement ? `$event` : `${``}(...args)`} => ${
              hasMultipleStatements ? `{` : `(`
            }`,
            exp,
            hasMultipleStatements ? `}` : `)`,
          ]);
        }
      }
      let ret = {
        props: [
          createObjectProperty(
            eventName,
            exp || createSimpleExpression(`() => {}`, false, loc)
          ),
        ],
      };
      if (augmentor) {
        ret = augmentor(ret);
      }
      if (shouldCache) {
        ret.props[0].value = context.cache(ret.props[0].value);
      }
      ret.props.forEach((p) => (p.key.isHandlerKey = true));
      return ret;
    };
    transformBind = (dir, _node, context) => {
      const { exp, modifiers, loc } = dir;
      const arg = dir.arg;
      if (arg.type !== 4) {
        arg.children.unshift(`(`);
        arg.children.push(`) || ""`);
      } else if (!arg.isStatic) {
        arg.content = `${arg.content} || ""`;
      }
      if (modifiers.includes("camel")) {
        if (arg.type === 4) {
          if (arg.isStatic) {
            arg.content = camelize(arg.content);
          } else {
            arg.content = `${context.helperString(CAMELIZE)}(${arg.content})`;
          }
        } else {
          arg.children.unshift(`${context.helperString(CAMELIZE)}(`);
          arg.children.push(`)`);
        }
      }
      if (!context.inSSR) {
        if (modifiers.includes("prop")) {
          injectPrefix(arg, ".");
        }
        if (modifiers.includes("attr")) {
          injectPrefix(arg, "^");
        }
      }
      if (!exp || (exp.type === 4 && !exp.content.trim())) {
        context.onError(createCompilerError(34, loc));
        return {
          props: [
            createObjectProperty(arg, createSimpleExpression("", true, loc)),
          ],
        };
      }
      return {
        props: [createObjectProperty(arg, exp)],
      };
    };
    injectPrefix = (arg, prefix) => {
      if (arg.type === 4) {
        if (arg.isStatic) {
          arg.content = prefix + arg.content;
        } else {
          arg.content = `\`${prefix}\${${arg.content}}\``;
        }
      } else {
        arg.children.unshift(`'${prefix}' + (`);
        arg.children.push(`)`);
      }
    };
    transformText = (node, context) => {
      if (
        node.type === 0 ||
        node.type === 1 ||
        node.type === 11 ||
        node.type === 10
      ) {
        return () => {
          const children = node.children;
          let currentContainer = void 0;
          let hasText = false;
          for (let i = 0; i < children.length; i++) {
            const child = children[i];
            if (isText(child)) {
              hasText = true;
              for (let j = i + 1; j < children.length; j++) {
                const next = children[j];
                if (isText(next)) {
                  if (!currentContainer) {
                    currentContainer = children[i] = {
                      type: 8,
                      loc: child.loc,
                      children: [child],
                    };
                  }
                  currentContainer.children.push(` + `, next);
                  children.splice(j, 1);
                  j--;
                } else {
                  currentContainer = void 0;
                  break;
                }
              }
            }
          }
          if (
            !hasText || // if this is a plain element with a single text child, leave it
            // as-is since the runtime has dedicated fast path for this by directly
            // setting textContent of the element.
            // for component root it's always normalized anyway.
            (children.length === 1 &&
              (node.type === 0 ||
                (node.type === 1 &&
                  node.tagType === 0 && // #3756
                  // custom directives can potentially add DOM elements arbitrarily,
                  // we need to avoid setting textContent of the element at runtime
                  // to avoid accidentally overwriting the DOM elements added
                  // by the user through custom directives.
                  !node.props.find(
                    (p) => p.type === 7 && !context.directiveTransforms[p.name]
                  ) && // in compat mode, <template> tags with no special directives
                  // will be rendered as a fragment so its children must be
                  // converted into vnodes.
                  !(node.tag === "template"))))
          ) {
            return;
          }
          for (let i = 0; i < children.length; i++) {
            const child = children[i];
            if (isText(child) || child.type === 8) {
              const callArgs = [];
              if (child.type !== 2 || child.content !== " ") {
                callArgs.push(child);
              }
              if (!context.ssr && getConstantType(child, context) === 0) {
                callArgs.push(1 + ``);
              }
              children[i] = {
                type: 12,
                content: child,
                loc: child.loc,
                codegenNode: createCallExpression(
                  context.helper(CREATE_TEXT),
                  callArgs
                ),
              };
            }
          }
        };
      }
    };
    seen = /* @__PURE__ */ new WeakSet();
    transformOnce = (node, context) => {
      if (node.type === 1 && findDir(node, "once", true)) {
        if (seen.has(node) || context.inVOnce) {
          return;
        }
        seen.add(node);
        context.inVOnce = true;
        context.helper(SET_BLOCK_TRACKING);
        return () => {
          context.inVOnce = false;
          const cur = context.currentNode;
          if (cur.codegenNode) {
            cur.codegenNode = context.cache(
              cur.codegenNode,
              true
              /* isVNode */
            );
          }
        };
      }
    };
    transformModel = (dir, node, context) => {
      const { exp, arg } = dir;
      if (!exp) {
        context.onError(createCompilerError(41, dir.loc));
        return createTransformProps();
      }
      const rawExp = exp.loc.source;
      const expString = exp.type === 4 ? exp.content : rawExp;
      context.bindingMetadata[rawExp];
      const maybeRef = false;
      if (!expString.trim() || (!isMemberExpression(expString) && !maybeRef)) {
        context.onError(createCompilerError(42, exp.loc));
        return createTransformProps();
      }
      const propName = arg ? arg : createSimpleExpression("modelValue", true);
      const eventName = arg
        ? isStaticExp(arg)
          ? `onUpdate:${arg.content}`
          : createCompoundExpression(['"onUpdate:" + ', arg])
        : `onUpdate:modelValue`;
      let assignmentExp;
      const eventArg = context.isTS ? `($event: any)` : `$event`;
      {
        assignmentExp = createCompoundExpression([
          `${eventArg} => ((`,
          exp,
          `) = $event)`,
        ]);
      }
      const props = [
        // modelValue: foo
        createObjectProperty(propName, dir.exp),
        // "onUpdate:modelValue": $event => (foo = $event)
        createObjectProperty(eventName, assignmentExp),
      ];
      if (dir.modifiers.length && node.tagType === 1) {
        const modifiers = dir.modifiers
          .map(
            (m) => (isSimpleIdentifier(m) ? m : JSON.stringify(m)) + `: true`
          )
          .join(`, `);
        const modifiersKey = arg
          ? isStaticExp(arg)
            ? `${arg.content}Modifiers`
            : createCompoundExpression([arg, ' + "Modifiers"'])
          : `modelModifiers`;
        props.push(
          createObjectProperty(
            modifiersKey,
            createSimpleExpression(
              `{ ${modifiers} }`,
              false,
              dir.loc,
              2
              /* CAN_HOIST */
            )
          )
        );
      }
      return createTransformProps(props);
    };
    validDivisionCharRE = /[\w).+\-_$\]]/;
    transformFilter = (node, context) => {
      if (!isCompatEnabled("COMPILER_FILTER", context)) {
        return;
      }
      if (node.type === 5) {
        rewriteFilter(node.content, context);
      }
      if (node.type === 1) {
        node.props.forEach((prop) => {
          if (prop.type === 7 && prop.name !== "for" && prop.exp) {
            rewriteFilter(prop.exp, context);
          }
        });
      }
    };
    seen$1 = /* @__PURE__ */ new WeakSet();
    transformMemo = (node, context) => {
      if (node.type === 1) {
        const dir = findDir(node, "memo");
        if (!dir || seen$1.has(node)) {
          return;
        }
        seen$1.add(node);
        return () => {
          const codegenNode =
            node.codegenNode || context.currentNode.codegenNode;
          if (codegenNode && codegenNode.type === 13) {
            if (node.tagType !== 1) {
              makeBlock(codegenNode, context);
            }
            node.codegenNode = createCallExpression(context.helper(WITH_MEMO), [
              dir.exp,
              createFunctionExpression(void 0, codegenNode),
              `_cache`,
              String(context.cached++),
            ]);
          }
        };
      }
    };
    noopDirectiveTransform = () => ({ props: [] });
  },
});

// node_modules/@vue/compiler-dom/dist/compiler-dom.esm-bundler.js
var compiler_dom_esm_bundler_exports = {};
__export(compiler_dom_esm_bundler_exports, {
  BASE_TRANSITION: () => BASE_TRANSITION,
  CAMELIZE: () => CAMELIZE,
  CAPITALIZE: () => CAPITALIZE,
  CREATE_BLOCK: () => CREATE_BLOCK,
  CREATE_COMMENT: () => CREATE_COMMENT,
  CREATE_ELEMENT_BLOCK: () => CREATE_ELEMENT_BLOCK,
  CREATE_ELEMENT_VNODE: () => CREATE_ELEMENT_VNODE,
  CREATE_SLOTS: () => CREATE_SLOTS,
  CREATE_STATIC: () => CREATE_STATIC,
  CREATE_TEXT: () => CREATE_TEXT,
  CREATE_VNODE: () => CREATE_VNODE,
  DOMDirectiveTransforms: () => DOMDirectiveTransforms,
  DOMNodeTransforms: () => DOMNodeTransforms,
  FRAGMENT: () => FRAGMENT,
  GUARD_REACTIVE_PROPS: () => GUARD_REACTIVE_PROPS,
  IS_MEMO_SAME: () => IS_MEMO_SAME,
  IS_REF: () => IS_REF,
  KEEP_ALIVE: () => KEEP_ALIVE,
  MERGE_PROPS: () => MERGE_PROPS,
  NORMALIZE_CLASS: () => NORMALIZE_CLASS,
  NORMALIZE_PROPS: () => NORMALIZE_PROPS,
  NORMALIZE_STYLE: () => NORMALIZE_STYLE,
  OPEN_BLOCK: () => OPEN_BLOCK,
  POP_SCOPE_ID: () => POP_SCOPE_ID,
  PUSH_SCOPE_ID: () => PUSH_SCOPE_ID,
  RENDER_LIST: () => RENDER_LIST,
  RENDER_SLOT: () => RENDER_SLOT,
  RESOLVE_COMPONENT: () => RESOLVE_COMPONENT,
  RESOLVE_DIRECTIVE: () => RESOLVE_DIRECTIVE,
  RESOLVE_DYNAMIC_COMPONENT: () => RESOLVE_DYNAMIC_COMPONENT,
  RESOLVE_FILTER: () => RESOLVE_FILTER,
  SET_BLOCK_TRACKING: () => SET_BLOCK_TRACKING,
  SUSPENSE: () => SUSPENSE,
  TELEPORT: () => TELEPORT,
  TO_DISPLAY_STRING: () => TO_DISPLAY_STRING,
  TO_HANDLERS: () => TO_HANDLERS,
  TO_HANDLER_KEY: () => TO_HANDLER_KEY,
  TRANSITION: () => TRANSITION,
  TRANSITION_GROUP: () => TRANSITION_GROUP,
  UNREF: () => UNREF,
  V_MODEL_CHECKBOX: () => V_MODEL_CHECKBOX,
  V_MODEL_DYNAMIC: () => V_MODEL_DYNAMIC,
  V_MODEL_RADIO: () => V_MODEL_RADIO,
  V_MODEL_SELECT: () => V_MODEL_SELECT,
  V_MODEL_TEXT: () => V_MODEL_TEXT,
  V_ON_WITH_KEYS: () => V_ON_WITH_KEYS,
  V_ON_WITH_MODIFIERS: () => V_ON_WITH_MODIFIERS,
  V_SHOW: () => V_SHOW,
  WITH_CTX: () => WITH_CTX,
  WITH_DIRECTIVES: () => WITH_DIRECTIVES,
  WITH_MEMO: () => WITH_MEMO,
  advancePositionWithClone: () => advancePositionWithClone,
  advancePositionWithMutation: () => advancePositionWithMutation,
  assert: () => assert,
  baseCompile: () => baseCompile,
  baseParse: () => baseParse,
  buildDirectiveArgs: () => buildDirectiveArgs,
  buildProps: () => buildProps,
  buildSlots: () => buildSlots,
  checkCompatEnabled: () => checkCompatEnabled,
  compile: () => compile,
  createArrayExpression: () => createArrayExpression,
  createAssignmentExpression: () => createAssignmentExpression,
  createBlockStatement: () => createBlockStatement,
  createCacheExpression: () => createCacheExpression,
  createCallExpression: () => createCallExpression,
  createCompilerError: () => createCompilerError,
  createCompoundExpression: () => createCompoundExpression,
  createConditionalExpression: () => createConditionalExpression,
  createDOMCompilerError: () => createDOMCompilerError,
  createForLoopParams: () => createForLoopParams,
  createFunctionExpression: () => createFunctionExpression,
  createIfStatement: () => createIfStatement,
  createInterpolation: () => createInterpolation,
  createObjectExpression: () => createObjectExpression,
  createObjectProperty: () => createObjectProperty,
  createReturnStatement: () => createReturnStatement,
  createRoot: () => createRoot,
  createSequenceExpression: () => createSequenceExpression,
  createSimpleExpression: () => createSimpleExpression,
  createStructuralDirectiveTransform: () => createStructuralDirectiveTransform,
  createTemplateLiteral: () => createTemplateLiteral,
  createTransformContext: () => createTransformContext,
  createVNodeCall: () => createVNodeCall,
  extractIdentifiers: () => extractIdentifiers,
  findDir: () => findDir,
  findProp: () => findProp,
  generate: () => generate,
  generateCodeFrame: () => generateCodeFrame,
  getBaseTransformPreset: () => getBaseTransformPreset,
  getInnerRange: () => getInnerRange,
  getMemoedVNodeCall: () => getMemoedVNodeCall,
  getVNodeBlockHelper: () => getVNodeBlockHelper,
  getVNodeHelper: () => getVNodeHelper,
  hasDynamicKeyVBind: () => hasDynamicKeyVBind,
  hasScopeRef: () => hasScopeRef,
  helperNameMap: () => helperNameMap,
  injectProp: () => injectProp,
  isBuiltInType: () => isBuiltInType,
  isCoreComponent: () => isCoreComponent,
  isFunctionType: () => isFunctionType,
  isInDestructureAssignment: () => isInDestructureAssignment,
  isMemberExpression: () => isMemberExpression,
  isMemberExpressionBrowser: () => isMemberExpressionBrowser,
  isMemberExpressionNode: () => isMemberExpressionNode,
  isReferencedIdentifier: () => isReferencedIdentifier,
  isSimpleIdentifier: () => isSimpleIdentifier,
  isSlotOutlet: () => isSlotOutlet,
  isStaticArgOf: () => isStaticArgOf,
  isStaticExp: () => isStaticExp,
  isStaticProperty: () => isStaticProperty,
  isStaticPropertyKey: () => isStaticPropertyKey,
  isTemplateNode: () => isTemplateNode,
  isText: () => isText,
  isVSlot: () => isVSlot,
  locStub: () => locStub,
  makeBlock: () => makeBlock,
  noopDirectiveTransform: () => noopDirectiveTransform,
  parse: () => parse,
  parserOptions: () => parserOptions,
  processExpression: () => processExpression,
  processFor: () => processFor,
  processIf: () => processIf,
  processSlotOutlet: () => processSlotOutlet,
  registerRuntimeHelpers: () => registerRuntimeHelpers,
  resolveComponentType: () => resolveComponentType,
  toValidAssetId: () => toValidAssetId,
  trackSlotScopes: () => trackSlotScopes,
  trackVForSlotScopes: () => trackVForSlotScopes,
  transform: () => transform,
  transformBind: () => transformBind,
  transformElement: () => transformElement,
  transformExpression: () => transformExpression,
  transformModel: () => transformModel,
  transformOn: () => transformOn,
  transformStyle: () => transformStyle,
  traverseNode: () => traverseNode,
  walkBlockDeclarations: () => walkBlockDeclarations,
  walkFunctionParams: () => walkFunctionParams,
  walkIdentifiers: () => walkIdentifiers,
  warnDeprecation: () => warnDeprecation,
});
function decodeHtmlBrowser(raw, asAttr = false) {
  if (!decoder) {
    decoder = document.createElement("div");
  }
  if (asAttr) {
    decoder.innerHTML = `<div foo="${raw.replace(/"/g, "&quot;")}">`;
    return decoder.children[0].getAttribute("foo");
  } else {
    decoder.innerHTML = raw;
    return decoder.textContent;
  }
}
function createDOMCompilerError(code, loc) {
  return createCompilerError(code, loc);
}
function compile(template, options = {}) {
  return baseCompile(
    template,
    extend({}, parserOptions, options, {
      nodeTransforms: [
        // ignore <script> and <tag>
        // this is not put inside DOMNodeTransforms because that list is used
        // by compiler-ssr to generate vnode fallback branches
        ignoreSideEffectTags,
        ...DOMNodeTransforms,
        ...(options.nodeTransforms || []),
      ],
      directiveTransforms: extend(
        {},
        DOMDirectiveTransforms,
        options.directiveTransforms || {}
      ),
      transformHoist: null,
    })
  );
}
function parse(template, options = {}) {
  return baseParse(template, extend({}, parserOptions, options));
}
var V_MODEL_RADIO,
  V_MODEL_CHECKBOX,
  V_MODEL_TEXT,
  V_MODEL_SELECT,
  V_MODEL_DYNAMIC,
  V_ON_WITH_MODIFIERS,
  V_ON_WITH_KEYS,
  V_SHOW,
  TRANSITION,
  TRANSITION_GROUP,
  decoder,
  isRawTextContainer,
  parserOptions,
  transformStyle,
  parseInlineCSS,
  transformVHtml,
  transformVText,
  transformModel2,
  isEventOptionModifier,
  isNonKeyModifier,
  maybeKeyModifier,
  isKeyboardEvent,
  resolveModifiers,
  transformClick,
  transformOn2,
  transformShow,
  ignoreSideEffectTags,
  DOMNodeTransforms,
  DOMDirectiveTransforms;
var init_compiler_dom_esm_bundler = __esm({
  "node_modules/@vue/compiler-dom/dist/compiler-dom.esm-bundler.js"() {
    init_compiler_core_esm_bundler();
    init_compiler_core_esm_bundler();
    init_shared_esm_bundler();
    V_MODEL_RADIO = Symbol(``);
    V_MODEL_CHECKBOX = Symbol(``);
    V_MODEL_TEXT = Symbol(``);
    V_MODEL_SELECT = Symbol(``);
    V_MODEL_DYNAMIC = Symbol(``);
    V_ON_WITH_MODIFIERS = Symbol(``);
    V_ON_WITH_KEYS = Symbol(``);
    V_SHOW = Symbol(``);
    TRANSITION = Symbol(``);
    TRANSITION_GROUP = Symbol(``);
    registerRuntimeHelpers({
      [V_MODEL_RADIO]: `vModelRadio`,
      [V_MODEL_CHECKBOX]: `vModelCheckbox`,
      [V_MODEL_TEXT]: `vModelText`,
      [V_MODEL_SELECT]: `vModelSelect`,
      [V_MODEL_DYNAMIC]: `vModelDynamic`,
      [V_ON_WITH_MODIFIERS]: `withModifiers`,
      [V_ON_WITH_KEYS]: `withKeys`,
      [V_SHOW]: `vShow`,
      [TRANSITION]: `Transition`,
      [TRANSITION_GROUP]: `TransitionGroup`,
    });
    isRawTextContainer = /* @__PURE__ */ makeMap(
      "style,iframe,script,noscript",
      true
    );
    parserOptions = {
      isVoidTag,
      isNativeTag: (tag) => isHTMLTag(tag) || isSVGTag(tag),
      isPreTag: (tag) => tag === "pre",
      decodeEntities: decodeHtmlBrowser,
      isBuiltInComponent: (tag) => {
        if (isBuiltInType(tag, `Transition`)) {
          return TRANSITION;
        } else if (isBuiltInType(tag, `TransitionGroup`)) {
          return TRANSITION_GROUP;
        }
      },
      // https://html.spec.whatwg.org/multipage/parsing.html#tree-construction-dispatcher
      getNamespace(tag, parent) {
        let ns = parent ? parent.ns : 0;
        if (parent && ns === 2) {
          if (parent.tag === "annotation-xml") {
            if (tag === "svg") {
              return 1;
            }
            if (
              parent.props.some(
                (a) =>
                  a.type === 6 &&
                  a.name === "encoding" &&
                  a.value != null &&
                  (a.value.content === "text/html" ||
                    a.value.content === "application/xhtml+xml")
              )
            ) {
              ns = 0;
            }
          } else if (
            /^m(?:[ions]|text)$/.test(parent.tag) &&
            tag !== "mglyph" &&
            tag !== "malignmark"
          ) {
            ns = 0;
          }
        } else if (parent && ns === 1) {
          if (
            parent.tag === "foreignObject" ||
            parent.tag === "desc" ||
            parent.tag === "title"
          ) {
            ns = 0;
          }
        }
        if (ns === 0) {
          if (tag === "svg") {
            return 1;
          }
          if (tag === "math") {
            return 2;
          }
        }
        return ns;
      },
      // https://html.spec.whatwg.org/multipage/parsing.html#parsing-html-fragments
      getTextMode({ tag, ns }) {
        if (ns === 0) {
          if (tag === "textarea" || tag === "title") {
            return 1;
          }
          if (isRawTextContainer(tag)) {
            return 2;
          }
        }
        return 0;
      },
    };
    transformStyle = (node) => {
      if (node.type === 1) {
        node.props.forEach((p, i) => {
          if (p.type === 6 && p.name === "style" && p.value) {
            node.props[i] = {
              type: 7,
              name: `bind`,
              arg: createSimpleExpression(`style`, true, p.loc),
              exp: parseInlineCSS(p.value.content, p.loc),
              modifiers: [],
              loc: p.loc,
            };
          }
        });
      }
    };
    parseInlineCSS = (cssText, loc) => {
      const normalized = parseStringStyle(cssText);
      return createSimpleExpression(
        JSON.stringify(normalized),
        false,
        loc,
        3
        /* CAN_STRINGIFY */
      );
    };
    transformVHtml = (dir, node, context) => {
      const { exp, loc } = dir;
      if (!exp) {
        context.onError(createDOMCompilerError(50, loc));
      }
      if (node.children.length) {
        context.onError(createDOMCompilerError(51, loc));
        node.children.length = 0;
      }
      return {
        props: [
          createObjectProperty(
            createSimpleExpression(`innerHTML`, true, loc),
            exp || createSimpleExpression("", true)
          ),
        ],
      };
    };
    transformVText = (dir, node, context) => {
      const { exp, loc } = dir;
      if (!exp) {
        context.onError(createDOMCompilerError(52, loc));
      }
      if (node.children.length) {
        context.onError(createDOMCompilerError(53, loc));
        node.children.length = 0;
      }
      return {
        props: [
          createObjectProperty(
            createSimpleExpression(`textContent`, true),
            exp
              ? createCallExpression(
                  context.helperString(TO_DISPLAY_STRING),
                  [exp],
                  loc
                )
              : createSimpleExpression("", true)
          ),
        ],
      };
    };
    transformModel2 = (dir, node, context) => {
      const baseResult = transformModel(dir, node, context);
      if (!baseResult.props.length || node.tagType === 1) {
        return baseResult;
      }
      if (dir.arg) {
        context.onError(createDOMCompilerError(55, dir.arg.loc));
      }
      const { tag } = node;
      const isCustomElement = context.isCustomElement(tag);
      if (
        tag === "input" ||
        tag === "textarea" ||
        tag === "select" ||
        isCustomElement
      ) {
        let directiveToUse = V_MODEL_TEXT;
        let isInvalidType = false;
        if (tag === "input" || isCustomElement) {
          const type = findProp(node, `type`);
          if (type) {
            if (type.type === 7) {
              directiveToUse = V_MODEL_DYNAMIC;
            } else if (type.value) {
              switch (type.value.content) {
                case "radio":
                  directiveToUse = V_MODEL_RADIO;
                  break;
                case "checkbox":
                  directiveToUse = V_MODEL_CHECKBOX;
                  break;
                case "file":
                  isInvalidType = true;
                  context.onError(createDOMCompilerError(56, dir.loc));
                  break;
              }
            }
          } else if (hasDynamicKeyVBind(node)) {
            directiveToUse = V_MODEL_DYNAMIC;
          } else;
        } else if (tag === "select") {
          directiveToUse = V_MODEL_SELECT;
        } else;
        if (!isInvalidType) {
          baseResult.needRuntime = context.helper(directiveToUse);
        }
      } else {
        context.onError(createDOMCompilerError(54, dir.loc));
      }
      baseResult.props = baseResult.props.filter(
        (p) => !(p.key.type === 4 && p.key.content === "modelValue")
      );
      return baseResult;
    };
    isEventOptionModifier = /* @__PURE__ */ makeMap(`passive,once,capture`);
    isNonKeyModifier = /* @__PURE__ */ makeMap(
      // event propagation management
      `stop,prevent,self,ctrl,shift,alt,meta,exact,middle`
    );
    maybeKeyModifier = /* @__PURE__ */ makeMap("left,right");
    isKeyboardEvent = /* @__PURE__ */ makeMap(
      `onkeyup,onkeydown,onkeypress`,
      true
    );
    resolveModifiers = (key, modifiers, context, loc) => {
      const keyModifiers = [];
      const nonKeyModifiers = [];
      const eventOptionModifiers = [];
      for (let i = 0; i < modifiers.length; i++) {
        const modifier = modifiers[i];
        if (
          modifier === "native" &&
          checkCompatEnabled("COMPILER_V_ON_NATIVE", context)
        ) {
          eventOptionModifiers.push(modifier);
        } else if (isEventOptionModifier(modifier)) {
          eventOptionModifiers.push(modifier);
        } else {
          if (maybeKeyModifier(modifier)) {
            if (isStaticExp(key)) {
              if (isKeyboardEvent(key.content)) {
                keyModifiers.push(modifier);
              } else {
                nonKeyModifiers.push(modifier);
              }
            } else {
              keyModifiers.push(modifier);
              nonKeyModifiers.push(modifier);
            }
          } else {
            if (isNonKeyModifier(modifier)) {
              nonKeyModifiers.push(modifier);
            } else {
              keyModifiers.push(modifier);
            }
          }
        }
      }
      return {
        keyModifiers,
        nonKeyModifiers,
        eventOptionModifiers,
      };
    };
    transformClick = (key, event) => {
      const isStaticClick =
        isStaticExp(key) && key.content.toLowerCase() === "onclick";
      return isStaticClick
        ? createSimpleExpression(event, true)
        : key.type !== 4
        ? createCompoundExpression([
            `(`,
            key,
            `) === "onClick" ? "${event}" : (`,
            key,
            `)`,
          ])
        : key;
    };
    transformOn2 = (dir, node, context) => {
      return transformOn(dir, node, context, (baseResult) => {
        const { modifiers } = dir;
        if (!modifiers.length) return baseResult;
        let { key, value: handlerExp } = baseResult.props[0];
        const { keyModifiers, nonKeyModifiers, eventOptionModifiers } =
          resolveModifiers(key, modifiers, context, dir.loc);
        if (nonKeyModifiers.includes("right")) {
          key = transformClick(key, `onContextmenu`);
        }
        if (nonKeyModifiers.includes("middle")) {
          key = transformClick(key, `onMouseup`);
        }
        if (nonKeyModifiers.length) {
          handlerExp = createCallExpression(
            context.helper(V_ON_WITH_MODIFIERS),
            [handlerExp, JSON.stringify(nonKeyModifiers)]
          );
        }
        if (
          keyModifiers.length && // if event name is dynamic, always wrap with keys guard
          (!isStaticExp(key) || isKeyboardEvent(key.content))
        ) {
          handlerExp = createCallExpression(context.helper(V_ON_WITH_KEYS), [
            handlerExp,
            JSON.stringify(keyModifiers),
          ]);
        }
        if (eventOptionModifiers.length) {
          const modifierPostfix = eventOptionModifiers.map(capitalize).join("");
          key = isStaticExp(key)
            ? createSimpleExpression(`${key.content}${modifierPostfix}`, true)
            : createCompoundExpression([`(`, key, `) + "${modifierPostfix}"`]);
        }
        return {
          props: [createObjectProperty(key, handlerExp)],
        };
      });
    };
    transformShow = (dir, node, context) => {
      const { exp, loc } = dir;
      if (!exp) {
        context.onError(createDOMCompilerError(58, loc));
      }
      return {
        props: [],
        needRuntime: context.helper(V_SHOW),
      };
    };
    ignoreSideEffectTags = (node, context) => {
      if (
        node.type === 1 &&
        node.tagType === 0 &&
        (node.tag === "script" || node.tag === "style")
      ) {
        context.onError(createDOMCompilerError(60, node.loc));
        context.removeNode();
      }
    };
    DOMNodeTransforms = [transformStyle, ...[]];
    DOMDirectiveTransforms = {
      cloak: noopDirectiveTransform,
      html: transformVHtml,
      text: transformVText,
      model: transformModel2,
      on: transformOn2,
      show: transformShow,
    };
  },
});

// node_modules/vue/dist/vue.cjs.prod.js
var require_vue_cjs_prod = __commonJS({
  "node_modules/vue/dist/vue.cjs.prod.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var compilerDom =
      (init_compiler_dom_esm_bundler(),
      __toCommonJS(compiler_dom_esm_bundler_exports));
    var runtimeDom =
      (init_runtime_dom_esm_bundler(),
      __toCommonJS(runtime_dom_esm_bundler_exports));
    var shared =
      (init_shared_esm_bundler(), __toCommonJS(shared_esm_bundler_exports));
    function _interopNamespace(e) {
      if (e && e.__esModule) return e;
      var n = /* @__PURE__ */ Object.create(null);
      if (e) {
        Object.keys(e).forEach(function (k) {
          n[k] = e[k];
        });
      }
      n["default"] = e;
      return Object.freeze(n);
    }
    var runtimeDom__namespace = /* @__PURE__ */ _interopNamespace(runtimeDom);
    var compileCache = /* @__PURE__ */ Object.create(null);
    function compileToFunction(template, options) {
      if (!shared.isString(template)) {
        if (template.nodeType) {
          template = template.innerHTML;
        } else {
          return shared.NOOP;
        }
      }
      const key = template;
      const cached = compileCache[key];
      if (cached) {
        return cached;
      }
      if (template[0] === "#") {
        const el = document.querySelector(template);
        template = el ? el.innerHTML : ``;
      }
      const { code } = compilerDom.compile(
        template,
        shared.extend(
          {
            hoistStatic: true,
            onError: void 0,
            onWarn: shared.NOOP,
          },
          options
        )
      );
      const render = new Function("Vue", code)(runtimeDom__namespace);
      render._rc = true;
      return (compileCache[key] = render);
    }
    runtimeDom.registerRuntimeCompiler(compileToFunction);
    Object.keys(runtimeDom).forEach(function (k) {
      if (k !== "default") exports[k] = runtimeDom[k];
    });
    exports.compile = compileToFunction;
  },
});

// node_modules/vue/index.js
var require_vue = __commonJS({
  "node_modules/vue/index.js"(exports, module) {
    {
      module.exports = require_vue_cjs_prod();
    }
  },
});

// node_modules/vue-toast-notification/dist/index.min.js
var require_index_min = __commonJS({
  "node_modules/vue-toast-notification/dist/index.min.js"(exports, module) {
    !(function (t, e) {
      "object" == typeof exports && "object" == typeof module
        ? (module.exports = e(require_vue()))
        : "function" == typeof define && define.amd
        ? define("VueToast", ["vue"], e)
        : "object" == typeof exports
        ? (exports.VueToast = e(require_vue()))
        : (t.VueToast = e(t.Vue));
    })(exports, (t) =>
      (() => {
        var e = {
            831: (t2, e2) => {
              Object.defineProperty(e2, "__esModule", { value: true }),
                (e2.default = (t3, e3) => {
                  const s2 = t3.__vccOpts || t3;
                  for (const [t4, o2] of e3) s2[t4] = o2;
                  return s2;
                });
            },
            976: (e2) => {
              e2.exports = t;
            },
          },
          s = {};
        function o(t2) {
          var i2 = s[t2];
          if (void 0 !== i2) return i2.exports;
          var n = (s[t2] = { exports: {} });
          return e[t2](n, n.exports, o), n.exports;
        }
        (o.d = (t2, e2) => {
          for (var s2 in e2)
            o.o(e2, s2) &&
              !o.o(t2, s2) &&
              Object.defineProperty(t2, s2, { enumerable: true, get: e2[s2] });
        }),
          (o.o = (t2, e2) => Object.prototype.hasOwnProperty.call(t2, e2)),
          (o.r = (t2) => {
            "undefined" != typeof Symbol &&
              Symbol.toStringTag &&
              Object.defineProperty(t2, Symbol.toStringTag, {
                value: "Module",
              }),
              Object.defineProperty(t2, "__esModule", { value: true });
          });
        var i = {};
        return (
          (() => {
            o.r(i),
              o.d(i, {
                ToastComponent: () => d,
                ToastPlugin: () => h,
                ToastPositions: () => l,
                default: () => v,
                useToast: () => m,
              });
            var t2 = o(976);
            const e2 = (0, t2.createElementVNode)(
                "div",
                { class: "v-toast__icon" },
                null,
                -1
              ),
              s2 = ["innerHTML"];
            function n(t3) {
              var e3;
              void 0 !== t3.remove
                ? t3.remove()
                : null === (e3 = t3.parentNode) ||
                  void 0 === e3 ||
                  e3.removeChild(t3);
            }
            function r(e3, s3, o2) {
              let i2 =
                arguments.length > 3 && void 0 !== arguments[3]
                  ? arguments[3]
                  : {};
              const n2 = (0, t2.h)(e3, s3, i2),
                r2 = document.createElement("div");
              return (
                r2.classList.add("v-toast--pending"),
                o2.appendChild(r2),
                (0, t2.render)(n2, r2),
                n2.component
              );
            }
            class a {
              constructor(t3, e3) {
                (this.startedAt = Date.now()),
                  (this.callback = t3),
                  (this.delay = e3),
                  (this.timer = setTimeout(t3, e3));
              }
              pause() {
                this.stop(), (this.delay -= Date.now() - this.startedAt);
              }
              resume() {
                this.stop(),
                  (this.startedAt = Date.now()),
                  (this.timer = setTimeout(this.callback, this.delay));
              }
              stop() {
                clearTimeout(this.timer);
              }
            }
            const l = Object.freeze({
              TOP_RIGHT: "top-right",
              TOP: "top",
              TOP_LEFT: "top-left",
              BOTTOM_RIGHT: "bottom-right",
              BOTTOM: "bottom",
              BOTTOM_LEFT: "bottom-left",
            });
            var c;
            const u = {
                all: (c = c || /* @__PURE__ */ new Map()),
                on: function (t3, e3) {
                  var s3 = c.get(t3);
                  s3 ? s3.push(e3) : c.set(t3, [e3]);
                },
                off: function (t3, e3) {
                  var s3 = c.get(t3);
                  s3 &&
                    (e3 ? s3.splice(s3.indexOf(e3) >>> 0, 1) : c.set(t3, []));
                },
                emit: function (t3, e3) {
                  var s3 = c.get(t3);
                  s3 &&
                    s3.slice().map(function (t4) {
                      t4(e3);
                    }),
                    (s3 = c.get("*")) &&
                      s3.slice().map(function (s4) {
                        s4(t3, e3);
                      });
                },
              },
              p = (0, t2.defineComponent)({
                name: "Toast",
                props: {
                  message: { type: String, required: true },
                  type: { type: String, default: "success" },
                  position: {
                    type: String,
                    default: l.BOTTOM_RIGHT,
                    validator: (t3) => Object.values(l).includes(t3),
                  },
                  duration: { type: Number, default: 3e3 },
                  dismissible: { type: Boolean, default: true },
                  onDismiss: { type: Function, default: () => {} },
                  onClick: { type: Function, default: () => {} },
                  queue: Boolean,
                  pauseOnHover: { type: Boolean, default: true },
                },
                data: () => ({
                  isActive: false,
                  parentTop: null,
                  parentBottom: null,
                  isHovered: false,
                }),
                beforeMount() {
                  this.setupContainer();
                },
                mounted() {
                  this.showNotice(), u.on("toast-clear", this.dismiss);
                },
                methods: {
                  setupContainer() {
                    if (
                      ((this.parentTop = document.querySelector(
                        ".v-toast.v-toast--top"
                      )),
                      (this.parentBottom = document.querySelector(
                        ".v-toast.v-toast--bottom"
                      )),
                      this.parentTop && this.parentBottom)
                    )
                      return;
                    this.parentTop ||
                      ((this.parentTop = document.createElement("div")),
                      (this.parentTop.className = "v-toast v-toast--top")),
                      this.parentBottom ||
                        ((this.parentBottom = document.createElement("div")),
                        (this.parentBottom.className =
                          "v-toast v-toast--bottom"));
                    const t3 = document.body;
                    t3.appendChild(this.parentTop),
                      t3.appendChild(this.parentBottom);
                  },
                  shouldQueue() {
                    return (
                      !!this.queue &&
                      (this.parentTop.childElementCount > 0 ||
                        this.parentBottom.childElementCount > 0)
                    );
                  },
                  dismiss() {
                    this.timer && this.timer.stop(),
                      clearTimeout(this.queueTimer),
                      (this.isActive = false),
                      setTimeout(() => {
                        this.onDismiss.apply(null, arguments);
                        const e3 = this.$refs.root;
                        (0, t2.render)(null, e3), n(e3);
                      }, 150);
                  },
                  showNotice() {
                    if (this.shouldQueue())
                      return void (this.queueTimer = setTimeout(
                        this.showNotice,
                        250
                      ));
                    const t3 = this.$refs.root.parentElement;
                    this.correctParent.insertAdjacentElement(
                      "afterbegin",
                      this.$refs.root
                    ),
                      n(t3),
                      (this.isActive = true),
                      this.duration &&
                        (this.timer = new a(this.dismiss, this.duration));
                  },
                  whenClicked() {
                    this.dismissible &&
                      (this.onClick.apply(null, arguments), this.dismiss());
                  },
                  toggleTimer(t3) {
                    this.pauseOnHover &&
                      this.timer &&
                      (t3 ? this.timer.pause() : this.timer.resume());
                  },
                },
                computed: {
                  correctParent() {
                    switch (this.position) {
                      case l.TOP:
                      case l.TOP_RIGHT:
                      case l.TOP_LEFT:
                        return this.parentTop;
                      case l.BOTTOM:
                      case l.BOTTOM_RIGHT:
                      case l.BOTTOM_LEFT:
                        return this.parentBottom;
                    }
                  },
                  transition() {
                    switch (this.position) {
                      case l.TOP:
                      case l.TOP_RIGHT:
                      case l.TOP_LEFT:
                        return {
                          enter: "v-toast--fade-in-down",
                          leave: "v-toast--fade-out",
                        };
                      case l.BOTTOM:
                      case l.BOTTOM_RIGHT:
                      case l.BOTTOM_LEFT:
                        return {
                          enter: "v-toast--fade-in-up",
                          leave: "v-toast--fade-out",
                        };
                    }
                  },
                },
                beforeUnmount() {
                  u.off("toast-clear", this.dismiss);
                },
              });
            const d = (0, o(831).default)(p, [
                [
                  "render",
                  function (o2, i2, n2, r2, a2, l2) {
                    return (
                      (0, t2.openBlock)(),
                      (0, t2.createBlock)(
                        t2.Transition,
                        {
                          "enter-active-class": o2.transition.enter,
                          "leave-active-class": o2.transition.leave,
                        },
                        {
                          default: (0, t2.withCtx)(() => [
                            (0, t2.withDirectives)(
                              (0, t2.createElementVNode)(
                                "div",
                                {
                                  ref: "root",
                                  role: "alert",
                                  class: (0, t2.normalizeClass)([
                                    "v-toast__item",
                                    [
                                      "v-toast__item--".concat(o2.type),
                                      "v-toast__item--".concat(o2.position),
                                    ],
                                  ]),
                                  onMouseover:
                                    i2[0] ||
                                    (i2[0] = (t3) => o2.toggleTimer(true)),
                                  onMouseleave:
                                    i2[1] ||
                                    (i2[1] = (t3) => o2.toggleTimer(false)),
                                  onClick:
                                    i2[2] ||
                                    (i2[2] = function () {
                                      return (
                                        o2.whenClicked &&
                                        o2.whenClicked(...arguments)
                                      );
                                    }),
                                },
                                [
                                  e2,
                                  (0, t2.createElementVNode)(
                                    "p",
                                    {
                                      class: "v-toast__text",
                                      innerHTML: o2.message,
                                    },
                                    null,
                                    8,
                                    s2
                                  ),
                                ],
                                34
                              ),
                              [[t2.vShow, o2.isActive]]
                            ),
                          ]),
                          _: 1,
                        },
                        8,
                        ["enter-active-class", "leave-active-class"]
                      )
                    );
                  },
                ],
              ]),
              m = function () {
                let t3 =
                  arguments.length > 0 && void 0 !== arguments[0]
                    ? arguments[0]
                    : {};
                return {
                  open(e3) {
                    let s3 = null;
                    "string" == typeof e3 && (s3 = e3);
                    const o2 = { message: s3 },
                      i2 = Object.assign({}, o2, t3, e3);
                    return { dismiss: r(d, i2, document.body).ctx.dismiss };
                  },
                  clear() {
                    u.emit("toast-clear");
                  },
                  success(t4) {
                    let e3 =
                      arguments.length > 1 && void 0 !== arguments[1]
                        ? arguments[1]
                        : {};
                    return this.open(
                      Object.assign({}, { message: t4, type: "success" }, e3)
                    );
                  },
                  error(t4) {
                    let e3 =
                      arguments.length > 1 && void 0 !== arguments[1]
                        ? arguments[1]
                        : {};
                    return this.open(
                      Object.assign({}, { message: t4, type: "error" }, e3)
                    );
                  },
                  info(t4) {
                    let e3 =
                      arguments.length > 1 && void 0 !== arguments[1]
                        ? arguments[1]
                        : {};
                    return this.open(
                      Object.assign({}, { message: t4, type: "info" }, e3)
                    );
                  },
                  warning(t4) {
                    let e3 =
                      arguments.length > 1 && void 0 !== arguments[1]
                        ? arguments[1]
                        : {};
                    return this.open(
                      Object.assign({}, { message: t4, type: "warning" }, e3)
                    );
                  },
                  default(t4) {
                    let e3 =
                      arguments.length > 1 && void 0 !== arguments[1]
                        ? arguments[1]
                        : {};
                    return this.open(
                      Object.assign({}, { message: t4, type: "default" }, e3)
                    );
                  },
                };
              },
              h = {
                install: function (t3) {
                  let e3 =
                      arguments.length > 1 && void 0 !== arguments[1]
                        ? arguments[1]
                        : {},
                    s3 = m(e3);
                  (t3.config.globalProperties.$toast = s3),
                    t3.provide("$toast", s3);
                },
              },
              v = h;
          })(),
          i
        );
      })()
    );
  },
});
const __vite__cjsImport10_vueToastNotification = require_index_min();

const themeDefault = "";

// node_modules/vue3-click-away/dist/module.js
var clickEventType = function () {
  return document.ontouchstart !== null ? "click" : "touchstart";
};
var UNIQUE_ID = "__vue_click_away__";
var onMounted = function (el, binding, vnode) {
  onUnmounted(el);
  let vm = vnode.context;
  let callback = binding.value;
  let nextTick = false;
  setTimeout(function () {
    nextTick = true;
  }, 0);
  el[UNIQUE_ID] = function (event) {
    if (
      (!el || !el.contains(event.target)) &&
      callback &&
      nextTick &&
      typeof callback === "function"
    ) {
      return callback.call(vm, event);
    }
  };
  document.addEventListener(clickEventType(), el[UNIQUE_ID], false);
};
var onUnmounted = function (el) {
  document.removeEventListener(clickEventType(), el[UNIQUE_ID], false);
  delete el[UNIQUE_ID];
};
var onUpdated = function (el, binding, vnode) {
  if (binding.value === binding.oldValue) {
    return;
  }
  onMounted(el, binding, vnode);
};
var plugin$1 = {
  install: function (app) {
    app.directive("click-away", directive$1);
  },
};
var directive$1 = {
  mounted: onMounted,
  updated: onUpdated,
  unmounted: onUnmounted,
};
var module_default = plugin$1;

// node_modules/vue-tippy/dist/vue-tippy.esm-browser.js
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [top, bottom, right, left];
var start = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function (
  acc,
  placement
) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
},
[]);
var placements = /* @__PURE__ */ []
  .concat(basePlacements, [auto])
  .reduce(function (acc, placement) {
    return acc.concat([
      placement,
      placement + "-" + start,
      placement + "-" + end,
    ]);
  }, []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [
  beforeRead,
  read,
  afterRead,
  beforeMain,
  main,
  afterMain,
  beforeWrite,
  write,
  afterWrite,
];
function getNodeName(element) {
  return element ? (element.nodeName || "").toLowerCase() : null;
}
function getWindow(node) {
  if (node == null) {
    return window;
  }
  if (node.toString() !== "[object Window]") {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node;
}
function isElement(node) {
  var OwnElement = getWindow(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}
function isHTMLElement(node) {
  var OwnElement = getWindow(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}
function isShadowRoot(node) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}
function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function (name) {
    var style = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element = state.elements[name];
    if (!isHTMLElement(element) || !getNodeName(element)) {
      return;
    }
    Object.assign(element.style, style);
    Object.keys(attributes).forEach(function (name2) {
      var value = attributes[name2];
      if (value === false) {
        element.removeAttribute(name2);
      } else {
        element.setAttribute(name2, value === true ? "" : value);
      }
    });
  });
}
function effect(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: "0",
      top: "0",
      margin: "0",
    },
    arrow: {
      position: "absolute",
    },
    reference: {},
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return function () {
    Object.keys(state.elements).forEach(function (name) {
      var element = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(
        state.styles.hasOwnProperty(name)
          ? state.styles[name]
          : initialStyles[name]
      );
      var style = styleProperties.reduce(function (style2, property) {
        style2[property] = "";
        return style2;
      }, {});
      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function (attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
}
var applyStyles$1 = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles,
  effect,
  requires: ["computeStyles"],
};
function getBasePlacement(placement) {
  return placement.split("-")[0];
}
var max$4 = Math.max;
var min$5 = Math.min;
var round$1 = Math.round;
function getBoundingClientRect(element, includeScale) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  var rect = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (isHTMLElement(element) && includeScale) {
    var offsetHeight = element.offsetHeight;
    var offsetWidth = element.offsetWidth;
    if (offsetWidth > 0) {
      scaleX = round$1(rect.width) / offsetWidth || 1;
    }
    if (offsetHeight > 0) {
      scaleY = round$1(rect.height) / offsetHeight || 1;
    }
  }
  return {
    width: rect.width / scaleX,
    height: rect.height / scaleY,
    top: rect.top / scaleY,
    right: rect.right / scaleX,
    bottom: rect.bottom / scaleY,
    left: rect.left / scaleX,
    x: rect.left / scaleX,
    y: rect.top / scaleY,
  };
}
function getLayoutRect(element) {
  var clientRect = getBoundingClientRect(element);
  var width = element.offsetWidth;
  var height = element.offsetHeight;
  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }
  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }
  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width,
    height,
  };
}
function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    var next = child;
    do {
      if (next && parent.isSameNode(next)) {
        return true;
      }
      next = next.parentNode || next.host;
    } while (next);
  }
  return false;
}
function getComputedStyle(element) {
  return getWindow(element).getComputedStyle(element);
}
function isTableElement(element) {
  return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
}
function getDocumentElement(element) {
  return (
    (isElement(element)
      ? element.ownerDocument
      : // $FlowFixMe[prop-missing]
        element.document) || window.document
  ).documentElement;
}
function getParentNode(element) {
  if (getNodeName(element) === "html") {
    return element;
  }
  return (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element.parentNode || // DOM Element detected
    (isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    getDocumentElement(element)
  );
}
function getTrueOffsetParent(element) {
  if (
    !isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
    getComputedStyle(element).position === "fixed"
  ) {
    return null;
  }
  return element.offsetParent;
}
function getContainingBlock(element) {
  var isFirefox = navigator.userAgent.toLowerCase().indexOf("firefox") !== -1;
  var isIE = navigator.userAgent.indexOf("Trident") !== -1;
  if (isIE && isHTMLElement(element)) {
    var elementCss = getComputedStyle(element);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode(element);
  while (
    isHTMLElement(currentNode) &&
    ["html", "body"].indexOf(getNodeName(currentNode)) < 0
  ) {
    var css = getComputedStyle(currentNode);
    if (
      css.transform !== "none" ||
      css.perspective !== "none" ||
      css.contain === "paint" ||
      ["transform", "perspective"].indexOf(css.willChange) !== -1 ||
      (isFirefox && css.willChange === "filter") ||
      (isFirefox && css.filter && css.filter !== "none")
    ) {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element) {
  var window2 = getWindow(element);
  var offsetParent = getTrueOffsetParent(element);
  while (
    offsetParent &&
    isTableElement(offsetParent) &&
    getComputedStyle(offsetParent).position === "static"
  ) {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (
    offsetParent &&
    (getNodeName(offsetParent) === "html" ||
      (getNodeName(offsetParent) === "body" &&
        getComputedStyle(offsetParent).position === "static"))
  ) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}
function within(min$1, value, max$1) {
  return max$4(min$1, min$5(value, max$1));
}
function withinMaxClamp(min2, value, max2) {
  var v = within(min2, value, max2);
  return v > max2 ? max2 : v;
}
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
  };
}
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}
function expandToHashMap(value, keys) {
  return keys.reduce(function (hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}
var toPaddingObject = function toPaddingObject2(padding, state) {
  padding =
    typeof padding === "function"
      ? padding(
          Object.assign({}, state.rects, {
            placement: state.placement,
          })
        )
      : padding;
  return mergePaddingObject(
    typeof padding !== "number"
      ? padding
      : expandToHashMap(padding, basePlacements)
  );
};
function arrow(_ref) {
  var _state$modifiersData$;
  var state = _ref.state,
    name = _ref.name,
    options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets2) {
    return;
  }
  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === "y" ? top : left;
  var maxProp = axis === "y" ? bottom : right;
  var endDiff =
    state.rects.reference[len] +
    state.rects.reference[axis] -
    popperOffsets2[axis] -
    state.rects.popper[len];
  var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent
    ? axis === "y"
      ? arrowOffsetParent.clientHeight || 0
      : arrowOffsetParent.clientWidth || 0
    : 0;
  var centerToReference = endDiff / 2 - startDiff / 2;
  var min2 = paddingObject[minProp];
  var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset2 = within(min2, center, max2);
  var axisProp = axis;
  state.modifiersData[name] =
    ((_state$modifiersData$ = {}),
    (_state$modifiersData$[axisProp] = offset2),
    (_state$modifiersData$.centerOffset = offset2 - center),
    _state$modifiersData$);
}
function effect$1(_ref2) {
  var state = _ref2.state,
    options = _ref2.options;
  var _options$element = options.element,
    arrowElement =
      _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (!contains(state.elements.popper, arrowElement)) {
    return;
  }
  state.elements.arrow = arrowElement;
}
var arrow$1 = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: arrow,
  effect: effect$1,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"],
};
function getVariation(placement) {
  return placement.split("-")[1];
}
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto",
};
function roundOffsetsByDPR(_ref) {
  var x = _ref.x,
    y = _ref.y;
  var win = window;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round$1(x * dpr) / dpr || 0,
    y: round$1(y * dpr) / dpr || 0,
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper2 = _ref2.popper,
    popperRect = _ref2.popperRect,
    placement = _ref2.placement,
    variation = _ref2.variation,
    offsets = _ref2.offsets,
    position = _ref2.position,
    gpuAcceleration = _ref2.gpuAcceleration,
    adaptive = _ref2.adaptive,
    roundOffsets = _ref2.roundOffsets,
    isFixed = _ref2.isFixed;
  var _ref3 =
      roundOffsets === true
        ? roundOffsetsByDPR(offsets)
        : typeof roundOffsets === "function"
        ? roundOffsets(offsets)
        : offsets,
    _ref3$x = _ref3.x,
    x = _ref3$x === void 0 ? 0 : _ref3$x,
    _ref3$y = _ref3.y,
    y = _ref3$y === void 0 ? 0 : _ref3$y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left;
  var sideY = top;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent(popper2);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow(popper2)) {
      offsetParent = getDocumentElement(popper2);
      if (
        getComputedStyle(offsetParent).position !== "static" &&
        position === "absolute"
      ) {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (
      placement === top ||
      ((placement === left || placement === right) && variation === end)
    ) {
      sideY = bottom;
      var offsetY =
        isFixed && win.visualViewport
          ? win.visualViewport.height
          : // $FlowFixMe[prop-missing]
            offsetParent[heightProp];
      y -= offsetY - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }
    if (
      placement === left ||
      ((placement === top || placement === bottom) && variation === end)
    ) {
      sideX = right;
      var offsetX =
        isFixed && win.visualViewport
          ? win.visualViewport.width
          : // $FlowFixMe[prop-missing]
            offsetParent[widthProp];
      x -= offsetX - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign(
    {
      position,
    },
    adaptive && unsetSides
  );
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign(
      {},
      commonStyles,
      ((_Object$assign = {}),
      (_Object$assign[sideY] = hasY ? "0" : ""),
      (_Object$assign[sideX] = hasX ? "0" : ""),
      (_Object$assign.transform =
        (win.devicePixelRatio || 1) <= 1
          ? "translate(" + x + "px, " + y + "px)"
          : "translate3d(" + x + "px, " + y + "px, 0)"),
      _Object$assign)
    );
  }
  return Object.assign(
    {},
    commonStyles,
    ((_Object$assign2 = {}),
    (_Object$assign2[sideY] = hasY ? y + "px" : ""),
    (_Object$assign2[sideX] = hasX ? x + "px" : ""),
    (_Object$assign2.transform = ""),
    _Object$assign2)
  );
}
function computeStyles(_ref4) {
  var state = _ref4.state,
    options = _ref4.options;
  var _options$gpuAccelerat = options.gpuAcceleration,
    gpuAcceleration =
      _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,
    _options$adaptive = options.adaptive,
    adaptive = _options$adaptive === void 0 ? true : _options$adaptive,
    _options$roundOffsets = options.roundOffsets,
    roundOffsets =
      _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  var commonStyles = {
    placement: getBasePlacement(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration,
    isFixed: state.options.strategy === "fixed",
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign(
      {},
      state.styles.popper,
      mapToStyles(
        Object.assign({}, commonStyles, {
          offsets: state.modifiersData.popperOffsets,
          position: state.options.strategy,
          adaptive,
          roundOffsets,
        })
      )
    );
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign(
      {},
      state.styles.arrow,
      mapToStyles(
        Object.assign({}, commonStyles, {
          offsets: state.modifiersData.arrow,
          position: "absolute",
          adaptive: false,
          roundOffsets,
        })
      )
    );
  }
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-placement": state.placement,
  });
}
var computeStyles$1 = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {},
};
var passive = {
  passive: true,
};
function effect$2(_ref) {
  var state = _ref.state,
    instance = _ref.instance,
    options = _ref.options;
  var _options$scroll = options.scroll,
    scroll = _options$scroll === void 0 ? true : _options$scroll,
    _options$resize = options.resize,
    resize = _options$resize === void 0 ? true : _options$resize;
  var window2 = getWindow(state.elements.popper);
  var scrollParents = [].concat(
    state.scrollParents.reference,
    state.scrollParents.popper
  );
  if (scroll) {
    scrollParents.forEach(function (scrollParent) {
      scrollParent.addEventListener("scroll", instance.update, passive);
    });
  }
  if (resize) {
    window2.addEventListener("resize", instance.update, passive);
  }
  return function () {
    if (scroll) {
      scrollParents.forEach(function (scrollParent) {
        scrollParent.removeEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window2.removeEventListener("resize", instance.update, passive);
    }
  };
}
var eventListeners = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function fn() {},
  effect: effect$2,
  data: {},
};
var hash = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom",
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function (matched) {
    return hash[matched];
  });
}
var hash$1 = {
  start: "end",
  end: "start",
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function (matched) {
    return hash$1[matched];
  });
}
function getWindowScroll(node) {
  var win = getWindow(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft,
    scrollTop,
  };
}
function getWindowScrollBarX(element) {
  return (
    getBoundingClientRect(getDocumentElement(element)).left +
    getWindowScroll(element).scrollLeft
  );
}
function getViewportRect(element) {
  var win = getWindow(element);
  var html = getDocumentElement(element);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x = 0;
  var y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    if (!/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x + getWindowScrollBarX(element),
    y,
  };
}
function getDocumentRect(element) {
  var _element$ownerDocumen;
  var html = getDocumentElement(element);
  var winScroll = getWindowScroll(element);
  var body =
    (_element$ownerDocumen = element.ownerDocument) == null
      ? void 0
      : _element$ownerDocumen.body;
  var width = max$4(
    html.scrollWidth,
    html.clientWidth,
    body ? body.scrollWidth : 0,
    body ? body.clientWidth : 0
  );
  var height = max$4(
    html.scrollHeight,
    html.clientHeight,
    body ? body.scrollHeight : 0,
    body ? body.clientHeight : 0
  );
  var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
  var y = -winScroll.scrollTop;
  if (getComputedStyle(body || html).direction === "rtl") {
    x += max$4(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x,
    y,
  };
}
function isScrollParent(element) {
  var _getComputedStyle = getComputedStyle(element),
    overflow = _getComputedStyle.overflow,
    overflowX = _getComputedStyle.overflowX,
    overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}
function getScrollParent(node) {
  if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
    return node.ownerDocument.body;
  }
  if (isHTMLElement(node) && isScrollParent(node)) {
    return node;
  }
  return getScrollParent(getParentNode(node));
}
function listScrollParents(element, list) {
  var _element$ownerDocumen;
  if (list === void 0) {
    list = [];
  }
  var scrollParent = getScrollParent(element);
  var isBody =
    scrollParent ===
    ((_element$ownerDocumen = element.ownerDocument) == null
      ? void 0
      : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody
    ? [win].concat(
        win.visualViewport || [],
        isScrollParent(scrollParent) ? scrollParent : []
      )
    : scrollParent;
  var updatedList = list.concat(target);
  return isBody
    ? updatedList
    : // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
      updatedList.concat(listScrollParents(getParentNode(target)));
}
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height,
  });
}
function getInnerBoundingClientRect(element) {
  var rect = getBoundingClientRect(element);
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element, clippingParent) {
  return clippingParent === viewport
    ? rectToClientRect(getViewportRect(element))
    : isElement(clippingParent)
    ? getInnerBoundingClientRect(clippingParent)
    : rectToClientRect(getDocumentRect(getDocumentElement(element)));
}
function getClippingParents(element) {
  var clippingParents2 = listScrollParents(getParentNode(element));
  var canEscapeClipping =
    ["absolute", "fixed"].indexOf(getComputedStyle(element).position) >= 0;
  var clipperElement =
    canEscapeClipping && isHTMLElement(element)
      ? getOffsetParent(element)
      : element;
  if (!isElement(clipperElement)) {
    return [];
  }
  return clippingParents2.filter(function (clippingParent) {
    return (
      isElement(clippingParent) &&
      contains(clippingParent, clipperElement) &&
      getNodeName(clippingParent) !== "body" &&
      (canEscapeClipping
        ? getComputedStyle(clippingParent).position !== "static"
        : true)
    );
  });
}
function getClippingRect(element, boundary, rootBoundary) {
  var mainClippingParents =
    boundary === "clippingParents"
      ? getClippingParents(element)
      : [].concat(boundary);
  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents2[0];
  var clippingRect = clippingParents2.reduce(function (
    accRect,
    clippingParent
  ) {
    var rect = getClientRectFromMixedType(element, clippingParent);
    accRect.top = max$4(rect.top, accRect.top);
    accRect.right = min$5(rect.right, accRect.right);
    accRect.bottom = min$5(rect.bottom, accRect.bottom);
    accRect.left = max$4(rect.left, accRect.left);
    return accRect;
  },
  getClientRectFromMixedType(element, firstClippingParent));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}
function computeOffsets(_ref) {
  var reference2 = _ref.reference,
    element = _ref.element,
    placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference2.x + reference2.width / 2 - element.width / 2;
  var commonY = reference2.y + reference2.height / 2 - element.height / 2;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference2.y - element.height,
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference2.y + reference2.height,
      };
      break;
    case right:
      offsets = {
        x: reference2.x + reference2.width,
        y: commonY,
      };
      break;
    case left:
      offsets = {
        x: reference2.x - element.width,
        y: commonY,
      };
      break;
    default:
      offsets = {
        x: reference2.x,
        y: reference2.y,
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start:
        offsets[mainAxis] =
          offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
        break;
      case end:
        offsets[mainAxis] =
          offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
        break;
    }
  }
  return offsets;
}
function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options,
    _options$placement = _options.placement,
    placement =
      _options$placement === void 0 ? state.placement : _options$placement,
    _options$boundary = _options.boundary,
    boundary =
      _options$boundary === void 0 ? clippingParents : _options$boundary,
    _options$rootBoundary = _options.rootBoundary,
    rootBoundary =
      _options$rootBoundary === void 0 ? viewport : _options$rootBoundary,
    _options$elementConte = _options.elementContext,
    elementContext =
      _options$elementConte === void 0 ? popper : _options$elementConte,
    _options$altBoundary = _options.altBoundary,
    altBoundary =
      _options$altBoundary === void 0 ? false : _options$altBoundary,
    _options$padding = _options.padding,
    padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(
    typeof padding !== "number"
      ? padding
      : expandToHashMap(padding, basePlacements)
  );
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(
    isElement(element)
      ? element
      : element.contextElement || getDocumentElement(state.elements.popper),
    boundary,
    rootBoundary
  );
  var referenceClientRect = getBoundingClientRect(state.elements.reference);
  var popperOffsets2 = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: "absolute",
    placement,
  });
  var popperClientRect = rectToClientRect(
    Object.assign({}, popperRect, popperOffsets2)
  );
  var elementClientRect =
    elementContext === popper ? popperClientRect : referenceClientRect;
  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom:
      elementClientRect.bottom -
      clippingClientRect.bottom +
      paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right:
      elementClientRect.right - clippingClientRect.right + paddingObject.right,
  };
  var offsetData = state.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    var offset2 = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function (key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
      overflowOffsets[key] += offset2[axis] * multiply;
    });
  }
  return overflowOffsets;
}
function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options,
    placement = _options.placement,
    boundary = _options.boundary,
    rootBoundary = _options.rootBoundary,
    padding = _options.padding,
    flipVariations = _options.flipVariations,
    _options$allowedAutoP = _options.allowedAutoPlacements,
    allowedAutoPlacements =
      _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements$1 = variation
    ? flipVariations
      ? variationPlacements
      : variationPlacements.filter(function (placement2) {
          return getVariation(placement2) === variation;
        })
    : basePlacements;
  var allowedPlacements = placements$1.filter(function (placement2) {
    return allowedAutoPlacements.indexOf(placement2) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements$1;
  }
  var overflows = allowedPlacements.reduce(function (acc, placement2) {
    acc[placement2] = detectOverflow(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding,
    })[getBasePlacement(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function (a, b) {
    return overflows[a] - overflows[b];
  });
}
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }
  var oppositePlacement = getOppositePlacement(placement);
  return [
    getOppositeVariationPlacement(placement),
    oppositePlacement,
    getOppositeVariationPlacement(oppositePlacement),
  ];
}
function flip(_ref) {
  var state = _ref.state,
    options = _ref.options,
    name = _ref.name;
  if (state.modifiersData[name]._skip) {
    return;
  }
  var _options$mainAxis = options.mainAxis,
    checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
    _options$altAxis = options.altAxis,
    checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,
    specifiedFallbackPlacements = options.fallbackPlacements,
    padding = options.padding,
    boundary = options.boundary,
    rootBoundary = options.rootBoundary,
    altBoundary = options.altBoundary,
    _options$flipVariatio = options.flipVariations,
    flipVariations =
      _options$flipVariatio === void 0 ? true : _options$flipVariatio,
    allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements =
    specifiedFallbackPlacements ||
    (isBasePlacement || !flipVariations
      ? [getOppositePlacement(preferredPlacement)]
      : getExpandedFallbackPlacements(preferredPlacement));
  var placements2 = [preferredPlacement]
    .concat(fallbackPlacements)
    .reduce(function (acc, placement2) {
      return acc.concat(
        getBasePlacement(placement2) === auto
          ? computeAutoPlacement(state, {
              placement: placement2,
              boundary,
              rootBoundary,
              padding,
              flipVariations,
              allowedAutoPlacements,
            })
          : placement2
      );
    }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = /* @__PURE__ */ new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements2[0];
  for (var i = 0; i < placements2.length; i++) {
    var placement = placements2[i];
    var _basePlacement = getBasePlacement(placement);
    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? "width" : "height";
    var overflow = detectOverflow(state, {
      placement,
      boundary,
      rootBoundary,
      altBoundary,
      padding,
    });
    var mainVariationSide = isVertical
      ? isStartVariation
        ? right
        : left
      : isStartVariation
      ? bottom
      : top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(
        overflow[mainVariationSide] <= 0,
        overflow[altVariationSide] <= 0
      );
    }
    if (
      checks.every(function (check) {
        return check;
      })
    ) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop2(_i2) {
      var fittingPlacement = placements2.find(function (placement2) {
        var checks2 = checksMap.get(placement2);
        if (checks2) {
          return checks2.slice(0, _i2).every(function (check) {
            return check;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);
      if (_ret === "break") break;
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
}
var flip$1 = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip,
  requiresIfExists: ["offset"],
  data: {
    _skip: false,
  },
};
function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0,
    };
  }
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x,
  };
}
function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function (side) {
    return overflow[side] >= 0;
  });
}
function hide(_ref) {
  var state = _ref.state,
    name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: "reference",
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true,
  });
  var referenceClippingOffsets = getSideOffsets(
    referenceOverflow,
    referenceRect
  );
  var popperEscapeOffsets = getSideOffsets(
    popperAltOverflow,
    popperRect,
    preventedOffsets
  );
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped,
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-reference-hidden": isReferenceHidden,
    "data-popper-escaped": hasPopperEscaped,
  });
}
var hide$1 = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide,
};
function distanceAndSkiddingToXY(placement, rects, offset2) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref =
      typeof offset2 === "function"
        ? offset2(
            Object.assign({}, rects, {
              placement,
            })
          )
        : offset2,
    skidding = _ref[0],
    distance = _ref[1];
  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0
    ? {
        x: distance,
        y: skidding,
      }
    : {
        x: skidding,
        y: distance,
      };
}
function offset(_ref2) {
  var state = _ref2.state,
    options = _ref2.options,
    name = _ref2.name;
  var _options$offset = options.offset,
    offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function (acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement],
    x = _data$state$placement.x,
    y = _data$state$placement.y;
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y;
  }
  state.modifiersData[name] = data;
}
var offset$1 = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset,
};
function popperOffsets(_ref) {
  var state = _ref.state,
    name = _ref.name;
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: "absolute",
    placement: state.placement,
  });
}
var popperOffsets$1 = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {},
};
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function preventOverflow(_ref) {
  var state = _ref.state,
    options = _ref.options,
    name = _ref.name;
  var _options$mainAxis = options.mainAxis,
    checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
    _options$altAxis = options.altAxis,
    checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,
    boundary = options.boundary,
    rootBoundary = options.rootBoundary,
    altBoundary = options.altBoundary,
    padding = options.padding,
    _options$tether = options.tether,
    tether = _options$tether === void 0 ? true : _options$tether,
    _options$tetherOffset = options.tetherOffset,
    tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state, {
    boundary,
    rootBoundary,
    padding,
    altBoundary,
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue =
    typeof tetherOffset === "function"
      ? tetherOffset(
          Object.assign({}, state.rects, {
            placement: state.placement,
          })
        )
      : tetherOffset;
  var normalizedTetherOffsetValue =
    typeof tetherOffsetValue === "number"
      ? {
          mainAxis: tetherOffsetValue,
          altAxis: tetherOffsetValue,
        }
      : Object.assign(
          {
            mainAxis: 0,
            altAxis: 0,
          },
          tetherOffsetValue
        );
  var offsetModifierState = state.modifiersData.offset
    ? state.modifiersData.offset[state.placement]
    : null;
  var data = {
    x: 0,
    y: 0,
  };
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === "y" ? top : left;
    var altSide = mainAxis === "y" ? bottom : right;
    var len = mainAxis === "y" ? "height" : "width";
    var offset2 = popperOffsets2[mainAxis];
    var min$1 = offset2 + overflow[mainSide];
    var max$1 = offset2 - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
    var arrowElement = state.elements.arrow;
    var arrowRect =
      tether && arrowElement
        ? getLayoutRect(arrowElement)
        : {
            width: 0,
            height: 0,
          };
    var arrowPaddingObject = state.modifiersData["arrow#persistent"]
      ? state.modifiersData["arrow#persistent"].padding
      : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide];
    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement
      ? referenceRect[len] / 2 -
        additive -
        arrowLen -
        arrowPaddingMin -
        normalizedTetherOffsetValue.mainAxis
      : minLen -
        arrowLen -
        arrowPaddingMin -
        normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement
      ? -referenceRect[len] / 2 +
        additive +
        arrowLen +
        arrowPaddingMax +
        normalizedTetherOffsetValue.mainAxis
      : maxLen +
        arrowLen +
        arrowPaddingMax +
        normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent =
      state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent
      ? mainAxis === "y"
        ? arrowOffsetParent.clientTop || 0
        : arrowOffsetParent.clientLeft || 0
      : 0;
    var offsetModifierValue =
      (_offsetModifierState$ =
        offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) !=
      null
        ? _offsetModifierState$
        : 0;
    var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset2 + maxOffset - offsetModifierValue;
    var preventedOffset = within(
      tether ? min$5(min$1, tetherMin) : min$1,
      offset2,
      tether ? max$4(max$1, tetherMax) : max$1
    );
    popperOffsets2[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset2;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === "x" ? top : left;
    var _altSide = mainAxis === "x" ? bottom : right;
    var _offset = popperOffsets2[altAxis];
    var _len = altAxis === "y" ? "height" : "width";
    var _min = _offset + overflow[_mainSide];
    var _max = _offset - overflow[_altSide];
    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
    var _offsetModifierValue =
      (_offsetModifierState$2 =
        offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) !=
      null
        ? _offsetModifierState$2
        : 0;
    var _tetherMin = isOriginSide
      ? _min
      : _offset -
        referenceRect[_len] -
        popperRect[_len] -
        _offsetModifierValue +
        normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide
      ? _offset +
        referenceRect[_len] +
        popperRect[_len] -
        _offsetModifierValue -
        normalizedTetherOffsetValue.altAxis
      : _max;
    var _preventedOffset =
      tether && isOriginSide
        ? withinMaxClamp(_tetherMin, _offset, _tetherMax)
        : within(
            tether ? _tetherMin : _min,
            _offset,
            tether ? _tetherMax : _max
          );
    popperOffsets2[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }
  state.modifiersData[name] = data;
}
var preventOverflow$1 = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"],
};
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop,
  };
}
function getNodeScroll(node) {
  if (node === getWindow(node) || !isHTMLElement(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}
function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = round$1(rect.width) / element.offsetWidth || 1;
  var scaleY = round$1(rect.height) / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var offsetParentIsScaled =
    isHTMLElement(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(
    elementOrVirtualElement,
    offsetParentIsScaled
  );
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0,
  };
  var offsets = {
    x: 0,
    y: 0,
  };
  if (isOffsetParentAnElement || (!isOffsetParentAnElement && !isFixed)) {
    if (
      getNodeName(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
      isScrollParent(documentElement)
    ) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height,
  };
}
function order(modifiers) {
  var map = /* @__PURE__ */ new Map();
  var visited = /* @__PURE__ */ new Set();
  var result = [];
  modifiers.forEach(function (modifier) {
    map.set(modifier.name, modifier);
  });
  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(
      modifier.requires || [],
      modifier.requiresIfExists || []
    );
    requires.forEach(function (dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);
        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers.forEach(function (modifier) {
    if (!visited.has(modifier.name)) {
      sort(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers) {
  var orderedModifiers = order(modifiers);
  return modifierPhases.reduce(function (acc, phase) {
    return acc.concat(
      orderedModifiers.filter(function (modifier) {
        return modifier.phase === phase;
      })
    );
  }, []);
}
function debounce(fn6) {
  var pending;
  return function () {
    if (!pending) {
      pending = new Promise(function (resolve) {
        Promise.resolve().then(function () {
          pending = void 0;
          resolve(fn6());
        });
      });
    }
    return pending;
  };
}
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function (merged2, current) {
    var existing = merged2[current.name];
    merged2[current.name] = existing
      ? Object.assign({}, existing, current, {
          options: Object.assign({}, existing.options, current.options),
          data: Object.assign({}, existing.data, current.data),
        })
      : current;
    return merged2;
  }, {});
  return Object.keys(merged).map(function (key) {
    return merged[key];
  });
}
var DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute",
};
function areValidElements() {
  for (
    var _len = arguments.length, args = new Array(_len), _key = 0;
    _key < _len;
    _key++
  ) {
    args[_key] = arguments[_key];
  }
  return !args.some(function (element) {
    return !(element && typeof element.getBoundingClientRect === "function");
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions,
    _generatorOptions$def = _generatorOptions.defaultModifiers,
    defaultModifiers2 =
      _generatorOptions$def === void 0 ? [] : _generatorOptions$def,
    _generatorOptions$def2 = _generatorOptions.defaultOptions,
    defaultOptions =
      _generatorOptions$def2 === void 0
        ? DEFAULT_OPTIONS
        : _generatorOptions$def2;
  return function createPopper2(reference2, popper2, options) {
    if (options === void 0) {
      options = defaultOptions;
    }
    var state = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference2,
        popper: popper2,
      },
      attributes: {},
      styles: {},
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state,
      setOptions: function setOptions(setOptionsAction) {
        var options2 =
          typeof setOptionsAction === "function"
            ? setOptionsAction(state.options)
            : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign(
          {},
          defaultOptions,
          state.options,
          options2
        );
        state.scrollParents = {
          reference: isElement(reference2)
            ? listScrollParents(reference2)
            : reference2.contextElement
            ? listScrollParents(reference2.contextElement)
            : [],
          popper: listScrollParents(popper2),
        };
        var orderedModifiers = orderModifiers(
          mergeByName([].concat(defaultModifiers2, state.options.modifiers))
        );
        state.orderedModifiers = orderedModifiers.filter(function (m) {
          return m.enabled;
        });
        runModifierEffects();
        return instance.update();
      },
      // Sync update  it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state.elements,
          reference3 = _state$elements.reference,
          popper3 = _state$elements.popper;
        if (!areValidElements(reference3, popper3)) {
          return;
        }
        state.rects = {
          reference: getCompositeRect(
            reference3,
            getOffsetParent(popper3),
            state.options.strategy === "fixed"
          ),
          popper: getLayoutRect(popper3),
        };
        state.reset = false;
        state.placement = state.options.placement;
        state.orderedModifiers.forEach(function (modifier) {
          return (state.modifiersData[modifier.name] = Object.assign(
            {},
            modifier.data
          ));
        });
        for (var index = 0; index < state.orderedModifiers.length; index++) {
          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }
          var _state$orderedModifie = state.orderedModifiers[index],
            fn6 = _state$orderedModifie.fn,
            _state$orderedModifie2 = _state$orderedModifie.options,
            _options =
              _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,
            name = _state$orderedModifie.name;
          if (typeof fn6 === "function") {
            state =
              fn6({
                state,
                options: _options,
                name,
                instance,
              }) || state;
          }
        }
      },
      // Async and optimistically optimized update  it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: debounce(function () {
        return new Promise(function (resolve) {
          instance.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      },
    };
    if (!areValidElements(reference2, popper2)) {
      return instance;
    }
    instance.setOptions(options).then(function (state2) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state2);
      }
    });
    function runModifierEffects() {
      state.orderedModifiers.forEach(function (_ref3) {
        var name = _ref3.name,
          _ref3$options = _ref3.options,
          options2 = _ref3$options === void 0 ? {} : _ref3$options,
          effect3 = _ref3.effect;
        if (typeof effect3 === "function") {
          var cleanupFn = effect3({
            state,
            name,
            instance,
            options: options2,
          });
          var noopFn = function noopFn2() {};
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function (fn6) {
        return fn6();
      });
      effectCleanupFns = [];
    }
    return instance;
  };
}
var defaultModifiers = [
  eventListeners,
  popperOffsets$1,
  computeStyles$1,
  applyStyles$1,
  offset$1,
  flip$1,
  preventOverflow$1,
  arrow$1,
  hide$1,
];
var createPopper = /* @__PURE__ */ popperGenerator({
  defaultModifiers,
});
var BOX_CLASS = "tippy-box";
var CONTENT_CLASS = "tippy-content";
var BACKDROP_CLASS = "tippy-backdrop";
var ARROW_CLASS = "tippy-arrow";
var SVG_ARROW_CLASS = "tippy-svg-arrow";
var TOUCH_OPTIONS = {
  passive: true,
  capture: true,
};
var TIPPY_DEFAULT_APPEND_TO = function TIPPY_DEFAULT_APPEND_TO2() {
  return document.body;
};
function getValueAtIndexOrReturn(value, index, defaultValue) {
  if (Array.isArray(value)) {
    var v = value[index];
    return v == null
      ? Array.isArray(defaultValue)
        ? defaultValue[index]
        : defaultValue
      : v;
  }
  return value;
}
function isType(value, type) {
  var str = {}.toString.call(value);
  return str.indexOf("[object") === 0 && str.indexOf(type + "]") > -1;
}
function invokeWithArgsOrReturn(value, args) {
  return typeof value === "function" ? value.apply(void 0, args) : value;
}
function debounce$1(fn6, ms) {
  if (ms === 0) {
    return fn6;
  }
  var timeout;
  return function (arg) {
    clearTimeout(timeout);
    timeout = setTimeout(function () {
      fn6(arg);
    }, ms);
  };
}
function removeProperties(obj, keys) {
  var clone = Object.assign({}, obj);
  keys.forEach(function (key) {
    delete clone[key];
  });
  return clone;
}
function splitBySpaces(value) {
  return value.split(/\s+/).filter(Boolean);
}
function normalizeToArray(value) {
  return [].concat(value);
}
function pushIfUnique(arr, value) {
  if (arr.indexOf(value) === -1) {
    arr.push(value);
  }
}
function unique(arr) {
  return arr.filter(function (item, index) {
    return arr.indexOf(item) === index;
  });
}
function getBasePlacement$1(placement) {
  return placement.split("-")[0];
}
function arrayFrom(value) {
  return [].slice.call(value);
}
function removeUndefinedProps(obj) {
  return Object.keys(obj).reduce(function (acc, key) {
    if (obj[key] !== void 0) {
      acc[key] = obj[key];
    }
    return acc;
  }, {});
}
function div() {
  return document.createElement("div");
}
function isElement$1(value) {
  return ["Element", "Fragment"].some(function (type) {
    return isType(value, type);
  });
}
function isNodeList(value) {
  return isType(value, "NodeList");
}
function isMouseEvent(value) {
  return isType(value, "MouseEvent");
}
function isReferenceElement(value) {
  return !!(value && value._tippy && value._tippy.reference === value);
}
function getArrayOfElements(value) {
  if (isElement$1(value)) {
    return [value];
  }
  if (isNodeList(value)) {
    return arrayFrom(value);
  }
  if (Array.isArray(value)) {
    return value;
  }
  return arrayFrom(document.querySelectorAll(value));
}
function setTransitionDuration(els, value) {
  els.forEach(function (el) {
    if (el) {
      el.style.transitionDuration = value + "ms";
    }
  });
}
function setVisibilityState(els, state) {
  els.forEach(function (el) {
    if (el) {
      el.setAttribute("data-state", state);
    }
  });
}
function getOwnerDocument(elementOrElements) {
  var _element$ownerDocumen;
  var _normalizeToArray = normalizeToArray(elementOrElements),
    element = _normalizeToArray[0];
  return element != null &&
    (_element$ownerDocumen = element.ownerDocument) != null &&
    _element$ownerDocumen.body
    ? element.ownerDocument
    : document;
}
function isCursorOutsideInteractiveBorder(popperTreeData, event) {
  var clientX = event.clientX,
    clientY = event.clientY;
  return popperTreeData.every(function (_ref) {
    var popperRect = _ref.popperRect,
      popperState = _ref.popperState,
      props2 = _ref.props;
    var interactiveBorder = props2.interactiveBorder;
    var basePlacement = getBasePlacement$1(popperState.placement);
    var offsetData = popperState.modifiersData.offset;
    if (!offsetData) {
      return true;
    }
    var topDistance = basePlacement === "bottom" ? offsetData.top.y : 0;
    var bottomDistance = basePlacement === "top" ? offsetData.bottom.y : 0;
    var leftDistance = basePlacement === "right" ? offsetData.left.x : 0;
    var rightDistance = basePlacement === "left" ? offsetData.right.x : 0;
    var exceedsTop = popperRect.top - clientY + topDistance > interactiveBorder;
    var exceedsBottom =
      clientY - popperRect.bottom - bottomDistance > interactiveBorder;
    var exceedsLeft =
      popperRect.left - clientX + leftDistance > interactiveBorder;
    var exceedsRight =
      clientX - popperRect.right - rightDistance > interactiveBorder;
    return exceedsTop || exceedsBottom || exceedsLeft || exceedsRight;
  });
}
function updateTransitionEndListener(box, action, listener) {
  var method = action + "EventListener";
  ["transitionend", "webkitTransitionEnd"].forEach(function (event) {
    box[method](event, listener);
  });
}
function actualContains(parent, child) {
  var target = child;
  while (target) {
    var _target$getRootNode;
    if (parent.contains(target)) {
      return true;
    }
    target =
      target.getRootNode == null
        ? void 0
        : (_target$getRootNode = target.getRootNode()) == null
        ? void 0
        : _target$getRootNode.host;
  }
  return false;
}
var currentInput = {
  isTouch: false,
};
var lastMouseMoveTime = 0;
function onDocumentTouchStart() {
  if (currentInput.isTouch) {
    return;
  }
  currentInput.isTouch = true;
  if (window.performance) {
    document.addEventListener("mousemove", onDocumentMouseMove);
  }
}
function onDocumentMouseMove() {
  var now = performance.now();
  if (now - lastMouseMoveTime < 20) {
    currentInput.isTouch = false;
    document.removeEventListener("mousemove", onDocumentMouseMove);
  }
  lastMouseMoveTime = now;
}
function onWindowBlur() {
  var activeElement = document.activeElement;
  if (isReferenceElement(activeElement)) {
    var instance = activeElement._tippy;
    if (activeElement.blur && !instance.state.isVisible) {
      activeElement.blur();
    }
  }
}
function bindGlobalEventListeners() {
  document.addEventListener("touchstart", onDocumentTouchStart, TOUCH_OPTIONS);
  window.addEventListener("blur", onWindowBlur);
}
var isBrowser =
  typeof window !== "undefined" && typeof document !== "undefined";
var isIE11 = isBrowser
  ? // @ts-ignore
    !!window.msCrypto
  : false;
var pluginProps = {
  animateFill: false,
  followCursor: false,
  inlinePositioning: false,
  sticky: false,
};
var renderProps = {
  allowHTML: false,
  animation: "fade",
  arrow: true,
  content: "",
  inertia: false,
  maxWidth: 350,
  role: "tooltip",
  theme: "",
  zIndex: 9999,
};
var defaultProps = Object.assign(
  {
    appendTo: TIPPY_DEFAULT_APPEND_TO,
    aria: {
      content: "auto",
      expanded: "auto",
    },
    delay: 0,
    duration: [300, 250],
    getReferenceClientRect: null,
    hideOnClick: true,
    ignoreAttributes: false,
    interactive: false,
    interactiveBorder: 2,
    interactiveDebounce: 0,
    moveTransition: "",
    offset: [0, 10],
    onAfterUpdate: function onAfterUpdate() {},
    onBeforeUpdate: function onBeforeUpdate() {},
    onCreate: function onCreate() {},
    onDestroy: function onDestroy() {},
    onHidden: function onHidden() {},
    onHide: function onHide() {},
    onMount: function onMount() {},
    onShow: function onShow() {},
    onShown: function onShown() {},
    onTrigger: function onTrigger() {},
    onUntrigger: function onUntrigger() {},
    onClickOutside: function onClickOutside() {},
    placement: "top",
    plugins: [],
    popperOptions: {},
    render: null,
    showOnCreate: false,
    touch: true,
    trigger: "mouseenter focus",
    triggerTarget: null,
  },
  pluginProps,
  renderProps
);
var defaultKeys = Object.keys(defaultProps);
var setDefaultProps = function setDefaultProps2(partialProps) {
  var keys = Object.keys(partialProps);
  keys.forEach(function (key) {
    defaultProps[key] = partialProps[key];
  });
};
function getExtendedPassedProps(passedProps) {
  var plugins = passedProps.plugins || [];
  var pluginProps2 = plugins.reduce(function (acc, plugin2) {
    var name = plugin2.name,
      defaultValue = plugin2.defaultValue;
    if (name) {
      var _name;
      acc[name] =
        passedProps[name] !== void 0
          ? passedProps[name]
          : (_name = defaultProps[name]) != null
          ? _name
          : defaultValue;
    }
    return acc;
  }, {});
  return Object.assign({}, passedProps, pluginProps2);
}
function getDataAttributeProps(reference2, plugins) {
  var propKeys = plugins
    ? Object.keys(
        getExtendedPassedProps(
          Object.assign({}, defaultProps, {
            plugins,
          })
        )
      )
    : defaultKeys;
  var props2 = propKeys.reduce(function (acc, key) {
    var valueAsString = (
      reference2.getAttribute("data-tippy-" + key) || ""
    ).trim();
    if (!valueAsString) {
      return acc;
    }
    if (key === "content") {
      acc[key] = valueAsString;
    } else {
      try {
        acc[key] = JSON.parse(valueAsString);
      } catch (e) {
        acc[key] = valueAsString;
      }
    }
    return acc;
  }, {});
  return props2;
}
function evaluateProps(reference2, props2) {
  var out = Object.assign(
    {},
    props2,
    {
      content: invokeWithArgsOrReturn(props2.content, [reference2]),
    },
    props2.ignoreAttributes
      ? {}
      : getDataAttributeProps(reference2, props2.plugins)
  );
  out.aria = Object.assign({}, defaultProps.aria, out.aria);
  out.aria = {
    expanded:
      out.aria.expanded === "auto" ? props2.interactive : out.aria.expanded,
    content:
      out.aria.content === "auto"
        ? props2.interactive
          ? null
          : "describedby"
        : out.aria.content,
  };
  return out;
}
var innerHTML = function innerHTML2() {
  return "innerHTML";
};
function dangerouslySetInnerHTML(element, html) {
  element[innerHTML()] = html;
}
function createArrowElement(value) {
  var arrow2 = div();
  if (value === true) {
    arrow2.className = ARROW_CLASS;
  } else {
    arrow2.className = SVG_ARROW_CLASS;
    if (isElement$1(value)) {
      arrow2.appendChild(value);
    } else {
      dangerouslySetInnerHTML(arrow2, value);
    }
  }
  return arrow2;
}
function setContent(content, props2) {
  if (isElement$1(props2.content)) {
    dangerouslySetInnerHTML(content, "");
    content.appendChild(props2.content);
  } else if (typeof props2.content !== "function") {
    if (props2.allowHTML) {
      dangerouslySetInnerHTML(content, props2.content);
    } else {
      content.textContent = props2.content;
    }
  }
}
function getChildren(popper2) {
  var box = popper2.firstElementChild;
  var boxChildren = arrayFrom(box.children);
  return {
    box,
    content: boxChildren.find(function (node) {
      return node.classList.contains(CONTENT_CLASS);
    }),
    arrow: boxChildren.find(function (node) {
      return (
        node.classList.contains(ARROW_CLASS) ||
        node.classList.contains(SVG_ARROW_CLASS)
      );
    }),
    backdrop: boxChildren.find(function (node) {
      return node.classList.contains(BACKDROP_CLASS);
    }),
  };
}
function render(instance) {
  var popper2 = div();
  var box = div();
  box.className = BOX_CLASS;
  box.setAttribute("data-state", "hidden");
  box.setAttribute("tabindex", "-1");
  var content = div();
  content.className = CONTENT_CLASS;
  content.setAttribute("data-state", "hidden");
  setContent(content, instance.props);
  popper2.appendChild(box);
  box.appendChild(content);
  onUpdate(instance.props, instance.props);
  function onUpdate(prevProps, nextProps) {
    var _getChildren = getChildren(popper2),
      box2 = _getChildren.box,
      content2 = _getChildren.content,
      arrow2 = _getChildren.arrow;
    if (nextProps.theme) {
      box2.setAttribute("data-theme", nextProps.theme);
    } else {
      box2.removeAttribute("data-theme");
    }
    if (typeof nextProps.animation === "string") {
      box2.setAttribute("data-animation", nextProps.animation);
    } else {
      box2.removeAttribute("data-animation");
    }
    if (nextProps.inertia) {
      box2.setAttribute("data-inertia", "");
    } else {
      box2.removeAttribute("data-inertia");
    }
    box2.style.maxWidth =
      typeof nextProps.maxWidth === "number"
        ? nextProps.maxWidth + "px"
        : nextProps.maxWidth;
    if (nextProps.role) {
      box2.setAttribute("role", nextProps.role);
    } else {
      box2.removeAttribute("role");
    }
    if (
      prevProps.content !== nextProps.content ||
      prevProps.allowHTML !== nextProps.allowHTML
    ) {
      setContent(content2, instance.props);
    }
    if (nextProps.arrow) {
      if (!arrow2) {
        box2.appendChild(createArrowElement(nextProps.arrow));
      } else if (prevProps.arrow !== nextProps.arrow) {
        box2.removeChild(arrow2);
        box2.appendChild(createArrowElement(nextProps.arrow));
      }
    } else if (arrow2) {
      box2.removeChild(arrow2);
    }
  }
  return {
    popper: popper2,
    onUpdate,
  };
}
render.$$tippy = true;
var idCounter = 1;
var mouseMoveListeners = [];
var mountedInstances = [];
function createTippy(reference2, passedProps) {
  var props2 = evaluateProps(
    reference2,
    Object.assign(
      {},
      defaultProps,
      getExtendedPassedProps(removeUndefinedProps(passedProps))
    )
  );
  var showTimeout;
  var hideTimeout;
  var scheduleHideAnimationFrame;
  var isVisibleFromClick = false;
  var didHideDueToDocumentMouseDown = false;
  var didTouchMove = false;
  var ignoreOnFirstUpdate = false;
  var lastTriggerEvent;
  var currentTransitionEndListener;
  var onFirstUpdate;
  var listeners = [];
  var debouncedOnMouseMove = debounce$1(
    onMouseMove,
    props2.interactiveDebounce
  );
  var currentTarget;
  var id = idCounter++;
  var popperInstance = null;
  var plugins = unique(props2.plugins);
  var state = {
    // Is the instance currently enabled?
    isEnabled: true,
    // Is the tippy currently showing and not transitioning out?
    isVisible: false,
    // Has the instance been destroyed?
    isDestroyed: false,
    // Is the tippy currently mounted to the DOM?
    isMounted: false,
    // Has the tippy finished transitioning in?
    isShown: false,
  };
  var instance = {
    // properties
    id,
    reference: reference2,
    popper: div(),
    popperInstance,
    props: props2,
    state,
    plugins,
    // methods
    clearDelayTimeouts,
    setProps,
    setContent: setContent2,
    show,
    hide: hide2,
    hideWithInteractivity,
    enable,
    disable,
    unmount,
    destroy,
  };
  if (!props2.render) {
    return instance;
  }
  var _props$render = props2.render(instance),
    popper2 = _props$render.popper,
    onUpdate = _props$render.onUpdate;
  popper2.setAttribute("data-tippy-root", "");
  popper2.id = "tippy-" + instance.id;
  instance.popper = popper2;
  reference2._tippy = instance;
  popper2._tippy = instance;
  var pluginsHooks = plugins.map(function (plugin2) {
    return plugin2.fn(instance);
  });
  var hasAriaExpanded = reference2.hasAttribute("aria-expanded");
  addListeners();
  handleAriaExpandedAttribute();
  handleStyles();
  invokeHook("onCreate", [instance]);
  if (props2.showOnCreate) {
    scheduleShow();
  }
  popper2.addEventListener("mouseenter", function () {
    if (instance.props.interactive && instance.state.isVisible) {
      instance.clearDelayTimeouts();
    }
  });
  popper2.addEventListener("mouseleave", function () {
    if (
      instance.props.interactive &&
      instance.props.trigger.indexOf("mouseenter") >= 0
    ) {
      getDocument().addEventListener("mousemove", debouncedOnMouseMove);
    }
  });
  return instance;
  function getNormalizedTouchSettings() {
    var touch = instance.props.touch;
    return Array.isArray(touch) ? touch : [touch, 0];
  }
  function getIsCustomTouchBehavior() {
    return getNormalizedTouchSettings()[0] === "hold";
  }
  function getIsDefaultRenderFn() {
    var _instance$props$rende;
    return !!(
      (_instance$props$rende = instance.props.render) != null &&
      _instance$props$rende.$$tippy
    );
  }
  function getCurrentTarget() {
    return currentTarget || reference2;
  }
  function getDocument() {
    var parent = getCurrentTarget().parentNode;
    return parent ? getOwnerDocument(parent) : document;
  }
  function getDefaultTemplateChildren() {
    return getChildren(popper2);
  }
  function getDelay(isShow) {
    if (
      (instance.state.isMounted && !instance.state.isVisible) ||
      currentInput.isTouch ||
      (lastTriggerEvent && lastTriggerEvent.type === "focus")
    ) {
      return 0;
    }
    return getValueAtIndexOrReturn(
      instance.props.delay,
      isShow ? 0 : 1,
      defaultProps.delay
    );
  }
  function handleStyles(fromHide) {
    if (fromHide === void 0) {
      fromHide = false;
    }
    popper2.style.pointerEvents =
      instance.props.interactive && !fromHide ? "" : "none";
    popper2.style.zIndex = "" + instance.props.zIndex;
  }
  function invokeHook(hook, args, shouldInvokePropsHook) {
    if (shouldInvokePropsHook === void 0) {
      shouldInvokePropsHook = true;
    }
    pluginsHooks.forEach(function (pluginHooks) {
      if (pluginHooks[hook]) {
        pluginHooks[hook].apply(pluginHooks, args);
      }
    });
    if (shouldInvokePropsHook) {
      var _instance$props;
      (_instance$props = instance.props)[hook].apply(_instance$props, args);
    }
  }
  function handleAriaContentAttribute() {
    var aria = instance.props.aria;
    if (!aria.content) {
      return;
    }
    var attr = "aria-" + aria.content;
    var id2 = popper2.id;
    var nodes = normalizeToArray(instance.props.triggerTarget || reference2);
    nodes.forEach(function (node) {
      var currentValue = node.getAttribute(attr);
      if (instance.state.isVisible) {
        node.setAttribute(attr, currentValue ? currentValue + " " + id2 : id2);
      } else {
        var nextValue = currentValue && currentValue.replace(id2, "").trim();
        if (nextValue) {
          node.setAttribute(attr, nextValue);
        } else {
          node.removeAttribute(attr);
        }
      }
    });
  }
  function handleAriaExpandedAttribute() {
    if (hasAriaExpanded || !instance.props.aria.expanded) {
      return;
    }
    var nodes = normalizeToArray(instance.props.triggerTarget || reference2);
    nodes.forEach(function (node) {
      if (instance.props.interactive) {
        node.setAttribute(
          "aria-expanded",
          instance.state.isVisible && node === getCurrentTarget()
            ? "true"
            : "false"
        );
      } else {
        node.removeAttribute("aria-expanded");
      }
    });
  }
  function cleanupInteractiveMouseListeners() {
    getDocument().removeEventListener("mousemove", debouncedOnMouseMove);
    mouseMoveListeners = mouseMoveListeners.filter(function (listener) {
      return listener !== debouncedOnMouseMove;
    });
  }
  function onDocumentPress(event) {
    if (currentInput.isTouch) {
      if (didTouchMove || event.type === "mousedown") {
        return;
      }
    }
    var actualTarget =
      (event.composedPath && event.composedPath()[0]) || event.target;
    if (instance.props.interactive && actualContains(popper2, actualTarget)) {
      return;
    }
    if (
      normalizeToArray(instance.props.triggerTarget || reference2).some(
        function (el) {
          return actualContains(el, actualTarget);
        }
      )
    ) {
      if (currentInput.isTouch) {
        return;
      }
      if (
        instance.state.isVisible &&
        instance.props.trigger.indexOf("click") >= 0
      ) {
        return;
      }
    } else {
      invokeHook("onClickOutside", [instance, event]);
    }
    if (instance.props.hideOnClick === true) {
      instance.clearDelayTimeouts();
      instance.hide();
      didHideDueToDocumentMouseDown = true;
      setTimeout(function () {
        didHideDueToDocumentMouseDown = false;
      });
      if (!instance.state.isMounted) {
        removeDocumentPress();
      }
    }
  }
  function onTouchMove() {
    didTouchMove = true;
  }
  function onTouchStart() {
    didTouchMove = false;
  }
  function addDocumentPress() {
    var doc = getDocument();
    doc.addEventListener("mousedown", onDocumentPress, true);
    doc.addEventListener("touchend", onDocumentPress, TOUCH_OPTIONS);
    doc.addEventListener("touchstart", onTouchStart, TOUCH_OPTIONS);
    doc.addEventListener("touchmove", onTouchMove, TOUCH_OPTIONS);
  }
  function removeDocumentPress() {
    var doc = getDocument();
    doc.removeEventListener("mousedown", onDocumentPress, true);
    doc.removeEventListener("touchend", onDocumentPress, TOUCH_OPTIONS);
    doc.removeEventListener("touchstart", onTouchStart, TOUCH_OPTIONS);
    doc.removeEventListener("touchmove", onTouchMove, TOUCH_OPTIONS);
  }
  function onTransitionedOut(duration, callback) {
    onTransitionEnd(duration, function () {
      if (
        !instance.state.isVisible &&
        popper2.parentNode &&
        popper2.parentNode.contains(popper2)
      ) {
        callback();
      }
    });
  }
  function onTransitionedIn(duration, callback) {
    onTransitionEnd(duration, callback);
  }
  function onTransitionEnd(duration, callback) {
    var box = getDefaultTemplateChildren().box;
    function listener(event) {
      if (event.target === box) {
        updateTransitionEndListener(box, "remove", listener);
        callback();
      }
    }
    if (duration === 0) {
      return callback();
    }
    updateTransitionEndListener(box, "remove", currentTransitionEndListener);
    updateTransitionEndListener(box, "add", listener);
    currentTransitionEndListener = listener;
  }
  function on(eventType, handler, options) {
    if (options === void 0) {
      options = false;
    }
    var nodes = normalizeToArray(instance.props.triggerTarget || reference2);
    nodes.forEach(function (node) {
      node.addEventListener(eventType, handler, options);
      listeners.push({
        node,
        eventType,
        handler,
        options,
      });
    });
  }
  function addListeners() {
    if (getIsCustomTouchBehavior()) {
      on("touchstart", onTrigger2, {
        passive: true,
      });
      on("touchend", onMouseLeave, {
        passive: true,
      });
    }
    splitBySpaces(instance.props.trigger).forEach(function (eventType) {
      if (eventType === "manual") {
        return;
      }
      on(eventType, onTrigger2);
      switch (eventType) {
        case "mouseenter":
          on("mouseleave", onMouseLeave);
          break;
        case "focus":
          on(isIE11 ? "focusout" : "blur", onBlurOrFocusOut);
          break;
        case "focusin":
          on("focusout", onBlurOrFocusOut);
          break;
      }
    });
  }
  function removeListeners() {
    listeners.forEach(function (_ref) {
      var node = _ref.node,
        eventType = _ref.eventType,
        handler = _ref.handler,
        options = _ref.options;
      node.removeEventListener(eventType, handler, options);
    });
    listeners = [];
  }
  function onTrigger2(event) {
    var _lastTriggerEvent;
    var shouldScheduleClickHide = false;
    if (
      !instance.state.isEnabled ||
      isEventListenerStopped(event) ||
      didHideDueToDocumentMouseDown
    ) {
      return;
    }
    var wasFocused =
      ((_lastTriggerEvent = lastTriggerEvent) == null
        ? void 0
        : _lastTriggerEvent.type) === "focus";
    lastTriggerEvent = event;
    currentTarget = event.currentTarget;
    handleAriaExpandedAttribute();
    if (!instance.state.isVisible && isMouseEvent(event)) {
      mouseMoveListeners.forEach(function (listener) {
        return listener(event);
      });
    }
    if (
      event.type === "click" &&
      (instance.props.trigger.indexOf("mouseenter") < 0 ||
        isVisibleFromClick) &&
      instance.props.hideOnClick !== false &&
      instance.state.isVisible
    ) {
      shouldScheduleClickHide = true;
    } else {
      scheduleShow(event);
    }
    if (event.type === "click") {
      isVisibleFromClick = !shouldScheduleClickHide;
    }
    if (shouldScheduleClickHide && !wasFocused) {
      scheduleHide(event);
    }
  }
  function onMouseMove(event) {
    var target = event.target;
    var isCursorOverReferenceOrPopper =
      getCurrentTarget().contains(target) || popper2.contains(target);
    if (event.type === "mousemove" && isCursorOverReferenceOrPopper) {
      return;
    }
    var popperTreeData = getNestedPopperTree()
      .concat(popper2)
      .map(function (popper3) {
        var _instance$popperInsta;
        var instance2 = popper3._tippy;
        var state2 =
          (_instance$popperInsta = instance2.popperInstance) == null
            ? void 0
            : _instance$popperInsta.state;
        if (state2) {
          return {
            popperRect: popper3.getBoundingClientRect(),
            popperState: state2,
            props: props2,
          };
        }
        return null;
      })
      .filter(Boolean);
    if (isCursorOutsideInteractiveBorder(popperTreeData, event)) {
      cleanupInteractiveMouseListeners();
      scheduleHide(event);
    }
  }
  function onMouseLeave(event) {
    var shouldBail =
      isEventListenerStopped(event) ||
      (instance.props.trigger.indexOf("click") >= 0 && isVisibleFromClick);
    if (shouldBail) {
      return;
    }
    if (instance.props.interactive) {
      instance.hideWithInteractivity(event);
      return;
    }
    scheduleHide(event);
  }
  function onBlurOrFocusOut(event) {
    if (
      instance.props.trigger.indexOf("focusin") < 0 &&
      event.target !== getCurrentTarget()
    ) {
      return;
    }
    if (
      instance.props.interactive &&
      event.relatedTarget &&
      popper2.contains(event.relatedTarget)
    ) {
      return;
    }
    scheduleHide(event);
  }
  function isEventListenerStopped(event) {
    return currentInput.isTouch
      ? getIsCustomTouchBehavior() !== event.type.indexOf("touch") >= 0
      : false;
  }
  function createPopperInstance() {
    destroyPopperInstance();
    var _instance$props2 = instance.props,
      popperOptions = _instance$props2.popperOptions,
      placement = _instance$props2.placement,
      offset2 = _instance$props2.offset,
      getReferenceClientRect = _instance$props2.getReferenceClientRect,
      moveTransition = _instance$props2.moveTransition;
    var arrow2 = getIsDefaultRenderFn() ? getChildren(popper2).arrow : null;
    var computedReference = getReferenceClientRect
      ? {
          getBoundingClientRect: getReferenceClientRect,
          contextElement:
            getReferenceClientRect.contextElement || getCurrentTarget(),
        }
      : reference2;
    var tippyModifier = {
      name: "$$tippy",
      enabled: true,
      phase: "beforeWrite",
      requires: ["computeStyles"],
      fn: function fn6(_ref2) {
        var state2 = _ref2.state;
        if (getIsDefaultRenderFn()) {
          var _getDefaultTemplateCh = getDefaultTemplateChildren(),
            box = _getDefaultTemplateCh.box;
          ["placement", "reference-hidden", "escaped"].forEach(function (attr) {
            if (attr === "placement") {
              box.setAttribute("data-placement", state2.placement);
            } else {
              if (state2.attributes.popper["data-popper-" + attr]) {
                box.setAttribute("data-" + attr, "");
              } else {
                box.removeAttribute("data-" + attr);
              }
            }
          });
          state2.attributes.popper = {};
        }
      },
    };
    var modifiers = [
      {
        name: "offset",
        options: {
          offset: offset2,
        },
      },
      {
        name: "preventOverflow",
        options: {
          padding: {
            top: 2,
            bottom: 2,
            left: 5,
            right: 5,
          },
        },
      },
      {
        name: "flip",
        options: {
          padding: 5,
        },
      },
      {
        name: "computeStyles",
        options: {
          adaptive: !moveTransition,
        },
      },
      tippyModifier,
    ];
    if (getIsDefaultRenderFn() && arrow2) {
      modifiers.push({
        name: "arrow",
        options: {
          element: arrow2,
          padding: 3,
        },
      });
    }
    modifiers.push.apply(
      modifiers,
      (popperOptions == null ? void 0 : popperOptions.modifiers) || []
    );
    instance.popperInstance = createPopper(
      computedReference,
      popper2,
      Object.assign({}, popperOptions, {
        placement,
        onFirstUpdate,
        modifiers,
      })
    );
  }
  function destroyPopperInstance() {
    if (instance.popperInstance) {
      instance.popperInstance.destroy();
      instance.popperInstance = null;
    }
  }
  function mount() {
    var appendTo = instance.props.appendTo;
    var parentNode;
    var node = getCurrentTarget();
    if (
      (instance.props.interactive && appendTo === TIPPY_DEFAULT_APPEND_TO) ||
      appendTo === "parent"
    ) {
      parentNode = node.parentNode;
    } else {
      parentNode = invokeWithArgsOrReturn(appendTo, [node]);
    }
    if (!parentNode.contains(popper2)) {
      parentNode.appendChild(popper2);
    }
    instance.state.isMounted = true;
    createPopperInstance();
  }
  function getNestedPopperTree() {
    return arrayFrom(popper2.querySelectorAll("[data-tippy-root]"));
  }
  function scheduleShow(event) {
    instance.clearDelayTimeouts();
    if (event) {
      invokeHook("onTrigger", [instance, event]);
    }
    addDocumentPress();
    var delay = getDelay(true);
    var _getNormalizedTouchSe = getNormalizedTouchSettings(),
      touchValue = _getNormalizedTouchSe[0],
      touchDelay = _getNormalizedTouchSe[1];
    if (currentInput.isTouch && touchValue === "hold" && touchDelay) {
      delay = touchDelay;
    }
    if (delay) {
      showTimeout = setTimeout(function () {
        instance.show();
      }, delay);
    } else {
      instance.show();
    }
  }
  function scheduleHide(event) {
    instance.clearDelayTimeouts();
    invokeHook("onUntrigger", [instance, event]);
    if (!instance.state.isVisible) {
      removeDocumentPress();
      return;
    }
    if (
      instance.props.trigger.indexOf("mouseenter") >= 0 &&
      instance.props.trigger.indexOf("click") >= 0 &&
      ["mouseleave", "mousemove"].indexOf(event.type) >= 0 &&
      isVisibleFromClick
    ) {
      return;
    }
    var delay = getDelay(false);
    if (delay) {
      hideTimeout = setTimeout(function () {
        if (instance.state.isVisible) {
          instance.hide();
        }
      }, delay);
    } else {
      scheduleHideAnimationFrame = requestAnimationFrame(function () {
        instance.hide();
      });
    }
  }
  function enable() {
    instance.state.isEnabled = true;
  }
  function disable() {
    instance.hide();
    instance.state.isEnabled = false;
  }
  function clearDelayTimeouts() {
    clearTimeout(showTimeout);
    clearTimeout(hideTimeout);
    cancelAnimationFrame(scheduleHideAnimationFrame);
  }
  function setProps(partialProps) {
    if (instance.state.isDestroyed) {
      return;
    }
    invokeHook("onBeforeUpdate", [instance, partialProps]);
    removeListeners();
    var prevProps = instance.props;
    var nextProps = evaluateProps(
      reference2,
      Object.assign({}, prevProps, removeUndefinedProps(partialProps), {
        ignoreAttributes: true,
      })
    );
    instance.props = nextProps;
    addListeners();
    if (prevProps.interactiveDebounce !== nextProps.interactiveDebounce) {
      cleanupInteractiveMouseListeners();
      debouncedOnMouseMove = debounce$1(
        onMouseMove,
        nextProps.interactiveDebounce
      );
    }
    if (prevProps.triggerTarget && !nextProps.triggerTarget) {
      normalizeToArray(prevProps.triggerTarget).forEach(function (node) {
        node.removeAttribute("aria-expanded");
      });
    } else if (nextProps.triggerTarget) {
      reference2.removeAttribute("aria-expanded");
    }
    handleAriaExpandedAttribute();
    handleStyles();
    if (onUpdate) {
      onUpdate(prevProps, nextProps);
    }
    if (instance.popperInstance) {
      createPopperInstance();
      getNestedPopperTree().forEach(function (nestedPopper) {
        requestAnimationFrame(nestedPopper._tippy.popperInstance.forceUpdate);
      });
    }
    invokeHook("onAfterUpdate", [instance, partialProps]);
  }
  function setContent2(content) {
    instance.setProps({
      content,
    });
  }
  function show() {
    var isAlreadyVisible = instance.state.isVisible;
    var isDestroyed = instance.state.isDestroyed;
    var isDisabled = !instance.state.isEnabled;
    var isTouchAndTouchDisabled = currentInput.isTouch && !instance.props.touch;
    var duration = getValueAtIndexOrReturn(
      instance.props.duration,
      0,
      defaultProps.duration
    );
    if (
      isAlreadyVisible ||
      isDestroyed ||
      isDisabled ||
      isTouchAndTouchDisabled
    ) {
      return;
    }
    if (getCurrentTarget().hasAttribute("disabled")) {
      return;
    }
    invokeHook("onShow", [instance], false);
    if (instance.props.onShow(instance) === false) {
      return;
    }
    instance.state.isVisible = true;
    if (getIsDefaultRenderFn()) {
      popper2.style.visibility = "visible";
    }
    handleStyles();
    addDocumentPress();
    if (!instance.state.isMounted) {
      popper2.style.transition = "none";
    }
    if (getIsDefaultRenderFn()) {
      var _getDefaultTemplateCh2 = getDefaultTemplateChildren(),
        box = _getDefaultTemplateCh2.box,
        content = _getDefaultTemplateCh2.content;
      setTransitionDuration([box, content], 0);
    }
    onFirstUpdate = function onFirstUpdate2() {
      var _instance$popperInsta2;
      if (!instance.state.isVisible || ignoreOnFirstUpdate) {
        return;
      }
      ignoreOnFirstUpdate = true;
      void popper2.offsetHeight;
      popper2.style.transition = instance.props.moveTransition;
      if (getIsDefaultRenderFn() && instance.props.animation) {
        var _getDefaultTemplateCh3 = getDefaultTemplateChildren(),
          _box = _getDefaultTemplateCh3.box,
          _content = _getDefaultTemplateCh3.content;
        setTransitionDuration([_box, _content], duration);
        setVisibilityState([_box, _content], "visible");
      }
      handleAriaContentAttribute();
      handleAriaExpandedAttribute();
      pushIfUnique(mountedInstances, instance);
      (_instance$popperInsta2 = instance.popperInstance) == null
        ? void 0
        : _instance$popperInsta2.forceUpdate();
      invokeHook("onMount", [instance]);
      if (instance.props.animation && getIsDefaultRenderFn()) {
        onTransitionedIn(duration, function () {
          instance.state.isShown = true;
          invokeHook("onShown", [instance]);
        });
      }
    };
    mount();
  }
  function hide2() {
    var isAlreadyHidden = !instance.state.isVisible;
    var isDestroyed = instance.state.isDestroyed;
    var isDisabled = !instance.state.isEnabled;
    var duration = getValueAtIndexOrReturn(
      instance.props.duration,
      1,
      defaultProps.duration
    );
    if (isAlreadyHidden || isDestroyed || isDisabled) {
      return;
    }
    invokeHook("onHide", [instance], false);
    if (instance.props.onHide(instance) === false) {
      return;
    }
    instance.state.isVisible = false;
    instance.state.isShown = false;
    ignoreOnFirstUpdate = false;
    isVisibleFromClick = false;
    if (getIsDefaultRenderFn()) {
      popper2.style.visibility = "hidden";
    }
    cleanupInteractiveMouseListeners();
    removeDocumentPress();
    handleStyles(true);
    if (getIsDefaultRenderFn()) {
      var _getDefaultTemplateCh4 = getDefaultTemplateChildren(),
        box = _getDefaultTemplateCh4.box,
        content = _getDefaultTemplateCh4.content;
      if (instance.props.animation) {
        setTransitionDuration([box, content], duration);
        setVisibilityState([box, content], "hidden");
      }
    }
    handleAriaContentAttribute();
    handleAriaExpandedAttribute();
    if (instance.props.animation) {
      if (getIsDefaultRenderFn()) {
        onTransitionedOut(duration, instance.unmount);
      }
    } else {
      instance.unmount();
    }
  }
  function hideWithInteractivity(event) {
    getDocument().addEventListener("mousemove", debouncedOnMouseMove);
    pushIfUnique(mouseMoveListeners, debouncedOnMouseMove);
    debouncedOnMouseMove(event);
  }
  function unmount() {
    if (instance.state.isVisible) {
      instance.hide();
    }
    if (!instance.state.isMounted) {
      return;
    }
    destroyPopperInstance();
    getNestedPopperTree().forEach(function (nestedPopper) {
      nestedPopper._tippy.unmount();
    });
    if (popper2.parentNode) {
      popper2.parentNode.removeChild(popper2);
    }
    mountedInstances = mountedInstances.filter(function (i) {
      return i !== instance;
    });
    instance.state.isMounted = false;
    invokeHook("onHidden", [instance]);
  }
  function destroy() {
    if (instance.state.isDestroyed) {
      return;
    }
    instance.clearDelayTimeouts();
    instance.unmount();
    removeListeners();
    delete reference2._tippy;
    instance.state.isDestroyed = true;
    invokeHook("onDestroy", [instance]);
  }
}
function tippy$1(targets, optionalProps) {
  if (optionalProps === void 0) {
    optionalProps = {};
  }
  var plugins = defaultProps.plugins.concat(optionalProps.plugins || []);
  bindGlobalEventListeners();
  var passedProps = Object.assign({}, optionalProps, {
    plugins,
  });
  var elements = getArrayOfElements(targets);
  var instances = elements.reduce(function (acc, reference2) {
    var instance = reference2 && createTippy(reference2, passedProps);
    if (instance) {
      acc.push(instance);
    }
    return acc;
  }, []);
  return isElement$1(targets) ? instances[0] : instances;
}
tippy$1.defaultProps = defaultProps;
tippy$1.setDefaultProps = setDefaultProps;
tippy$1.currentInput = currentInput;
var applyStylesModifier = Object.assign({}, applyStyles$1, {
  effect: function effect2(_ref) {
    var state = _ref.state;
    var initialStyles = {
      popper: {
        position: state.options.strategy,
        left: "0",
        top: "0",
        margin: "0",
      },
      arrow: {
        position: "absolute",
      },
      reference: {},
    };
    Object.assign(state.elements.popper.style, initialStyles.popper);
    state.styles = initialStyles;
    if (state.elements.arrow) {
      Object.assign(state.elements.arrow.style, initialStyles.arrow);
    }
  },
});
var createSingleton = function createSingleton2(tippyInstances, optionalProps) {
  var _optionalProps$popper;
  if (optionalProps === void 0) {
    optionalProps = {};
  }
  var individualInstances = tippyInstances;
  var references = [];
  var triggerTargets = [];
  var currentTarget;
  var overrides = optionalProps.overrides;
  var interceptSetPropsCleanups = [];
  var shownOnCreate = false;
  function setTriggerTargets() {
    triggerTargets = individualInstances
      .map(function (instance) {
        return normalizeToArray(
          instance.props.triggerTarget || instance.reference
        );
      })
      .reduce(function (acc, item) {
        return acc.concat(item);
      }, []);
  }
  function setReferences() {
    references = individualInstances.map(function (instance) {
      return instance.reference;
    });
  }
  function enableInstances(isEnabled) {
    individualInstances.forEach(function (instance) {
      if (isEnabled) {
        instance.enable();
      } else {
        instance.disable();
      }
    });
  }
  function interceptSetProps(singleton2) {
    return individualInstances.map(function (instance) {
      var originalSetProps2 = instance.setProps;
      instance.setProps = function (props2) {
        originalSetProps2(props2);
        if (instance.reference === currentTarget) {
          singleton2.setProps(props2);
        }
      };
      return function () {
        instance.setProps = originalSetProps2;
      };
    });
  }
  function prepareInstance(singleton2, target) {
    var index = triggerTargets.indexOf(target);
    if (target === currentTarget) {
      return;
    }
    currentTarget = target;
    var overrideProps = (overrides || [])
      .concat("content")
      .reduce(function (acc, prop) {
        acc[prop] = individualInstances[index].props[prop];
        return acc;
      }, {});
    singleton2.setProps(
      Object.assign({}, overrideProps, {
        getReferenceClientRect:
          typeof overrideProps.getReferenceClientRect === "function"
            ? overrideProps.getReferenceClientRect
            : function () {
                var _references$index;
                return (_references$index = references[index]) == null
                  ? void 0
                  : _references$index.getBoundingClientRect();
              },
      })
    );
  }
  enableInstances(false);
  setReferences();
  setTriggerTargets();
  var plugin2 = {
    fn: function fn6() {
      return {
        onDestroy: function onDestroy2() {
          enableInstances(true);
        },
        onHidden: function onHidden2() {
          currentTarget = null;
        },
        onClickOutside: function onClickOutside2(instance) {
          if (instance.props.showOnCreate && !shownOnCreate) {
            shownOnCreate = true;
            currentTarget = null;
          }
        },
        onShow: function onShow2(instance) {
          if (instance.props.showOnCreate && !shownOnCreate) {
            shownOnCreate = true;
            prepareInstance(instance, references[0]);
          }
        },
        onTrigger: function onTrigger2(instance, event) {
          prepareInstance(instance, event.currentTarget);
        },
      };
    },
  };
  var singleton = tippy$1(
    div(),
    Object.assign({}, removeProperties(optionalProps, ["overrides"]), {
      plugins: [plugin2].concat(optionalProps.plugins || []),
      triggerTarget: triggerTargets,
      popperOptions: Object.assign({}, optionalProps.popperOptions, {
        modifiers: [].concat(
          ((_optionalProps$popper = optionalProps.popperOptions) == null
            ? void 0
            : _optionalProps$popper.modifiers) || [],
          [applyStylesModifier]
        ),
      }),
    })
  );
  var originalShow = singleton.show;
  singleton.show = function (target) {
    originalShow();
    if (!currentTarget && target == null) {
      return prepareInstance(singleton, references[0]);
    }
    if (currentTarget && target == null) {
      return;
    }
    if (typeof target === "number") {
      return (
        references[target] && prepareInstance(singleton, references[target])
      );
    }
    if (individualInstances.indexOf(target) >= 0) {
      var ref2 = target.reference;
      return prepareInstance(singleton, ref2);
    }
    if (references.indexOf(target) >= 0) {
      return prepareInstance(singleton, target);
    }
  };
  singleton.showNext = function () {
    var first = references[0];
    if (!currentTarget) {
      return singleton.show(0);
    }
    var index = references.indexOf(currentTarget);
    singleton.show(references[index + 1] || first);
  };
  singleton.showPrevious = function () {
    var last = references[references.length - 1];
    if (!currentTarget) {
      return singleton.show(last);
    }
    var index = references.indexOf(currentTarget);
    var target = references[index - 1] || last;
    singleton.show(target);
  };
  var originalSetProps = singleton.setProps;
  singleton.setProps = function (props2) {
    overrides = props2.overrides || overrides;
    originalSetProps(props2);
  };
  singleton.setInstances = function (nextInstances) {
    enableInstances(true);
    interceptSetPropsCleanups.forEach(function (fn6) {
      return fn6();
    });
    individualInstances = nextInstances;
    enableInstances(false);
    setReferences();
    setTriggerTargets();
    interceptSetPropsCleanups = interceptSetProps(singleton);
    singleton.setProps({
      triggerTarget: triggerTargets,
    });
  };
  interceptSetPropsCleanups = interceptSetProps(singleton);
  return singleton;
};
var animateFill = {
  name: "animateFill",
  defaultValue: false,
  fn: function fn2(instance) {
    var _instance$props$rende;
    if (
      !(
        (_instance$props$rende = instance.props.render) != null &&
        _instance$props$rende.$$tippy
      )
    ) {
      return {};
    }
    var _getChildren = getChildren(instance.popper),
      box = _getChildren.box,
      content = _getChildren.content;
    var backdrop = instance.props.animateFill ? createBackdropElement() : null;
    return {
      onCreate: function onCreate2() {
        if (backdrop) {
          box.insertBefore(backdrop, box.firstElementChild);
          box.setAttribute("data-animatefill", "");
          box.style.overflow = "hidden";
          instance.setProps({
            arrow: false,
            animation: "shift-away",
          });
        }
      },
      onMount: function onMount2() {
        if (backdrop) {
          var transitionDuration = box.style.transitionDuration;
          var duration = Number(transitionDuration.replace("ms", ""));
          content.style.transitionDelay = Math.round(duration / 10) + "ms";
          backdrop.style.transitionDuration = transitionDuration;
          setVisibilityState([backdrop], "visible");
        }
      },
      onShow: function onShow2() {
        if (backdrop) {
          backdrop.style.transitionDuration = "0ms";
        }
      },
      onHide: function onHide2() {
        if (backdrop) {
          setVisibilityState([backdrop], "hidden");
        }
      },
    };
  },
};
function createBackdropElement() {
  var backdrop = div();
  backdrop.className = BACKDROP_CLASS;
  setVisibilityState([backdrop], "hidden");
  return backdrop;
}
var mouseCoords = {
  clientX: 0,
  clientY: 0,
};
var activeInstances = [];
function storeMouseCoords(_ref) {
  var clientX = _ref.clientX,
    clientY = _ref.clientY;
  mouseCoords = {
    clientX,
    clientY,
  };
}
function addMouseCoordsListener(doc) {
  doc.addEventListener("mousemove", storeMouseCoords);
}
function removeMouseCoordsListener(doc) {
  doc.removeEventListener("mousemove", storeMouseCoords);
}
var followCursor = {
  name: "followCursor",
  defaultValue: false,
  fn: function fn3(instance) {
    var reference2 = instance.reference;
    var doc = getOwnerDocument(instance.props.triggerTarget || reference2);
    var isInternalUpdate = false;
    var wasFocusEvent = false;
    var isUnmounted = true;
    var prevProps = instance.props;
    function getIsInitialBehavior() {
      return (
        instance.props.followCursor === "initial" && instance.state.isVisible
      );
    }
    function addListener() {
      doc.addEventListener("mousemove", onMouseMove);
    }
    function removeListener() {
      doc.removeEventListener("mousemove", onMouseMove);
    }
    function unsetGetReferenceClientRect() {
      isInternalUpdate = true;
      instance.setProps({
        getReferenceClientRect: null,
      });
      isInternalUpdate = false;
    }
    function onMouseMove(event) {
      var isCursorOverReference = event.target
        ? reference2.contains(event.target)
        : true;
      var followCursor2 = instance.props.followCursor;
      var clientX = event.clientX,
        clientY = event.clientY;
      var rect = reference2.getBoundingClientRect();
      var relativeX = clientX - rect.left;
      var relativeY = clientY - rect.top;
      if (isCursorOverReference || !instance.props.interactive) {
        instance.setProps({
          // @ts-ignore - unneeded DOMRect properties
          getReferenceClientRect: function getReferenceClientRect() {
            var rect2 = reference2.getBoundingClientRect();
            var x = clientX;
            var y = clientY;
            if (followCursor2 === "initial") {
              x = rect2.left + relativeX;
              y = rect2.top + relativeY;
            }
            var top2 = followCursor2 === "horizontal" ? rect2.top : y;
            var right2 = followCursor2 === "vertical" ? rect2.right : x;
            var bottom2 = followCursor2 === "horizontal" ? rect2.bottom : y;
            var left2 = followCursor2 === "vertical" ? rect2.left : x;
            return {
              width: right2 - left2,
              height: bottom2 - top2,
              top: top2,
              right: right2,
              bottom: bottom2,
              left: left2,
            };
          },
        });
      }
    }
    function create() {
      if (instance.props.followCursor) {
        activeInstances.push({
          instance,
          doc,
        });
        addMouseCoordsListener(doc);
      }
    }
    function destroy() {
      activeInstances = activeInstances.filter(function (data) {
        return data.instance !== instance;
      });
      if (
        activeInstances.filter(function (data) {
          return data.doc === doc;
        }).length === 0
      ) {
        removeMouseCoordsListener(doc);
      }
    }
    return {
      onCreate: create,
      onDestroy: destroy,
      onBeforeUpdate: function onBeforeUpdate2() {
        prevProps = instance.props;
      },
      onAfterUpdate: function onAfterUpdate2(_, _ref2) {
        var followCursor2 = _ref2.followCursor;
        if (isInternalUpdate) {
          return;
        }
        if (
          followCursor2 !== void 0 &&
          prevProps.followCursor !== followCursor2
        ) {
          destroy();
          if (followCursor2) {
            create();
            if (
              instance.state.isMounted &&
              !wasFocusEvent &&
              !getIsInitialBehavior()
            ) {
              addListener();
            }
          } else {
            removeListener();
            unsetGetReferenceClientRect();
          }
        }
      },
      onMount: function onMount2() {
        if (instance.props.followCursor && !wasFocusEvent) {
          if (isUnmounted) {
            onMouseMove(mouseCoords);
            isUnmounted = false;
          }
          if (!getIsInitialBehavior()) {
            addListener();
          }
        }
      },
      onTrigger: function onTrigger2(_, event) {
        if (isMouseEvent(event)) {
          mouseCoords = {
            clientX: event.clientX,
            clientY: event.clientY,
          };
        }
        wasFocusEvent = event.type === "focus";
      },
      onHidden: function onHidden2() {
        if (instance.props.followCursor) {
          unsetGetReferenceClientRect();
          removeListener();
          isUnmounted = true;
        }
      },
    };
  },
};
function getProps(props2, modifier) {
  var _props$popperOptions;
  return {
    popperOptions: Object.assign({}, props2.popperOptions, {
      modifiers: [].concat(
        (
          ((_props$popperOptions = props2.popperOptions) == null
            ? void 0
            : _props$popperOptions.modifiers) || []
        ).filter(function (_ref) {
          var name = _ref.name;
          return name !== modifier.name;
        }),
        [modifier]
      ),
    }),
  };
}
var inlinePositioning = {
  name: "inlinePositioning",
  defaultValue: false,
  fn: function fn4(instance) {
    var reference2 = instance.reference;
    function isEnabled() {
      return !!instance.props.inlinePositioning;
    }
    var placement;
    var cursorRectIndex = -1;
    var isInternalUpdate = false;
    var triedPlacements = [];
    var modifier = {
      name: "tippyInlinePositioning",
      enabled: true,
      phase: "afterWrite",
      fn: function fn6(_ref2) {
        var state = _ref2.state;
        if (isEnabled()) {
          if (triedPlacements.indexOf(state.placement) !== -1) {
            triedPlacements = [];
          }
          if (
            placement !== state.placement &&
            triedPlacements.indexOf(state.placement) === -1
          ) {
            triedPlacements.push(state.placement);
            instance.setProps({
              // @ts-ignore - unneeded DOMRect properties
              getReferenceClientRect: function getReferenceClientRect() {
                return _getReferenceClientRect(state.placement);
              },
            });
          }
          placement = state.placement;
        }
      },
    };
    function _getReferenceClientRect(placement2) {
      return getInlineBoundingClientRect(
        getBasePlacement$1(placement2),
        reference2.getBoundingClientRect(),
        arrayFrom(reference2.getClientRects()),
        cursorRectIndex
      );
    }
    function setInternalProps(partialProps) {
      isInternalUpdate = true;
      instance.setProps(partialProps);
      isInternalUpdate = false;
    }
    function addModifier() {
      if (!isInternalUpdate) {
        setInternalProps(getProps(instance.props, modifier));
      }
    }
    return {
      onCreate: addModifier,
      onAfterUpdate: addModifier,
      onTrigger: function onTrigger2(_, event) {
        if (isMouseEvent(event)) {
          var rects = arrayFrom(instance.reference.getClientRects());
          var cursorRect = rects.find(function (rect) {
            return (
              rect.left - 2 <= event.clientX &&
              rect.right + 2 >= event.clientX &&
              rect.top - 2 <= event.clientY &&
              rect.bottom + 2 >= event.clientY
            );
          });
          var index = rects.indexOf(cursorRect);
          cursorRectIndex = index > -1 ? index : cursorRectIndex;
        }
      },
      onHidden: function onHidden2() {
        cursorRectIndex = -1;
      },
    };
  },
};
function getInlineBoundingClientRect(
  currentBasePlacement,
  boundingRect,
  clientRects,
  cursorRectIndex
) {
  if (clientRects.length < 2 || currentBasePlacement === null) {
    return boundingRect;
  }
  if (
    clientRects.length === 2 &&
    cursorRectIndex >= 0 &&
    clientRects[0].left > clientRects[1].right
  ) {
    return clientRects[cursorRectIndex] || boundingRect;
  }
  switch (currentBasePlacement) {
    case "top":
    case "bottom": {
      var firstRect = clientRects[0];
      var lastRect = clientRects[clientRects.length - 1];
      var isTop = currentBasePlacement === "top";
      var top2 = firstRect.top;
      var bottom2 = lastRect.bottom;
      var left2 = isTop ? firstRect.left : lastRect.left;
      var right2 = isTop ? firstRect.right : lastRect.right;
      var width = right2 - left2;
      var height = bottom2 - top2;
      return {
        top: top2,
        bottom: bottom2,
        left: left2,
        right: right2,
        width,
        height,
      };
    }
    case "left":
    case "right": {
      var minLeft = Math.min.apply(
        Math,
        clientRects.map(function (rects) {
          return rects.left;
        })
      );
      var maxRight = Math.max.apply(
        Math,
        clientRects.map(function (rects) {
          return rects.right;
        })
      );
      var measureRects = clientRects.filter(function (rect) {
        return currentBasePlacement === "left"
          ? rect.left === minLeft
          : rect.right === maxRight;
      });
      var _top = measureRects[0].top;
      var _bottom = measureRects[measureRects.length - 1].bottom;
      var _left = minLeft;
      var _right = maxRight;
      var _width = _right - _left;
      var _height = _bottom - _top;
      return {
        top: _top,
        bottom: _bottom,
        left: _left,
        right: _right,
        width: _width,
        height: _height,
      };
    }
    default: {
      return boundingRect;
    }
  }
}
var sticky = {
  name: "sticky",
  defaultValue: false,
  fn: function fn5(instance) {
    var reference2 = instance.reference,
      popper2 = instance.popper;
    function getReference() {
      return instance.popperInstance
        ? instance.popperInstance.state.elements.reference
        : reference2;
    }
    function shouldCheck(value) {
      return instance.props.sticky === true || instance.props.sticky === value;
    }
    var prevRefRect = null;
    var prevPopRect = null;
    function updatePosition() {
      var currentRefRect = shouldCheck("reference")
        ? getReference().getBoundingClientRect()
        : null;
      var currentPopRect = shouldCheck("popper")
        ? popper2.getBoundingClientRect()
        : null;
      if (
        (currentRefRect && areRectsDifferent(prevRefRect, currentRefRect)) ||
        (currentPopRect && areRectsDifferent(prevPopRect, currentPopRect))
      ) {
        if (instance.popperInstance) {
          instance.popperInstance.update();
        }
      }
      prevRefRect = currentRefRect;
      prevPopRect = currentPopRect;
      if (instance.state.isMounted) {
        requestAnimationFrame(updatePosition);
      }
    }
    return {
      onMount: function onMount2() {
        if (instance.props.sticky) {
          updatePosition();
        }
      },
    };
  },
};
function areRectsDifferent(rectA, rectB) {
  if (rectA && rectB) {
    return (
      rectA.top !== rectB.top ||
      rectA.right !== rectB.right ||
      rectA.bottom !== rectB.bottom ||
      rectA.left !== rectB.left
    );
  }
  return true;
}
tippy$1.setDefaultProps({
  render,
});
tippy$1.setDefaultProps({
  //@ts-ignore
  onShow: (instance) => {
    if (!instance.props.content) return false;
  },
});
function useTippy(el, opts = {}, settings = { mount: true, appName: "Tippy" }) {
  settings = Object.assign({ mount: true, appName: "Tippy" }, settings);
  const vm = getCurrentInstance();
  const instance = ref();
  const state = ref({
    isEnabled: false,
    isVisible: false,
    isDestroyed: false,
    isMounted: false,
    isShown: false,
  });
  const headlessApp = shallowRef();
  let container = null;
  const getContainer = () => {
    if (container) return container;
    container = document.createDocumentFragment();
    return container;
  };
  const getContent = (content) => {
    let newContent;
    let unwrappedContent = isRef(content) ? content.value : content;
    if (isVNode(unwrappedContent)) {
      if (!headlessApp.value) {
        headlessApp.value = createApp({
          name: settings.appName,
          setup: () => {
            return () => (isRef(content) ? content.value : content);
          },
        });
        if (vm) {
          Object.assign(headlessApp.value._context, vm.appContext);
        }
        headlessApp.value.mount(getContainer());
      }
      newContent = () => getContainer();
    } else if (typeof unwrappedContent === "object") {
      if (!headlessApp.value) {
        headlessApp.value = createApp({
          name: settings.appName,
          setup: () => {
            return () => h(isRef(content) ? content.value : content);
          },
        });
        if (vm) {
          Object.assign(headlessApp.value._context, vm.appContext);
        }
        headlessApp.value.mount(getContainer());
      }
      newContent = () => getContainer();
    } else {
      newContent = unwrappedContent;
    }
    return newContent;
  };
  const getProps2 = (opts2) => {
    let options = {};
    if (isRef(opts2)) {
      options = opts2.value || {};
    } else if (isReactive(opts2)) {
      options = { ...opts2 };
    } else {
      options = { ...opts2 };
    }
    if (options.content) {
      options.content = getContent(options.content);
    }
    if (options.triggerTarget) {
      options.triggerTarget = isRef(options.triggerTarget)
        ? options.triggerTarget.value
        : options.triggerTarget;
    }
    if (!options.plugins || !Array.isArray(options.plugins)) {
      options.plugins = [];
    }
    options.plugins = options.plugins.filter(
      (plugin2) => plugin2.name !== "vueTippyReactiveState"
    );
    options.plugins.push({
      name: "vueTippyReactiveState",
      fn: () => {
        return {
          onCreate() {
            state.value.isEnabled = true;
          },
          onMount() {
            state.value.isMounted = true;
          },
          onShow() {
            state.value.isMounted = true;
            state.value.isVisible = true;
          },
          onShown() {
            state.value.isShown = true;
          },
          onHide() {
            state.value.isMounted = false;
            state.value.isVisible = false;
          },
          onHidden() {
            state.value.isShown = false;
          },
          onUnmounted() {
            state.value.isMounted = false;
          },
          onDestroy() {
            state.value.isDestroyed = true;
          },
        };
      },
    });
    return options;
  };
  const refresh = () => {
    if (!instance.value) return;
    instance.value.setProps(getProps2(opts));
  };
  const refreshContent = () => {
    if (!instance.value || !opts.content) return;
    instance.value.setContent(getContent(opts.content));
  };
  const setContent2 = (value) => {
    var _a;
    (_a = instance.value) === null || _a === void 0
      ? void 0
      : _a.setContent(getContent(value));
  };
  const setProps = (value) => {
    var _a;
    (_a = instance.value) === null || _a === void 0
      ? void 0
      : _a.setProps(getProps2(value));
  };
  const destroy = () => {
    var _a;
    if (instance.value) {
      instance.value.destroy();
      instance.value = void 0;
    }
    container = null;
    (_a = headlessApp.value) === null || _a === void 0 ? void 0 : _a.unmount();
    headlessApp.value = void 0;
  };
  const show = () => {
    var _a;
    (_a = instance.value) === null || _a === void 0 ? void 0 : _a.show();
  };
  const hide2 = () => {
    var _a;
    (_a = instance.value) === null || _a === void 0 ? void 0 : _a.hide();
  };
  const disable = () => {
    var _a;
    (_a = instance.value) === null || _a === void 0 ? void 0 : _a.disable();
    state.value.isEnabled = false;
  };
  const enable = () => {
    var _a;
    (_a = instance.value) === null || _a === void 0 ? void 0 : _a.enable();
    state.value.isEnabled = true;
  };
  const unmount = () => {
    var _a;
    (_a = instance.value) === null || _a === void 0 ? void 0 : _a.unmount();
  };
  const mount = () => {
    if (!el) return;
    let target = isRef(el) ? el.value : el;
    if (typeof target === "function") target = target();
    if (target) {
      instance.value = tippy$1(target, getProps2(opts));
      target.$tippy = response;
    }
  };
  const response = {
    tippy: instance,
    refresh,
    refreshContent,
    setContent: setContent2,
    setProps,
    destroy,
    hide: hide2,
    show,
    disable,
    enable,
    unmount,
    mount,
    state,
  };
  if (settings.mount) {
    if (vm) {
      if (vm.isMounted) {
        mount();
      } else {
        onMounted$1(mount);
      }
    } else {
      mount();
    }
  }
  if (vm) {
    onUnmounted$1(() => {
      destroy();
    });
  }
  if (isRef(opts) || isReactive(opts)) {
    watch(opts, refresh, { immediate: false });
  } else if (isRef(opts.content)) {
    watch(opts.content, refreshContent, { immediate: false });
  }
  return response;
}
function useSingleton(instances, optionalProps) {
  const singleton = ref();
  onMounted$1(() => {
    const pendingTippyInstances = Array.isArray(instances)
      ? instances.map((i) => i.value)
      : typeof instances === "function"
      ? instances()
      : instances.value;
    const tippyInstances = pendingTippyInstances
      .map((instance) => {
        if (instance instanceof Element) {
          return instance._tippy;
        }
        return instance;
      })
      .filter(Boolean);
    singleton.value = createSingleton(
      tippyInstances,
      optionalProps
        ? { allowHTML: true, ...optionalProps }
        : { allowHTML: true }
    );
  });
  return {
    singleton,
  };
}
function toValue(r) {
  return typeof r === "function" ? r() : unref(r);
}
function unrefElement(elRef) {
  var _a, _b;
  const plain = toValue(elRef);
  return (_b = (_a = plain) === null || _a === void 0 ? void 0 : _a.$el) !==
    null && _b !== void 0
    ? _b
    : plain;
}
var TippyComponent = defineComponent({
  props: {
    to: {
      type: [String, Function],
    },
    tag: {
      type: [String, Object],
      default: "span",
    },
    contentTag: {
      type: [String, Object],
      default: "span",
    },
    contentClass: {
      type: String,
      default: null,
    },
    appendTo: { default: () => tippy$1.defaultProps["appendTo"] },
    aria: { default: () => tippy$1.defaultProps["aria"] },
    delay: { default: () => tippy$1.defaultProps["delay"] },
    duration: { default: () => tippy$1.defaultProps["duration"] },
    getReferenceClientRect: {
      default: () => tippy$1.defaultProps["getReferenceClientRect"],
    },
    hideOnClick: {
      type: [Boolean, String],
      default: () => tippy$1.defaultProps["hideOnClick"],
    },
    ignoreAttributes: {
      type: Boolean,
      default: () => tippy$1.defaultProps["ignoreAttributes"],
    },
    interactive: {
      type: Boolean,
      default: () => tippy$1.defaultProps["interactive"],
    },
    interactiveBorder: {
      default: () => tippy$1.defaultProps["interactiveBorder"],
    },
    interactiveDebounce: {
      default: () => tippy$1.defaultProps["interactiveDebounce"],
    },
    moveTransition: { default: () => tippy$1.defaultProps["moveTransition"] },
    offset: { default: () => tippy$1.defaultProps["offset"] },
    onAfterUpdate: { default: () => tippy$1.defaultProps["onAfterUpdate"] },
    onBeforeUpdate: { default: () => tippy$1.defaultProps["onBeforeUpdate"] },
    onCreate: { default: () => tippy$1.defaultProps["onCreate"] },
    onDestroy: { default: () => tippy$1.defaultProps["onDestroy"] },
    onHidden: { default: () => tippy$1.defaultProps["onHidden"] },
    onHide: { default: () => tippy$1.defaultProps["onHide"] },
    onMount: { default: () => tippy$1.defaultProps["onMount"] },
    onShow: { default: () => tippy$1.defaultProps["onShow"] },
    onShown: { default: () => tippy$1.defaultProps["onShown"] },
    onTrigger: { default: () => tippy$1.defaultProps["onTrigger"] },
    onUntrigger: { default: () => tippy$1.defaultProps["onUntrigger"] },
    onClickOutside: { default: () => tippy$1.defaultProps["onClickOutside"] },
    placement: { default: () => tippy$1.defaultProps["placement"] },
    plugins: { default: () => tippy$1.defaultProps["plugins"] },
    popperOptions: { default: () => tippy$1.defaultProps["popperOptions"] },
    render: { default: () => tippy$1.defaultProps["render"] },
    showOnCreate: {
      type: Boolean,
      default: () => tippy$1.defaultProps["showOnCreate"],
    },
    touch: {
      type: [Boolean, String, Array],
      default: () => tippy$1.defaultProps["touch"],
    },
    trigger: { default: () => tippy$1.defaultProps["trigger"] },
    triggerTarget: { default: () => tippy$1.defaultProps["triggerTarget"] },
    animateFill: {
      type: Boolean,
      default: () => tippy$1.defaultProps["animateFill"],
    },
    followCursor: {
      type: [Boolean, String],
      default: () => tippy$1.defaultProps["followCursor"],
    },
    inlinePositioning: {
      type: Boolean,
      default: () => tippy$1.defaultProps["inlinePositioning"],
    },
    sticky: {
      type: [Boolean, String],
      default: () => tippy$1.defaultProps["sticky"],
    },
    allowHTML: {
      type: Boolean,
      default: () => tippy$1.defaultProps["allowHTML"],
    },
    animation: { default: () => tippy$1.defaultProps["animation"] },
    arrow: { default: () => tippy$1.defaultProps["arrow"] },
    content: { default: () => tippy$1.defaultProps["content"] },
    inertia: { default: () => tippy$1.defaultProps["inertia"] },
    maxWidth: { default: () => tippy$1.defaultProps["maxWidth"] },
    role: { default: () => tippy$1.defaultProps["role"] },
    theme: { default: () => tippy$1.defaultProps["theme"] },
    zIndex: { default: () => tippy$1.defaultProps["zIndex"] },
  },
  emits: ["state"],
  setup(props2, { slots, emit, expose }) {
    const elem = ref();
    const findParentHelper = ref();
    const contentElem = ref();
    const mounted = ref(false);
    const getOptions = () => {
      let options = { ...props2 };
      for (const prop of ["to", "tag", "contentTag", "contentClass"]) {
        if (options.hasOwnProperty(prop)) {
          delete options[prop];
        }
      }
      return options;
    };
    let target = () => unrefElement(elem);
    if (props2.to) {
      if (typeof Element !== "undefined" && props2.to instanceof Element) {
        target = () => props2.to;
      } else if (props2.to === "parent") {
        target = () => {
          let el = elem.value;
          if (!el) {
            el = elem.value = findParentHelper.value.parentElement;
          }
          return el;
        };
      } else if (typeof props2.to === "string" || props2.to instanceof String) {
        target = () => document.querySelector(props2.to);
      }
    }
    const tippy2 = useTippy(target, getOptions());
    let contentSlot = slots.content;
    if (!contentSlot && props2.to === "parent") {
      contentSlot = slots.default;
    }
    onMounted$1(() => {
      mounted.value = true;
      nextTick(() => {
        if (contentSlot) tippy2.setContent(() => contentElem.value);
      });
    });
    watch(
      tippy2.state,
      () => {
        emit("state", unref(tippy2.state));
      },
      { immediate: true, deep: true }
    );
    watch(
      () => props2,
      () => {
        tippy2.setProps(getOptions());
        if (contentSlot) tippy2.setContent(() => contentElem.value);
      },
      { deep: true }
    );
    let exposed = reactive({
      elem,
      contentElem,
      mounted,
      ...tippy2,
    });
    expose(exposed);
    return () => {
      const contentTag =
        typeof props2.contentTag === "string"
          ? props2.contentTag
          : props2.contentTag;
      const content = contentSlot
        ? h(
            contentTag,
            {
              ref: contentElem,
              style: { display: mounted.value ? "inherit" : "none" },
              class: props2.contentClass,
            },
            contentSlot(exposed)
          )
        : null;
      if (props2.to === "parent") {
        const result = [];
        if (!elem.value) {
          const findParentHelperNode = h("span", {
            ref: findParentHelper,
            "data-v-tippy": "",
            style: { display: "none" },
          });
          result.push(findParentHelperNode);
        }
        if (content) {
          result.push(content);
        }
        return result;
      }
      const slot = slots.default ? slots.default(exposed) : [];
      if (!props2.tag) {
        const trigger = h(slot[0], {
          ref: elem,
          "data-v-tippy": "",
        });
        return content ? [trigger, content] : trigger;
      }
      const tag = typeof props2.tag === "string" ? props2.tag : props2.tag;
      return h(
        tag,
        { ref: elem, "data-v-tippy": "" },
        content ? [slot, content] : slot
      );
    };
  },
});
var booleanProps = [
  "a11y",
  "allowHTML",
  "arrow",
  "flip",
  "flipOnUpdate",
  "hideOnClick",
  "ignoreAttributes",
  "inertia",
  "interactive",
  "lazy",
  "multiple",
  "showOnInit",
  "touch",
  "touchHold",
];
var props = {};
Object.keys(tippy$1.defaultProps).forEach((prop) => {
  if (booleanProps.includes(prop)) {
    props[prop] = {
      type: Boolean,
      default: function () {
        return tippy$1.defaultProps[prop];
      },
    };
  } else {
    props[prop] = {
      default: function () {
        return tippy$1.defaultProps[prop];
      },
    };
  }
});
var TippySingleton = defineComponent({
  props,
  setup(props2) {
    const instances = ref([]);
    const { singleton } = useSingleton(instances, props2);
    return { instances, singleton };
  },
  mounted() {
    var _a;
    const parent = this.$el.parentElement;
    const elements = parent.querySelectorAll("[data-v-tippy]");
    this.instances = Array.from(elements)
      .map((el) => el._tippy)
      .filter(Boolean);
    (_a = this.singleton) === null || _a === void 0
      ? void 0
      : _a.setInstances(this.instances);
  },
  render() {
    let slot = this.$slots.default ? this.$slots.default() : [];
    return h(() => slot);
  },
});
var directive = {
  mounted(el, binding, vnode) {
    const opts =
      typeof binding.value === "string"
        ? { content: binding.value }
        : binding.value || {};
    const modifiers = Object.keys(binding.modifiers || {});
    const placement = modifiers.find((modifier) => modifier !== "arrow");
    const withArrow =
      modifiers.findIndex((modifier) => modifier === "arrow") !== -1;
    if (placement) {
      opts.placement = opts.placement || placement;
    }
    if (withArrow) {
      opts.arrow = opts.arrow !== void 0 ? opts.arrow : true;
    }
    if (vnode.props && vnode.props.onTippyShow) {
      opts.onShow = function (...args) {
        var _a;
        return (_a = vnode.props) === null || _a === void 0
          ? void 0
          : _a.onTippyShow(...args);
      };
    }
    if (vnode.props && vnode.props.onTippyShown) {
      opts.onShown = function (...args) {
        var _a;
        return (_a = vnode.props) === null || _a === void 0
          ? void 0
          : _a.onTippyShown(...args);
      };
    }
    if (vnode.props && vnode.props.onTippyHidden) {
      opts.onHidden = function (...args) {
        var _a;
        return (_a = vnode.props) === null || _a === void 0
          ? void 0
          : _a.onTippyHidden(...args);
      };
    }
    if (vnode.props && vnode.props.onTippyHide) {
      opts.onHide = function (...args) {
        var _a;
        return (_a = vnode.props) === null || _a === void 0
          ? void 0
          : _a.onTippyHide(...args);
      };
    }
    if (vnode.props && vnode.props.onTippyMount) {
      opts.onMount = function (...args) {
        var _a;
        return (_a = vnode.props) === null || _a === void 0
          ? void 0
          : _a.onTippyMount(...args);
      };
    }
    if (el.getAttribute("title") && !opts.content) {
      opts.content = el.getAttribute("title");
      el.removeAttribute("title");
    }
    if (el.getAttribute("content") && !opts.content) {
      opts.content = el.getAttribute("content");
    }
    useTippy(el, opts);
  },
  unmounted(el) {
    if (el.$tippy) {
      el.$tippy.destroy();
    } else if (el._tippy) {
      el._tippy.destroy();
    }
  },
  updated(el, binding) {
    const opts =
      typeof binding.value === "string"
        ? { content: binding.value }
        : binding.value || {};
    if (el.getAttribute("title") && !opts.content) {
      opts.content = el.getAttribute("title");
      el.removeAttribute("title");
    }
    if (el.getAttribute("content") && !opts.content) {
      opts.content = el.getAttribute("content");
    }
    if (el.$tippy) {
      el.$tippy.setProps(opts || {});
    } else if (el._tippy) {
      el._tippy.setProps(opts || {});
    }
  },
};
var plugin = {
  install(app, options = {}) {
    tippy$1.setDefaultProps(options.defaultProps || {});
    app.directive(options.directive || "tippy", directive);
    app.component(options.component || "tippy", TippyComponent);
    app.component(
      options.componentSingleton || "tippy-singleton",
      TippySingleton
    );
  },
};
var setDefaultProps$1 = tippy$1.setDefaultProps;
setDefaultProps$1({
  ignoreAttributes: true,
  plugins: [sticky, inlinePositioning, followCursor, animateFill],
});
var vue_tippy_esm_browser_default = plugin;
/*! Bundled license information:

vue-tippy/dist/vue-tippy.esm-browser.js:
  (*!
    * vue-tippy v6.4.1
    * (c) 2023 
    * @license MIT
    *)
*/

const tippy = "";

const style = "";

/** Time after which a notification is hidden. */
const MESSAGE_HIDE_DELAY_MS = 5000;

/**
 * Store notifications to users of the web frontend.
 */
const useNotifs = defineStore("notifications", {
  state: () => ({
    /**
     * History of notifications.
     *
     * The 'id' is just for Tabulator to uniquely identify rows, in order to be
     * able to scroll to them.
     *
     * @type {{ id: Number, msg: string, time: Date }[]} */
    history: [],
    /** @type { id: Number, msg: string, time: Date } */
    last: "",

    hideTimerID: 0,
    lastID: 0,
  }),
  getters: {
    empty: (state) => state.history.length == 0,
  },
  actions: {
    /**
     * Add a simple notification.
     * @param {string} message
     */
    add(message) {
      const notif = { id: this._generateID(), msg: message, time: new Date() };
      this.history.push(notif);
      this.last = notif;
      this._prune();
      this._restartHideTimer();
    },

    /**
     * @param {API.SocketIOJobUpdate} jobUpdate Job update received via SocketIO.
     */
    addJobUpdate(jobUpdate) {
      let msg = "Job";
      if (jobUpdate.name) msg += ` ${jobUpdate.name}`;
      if (jobUpdate.was_deleted) {
        msg += " was deleted";
      } else if (
        jobUpdate.previous_status &&
        jobUpdate.previous_status != jobUpdate.status
      ) {
        msg += ` changed status ${jobUpdate.previous_status}  ${jobUpdate.status}`;
      } else {
        // Don't bother logging just "Job" + its name, as it conveys no info.
        return;
      }
      this.add(msg);
    },

    /**
     * @param {API.SocketIOTaskUpdate} taskUpdate Task update received via SocketIO.
     */
    addTaskUpdate(taskUpdate) {
      let msg = `Task ${taskUpdate.name}`;
      if (
        taskUpdate.previous_status &&
        taskUpdate.previous_status != taskUpdate.status
      ) {
        msg += ` changed status ${taskUpdate.previous_status}  ${taskUpdate.status}`;
      }
      if (taskUpdate.activity) {
        msg += `: ${taskUpdate.activity}`;
      }
      this.add(msg);
    },

    /**
     * @param {API.SocketIOWorkerUpdate} workerUpdate Worker update received via SocketIO.
     */
    addWorkerUpdate(workerUpdate) {
      let msg = `Worker ${workerUpdate.name}`;
      if (
        workerUpdate.previous_status &&
        workerUpdate.previous_status != workerUpdate.status
      ) {
        msg += ` changed status ${workerUpdate.previous_status}  ${workerUpdate.status}`;
        this.add(msg);
      } else if (workerUpdate.deleted_at) {
        msg += " was removed from the system";
        this.add(msg);
      }
    },

    /* Ensure there is only 1000 items in the history. */
    _prune() {
      if (this.history.length <= 1000) return;
      this.history.splice(0, 1000 - this.history.length);
    },

    _restartHideTimer() {
      if (this.hideTimerID) window.clearTimeout(this.hideTimerID);
      this.hideTimerID = window.setTimeout(
        this._hideMessage,
        MESSAGE_HIDE_DELAY_MS
      );
    },
    _hideMessage() {
      this.$patch({
        hideTimerID: 0,
        last: "",
      });
    },
    _generateID() {
      return ++this.lastID;
    },
  },
});

/**
 * Status of the SocketIO/Websocket connection to Flamenco Manager.
 */
const useSocketStatus = defineStore("socket-status", {
  state: () => ({
    /** @type { bool } */
    isConnected: false,

    wasEverDisconnected: false,

    /** @type {string} */
    message: "",
  }),
  actions: {
    /**
     * Indicate the connection was lost.
     * @param {string} reason
     */
    disconnected(reason) {
      // Only patch the state if it actually will change.
      if (!this.isConnected) return;
      this._get_notifs().add(`Connection to Inferix Manager lost`);
      this.$patch({
        isConnected: false,
        wasEverDisconnected: true,
        message: `${reason}`,
      });
    },
    /**
     * Indicate the connection is good.
     */
    connected() {
      // Only patch the state if it actually will change.
      if (this.isConnected) return;

      if (this.wasEverDisconnected)
        this._get_notifs().add("Connection to Inferix Manager established");
      this.$patch({
        isConnected: true,
        message: "",
      });
    },

    _get_notifs() {
      // Not sure if this is the best way to deal with those notifications. It feels a
      // bit spaghetto to have one Pinia store influence another. Maybe move this to
      // the app level once the Workers and Settings views are fleshed out. Maybe
      // that'll cause the Notifications popover to be handled at the app-global
      // level, instead of per view, creating a better place to put this logic.
      return useNotifs();
    },
  },
});

// node_modules/lodash/lodash.js
var require_lodash = __commonJS({
  "node_modules/lodash/lodash.js"(exports, module) {
    (function () {
      var undefined$1;
      var VERSION = "4.17.21";
      var LARGE_ARRAY_SIZE = 200;
      var CORE_ERROR_TEXT =
          "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.",
        FUNC_ERROR_TEXT = "Expected a function",
        INVALID_TEMPL_VAR_ERROR_TEXT =
          "Invalid `variable` option passed into `_.template`";
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      var MAX_MEMOIZE_SIZE = 500;
      var PLACEHOLDER = "__lodash_placeholder__";
      var CLONE_DEEP_FLAG = 1,
        CLONE_FLAT_FLAG = 2,
        CLONE_SYMBOLS_FLAG = 4;
      var COMPARE_PARTIAL_FLAG = 1,
        COMPARE_UNORDERED_FLAG = 2;
      var WRAP_BIND_FLAG = 1,
        WRAP_BIND_KEY_FLAG = 2,
        WRAP_CURRY_BOUND_FLAG = 4,
        WRAP_CURRY_FLAG = 8,
        WRAP_CURRY_RIGHT_FLAG = 16,
        WRAP_PARTIAL_FLAG = 32,
        WRAP_PARTIAL_RIGHT_FLAG = 64,
        WRAP_ARY_FLAG = 128,
        WRAP_REARG_FLAG = 256,
        WRAP_FLIP_FLAG = 512;
      var DEFAULT_TRUNC_LENGTH = 30,
        DEFAULT_TRUNC_OMISSION = "...";
      var HOT_COUNT = 800,
        HOT_SPAN = 16;
      var LAZY_FILTER_FLAG = 1,
        LAZY_MAP_FLAG = 2,
        LAZY_WHILE_FLAG = 3;
      var INFINITY = 1 / 0,
        MAX_SAFE_INTEGER = 9007199254740991,
        MAX_INTEGER = 17976931348623157e292,
        NAN = 0 / 0;
      var MAX_ARRAY_LENGTH = 4294967295,
        MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
        HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
      var wrapFlags = [
        ["ary", WRAP_ARY_FLAG],
        ["bind", WRAP_BIND_FLAG],
        ["bindKey", WRAP_BIND_KEY_FLAG],
        ["curry", WRAP_CURRY_FLAG],
        ["curryRight", WRAP_CURRY_RIGHT_FLAG],
        ["flip", WRAP_FLIP_FLAG],
        ["partial", WRAP_PARTIAL_FLAG],
        ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
        ["rearg", WRAP_REARG_FLAG],
      ];
      var argsTag = "[object Arguments]",
        arrayTag = "[object Array]",
        asyncTag = "[object AsyncFunction]",
        boolTag = "[object Boolean]",
        dateTag = "[object Date]",
        domExcTag = "[object DOMException]",
        errorTag = "[object Error]",
        funcTag = "[object Function]",
        genTag = "[object GeneratorFunction]",
        mapTag = "[object Map]",
        numberTag = "[object Number]",
        nullTag = "[object Null]",
        objectTag = "[object Object]",
        promiseTag = "[object Promise]",
        proxyTag = "[object Proxy]",
        regexpTag = "[object RegExp]",
        setTag = "[object Set]",
        stringTag = "[object String]",
        symbolTag = "[object Symbol]",
        undefinedTag = "[object Undefined]",
        weakMapTag = "[object WeakMap]",
        weakSetTag = "[object WeakSet]";
      var arrayBufferTag = "[object ArrayBuffer]",
        dataViewTag = "[object DataView]",
        float32Tag = "[object Float32Array]",
        float64Tag = "[object Float64Array]",
        int8Tag = "[object Int8Array]",
        int16Tag = "[object Int16Array]",
        int32Tag = "[object Int32Array]",
        uint8Tag = "[object Uint8Array]",
        uint8ClampedTag = "[object Uint8ClampedArray]",
        uint16Tag = "[object Uint16Array]",
        uint32Tag = "[object Uint32Array]";
      var reEmptyStringLeading = /\b__p \+= '';/g,
        reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
        reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
      var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,
        reUnescapedHtml = /[&<>"']/g,
        reHasEscapedHtml = RegExp(reEscapedHtml.source),
        reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
      var reEscape = /<%-([\s\S]+?)%>/g,
        reEvaluate = /<%([\s\S]+?)%>/g,
        reInterpolate = /<%=([\s\S]+?)%>/g;
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
        reIsPlainProp = /^\w*$/,
        rePropName =
          /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
        reHasRegExpChar = RegExp(reRegExpChar.source);
      var reTrimStart = /^\s+/;
      var reWhitespace = /\s/;
      var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
        reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/,
        reSplitDetails = /,? & /;
      var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
      var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
      var reEscapeChar = /\\(\\)?/g;
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
      var reFlags = /\w*$/;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var reIsOctal = /^0o[0-7]+$/i;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
      var reNoMatch = /($^)/;
      var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
      var rsAstralRange = "\\ud800-\\udfff",
        rsComboMarksRange = "\\u0300-\\u036f",
        reComboHalfMarksRange = "\\ufe20-\\ufe2f",
        rsComboSymbolsRange = "\\u20d0-\\u20ff",
        rsComboRange =
          rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
        rsDingbatRange = "\\u2700-\\u27bf",
        rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff",
        rsMathOpRange = "\\xac\\xb1\\xd7\\xf7",
        rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf",
        rsPunctuationRange = "\\u2000-\\u206f",
        rsSpaceRange =
          " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000",
        rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde",
        rsVarRange = "\\ufe0e\\ufe0f",
        rsBreakRange =
          rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
      var rsApos = "[']",
        rsAstral = "[" + rsAstralRange + "]",
        rsBreak = "[" + rsBreakRange + "]",
        rsCombo = "[" + rsComboRange + "]",
        rsDigits = "\\d+",
        rsDingbat = "[" + rsDingbatRange + "]",
        rsLower = "[" + rsLowerRange + "]",
        rsMisc =
          "[^" +
          rsAstralRange +
          rsBreakRange +
          rsDigits +
          rsDingbatRange +
          rsLowerRange +
          rsUpperRange +
          "]",
        rsFitz = "\\ud83c[\\udffb-\\udfff]",
        rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")",
        rsNonAstral = "[^" + rsAstralRange + "]",
        rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}",
        rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]",
        rsUpper = "[" + rsUpperRange + "]",
        rsZWJ = "\\u200d";
      var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")",
        rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")",
        rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?",
        rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?",
        reOptMod = rsModifier + "?",
        rsOptVar = "[" + rsVarRange + "]?",
        rsOptJoin =
          "(?:" +
          rsZWJ +
          "(?:" +
          [rsNonAstral, rsRegional, rsSurrPair].join("|") +
          ")" +
          rsOptVar +
          reOptMod +
          ")*",
        rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])",
        rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])",
        rsSeq = rsOptVar + reOptMod + rsOptJoin,
        rsEmoji =
          "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq,
        rsSymbol =
          "(?:" +
          [
            rsNonAstral + rsCombo + "?",
            rsCombo,
            rsRegional,
            rsSurrPair,
            rsAstral,
          ].join("|") +
          ")";
      var reApos = RegExp(rsApos, "g");
      var reComboMark = RegExp(rsCombo, "g");
      var reUnicode = RegExp(
        rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq,
        "g"
      );
      var reUnicodeWord = RegExp(
        [
          rsUpper +
            "?" +
            rsLower +
            "+" +
            rsOptContrLower +
            "(?=" +
            [rsBreak, rsUpper, "$"].join("|") +
            ")",
          rsMiscUpper +
            "+" +
            rsOptContrUpper +
            "(?=" +
            [rsBreak, rsUpper + rsMiscLower, "$"].join("|") +
            ")",
          rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
          rsUpper + "+" + rsOptContrUpper,
          rsOrdUpper,
          rsOrdLower,
          rsDigits,
          rsEmoji,
        ].join("|"),
        "g"
      );
      var reHasUnicode = RegExp(
        "[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]"
      );
      var reHasUnicodeWord =
        /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
      var contextProps = [
        "Array",
        "Buffer",
        "DataView",
        "Date",
        "Error",
        "Float32Array",
        "Float64Array",
        "Function",
        "Int8Array",
        "Int16Array",
        "Int32Array",
        "Map",
        "Math",
        "Object",
        "Promise",
        "RegExp",
        "Set",
        "String",
        "Symbol",
        "TypeError",
        "Uint8Array",
        "Uint8ClampedArray",
        "Uint16Array",
        "Uint32Array",
        "WeakMap",
        "_",
        "clearTimeout",
        "isFinite",
        "parseInt",
        "setTimeout",
      ];
      var templateCounter = -1;
      var typedArrayTags = {};
      typedArrayTags[float32Tag] =
        typedArrayTags[float64Tag] =
        typedArrayTags[int8Tag] =
        typedArrayTags[int16Tag] =
        typedArrayTags[int32Tag] =
        typedArrayTags[uint8Tag] =
        typedArrayTags[uint8ClampedTag] =
        typedArrayTags[uint16Tag] =
        typedArrayTags[uint32Tag] =
          true;
      typedArrayTags[argsTag] =
        typedArrayTags[arrayTag] =
        typedArrayTags[arrayBufferTag] =
        typedArrayTags[boolTag] =
        typedArrayTags[dataViewTag] =
        typedArrayTags[dateTag] =
        typedArrayTags[errorTag] =
        typedArrayTags[funcTag] =
        typedArrayTags[mapTag] =
        typedArrayTags[numberTag] =
        typedArrayTags[objectTag] =
        typedArrayTags[regexpTag] =
        typedArrayTags[setTag] =
        typedArrayTags[stringTag] =
        typedArrayTags[weakMapTag] =
          false;
      var cloneableTags = {};
      cloneableTags[argsTag] =
        cloneableTags[arrayTag] =
        cloneableTags[arrayBufferTag] =
        cloneableTags[dataViewTag] =
        cloneableTags[boolTag] =
        cloneableTags[dateTag] =
        cloneableTags[float32Tag] =
        cloneableTags[float64Tag] =
        cloneableTags[int8Tag] =
        cloneableTags[int16Tag] =
        cloneableTags[int32Tag] =
        cloneableTags[mapTag] =
        cloneableTags[numberTag] =
        cloneableTags[objectTag] =
        cloneableTags[regexpTag] =
        cloneableTags[setTag] =
        cloneableTags[stringTag] =
        cloneableTags[symbolTag] =
        cloneableTags[uint8Tag] =
        cloneableTags[uint8ClampedTag] =
        cloneableTags[uint16Tag] =
        cloneableTags[uint32Tag] =
          true;
      cloneableTags[errorTag] =
        cloneableTags[funcTag] =
        cloneableTags[weakMapTag] =
          false;
      var deburredLetters = {
        // Latin-1 Supplement block.
        : "A",
        : "A",
        : "A",
        : "A",
        : "A",
        : "A",
        : "a",
        : "a",
        : "a",
        : "a",
        : "a",
        : "a",
        : "C",
        : "c",
        : "D",
        : "d",
        : "E",
        : "E",
        : "E",
        : "E",
        : "e",
        : "e",
        : "e",
        : "e",
        : "I",
        : "I",
        : "I",
        : "I",
        : "i",
        : "i",
        : "i",
        : "i",
        : "N",
        : "n",
        : "O",
        : "O",
        : "O",
        : "O",
        : "O",
        : "O",
        : "o",
        : "o",
        : "o",
        : "o",
        : "o",
        : "o",
        : "U",
        : "U",
        : "U",
        : "U",
        : "u",
        : "u",
        : "u",
        : "u",
        : "Y",
        : "y",
        : "y",
        : "Ae",
        : "ae",
        : "Th",
        : "th",
        : "ss",
        // Latin Extended-A block.
        : "A",
        : "A",
        : "A",
        : "a",
        : "a",
        : "a",
        : "C",
        : "C",
        : "C",
        : "C",
        : "c",
        : "c",
        : "c",
        : "c",
        : "D",
        : "D",
        : "d",
        : "d",
        : "E",
        : "E",
        : "E",
        : "E",
        : "E",
        : "e",
        : "e",
        : "e",
        : "e",
        : "e",
        : "G",
        : "G",
        : "G",
        : "G",
        : "g",
        : "g",
        : "g",
        : "g",
        : "H",
        : "H",
        : "h",
        : "h",
        : "I",
        : "I",
        : "I",
        : "I",
        : "I",
        : "i",
        : "i",
        : "i",
        : "i",
        : "i",
        : "J",
        : "j",
        : "K",
        : "k",
        : "k",
        : "L",
        : "L",
        : "L",
        : "L",
        : "L",
        : "l",
        : "l",
        : "l",
        : "l",
        : "l",
        : "N",
        : "N",
        : "N",
        : "N",
        : "n",
        : "n",
        : "n",
        : "n",
        : "O",
        : "O",
        : "O",
        : "o",
        : "o",
        : "o",
        : "R",
        : "R",
        : "R",
        : "r",
        : "r",
        : "r",
        : "S",
        : "S",
        : "S",
        : "S",
        : "s",
        : "s",
        : "s",
        : "s",
        : "T",
        : "T",
        : "T",
        : "t",
        : "t",
        : "t",
        : "U",
        : "U",
        : "U",
        : "U",
        : "U",
        : "U",
        : "u",
        : "u",
        : "u",
        : "u",
        : "u",
        : "u",
        : "W",
        : "w",
        : "Y",
        : "y",
        : "Y",
        : "Z",
        : "Z",
        : "Z",
        : "z",
        : "z",
        : "z",
        : "IJ",
        : "ij",
        : "Oe",
        : "oe",
        : "'n",
        : "s",
      };
      var htmlEscapes = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;",
      };
      var htmlUnescapes = {
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&quot;": '"',
        "&#39;": "'",
      };
      var stringEscapes = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029",
      };
      var freeParseFloat = parseFloat,
        freeParseInt = parseInt;
      var freeGlobal =
        typeof global == "object" &&
        global &&
        global.Object === Object &&
        global;
      var freeSelf =
        typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      var freeExports =
        typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule =
        freeExports &&
        typeof module == "object" &&
        module &&
        !module.nodeType &&
        module;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var freeProcess = moduleExports && freeGlobal.process;
      var nodeUtil = (function () {
        try {
          var types =
            freeModule &&
            freeModule.require &&
            freeModule.require("util").types;
          if (types) {
            return types;
          }
          return (
            freeProcess && freeProcess.binding && freeProcess.binding("util")
          );
        } catch (e) {}
      })();
      var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer,
        nodeIsDate = nodeUtil && nodeUtil.isDate,
        nodeIsMap = nodeUtil && nodeUtil.isMap,
        nodeIsRegExp = nodeUtil && nodeUtil.isRegExp,
        nodeIsSet = nodeUtil && nodeUtil.isSet,
        nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args[0]);
          case 2:
            return func.call(thisArg, args[0], args[1]);
          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
      function arrayAggregator(array, setter, iteratee, accumulator) {
        var index = -1,
          length = array == null ? 0 : array.length;
        while (++index < length) {
          var value = array[index];
          setter(accumulator, value, iteratee(value), array);
        }
        return accumulator;
      }
      function arrayEach(array, iteratee) {
        var index = -1,
          length = array == null ? 0 : array.length;
        while (++index < length) {
          if (iteratee(array[index], index, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEachRight(array, iteratee) {
        var length = array == null ? 0 : array.length;
        while (length--) {
          if (iteratee(array[length], length, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEvery(array, predicate) {
        var index = -1,
          length = array == null ? 0 : array.length;
        while (++index < length) {
          if (!predicate(array[index], index, array)) {
            return false;
          }
        }
        return true;
      }
      function arrayFilter(array, predicate) {
        var index = -1,
          length = array == null ? 0 : array.length,
          resIndex = 0,
          result = [];
        while (++index < length) {
          var value = array[index];
          if (predicate(value, index, array)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      function arrayIncludes(array, value) {
        var length = array == null ? 0 : array.length;
        return !!length && baseIndexOf(array, value, 0) > -1;
      }
      function arrayIncludesWith(array, value, comparator) {
        var index = -1,
          length = array == null ? 0 : array.length;
        while (++index < length) {
          if (comparator(value, array[index])) {
            return true;
          }
        }
        return false;
      }
      function arrayMap(array, iteratee) {
        var index = -1,
          length = array == null ? 0 : array.length,
          result = Array(length);
        while (++index < length) {
          result[index] = iteratee(array[index], index, array);
        }
        return result;
      }
      function arrayPush(array, values) {
        var index = -1,
          length = values.length,
          offset = array.length;
        while (++index < length) {
          array[offset + index] = values[index];
        }
        return array;
      }
      function arrayReduce(array, iteratee, accumulator, initAccum) {
        var index = -1,
          length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[++index];
        }
        while (++index < length) {
          accumulator = iteratee(accumulator, array[index], index, array);
        }
        return accumulator;
      }
      function arrayReduceRight(array, iteratee, accumulator, initAccum) {
        var length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[--length];
        }
        while (length--) {
          accumulator = iteratee(accumulator, array[length], length, array);
        }
        return accumulator;
      }
      function arraySome(array, predicate) {
        var index = -1,
          length = array == null ? 0 : array.length;
        while (++index < length) {
          if (predicate(array[index], index, array)) {
            return true;
          }
        }
        return false;
      }
      var asciiSize = baseProperty("length");
      function asciiToArray(string) {
        return string.split("");
      }
      function asciiWords(string) {
        return string.match(reAsciiWord) || [];
      }
      function baseFindKey(collection, predicate, eachFunc) {
        var result;
        eachFunc(collection, function (value, key, collection2) {
          if (predicate(value, key, collection2)) {
            result = key;
            return false;
          }
        });
        return result;
      }
      function baseFindIndex(array, predicate, fromIndex, fromRight) {
        var length = array.length,
          index = fromIndex + (fromRight ? 1 : -1);
        while (fromRight ? index-- : ++index < length) {
          if (predicate(array[index], index, array)) {
            return index;
          }
        }
        return -1;
      }
      function baseIndexOf(array, value, fromIndex) {
        return value === value
          ? strictIndexOf(array, value, fromIndex)
          : baseFindIndex(array, baseIsNaN, fromIndex);
      }
      function baseIndexOfWith(array, value, fromIndex, comparator) {
        var index = fromIndex - 1,
          length = array.length;
        while (++index < length) {
          if (comparator(array[index], value)) {
            return index;
          }
        }
        return -1;
      }
      function baseIsNaN(value) {
        return value !== value;
      }
      function baseMean(array, iteratee) {
        var length = array == null ? 0 : array.length;
        return length ? baseSum(array, iteratee) / length : NAN;
      }
      function baseProperty(key) {
        return function (object) {
          return object == null ? undefined$1 : object[key];
        };
      }
      function basePropertyOf(object) {
        return function (key) {
          return object == null ? undefined$1 : object[key];
        };
      }
      function baseReduce(
        collection,
        iteratee,
        accumulator,
        initAccum,
        eachFunc
      ) {
        eachFunc(collection, function (value, index, collection2) {
          accumulator = initAccum
            ? ((initAccum = false), value)
            : iteratee(accumulator, value, index, collection2);
        });
        return accumulator;
      }
      function baseSortBy(array, comparer) {
        var length = array.length;
        array.sort(comparer);
        while (length--) {
          array[length] = array[length].value;
        }
        return array;
      }
      function baseSum(array, iteratee) {
        var result,
          index = -1,
          length = array.length;
        while (++index < length) {
          var current = iteratee(array[index]);
          if (current !== undefined$1) {
            result = result === undefined$1 ? current : result + current;
          }
        }
        return result;
      }
      function baseTimes(n, iteratee) {
        var index = -1,
          result = Array(n);
        while (++index < n) {
          result[index] = iteratee(index);
        }
        return result;
      }
      function baseToPairs(object, props) {
        return arrayMap(props, function (key) {
          return [key, object[key]];
        });
      }
      function baseTrim(string) {
        return string
          ? string
              .slice(0, trimmedEndIndex(string) + 1)
              .replace(reTrimStart, "")
          : string;
      }
      function baseUnary(func) {
        return function (value) {
          return func(value);
        };
      }
      function baseValues(object, props) {
        return arrayMap(props, function (key) {
          return object[key];
        });
      }
      function cacheHas(cache, key) {
        return cache.has(key);
      }
      function charsStartIndex(strSymbols, chrSymbols) {
        var index = -1,
          length = strSymbols.length;
        while (
          ++index < length &&
          baseIndexOf(chrSymbols, strSymbols[index], 0) > -1
        ) {}
        return index;
      }
      function charsEndIndex(strSymbols, chrSymbols) {
        var index = strSymbols.length;
        while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
        return index;
      }
      function countHolders(array, placeholder) {
        var length = array.length,
          result = 0;
        while (length--) {
          if (array[length] === placeholder) {
            ++result;
          }
        }
        return result;
      }
      var deburrLetter = basePropertyOf(deburredLetters);
      var escapeHtmlChar = basePropertyOf(htmlEscapes);
      function escapeStringChar(chr) {
        return "\\" + stringEscapes[chr];
      }
      function getValue(object, key) {
        return object == null ? undefined$1 : object[key];
      }
      function hasUnicode(string) {
        return reHasUnicode.test(string);
      }
      function hasUnicodeWord(string) {
        return reHasUnicodeWord.test(string);
      }
      function iteratorToArray(iterator) {
        var data,
          result = [];
        while (!(data = iterator.next()).done) {
          result.push(data.value);
        }
        return result;
      }
      function mapToArray(map) {
        var index = -1,
          result = Array(map.size);
        map.forEach(function (value, key) {
          result[++index] = [key, value];
        });
        return result;
      }
      function overArg(func, transform) {
        return function (arg) {
          return func(transform(arg));
        };
      }
      function replaceHolders(array, placeholder) {
        var index = -1,
          length = array.length,
          resIndex = 0,
          result = [];
        while (++index < length) {
          var value = array[index];
          if (value === placeholder || value === PLACEHOLDER) {
            array[index] = PLACEHOLDER;
            result[resIndex++] = index;
          }
        }
        return result;
      }
      function setToArray(set) {
        var index = -1,
          result = Array(set.size);
        set.forEach(function (value) {
          result[++index] = value;
        });
        return result;
      }
      function setToPairs(set) {
        var index = -1,
          result = Array(set.size);
        set.forEach(function (value) {
          result[++index] = [value, value];
        });
        return result;
      }
      function strictIndexOf(array, value, fromIndex) {
        var index = fromIndex - 1,
          length = array.length;
        while (++index < length) {
          if (array[index] === value) {
            return index;
          }
        }
        return -1;
      }
      function strictLastIndexOf(array, value, fromIndex) {
        var index = fromIndex + 1;
        while (index--) {
          if (array[index] === value) {
            return index;
          }
        }
        return index;
      }
      function stringSize(string) {
        return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
      }
      function stringToArray(string) {
        return hasUnicode(string)
          ? unicodeToArray(string)
          : asciiToArray(string);
      }
      function trimmedEndIndex(string) {
        var index = string.length;
        while (index-- && reWhitespace.test(string.charAt(index))) {}
        return index;
      }
      var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
      function unicodeSize(string) {
        var result = (reUnicode.lastIndex = 0);
        while (reUnicode.test(string)) {
          ++result;
        }
        return result;
      }
      function unicodeToArray(string) {
        return string.match(reUnicode) || [];
      }
      function unicodeWords(string) {
        return string.match(reUnicodeWord) || [];
      }
      var runInContext = function runInContext2(context) {
        context =
          context == null
            ? root
            : _.defaults(root.Object(), context, _.pick(root, contextProps));
        var Array2 = context.Array,
          Date = context.Date,
          Error = context.Error,
          Function2 = context.Function,
          Math = context.Math,
          Object2 = context.Object,
          RegExp2 = context.RegExp,
          String = context.String,
          TypeError = context.TypeError;
        var arrayProto = Array2.prototype,
          funcProto = Function2.prototype,
          objectProto = Object2.prototype;
        var coreJsData = context["__core-js_shared__"];
        var funcToString = funcProto.toString;
        var hasOwnProperty = objectProto.hasOwnProperty;
        var idCounter = 0;
        var maskSrcKey = (function () {
          var uid = /[^.]+$/.exec(
            (coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO) || ""
          );
          return uid ? "Symbol(src)_1." + uid : "";
        })();
        var nativeObjectToString = objectProto.toString;
        var objectCtorString = funcToString.call(Object2);
        var oldDash = root._;
        var reIsNative = RegExp2(
          "^" +
            funcToString
              .call(hasOwnProperty)
              .replace(reRegExpChar, "\\$&")
              .replace(
                /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
                "$1.*?"
              ) +
            "$"
        );
        var Buffer = moduleExports ? context.Buffer : undefined$1,
          Symbol = context.Symbol,
          Uint8Array = context.Uint8Array,
          allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined$1,
          getPrototype = overArg(Object2.getPrototypeOf, Object2),
          objectCreate = Object2.create,
          propertyIsEnumerable = objectProto.propertyIsEnumerable,
          splice = arrayProto.splice,
          spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined$1,
          symIterator = Symbol ? Symbol.iterator : undefined$1,
          symToStringTag = Symbol ? Symbol.toStringTag : undefined$1;
        var defineProperty = (function () {
          try {
            var func = getNative(Object2, "defineProperty");
            func({}, "", {});
            return func;
          } catch (e) {}
        })();
        var ctxClearTimeout =
            context.clearTimeout !== root.clearTimeout && context.clearTimeout,
          ctxNow = Date && Date.now !== root.Date.now && Date.now,
          ctxSetTimeout =
            context.setTimeout !== root.setTimeout && context.setTimeout;
        var nativeCeil = Math.ceil,
          nativeFloor = Math.floor,
          nativeGetSymbols = Object2.getOwnPropertySymbols,
          nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined$1,
          nativeIsFinite = context.isFinite,
          nativeJoin = arrayProto.join,
          nativeKeys = overArg(Object2.keys, Object2),
          nativeMax = Math.max,
          nativeMin = Math.min,
          nativeNow = Date.now,
          nativeParseInt = context.parseInt,
          nativeRandom = Math.random,
          nativeReverse = arrayProto.reverse;
        var DataView = getNative(context, "DataView"),
          Map = getNative(context, "Map"),
          Promise2 = getNative(context, "Promise"),
          Set = getNative(context, "Set"),
          WeakMap = getNative(context, "WeakMap"),
          nativeCreate = getNative(Object2, "create");
        var metaMap = WeakMap && new WeakMap();
        var realNames = {};
        var dataViewCtorString = toSource(DataView),
          mapCtorString = toSource(Map),
          promiseCtorString = toSource(Promise2),
          setCtorString = toSource(Set),
          weakMapCtorString = toSource(WeakMap);
        var symbolProto = Symbol ? Symbol.prototype : undefined$1,
          symbolValueOf = symbolProto ? symbolProto.valueOf : undefined$1,
          symbolToString = symbolProto ? symbolProto.toString : undefined$1;
        function lodash(value) {
          if (
            isObjectLike(value) &&
            !isArray(value) &&
            !(value instanceof LazyWrapper)
          ) {
            if (value instanceof LodashWrapper) {
              return value;
            }
            if (hasOwnProperty.call(value, "__wrapped__")) {
              return wrapperClone(value);
            }
          }
          return new LodashWrapper(value);
        }
        var baseCreate = (function () {
          function object() {}
          return function (proto) {
            if (!isObject(proto)) {
              return {};
            }
            if (objectCreate) {
              return objectCreate(proto);
            }
            object.prototype = proto;
            var result2 = new object();
            object.prototype = undefined$1;
            return result2;
          };
        })();
        function baseLodash() {}
        function LodashWrapper(value, chainAll) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__chain__ = !!chainAll;
          this.__index__ = 0;
          this.__values__ = undefined$1;
        }
        lodash.templateSettings = {
          /**
           * Used to detect `data` property values to be HTML-escaped.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          escape: reEscape,
          /**
           * Used to detect code to be evaluated.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          evaluate: reEvaluate,
          /**
           * Used to detect `data` property values to inject.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          interpolate: reInterpolate,
          /**
           * Used to reference the data object in the template text.
           *
           * @memberOf _.templateSettings
           * @type {string}
           */
          variable: "",
          /**
           * Used to import variables into the compiled template.
           *
           * @memberOf _.templateSettings
           * @type {Object}
           */
          imports: {
            /**
             * A reference to the `lodash` function.
             *
             * @memberOf _.templateSettings.imports
             * @type {Function}
             */
            _: lodash,
          },
        };
        lodash.prototype = baseLodash.prototype;
        lodash.prototype.constructor = lodash;
        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;
        function LazyWrapper(value) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__dir__ = 1;
          this.__filtered__ = false;
          this.__iteratees__ = [];
          this.__takeCount__ = MAX_ARRAY_LENGTH;
          this.__views__ = [];
        }
        function lazyClone() {
          var result2 = new LazyWrapper(this.__wrapped__);
          result2.__actions__ = copyArray(this.__actions__);
          result2.__dir__ = this.__dir__;
          result2.__filtered__ = this.__filtered__;
          result2.__iteratees__ = copyArray(this.__iteratees__);
          result2.__takeCount__ = this.__takeCount__;
          result2.__views__ = copyArray(this.__views__);
          return result2;
        }
        function lazyReverse() {
          if (this.__filtered__) {
            var result2 = new LazyWrapper(this);
            result2.__dir__ = -1;
            result2.__filtered__ = true;
          } else {
            result2 = this.clone();
            result2.__dir__ *= -1;
          }
          return result2;
        }
        function lazyValue() {
          var array = this.__wrapped__.value(),
            dir = this.__dir__,
            isArr = isArray(array),
            isRight = dir < 0,
            arrLength = isArr ? array.length : 0,
            view = getView(0, arrLength, this.__views__),
            start = view.start,
            end = view.end,
            length = end - start,
            index = isRight ? end : start - 1,
            iteratees = this.__iteratees__,
            iterLength = iteratees.length,
            resIndex = 0,
            takeCount = nativeMin(length, this.__takeCount__);
          if (
            !isArr ||
            (!isRight && arrLength == length && takeCount == length)
          ) {
            return baseWrapperValue(array, this.__actions__);
          }
          var result2 = [];
          outer: while (length-- && resIndex < takeCount) {
            index += dir;
            var iterIndex = -1,
              value = array[index];
            while (++iterIndex < iterLength) {
              var data = iteratees[iterIndex],
                iteratee2 = data.iteratee,
                type = data.type,
                computed = iteratee2(value);
              if (type == LAZY_MAP_FLAG) {
                value = computed;
              } else if (!computed) {
                if (type == LAZY_FILTER_FLAG) {
                  continue outer;
                } else {
                  break outer;
                }
              }
            }
            result2[resIndex++] = value;
          }
          return result2;
        }
        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;
        function Hash(entries) {
          var index = -1,
            length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function hashClear() {
          this.__data__ = nativeCreate ? nativeCreate(null) : {};
          this.size = 0;
        }
        function hashDelete(key) {
          var result2 = this.has(key) && delete this.__data__[key];
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function hashGet(key) {
          var data = this.__data__;
          if (nativeCreate) {
            var result2 = data[key];
            return result2 === HASH_UNDEFINED ? undefined$1 : result2;
          }
          return hasOwnProperty.call(data, key) ? data[key] : undefined$1;
        }
        function hashHas(key) {
          var data = this.__data__;
          return nativeCreate
            ? data[key] !== undefined$1
            : hasOwnProperty.call(data, key);
        }
        function hashSet(key, value) {
          var data = this.__data__;
          this.size += this.has(key) ? 0 : 1;
          data[key] =
            nativeCreate && value === undefined$1 ? HASH_UNDEFINED : value;
          return this;
        }
        Hash.prototype.clear = hashClear;
        Hash.prototype["delete"] = hashDelete;
        Hash.prototype.get = hashGet;
        Hash.prototype.has = hashHas;
        Hash.prototype.set = hashSet;
        function ListCache(entries) {
          var index = -1,
            length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function listCacheClear() {
          this.__data__ = [];
          this.size = 0;
        }
        function listCacheDelete(key) {
          var data = this.__data__,
            index = assocIndexOf(data, key);
          if (index < 0) {
            return false;
          }
          var lastIndex = data.length - 1;
          if (index == lastIndex) {
            data.pop();
          } else {
            splice.call(data, index, 1);
          }
          --this.size;
          return true;
        }
        function listCacheGet(key) {
          var data = this.__data__,
            index = assocIndexOf(data, key);
          return index < 0 ? undefined$1 : data[index][1];
        }
        function listCacheHas(key) {
          return assocIndexOf(this.__data__, key) > -1;
        }
        function listCacheSet(key, value) {
          var data = this.__data__,
            index = assocIndexOf(data, key);
          if (index < 0) {
            ++this.size;
            data.push([key, value]);
          } else {
            data[index][1] = value;
          }
          return this;
        }
        ListCache.prototype.clear = listCacheClear;
        ListCache.prototype["delete"] = listCacheDelete;
        ListCache.prototype.get = listCacheGet;
        ListCache.prototype.has = listCacheHas;
        ListCache.prototype.set = listCacheSet;
        function MapCache(entries) {
          var index = -1,
            length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function mapCacheClear() {
          this.size = 0;
          this.__data__ = {
            hash: new Hash(),
            map: new (Map || ListCache)(),
            string: new Hash(),
          };
        }
        function mapCacheDelete(key) {
          var result2 = getMapData(this, key)["delete"](key);
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function mapCacheGet(key) {
          return getMapData(this, key).get(key);
        }
        function mapCacheHas(key) {
          return getMapData(this, key).has(key);
        }
        function mapCacheSet(key, value) {
          var data = getMapData(this, key),
            size2 = data.size;
          data.set(key, value);
          this.size += data.size == size2 ? 0 : 1;
          return this;
        }
        MapCache.prototype.clear = mapCacheClear;
        MapCache.prototype["delete"] = mapCacheDelete;
        MapCache.prototype.get = mapCacheGet;
        MapCache.prototype.has = mapCacheHas;
        MapCache.prototype.set = mapCacheSet;
        function SetCache(values2) {
          var index = -1,
            length = values2 == null ? 0 : values2.length;
          this.__data__ = new MapCache();
          while (++index < length) {
            this.add(values2[index]);
          }
        }
        function setCacheAdd(value) {
          this.__data__.set(value, HASH_UNDEFINED);
          return this;
        }
        function setCacheHas(value) {
          return this.__data__.has(value);
        }
        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
        SetCache.prototype.has = setCacheHas;
        function Stack(entries) {
          var data = (this.__data__ = new ListCache(entries));
          this.size = data.size;
        }
        function stackClear() {
          this.__data__ = new ListCache();
          this.size = 0;
        }
        function stackDelete(key) {
          var data = this.__data__,
            result2 = data["delete"](key);
          this.size = data.size;
          return result2;
        }
        function stackGet(key) {
          return this.__data__.get(key);
        }
        function stackHas(key) {
          return this.__data__.has(key);
        }
        function stackSet(key, value) {
          var data = this.__data__;
          if (data instanceof ListCache) {
            var pairs = data.__data__;
            if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
              pairs.push([key, value]);
              this.size = ++data.size;
              return this;
            }
            data = this.__data__ = new MapCache(pairs);
          }
          data.set(key, value);
          this.size = data.size;
          return this;
        }
        Stack.prototype.clear = stackClear;
        Stack.prototype["delete"] = stackDelete;
        Stack.prototype.get = stackGet;
        Stack.prototype.has = stackHas;
        Stack.prototype.set = stackSet;
        function arrayLikeKeys(value, inherited) {
          var isArr = isArray(value),
            isArg = !isArr && isArguments(value),
            isBuff = !isArr && !isArg && isBuffer(value),
            isType = !isArr && !isArg && !isBuff && isTypedArray(value),
            skipIndexes = isArr || isArg || isBuff || isType,
            result2 = skipIndexes ? baseTimes(value.length, String) : [],
            length = result2.length;
          for (var key in value) {
            if (
              (inherited || hasOwnProperty.call(value, key)) &&
              !(
                skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
                (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
                  (isBuff && (key == "offset" || key == "parent")) || // PhantomJS 2 has enumerable non-index properties on typed arrays.
                  (isType &&
                    (key == "buffer" ||
                      key == "byteLength" ||
                      key == "byteOffset")) || // Skip index properties.
                  isIndex(key, length))
              )
            ) {
              result2.push(key);
            }
          }
          return result2;
        }
        function arraySample(array) {
          var length = array.length;
          return length ? array[baseRandom(0, length - 1)] : undefined$1;
        }
        function arraySampleSize(array, n) {
          return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
        }
        function arrayShuffle(array) {
          return shuffleSelf(copyArray(array));
        }
        function assignMergeValue(object, key, value) {
          if (
            (value !== undefined$1 && !eq(object[key], value)) ||
            (value === undefined$1 && !(key in object))
          ) {
            baseAssignValue(object, key, value);
          }
        }
        function assignValue(object, key, value) {
          var objValue = object[key];
          if (
            !(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
            (value === undefined$1 && !(key in object))
          ) {
            baseAssignValue(object, key, value);
          }
        }
        function assocIndexOf(array, key) {
          var length = array.length;
          while (length--) {
            if (eq(array[length][0], key)) {
              return length;
            }
          }
          return -1;
        }
        function baseAggregator(collection, setter, iteratee2, accumulator) {
          baseEach(collection, function (value, key, collection2) {
            setter(accumulator, value, iteratee2(value), collection2);
          });
          return accumulator;
        }
        function baseAssign(object, source) {
          return object && copyObject(source, keys(source), object);
        }
        function baseAssignIn(object, source) {
          return object && copyObject(source, keysIn(source), object);
        }
        function baseAssignValue(object, key, value) {
          if (key == "__proto__" && defineProperty) {
            defineProperty(object, key, {
              configurable: true,
              enumerable: true,
              value: value,
              writable: true,
            });
          } else {
            object[key] = value;
          }
        }
        function baseAt(object, paths) {
          var index = -1,
            length = paths.length,
            result2 = Array2(length),
            skip = object == null;
          while (++index < length) {
            result2[index] = skip ? undefined$1 : get(object, paths[index]);
          }
          return result2;
        }
        function baseClamp(number, lower, upper) {
          if (number === number) {
            if (upper !== undefined$1) {
              number = number <= upper ? number : upper;
            }
            if (lower !== undefined$1) {
              number = number >= lower ? number : lower;
            }
          }
          return number;
        }
        function baseClone(value, bitmask, customizer, key, object, stack) {
          var result2,
            isDeep = bitmask & CLONE_DEEP_FLAG,
            isFlat = bitmask & CLONE_FLAT_FLAG,
            isFull = bitmask & CLONE_SYMBOLS_FLAG;
          if (customizer) {
            result2 = object
              ? customizer(value, key, object, stack)
              : customizer(value);
          }
          if (result2 !== undefined$1) {
            return result2;
          }
          if (!isObject(value)) {
            return value;
          }
          var isArr = isArray(value);
          if (isArr) {
            result2 = initCloneArray(value);
            if (!isDeep) {
              return copyArray(value, result2);
            }
          } else {
            var tag = getTag(value),
              isFunc = tag == funcTag || tag == genTag;
            if (isBuffer(value)) {
              return cloneBuffer(value, isDeep);
            }
            if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
              result2 = isFlat || isFunc ? {} : initCloneObject(value);
              if (!isDeep) {
                return isFlat
                  ? copySymbolsIn(value, baseAssignIn(result2, value))
                  : copySymbols(value, baseAssign(result2, value));
              }
            } else {
              if (!cloneableTags[tag]) {
                return object ? value : {};
              }
              result2 = initCloneByTag(value, tag, isDeep);
            }
          }
          stack || (stack = new Stack());
          var stacked = stack.get(value);
          if (stacked) {
            return stacked;
          }
          stack.set(value, result2);
          if (isSet(value)) {
            value.forEach(function (subValue) {
              result2.add(
                baseClone(subValue, bitmask, customizer, subValue, value, stack)
              );
            });
          } else if (isMap(value)) {
            value.forEach(function (subValue, key2) {
              result2.set(
                key2,
                baseClone(subValue, bitmask, customizer, key2, value, stack)
              );
            });
          }
          var keysFunc = isFull
            ? isFlat
              ? getAllKeysIn
              : getAllKeys
            : isFlat
            ? keysIn
            : keys;
          var props = isArr ? undefined$1 : keysFunc(value);
          arrayEach(props || value, function (subValue, key2) {
            if (props) {
              key2 = subValue;
              subValue = value[key2];
            }
            assignValue(
              result2,
              key2,
              baseClone(subValue, bitmask, customizer, key2, value, stack)
            );
          });
          return result2;
        }
        function baseConforms(source) {
          var props = keys(source);
          return function (object) {
            return baseConformsTo(object, source, props);
          };
        }
        function baseConformsTo(object, source, props) {
          var length = props.length;
          if (object == null) {
            return !length;
          }
          object = Object2(object);
          while (length--) {
            var key = props[length],
              predicate = source[key],
              value = object[key];
            if (
              (value === undefined$1 && !(key in object)) ||
              !predicate(value)
            ) {
              return false;
            }
          }
          return true;
        }
        function baseDelay(func, wait, args) {
          if (typeof func != "function") {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          return setTimeout(function () {
            func.apply(undefined$1, args);
          }, wait);
        }
        function baseDifference(array, values2, iteratee2, comparator) {
          var index = -1,
            includes2 = arrayIncludes,
            isCommon = true,
            length = array.length,
            result2 = [],
            valuesLength = values2.length;
          if (!length) {
            return result2;
          }
          if (iteratee2) {
            values2 = arrayMap(values2, baseUnary(iteratee2));
          }
          if (comparator) {
            includes2 = arrayIncludesWith;
            isCommon = false;
          } else if (values2.length >= LARGE_ARRAY_SIZE) {
            includes2 = cacheHas;
            isCommon = false;
            values2 = new SetCache(values2);
          }
          outer: while (++index < length) {
            var value = array[index],
              computed = iteratee2 == null ? value : iteratee2(value);
            value = comparator || value !== 0 ? value : 0;
            if (isCommon && computed === computed) {
              var valuesIndex = valuesLength;
              while (valuesIndex--) {
                if (values2[valuesIndex] === computed) {
                  continue outer;
                }
              }
              result2.push(value);
            } else if (!includes2(values2, computed, comparator)) {
              result2.push(value);
            }
          }
          return result2;
        }
        var baseEach = createBaseEach(baseForOwn);
        var baseEachRight = createBaseEach(baseForOwnRight, true);
        function baseEvery(collection, predicate) {
          var result2 = true;
          baseEach(collection, function (value, index, collection2) {
            result2 = !!predicate(value, index, collection2);
            return result2;
          });
          return result2;
        }
        function baseExtremum(array, iteratee2, comparator) {
          var index = -1,
            length = array.length;
          while (++index < length) {
            var value = array[index],
              current = iteratee2(value);
            if (
              current != null &&
              (computed === undefined$1
                ? current === current && !isSymbol(current)
                : comparator(current, computed))
            ) {
              var computed = current,
                result2 = value;
            }
          }
          return result2;
        }
        function baseFill(array, value, start, end) {
          var length = array.length;
          start = toInteger(start);
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end === undefined$1 || end > length ? length : toInteger(end);
          if (end < 0) {
            end += length;
          }
          end = start > end ? 0 : toLength(end);
          while (start < end) {
            array[start++] = value;
          }
          return array;
        }
        function baseFilter(collection, predicate) {
          var result2 = [];
          baseEach(collection, function (value, index, collection2) {
            if (predicate(value, index, collection2)) {
              result2.push(value);
            }
          });
          return result2;
        }
        function baseFlatten(array, depth, predicate, isStrict, result2) {
          var index = -1,
            length = array.length;
          predicate || (predicate = isFlattenable);
          result2 || (result2 = []);
          while (++index < length) {
            var value = array[index];
            if (depth > 0 && predicate(value)) {
              if (depth > 1) {
                baseFlatten(value, depth - 1, predicate, isStrict, result2);
              } else {
                arrayPush(result2, value);
              }
            } else if (!isStrict) {
              result2[result2.length] = value;
            }
          }
          return result2;
        }
        var baseFor = createBaseFor();
        var baseForRight = createBaseFor(true);
        function baseForOwn(object, iteratee2) {
          return object && baseFor(object, iteratee2, keys);
        }
        function baseForOwnRight(object, iteratee2) {
          return object && baseForRight(object, iteratee2, keys);
        }
        function baseFunctions(object, props) {
          return arrayFilter(props, function (key) {
            return isFunction(object[key]);
          });
        }
        function baseGet(object, path) {
          path = castPath(path, object);
          var index = 0,
            length = path.length;
          while (object != null && index < length) {
            object = object[toKey(path[index++])];
          }
          return index && index == length ? object : undefined$1;
        }
        function baseGetAllKeys(object, keysFunc, symbolsFunc) {
          var result2 = keysFunc(object);
          return isArray(object)
            ? result2
            : arrayPush(result2, symbolsFunc(object));
        }
        function baseGetTag(value) {
          if (value == null) {
            return value === undefined$1 ? undefinedTag : nullTag;
          }
          return symToStringTag && symToStringTag in Object2(value)
            ? getRawTag(value)
            : objectToString(value);
        }
        function baseGt(value, other) {
          return value > other;
        }
        function baseHas(object, key) {
          return object != null && hasOwnProperty.call(object, key);
        }
        function baseHasIn(object, key) {
          return object != null && key in Object2(object);
        }
        function baseInRange(number, start, end) {
          return (
            number >= nativeMin(start, end) && number < nativeMax(start, end)
          );
        }
        function baseIntersection(arrays, iteratee2, comparator) {
          var includes2 = comparator ? arrayIncludesWith : arrayIncludes,
            length = arrays[0].length,
            othLength = arrays.length,
            othIndex = othLength,
            caches = Array2(othLength),
            maxLength = Infinity,
            result2 = [];
          while (othIndex--) {
            var array = arrays[othIndex];
            if (othIndex && iteratee2) {
              array = arrayMap(array, baseUnary(iteratee2));
            }
            maxLength = nativeMin(array.length, maxLength);
            caches[othIndex] =
              !comparator &&
              (iteratee2 || (length >= 120 && array.length >= 120))
                ? new SetCache(othIndex && array)
                : undefined$1;
          }
          array = arrays[0];
          var index = -1,
            seen = caches[0];
          outer: while (++index < length && result2.length < maxLength) {
            var value = array[index],
              computed = iteratee2 ? iteratee2(value) : value;
            value = comparator || value !== 0 ? value : 0;
            if (
              !(seen
                ? cacheHas(seen, computed)
                : includes2(result2, computed, comparator))
            ) {
              othIndex = othLength;
              while (--othIndex) {
                var cache = caches[othIndex];
                if (
                  !(cache
                    ? cacheHas(cache, computed)
                    : includes2(arrays[othIndex], computed, comparator))
                ) {
                  continue outer;
                }
              }
              if (seen) {
                seen.push(computed);
              }
              result2.push(value);
            }
          }
          return result2;
        }
        function baseInverter(object, setter, iteratee2, accumulator) {
          baseForOwn(object, function (value, key, object2) {
            setter(accumulator, iteratee2(value), key, object2);
          });
          return accumulator;
        }
        function baseInvoke(object, path, args) {
          path = castPath(path, object);
          object = parent(object, path);
          var func = object == null ? object : object[toKey(last(path))];
          return func == null ? undefined$1 : apply(func, object, args);
        }
        function baseIsArguments(value) {
          return isObjectLike(value) && baseGetTag(value) == argsTag;
        }
        function baseIsArrayBuffer(value) {
          return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
        }
        function baseIsDate(value) {
          return isObjectLike(value) && baseGetTag(value) == dateTag;
        }
        function baseIsEqual(value, other, bitmask, customizer, stack) {
          if (value === other) {
            return true;
          }
          if (
            value == null ||
            other == null ||
            (!isObjectLike(value) && !isObjectLike(other))
          ) {
            return value !== value && other !== other;
          }
          return baseIsEqualDeep(
            value,
            other,
            bitmask,
            customizer,
            baseIsEqual,
            stack
          );
        }
        function baseIsEqualDeep(
          object,
          other,
          bitmask,
          customizer,
          equalFunc,
          stack
        ) {
          var objIsArr = isArray(object),
            othIsArr = isArray(other),
            objTag = objIsArr ? arrayTag : getTag(object),
            othTag = othIsArr ? arrayTag : getTag(other);
          objTag = objTag == argsTag ? objectTag : objTag;
          othTag = othTag == argsTag ? objectTag : othTag;
          var objIsObj = objTag == objectTag,
            othIsObj = othTag == objectTag,
            isSameTag = objTag == othTag;
          if (isSameTag && isBuffer(object)) {
            if (!isBuffer(other)) {
              return false;
            }
            objIsArr = true;
            objIsObj = false;
          }
          if (isSameTag && !objIsObj) {
            stack || (stack = new Stack());
            return objIsArr || isTypedArray(object)
              ? equalArrays(
                  object,
                  other,
                  bitmask,
                  customizer,
                  equalFunc,
                  stack
                )
              : equalByTag(
                  object,
                  other,
                  objTag,
                  bitmask,
                  customizer,
                  equalFunc,
                  stack
                );
          }
          if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
            var objIsWrapped =
                objIsObj && hasOwnProperty.call(object, "__wrapped__"),
              othIsWrapped =
                othIsObj && hasOwnProperty.call(other, "__wrapped__");
            if (objIsWrapped || othIsWrapped) {
              var objUnwrapped = objIsWrapped ? object.value() : object,
                othUnwrapped = othIsWrapped ? other.value() : other;
              stack || (stack = new Stack());
              return equalFunc(
                objUnwrapped,
                othUnwrapped,
                bitmask,
                customizer,
                stack
              );
            }
          }
          if (!isSameTag) {
            return false;
          }
          stack || (stack = new Stack());
          return equalObjects(
            object,
            other,
            bitmask,
            customizer,
            equalFunc,
            stack
          );
        }
        function baseIsMap(value) {
          return isObjectLike(value) && getTag(value) == mapTag;
        }
        function baseIsMatch(object, source, matchData, customizer) {
          var index = matchData.length,
            length = index,
            noCustomizer = !customizer;
          if (object == null) {
            return !length;
          }
          object = Object2(object);
          while (index--) {
            var data = matchData[index];
            if (
              noCustomizer && data[2]
                ? data[1] !== object[data[0]]
                : !(data[0] in object)
            ) {
              return false;
            }
          }
          while (++index < length) {
            data = matchData[index];
            var key = data[0],
              objValue = object[key],
              srcValue = data[1];
            if (noCustomizer && data[2]) {
              if (objValue === undefined$1 && !(key in object)) {
                return false;
              }
            } else {
              var stack = new Stack();
              if (customizer) {
                var result2 = customizer(
                  objValue,
                  srcValue,
                  key,
                  object,
                  source,
                  stack
                );
              }
              if (
                !(result2 === undefined$1
                  ? baseIsEqual(
                      srcValue,
                      objValue,
                      COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG,
                      customizer,
                      stack
                    )
                  : result2)
              ) {
                return false;
              }
            }
          }
          return true;
        }
        function baseIsNative(value) {
          if (!isObject(value) || isMasked(value)) {
            return false;
          }
          var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
          return pattern.test(toSource(value));
        }
        function baseIsRegExp(value) {
          return isObjectLike(value) && baseGetTag(value) == regexpTag;
        }
        function baseIsSet(value) {
          return isObjectLike(value) && getTag(value) == setTag;
        }
        function baseIsTypedArray(value) {
          return (
            isObjectLike(value) &&
            isLength(value.length) &&
            !!typedArrayTags[baseGetTag(value)]
          );
        }
        function baseIteratee(value) {
          if (typeof value == "function") {
            return value;
          }
          if (value == null) {
            return identity;
          }
          if (typeof value == "object") {
            return isArray(value)
              ? baseMatchesProperty(value[0], value[1])
              : baseMatches(value);
          }
          return property(value);
        }
        function baseKeys(object) {
          if (!isPrototype(object)) {
            return nativeKeys(object);
          }
          var result2 = [];
          for (var key in Object2(object)) {
            if (hasOwnProperty.call(object, key) && key != "constructor") {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseKeysIn(object) {
          if (!isObject(object)) {
            return nativeKeysIn(object);
          }
          var isProto = isPrototype(object),
            result2 = [];
          for (var key in object) {
            if (
              !(
                key == "constructor" &&
                (isProto || !hasOwnProperty.call(object, key))
              )
            ) {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseLt(value, other) {
          return value < other;
        }
        function baseMap(collection, iteratee2) {
          var index = -1,
            result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function (value, key, collection2) {
            result2[++index] = iteratee2(value, key, collection2);
          });
          return result2;
        }
        function baseMatches(source) {
          var matchData = getMatchData(source);
          if (matchData.length == 1 && matchData[0][2]) {
            return matchesStrictComparable(matchData[0][0], matchData[0][1]);
          }
          return function (object) {
            return object === source || baseIsMatch(object, source, matchData);
          };
        }
        function baseMatchesProperty(path, srcValue) {
          if (isKey(path) && isStrictComparable(srcValue)) {
            return matchesStrictComparable(toKey(path), srcValue);
          }
          return function (object) {
            var objValue = get(object, path);
            return objValue === undefined$1 && objValue === srcValue
              ? hasIn(object, path)
              : baseIsEqual(
                  srcValue,
                  objValue,
                  COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG
                );
          };
        }
        function baseMerge(object, source, srcIndex, customizer, stack) {
          if (object === source) {
            return;
          }
          baseFor(
            source,
            function (srcValue, key) {
              stack || (stack = new Stack());
              if (isObject(srcValue)) {
                baseMergeDeep(
                  object,
                  source,
                  key,
                  srcIndex,
                  baseMerge,
                  customizer,
                  stack
                );
              } else {
                var newValue = customizer
                  ? customizer(
                      safeGet(object, key),
                      srcValue,
                      key + "",
                      object,
                      source,
                      stack
                    )
                  : undefined$1;
                if (newValue === undefined$1) {
                  newValue = srcValue;
                }
                assignMergeValue(object, key, newValue);
              }
            },
            keysIn
          );
        }
        function baseMergeDeep(
          object,
          source,
          key,
          srcIndex,
          mergeFunc,
          customizer,
          stack
        ) {
          var objValue = safeGet(object, key),
            srcValue = safeGet(source, key),
            stacked = stack.get(srcValue);
          if (stacked) {
            assignMergeValue(object, key, stacked);
            return;
          }
          var newValue = customizer
            ? customizer(objValue, srcValue, key + "", object, source, stack)
            : undefined$1;
          var isCommon = newValue === undefined$1;
          if (isCommon) {
            var isArr = isArray(srcValue),
              isBuff = !isArr && isBuffer(srcValue),
              isTyped = !isArr && !isBuff && isTypedArray(srcValue);
            newValue = srcValue;
            if (isArr || isBuff || isTyped) {
              if (isArray(objValue)) {
                newValue = objValue;
              } else if (isArrayLikeObject(objValue)) {
                newValue = copyArray(objValue);
              } else if (isBuff) {
                isCommon = false;
                newValue = cloneBuffer(srcValue, true);
              } else if (isTyped) {
                isCommon = false;
                newValue = cloneTypedArray(srcValue, true);
              } else {
                newValue = [];
              }
            } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
              newValue = objValue;
              if (isArguments(objValue)) {
                newValue = toPlainObject(objValue);
              } else if (!isObject(objValue) || isFunction(objValue)) {
                newValue = initCloneObject(srcValue);
              }
            } else {
              isCommon = false;
            }
          }
          if (isCommon) {
            stack.set(srcValue, newValue);
            mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
            stack["delete"](srcValue);
          }
          assignMergeValue(object, key, newValue);
        }
        function baseNth(array, n) {
          var length = array.length;
          if (!length) {
            return;
          }
          n += n < 0 ? length : 0;
          return isIndex(n, length) ? array[n] : undefined$1;
        }
        function baseOrderBy(collection, iteratees, orders) {
          if (iteratees.length) {
            iteratees = arrayMap(iteratees, function (iteratee2) {
              if (isArray(iteratee2)) {
                return function (value) {
                  return baseGet(
                    value,
                    iteratee2.length === 1 ? iteratee2[0] : iteratee2
                  );
                };
              }
              return iteratee2;
            });
          } else {
            iteratees = [identity];
          }
          var index = -1;
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          var result2 = baseMap(collection, function (value, key, collection2) {
            var criteria = arrayMap(iteratees, function (iteratee2) {
              return iteratee2(value);
            });
            return { criteria: criteria, index: ++index, value: value };
          });
          return baseSortBy(result2, function (object, other) {
            return compareMultiple(object, other, orders);
          });
        }
        function basePick(object, paths) {
          return basePickBy(object, paths, function (value, path) {
            return hasIn(object, path);
          });
        }
        function basePickBy(object, paths, predicate) {
          var index = -1,
            length = paths.length,
            result2 = {};
          while (++index < length) {
            var path = paths[index],
              value = baseGet(object, path);
            if (predicate(value, path)) {
              baseSet(result2, castPath(path, object), value);
            }
          }
          return result2;
        }
        function basePropertyDeep(path) {
          return function (object) {
            return baseGet(object, path);
          };
        }
        function basePullAll(array, values2, iteratee2, comparator) {
          var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf,
            index = -1,
            length = values2.length,
            seen = array;
          if (array === values2) {
            values2 = copyArray(values2);
          }
          if (iteratee2) {
            seen = arrayMap(array, baseUnary(iteratee2));
          }
          while (++index < length) {
            var fromIndex = 0,
              value = values2[index],
              computed = iteratee2 ? iteratee2(value) : value;
            while (
              (fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1
            ) {
              if (seen !== array) {
                splice.call(seen, fromIndex, 1);
              }
              splice.call(array, fromIndex, 1);
            }
          }
          return array;
        }
        function basePullAt(array, indexes) {
          var length = array ? indexes.length : 0,
            lastIndex = length - 1;
          while (length--) {
            var index = indexes[length];
            if (length == lastIndex || index !== previous) {
              var previous = index;
              if (isIndex(index)) {
                splice.call(array, index, 1);
              } else {
                baseUnset(array, index);
              }
            }
          }
          return array;
        }
        function baseRandom(lower, upper) {
          return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
        }
        function baseRange(start, end, step, fromRight) {
          var index = -1,
            length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
            result2 = Array2(length);
          while (length--) {
            result2[fromRight ? length : ++index] = start;
            start += step;
          }
          return result2;
        }
        function baseRepeat(string, n) {
          var result2 = "";
          if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
            return result2;
          }
          do {
            if (n % 2) {
              result2 += string;
            }
            n = nativeFloor(n / 2);
            if (n) {
              string += string;
            }
          } while (n);
          return result2;
        }
        function baseRest(func, start) {
          return setToString(overRest(func, start, identity), func + "");
        }
        function baseSample(collection) {
          return arraySample(values(collection));
        }
        function baseSampleSize(collection, n) {
          var array = values(collection);
          return shuffleSelf(array, baseClamp(n, 0, array.length));
        }
        function baseSet(object, path, value, customizer) {
          if (!isObject(object)) {
            return object;
          }
          path = castPath(path, object);
          var index = -1,
            length = path.length,
            lastIndex = length - 1,
            nested = object;
          while (nested != null && ++index < length) {
            var key = toKey(path[index]),
              newValue = value;
            if (
              key === "__proto__" ||
              key === "constructor" ||
              key === "prototype"
            ) {
              return object;
            }
            if (index != lastIndex) {
              var objValue = nested[key];
              newValue = customizer
                ? customizer(objValue, key, nested)
                : undefined$1;
              if (newValue === undefined$1) {
                newValue = isObject(objValue)
                  ? objValue
                  : isIndex(path[index + 1])
                  ? []
                  : {};
              }
            }
            assignValue(nested, key, newValue);
            nested = nested[key];
          }
          return object;
        }
        var baseSetData = !metaMap
          ? identity
          : function (func, data) {
              metaMap.set(func, data);
              return func;
            };
        var baseSetToString = !defineProperty
          ? identity
          : function (func, string) {
              return defineProperty(func, "toString", {
                configurable: true,
                enumerable: false,
                value: constant(string),
                writable: true,
              });
            };
        function baseShuffle(collection) {
          return shuffleSelf(values(collection));
        }
        function baseSlice(array, start, end) {
          var index = -1,
            length = array.length;
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end > length ? length : end;
          if (end < 0) {
            end += length;
          }
          length = start > end ? 0 : (end - start) >>> 0;
          start >>>= 0;
          var result2 = Array2(length);
          while (++index < length) {
            result2[index] = array[index + start];
          }
          return result2;
        }
        function baseSome(collection, predicate) {
          var result2;
          baseEach(collection, function (value, index, collection2) {
            result2 = predicate(value, index, collection2);
            return !result2;
          });
          return !!result2;
        }
        function baseSortedIndex(array, value, retHighest) {
          var low = 0,
            high = array == null ? low : array.length;
          if (
            typeof value == "number" &&
            value === value &&
            high <= HALF_MAX_ARRAY_LENGTH
          ) {
            while (low < high) {
              var mid = (low + high) >>> 1,
                computed = array[mid];
              if (
                computed !== null &&
                !isSymbol(computed) &&
                (retHighest ? computed <= value : computed < value)
              ) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return high;
          }
          return baseSortedIndexBy(array, value, identity, retHighest);
        }
        function baseSortedIndexBy(array, value, iteratee2, retHighest) {
          var low = 0,
            high = array == null ? 0 : array.length;
          if (high === 0) {
            return 0;
          }
          value = iteratee2(value);
          var valIsNaN = value !== value,
            valIsNull = value === null,
            valIsSymbol = isSymbol(value),
            valIsUndefined = value === undefined$1;
          while (low < high) {
            var mid = nativeFloor((low + high) / 2),
              computed = iteratee2(array[mid]),
              othIsDefined = computed !== undefined$1,
              othIsNull = computed === null,
              othIsReflexive = computed === computed,
              othIsSymbol = isSymbol(computed);
            if (valIsNaN) {
              var setLow = retHighest || othIsReflexive;
            } else if (valIsUndefined) {
              setLow = othIsReflexive && (retHighest || othIsDefined);
            } else if (valIsNull) {
              setLow =
                othIsReflexive && othIsDefined && (retHighest || !othIsNull);
            } else if (valIsSymbol) {
              setLow =
                othIsReflexive &&
                othIsDefined &&
                !othIsNull &&
                (retHighest || !othIsSymbol);
            } else if (othIsNull || othIsSymbol) {
              setLow = false;
            } else {
              setLow = retHighest ? computed <= value : computed < value;
            }
            if (setLow) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return nativeMin(high, MAX_ARRAY_INDEX);
        }
        function baseSortedUniq(array, iteratee2) {
          var index = -1,
            length = array.length,
            resIndex = 0,
            result2 = [];
          while (++index < length) {
            var value = array[index],
              computed = iteratee2 ? iteratee2(value) : value;
            if (!index || !eq(computed, seen)) {
              var seen = computed;
              result2[resIndex++] = value === 0 ? 0 : value;
            }
          }
          return result2;
        }
        function baseToNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          return +value;
        }
        function baseToString(value) {
          if (typeof value == "string") {
            return value;
          }
          if (isArray(value)) {
            return arrayMap(value, baseToString) + "";
          }
          if (isSymbol(value)) {
            return symbolToString ? symbolToString.call(value) : "";
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function baseUniq(array, iteratee2, comparator) {
          var index = -1,
            includes2 = arrayIncludes,
            length = array.length,
            isCommon = true,
            result2 = [],
            seen = result2;
          if (comparator) {
            isCommon = false;
            includes2 = arrayIncludesWith;
          } else if (length >= LARGE_ARRAY_SIZE) {
            var set2 = iteratee2 ? null : createSet(array);
            if (set2) {
              return setToArray(set2);
            }
            isCommon = false;
            includes2 = cacheHas;
            seen = new SetCache();
          } else {
            seen = iteratee2 ? [] : result2;
          }
          outer: while (++index < length) {
            var value = array[index],
              computed = iteratee2 ? iteratee2(value) : value;
            value = comparator || value !== 0 ? value : 0;
            if (isCommon && computed === computed) {
              var seenIndex = seen.length;
              while (seenIndex--) {
                if (seen[seenIndex] === computed) {
                  continue outer;
                }
              }
              if (iteratee2) {
                seen.push(computed);
              }
              result2.push(value);
            } else if (!includes2(seen, computed, comparator)) {
              if (seen !== result2) {
                seen.push(computed);
              }
              result2.push(value);
            }
          }
          return result2;
        }
        function baseUnset(object, path) {
          path = castPath(path, object);
          object = parent(object, path);
          return object == null || delete object[toKey(last(path))];
        }
        function baseUpdate(object, path, updater, customizer) {
          return baseSet(
            object,
            path,
            updater(baseGet(object, path)),
            customizer
          );
        }
        function baseWhile(array, predicate, isDrop, fromRight) {
          var length = array.length,
            index = fromRight ? length : -1;
          while (
            (fromRight ? index-- : ++index < length) &&
            predicate(array[index], index, array)
          ) {}
          return isDrop
            ? baseSlice(
                array,
                fromRight ? 0 : index,
                fromRight ? index + 1 : length
              )
            : baseSlice(
                array,
                fromRight ? index + 1 : 0,
                fromRight ? length : index
              );
        }
        function baseWrapperValue(value, actions) {
          var result2 = value;
          if (result2 instanceof LazyWrapper) {
            result2 = result2.value();
          }
          return arrayReduce(
            actions,
            function (result3, action) {
              return action.func.apply(
                action.thisArg,
                arrayPush([result3], action.args)
              );
            },
            result2
          );
        }
        function baseXor(arrays, iteratee2, comparator) {
          var length = arrays.length;
          if (length < 2) {
            return length ? baseUniq(arrays[0]) : [];
          }
          var index = -1,
            result2 = Array2(length);
          while (++index < length) {
            var array = arrays[index],
              othIndex = -1;
            while (++othIndex < length) {
              if (othIndex != index) {
                result2[index] = baseDifference(
                  result2[index] || array,
                  arrays[othIndex],
                  iteratee2,
                  comparator
                );
              }
            }
          }
          return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
        }
        function baseZipObject(props, values2, assignFunc) {
          var index = -1,
            length = props.length,
            valsLength = values2.length,
            result2 = {};
          while (++index < length) {
            var value = index < valsLength ? values2[index] : undefined$1;
            assignFunc(result2, props[index], value);
          }
          return result2;
        }
        function castArrayLikeObject(value) {
          return isArrayLikeObject(value) ? value : [];
        }
        function castFunction(value) {
          return typeof value == "function" ? value : identity;
        }
        function castPath(value, object) {
          if (isArray(value)) {
            return value;
          }
          return isKey(value, object) ? [value] : stringToPath(toString(value));
        }
        var castRest = baseRest;
        function castSlice(array, start, end) {
          var length = array.length;
          end = end === undefined$1 ? length : end;
          return !start && end >= length ? array : baseSlice(array, start, end);
        }
        var clearTimeout =
          ctxClearTimeout ||
          function (id) {
            return root.clearTimeout(id);
          };
        function cloneBuffer(buffer, isDeep) {
          if (isDeep) {
            return buffer.slice();
          }
          var length = buffer.length,
            result2 = allocUnsafe
              ? allocUnsafe(length)
              : new buffer.constructor(length);
          buffer.copy(result2);
          return result2;
        }
        function cloneArrayBuffer(arrayBuffer) {
          var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
          new Uint8Array(result2).set(new Uint8Array(arrayBuffer));
          return result2;
        }
        function cloneDataView(dataView, isDeep) {
          var buffer = isDeep
            ? cloneArrayBuffer(dataView.buffer)
            : dataView.buffer;
          return new dataView.constructor(
            buffer,
            dataView.byteOffset,
            dataView.byteLength
          );
        }
        function cloneRegExp(regexp) {
          var result2 = new regexp.constructor(
            regexp.source,
            reFlags.exec(regexp)
          );
          result2.lastIndex = regexp.lastIndex;
          return result2;
        }
        function cloneSymbol(symbol) {
          return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
        }
        function cloneTypedArray(typedArray, isDeep) {
          var buffer = isDeep
            ? cloneArrayBuffer(typedArray.buffer)
            : typedArray.buffer;
          return new typedArray.constructor(
            buffer,
            typedArray.byteOffset,
            typedArray.length
          );
        }
        function compareAscending(value, other) {
          if (value !== other) {
            var valIsDefined = value !== undefined$1,
              valIsNull = value === null,
              valIsReflexive = value === value,
              valIsSymbol = isSymbol(value);
            var othIsDefined = other !== undefined$1,
              othIsNull = other === null,
              othIsReflexive = other === other,
              othIsSymbol = isSymbol(other);
            if (
              (!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
              (valIsSymbol &&
                othIsDefined &&
                othIsReflexive &&
                !othIsNull &&
                !othIsSymbol) ||
              (valIsNull && othIsDefined && othIsReflexive) ||
              (!valIsDefined && othIsReflexive) ||
              !valIsReflexive
            ) {
              return 1;
            }
            if (
              (!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
              (othIsSymbol &&
                valIsDefined &&
                valIsReflexive &&
                !valIsNull &&
                !valIsSymbol) ||
              (othIsNull && valIsDefined && valIsReflexive) ||
              (!othIsDefined && valIsReflexive) ||
              !othIsReflexive
            ) {
              return -1;
            }
          }
          return 0;
        }
        function compareMultiple(object, other, orders) {
          var index = -1,
            objCriteria = object.criteria,
            othCriteria = other.criteria,
            length = objCriteria.length,
            ordersLength = orders.length;
          while (++index < length) {
            var result2 = compareAscending(
              objCriteria[index],
              othCriteria[index]
            );
            if (result2) {
              if (index >= ordersLength) {
                return result2;
              }
              var order = orders[index];
              return result2 * (order == "desc" ? -1 : 1);
            }
          }
          return object.index - other.index;
        }
        function composeArgs(args, partials, holders, isCurried) {
          var argsIndex = -1,
            argsLength = args.length,
            holdersLength = holders.length,
            leftIndex = -1,
            leftLength = partials.length,
            rangeLength = nativeMax(argsLength - holdersLength, 0),
            result2 = Array2(leftLength + rangeLength),
            isUncurried = !isCurried;
          while (++leftIndex < leftLength) {
            result2[leftIndex] = partials[leftIndex];
          }
          while (++argsIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[holders[argsIndex]] = args[argsIndex];
            }
          }
          while (rangeLength--) {
            result2[leftIndex++] = args[argsIndex++];
          }
          return result2;
        }
        function composeArgsRight(args, partials, holders, isCurried) {
          var argsIndex = -1,
            argsLength = args.length,
            holdersIndex = -1,
            holdersLength = holders.length,
            rightIndex = -1,
            rightLength = partials.length,
            rangeLength = nativeMax(argsLength - holdersLength, 0),
            result2 = Array2(rangeLength + rightLength),
            isUncurried = !isCurried;
          while (++argsIndex < rangeLength) {
            result2[argsIndex] = args[argsIndex];
          }
          var offset = argsIndex;
          while (++rightIndex < rightLength) {
            result2[offset + rightIndex] = partials[rightIndex];
          }
          while (++holdersIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[offset + holders[holdersIndex]] = args[argsIndex++];
            }
          }
          return result2;
        }
        function copyArray(source, array) {
          var index = -1,
            length = source.length;
          array || (array = Array2(length));
          while (++index < length) {
            array[index] = source[index];
          }
          return array;
        }
        function copyObject(source, props, object, customizer) {
          var isNew = !object;
          object || (object = {});
          var index = -1,
            length = props.length;
          while (++index < length) {
            var key = props[index];
            var newValue = customizer
              ? customizer(object[key], source[key], key, object, source)
              : undefined$1;
            if (newValue === undefined$1) {
              newValue = source[key];
            }
            if (isNew) {
              baseAssignValue(object, key, newValue);
            } else {
              assignValue(object, key, newValue);
            }
          }
          return object;
        }
        function copySymbols(source, object) {
          return copyObject(source, getSymbols(source), object);
        }
        function copySymbolsIn(source, object) {
          return copyObject(source, getSymbolsIn(source), object);
        }
        function createAggregator(setter, initializer) {
          return function (collection, iteratee2) {
            var func = isArray(collection) ? arrayAggregator : baseAggregator,
              accumulator = initializer ? initializer() : {};
            return func(
              collection,
              setter,
              getIteratee(iteratee2, 2),
              accumulator
            );
          };
        }
        function createAssigner(assigner) {
          return baseRest(function (object, sources) {
            var index = -1,
              length = sources.length,
              customizer = length > 1 ? sources[length - 1] : undefined$1,
              guard = length > 2 ? sources[2] : undefined$1;
            customizer =
              assigner.length > 3 && typeof customizer == "function"
                ? (length--, customizer)
                : undefined$1;
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              customizer = length < 3 ? undefined$1 : customizer;
              length = 1;
            }
            object = Object2(object);
            while (++index < length) {
              var source = sources[index];
              if (source) {
                assigner(object, source, index, customizer);
              }
            }
            return object;
          });
        }
        function createBaseEach(eachFunc, fromRight) {
          return function (collection, iteratee2) {
            if (collection == null) {
              return collection;
            }
            if (!isArrayLike(collection)) {
              return eachFunc(collection, iteratee2);
            }
            var length = collection.length,
              index = fromRight ? length : -1,
              iterable = Object2(collection);
            while (fromRight ? index-- : ++index < length) {
              if (iteratee2(iterable[index], index, iterable) === false) {
                break;
              }
            }
            return collection;
          };
        }
        function createBaseFor(fromRight) {
          return function (object, iteratee2, keysFunc) {
            var index = -1,
              iterable = Object2(object),
              props = keysFunc(object),
              length = props.length;
            while (length--) {
              var key = props[fromRight ? length : ++index];
              if (iteratee2(iterable[key], key, iterable) === false) {
                break;
              }
            }
            return object;
          };
        }
        function createBind(func, bitmask, thisArg) {
          var isBind = bitmask & WRAP_BIND_FLAG,
            Ctor = createCtor(func);
          function wrapper() {
            var fn =
              this && this !== root && this instanceof wrapper ? Ctor : func;
            return fn.apply(isBind ? thisArg : this, arguments);
          }
          return wrapper;
        }
        function createCaseFirst(methodName) {
          return function (string) {
            string = toString(string);
            var strSymbols = hasUnicode(string)
              ? stringToArray(string)
              : undefined$1;
            var chr = strSymbols ? strSymbols[0] : string.charAt(0);
            var trailing = strSymbols
              ? castSlice(strSymbols, 1).join("")
              : string.slice(1);
            return chr[methodName]() + trailing;
          };
        }
        function createCompounder(callback) {
          return function (string) {
            return arrayReduce(
              words(deburr(string).replace(reApos, "")),
              callback,
              ""
            );
          };
        }
        function createCtor(Ctor) {
          return function () {
            var args = arguments;
            switch (args.length) {
              case 0:
                return new Ctor();
              case 1:
                return new Ctor(args[0]);
              case 2:
                return new Ctor(args[0], args[1]);
              case 3:
                return new Ctor(args[0], args[1], args[2]);
              case 4:
                return new Ctor(args[0], args[1], args[2], args[3]);
              case 5:
                return new Ctor(args[0], args[1], args[2], args[3], args[4]);
              case 6:
                return new Ctor(
                  args[0],
                  args[1],
                  args[2],
                  args[3],
                  args[4],
                  args[5]
                );
              case 7:
                return new Ctor(
                  args[0],
                  args[1],
                  args[2],
                  args[3],
                  args[4],
                  args[5],
                  args[6]
                );
            }
            var thisBinding = baseCreate(Ctor.prototype),
              result2 = Ctor.apply(thisBinding, args);
            return isObject(result2) ? result2 : thisBinding;
          };
        }
        function createCurry(func, bitmask, arity) {
          var Ctor = createCtor(func);
          function wrapper() {
            var length = arguments.length,
              args = Array2(length),
              index = length,
              placeholder = getHolder(wrapper);
            while (index--) {
              args[index] = arguments[index];
            }
            var holders =
              length < 3 &&
              args[0] !== placeholder &&
              args[length - 1] !== placeholder
                ? []
                : replaceHolders(args, placeholder);
            length -= holders.length;
            if (length < arity) {
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                undefined$1,
                args,
                holders,
                undefined$1,
                undefined$1,
                arity - length
              );
            }
            var fn =
              this && this !== root && this instanceof wrapper ? Ctor : func;
            return apply(fn, this, args);
          }
          return wrapper;
        }
        function createFind(findIndexFunc) {
          return function (collection, predicate, fromIndex) {
            var iterable = Object2(collection);
            if (!isArrayLike(collection)) {
              var iteratee2 = getIteratee(predicate, 3);
              collection = keys(collection);
              predicate = function (key) {
                return iteratee2(iterable[key], key, iterable);
              };
            }
            var index = findIndexFunc(collection, predicate, fromIndex);
            return index > -1
              ? iterable[iteratee2 ? collection[index] : index]
              : undefined$1;
          };
        }
        function createFlow(fromRight) {
          return flatRest(function (funcs) {
            var length = funcs.length,
              index = length,
              prereq = LodashWrapper.prototype.thru;
            if (fromRight) {
              funcs.reverse();
            }
            while (index--) {
              var func = funcs[index];
              if (typeof func != "function") {
                throw new TypeError(FUNC_ERROR_TEXT);
              }
              if (prereq && !wrapper && getFuncName(func) == "wrapper") {
                var wrapper = new LodashWrapper([], true);
              }
            }
            index = wrapper ? index : length;
            while (++index < length) {
              func = funcs[index];
              var funcName = getFuncName(func),
                data = funcName == "wrapper" ? getData(func) : undefined$1;
              if (
                data &&
                isLaziable(data[0]) &&
                data[1] ==
                  (WRAP_ARY_FLAG |
                    WRAP_CURRY_FLAG |
                    WRAP_PARTIAL_FLAG |
                    WRAP_REARG_FLAG) &&
                !data[4].length &&
                data[9] == 1
              ) {
                wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
              } else {
                wrapper =
                  func.length == 1 && isLaziable(func)
                    ? wrapper[funcName]()
                    : wrapper.thru(func);
              }
            }
            return function () {
              var args = arguments,
                value = args[0];
              if (wrapper && args.length == 1 && isArray(value)) {
                return wrapper.plant(value).value();
              }
              var index2 = 0,
                result2 = length ? funcs[index2].apply(this, args) : value;
              while (++index2 < length) {
                result2 = funcs[index2].call(this, result2);
              }
              return result2;
            };
          });
        }
        function createHybrid(
          func,
          bitmask,
          thisArg,
          partials,
          holders,
          partialsRight,
          holdersRight,
          argPos,
          ary2,
          arity
        ) {
          var isAry = bitmask & WRAP_ARY_FLAG,
            isBind = bitmask & WRAP_BIND_FLAG,
            isBindKey = bitmask & WRAP_BIND_KEY_FLAG,
            isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),
            isFlip = bitmask & WRAP_FLIP_FLAG,
            Ctor = isBindKey ? undefined$1 : createCtor(func);
          function wrapper() {
            var length = arguments.length,
              args = Array2(length),
              index = length;
            while (index--) {
              args[index] = arguments[index];
            }
            if (isCurried) {
              var placeholder = getHolder(wrapper),
                holdersCount = countHolders(args, placeholder);
            }
            if (partials) {
              args = composeArgs(args, partials, holders, isCurried);
            }
            if (partialsRight) {
              args = composeArgsRight(
                args,
                partialsRight,
                holdersRight,
                isCurried
              );
            }
            length -= holdersCount;
            if (isCurried && length < arity) {
              var newHolders = replaceHolders(args, placeholder);
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                thisArg,
                args,
                newHolders,
                argPos,
                ary2,
                arity - length
              );
            }
            var thisBinding = isBind ? thisArg : this,
              fn = isBindKey ? thisBinding[func] : func;
            length = args.length;
            if (argPos) {
              args = reorder(args, argPos);
            } else if (isFlip && length > 1) {
              args.reverse();
            }
            if (isAry && ary2 < length) {
              args.length = ary2;
            }
            if (this && this !== root && this instanceof wrapper) {
              fn = Ctor || createCtor(fn);
            }
            return fn.apply(thisBinding, args);
          }
          return wrapper;
        }
        function createInverter(setter, toIteratee) {
          return function (object, iteratee2) {
            return baseInverter(object, setter, toIteratee(iteratee2), {});
          };
        }
        function createMathOperation(operator, defaultValue) {
          return function (value, other) {
            var result2;
            if (value === undefined$1 && other === undefined$1) {
              return defaultValue;
            }
            if (value !== undefined$1) {
              result2 = value;
            }
            if (other !== undefined$1) {
              if (result2 === undefined$1) {
                return other;
              }
              if (typeof value == "string" || typeof other == "string") {
                value = baseToString(value);
                other = baseToString(other);
              } else {
                value = baseToNumber(value);
                other = baseToNumber(other);
              }
              result2 = operator(value, other);
            }
            return result2;
          };
        }
        function createOver(arrayFunc) {
          return flatRest(function (iteratees) {
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            return baseRest(function (args) {
              var thisArg = this;
              return arrayFunc(iteratees, function (iteratee2) {
                return apply(iteratee2, thisArg, args);
              });
            });
          });
        }
        function createPadding(length, chars) {
          chars = chars === undefined$1 ? " " : baseToString(chars);
          var charsLength = chars.length;
          if (charsLength < 2) {
            return charsLength ? baseRepeat(chars, length) : chars;
          }
          var result2 = baseRepeat(
            chars,
            nativeCeil(length / stringSize(chars))
          );
          return hasUnicode(chars)
            ? castSlice(stringToArray(result2), 0, length).join("")
            : result2.slice(0, length);
        }
        function createPartial(func, bitmask, thisArg, partials) {
          var isBind = bitmask & WRAP_BIND_FLAG,
            Ctor = createCtor(func);
          function wrapper() {
            var argsIndex = -1,
              argsLength = arguments.length,
              leftIndex = -1,
              leftLength = partials.length,
              args = Array2(leftLength + argsLength),
              fn =
                this && this !== root && this instanceof wrapper ? Ctor : func;
            while (++leftIndex < leftLength) {
              args[leftIndex] = partials[leftIndex];
            }
            while (argsLength--) {
              args[leftIndex++] = arguments[++argsIndex];
            }
            return apply(fn, isBind ? thisArg : this, args);
          }
          return wrapper;
        }
        function createRange(fromRight) {
          return function (start, end, step) {
            if (
              step &&
              typeof step != "number" &&
              isIterateeCall(start, end, step)
            ) {
              end = step = undefined$1;
            }
            start = toFinite(start);
            if (end === undefined$1) {
              end = start;
              start = 0;
            } else {
              end = toFinite(end);
            }
            step =
              step === undefined$1 ? (start < end ? 1 : -1) : toFinite(step);
            return baseRange(start, end, step, fromRight);
          };
        }
        function createRelationalOperation(operator) {
          return function (value, other) {
            if (!(typeof value == "string" && typeof other == "string")) {
              value = toNumber(value);
              other = toNumber(other);
            }
            return operator(value, other);
          };
        }
        function createRecurry(
          func,
          bitmask,
          wrapFunc,
          placeholder,
          thisArg,
          partials,
          holders,
          argPos,
          ary2,
          arity
        ) {
          var isCurry = bitmask & WRAP_CURRY_FLAG,
            newHolders = isCurry ? holders : undefined$1,
            newHoldersRight = isCurry ? undefined$1 : holders,
            newPartials = isCurry ? partials : undefined$1,
            newPartialsRight = isCurry ? undefined$1 : partials;
          bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
          bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
          if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
            bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
          }
          var newData = [
            func,
            bitmask,
            thisArg,
            newPartials,
            newHolders,
            newPartialsRight,
            newHoldersRight,
            argPos,
            ary2,
            arity,
          ];
          var result2 = wrapFunc.apply(undefined$1, newData);
          if (isLaziable(func)) {
            setData(result2, newData);
          }
          result2.placeholder = placeholder;
          return setWrapToString(result2, func, bitmask);
        }
        function createRound(methodName) {
          var func = Math[methodName];
          return function (number, precision) {
            number = toNumber(number);
            precision =
              precision == null ? 0 : nativeMin(toInteger(precision), 292);
            if (precision && nativeIsFinite(number)) {
              var pair = (toString(number) + "e").split("e"),
                value = func(pair[0] + "e" + (+pair[1] + precision));
              pair = (toString(value) + "e").split("e");
              return +(pair[0] + "e" + (+pair[1] - precision));
            }
            return func(number);
          };
        }
        var createSet = !(Set && 1 / setToArray(new Set([, -0]))[1] == INFINITY)
          ? noop
          : function (values2) {
              return new Set(values2);
            };
        function createToPairs(keysFunc) {
          return function (object) {
            var tag = getTag(object);
            if (tag == mapTag) {
              return mapToArray(object);
            }
            if (tag == setTag) {
              return setToPairs(object);
            }
            return baseToPairs(object, keysFunc(object));
          };
        }
        function createWrap(
          func,
          bitmask,
          thisArg,
          partials,
          holders,
          argPos,
          ary2,
          arity
        ) {
          var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
          if (!isBindKey && typeof func != "function") {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          var length = partials ? partials.length : 0;
          if (!length) {
            bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
            partials = holders = undefined$1;
          }
          ary2 = ary2 === undefined$1 ? ary2 : nativeMax(toInteger(ary2), 0);
          arity = arity === undefined$1 ? arity : toInteger(arity);
          length -= holders ? holders.length : 0;
          if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
            var partialsRight = partials,
              holdersRight = holders;
            partials = holders = undefined$1;
          }
          var data = isBindKey ? undefined$1 : getData(func);
          var newData = [
            func,
            bitmask,
            thisArg,
            partials,
            holders,
            partialsRight,
            holdersRight,
            argPos,
            ary2,
            arity,
          ];
          if (data) {
            mergeData(newData, data);
          }
          func = newData[0];
          bitmask = newData[1];
          thisArg = newData[2];
          partials = newData[3];
          holders = newData[4];
          arity = newData[9] =
            newData[9] === undefined$1
              ? isBindKey
                ? 0
                : func.length
              : nativeMax(newData[9] - length, 0);
          if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
            bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
          }
          if (!bitmask || bitmask == WRAP_BIND_FLAG) {
            var result2 = createBind(func, bitmask, thisArg);
          } else if (
            bitmask == WRAP_CURRY_FLAG ||
            bitmask == WRAP_CURRY_RIGHT_FLAG
          ) {
            result2 = createCurry(func, bitmask, arity);
          } else if (
            (bitmask == WRAP_PARTIAL_FLAG ||
              bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) &&
            !holders.length
          ) {
            result2 = createPartial(func, bitmask, thisArg, partials);
          } else {
            result2 = createHybrid.apply(undefined$1, newData);
          }
          var setter = data ? baseSetData : setData;
          return setWrapToString(setter(result2, newData), func, bitmask);
        }
        function customDefaultsAssignIn(objValue, srcValue, key, object) {
          if (
            objValue === undefined$1 ||
            (eq(objValue, objectProto[key]) &&
              !hasOwnProperty.call(object, key))
          ) {
            return srcValue;
          }
          return objValue;
        }
        function customDefaultsMerge(
          objValue,
          srcValue,
          key,
          object,
          source,
          stack
        ) {
          if (isObject(objValue) && isObject(srcValue)) {
            stack.set(srcValue, objValue);
            baseMerge(
              objValue,
              srcValue,
              undefined$1,
              customDefaultsMerge,
              stack
            );
            stack["delete"](srcValue);
          }
          return objValue;
        }
        function customOmitClone(value) {
          return isPlainObject(value) ? undefined$1 : value;
        }
        function equalArrays(
          array,
          other,
          bitmask,
          customizer,
          equalFunc,
          stack
        ) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
            arrLength = array.length,
            othLength = other.length;
          if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
            return false;
          }
          var arrStacked = stack.get(array);
          var othStacked = stack.get(other);
          if (arrStacked && othStacked) {
            return arrStacked == other && othStacked == array;
          }
          var index = -1,
            result2 = true,
            seen =
              bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined$1;
          stack.set(array, other);
          stack.set(other, array);
          while (++index < arrLength) {
            var arrValue = array[index],
              othValue = other[index];
            if (customizer) {
              var compared = isPartial
                ? customizer(othValue, arrValue, index, other, array, stack)
                : customizer(arrValue, othValue, index, array, other, stack);
            }
            if (compared !== undefined$1) {
              if (compared) {
                continue;
              }
              result2 = false;
              break;
            }
            if (seen) {
              if (
                !arraySome(other, function (othValue2, othIndex) {
                  if (
                    !cacheHas(seen, othIndex) &&
                    (arrValue === othValue2 ||
                      equalFunc(
                        arrValue,
                        othValue2,
                        bitmask,
                        customizer,
                        stack
                      ))
                  ) {
                    return seen.push(othIndex);
                  }
                })
              ) {
                result2 = false;
                break;
              }
            } else if (
              !(
                arrValue === othValue ||
                equalFunc(arrValue, othValue, bitmask, customizer, stack)
              )
            ) {
              result2 = false;
              break;
            }
          }
          stack["delete"](array);
          stack["delete"](other);
          return result2;
        }
        function equalByTag(
          object,
          other,
          tag,
          bitmask,
          customizer,
          equalFunc,
          stack
        ) {
          switch (tag) {
            case dataViewTag:
              if (
                object.byteLength != other.byteLength ||
                object.byteOffset != other.byteOffset
              ) {
                return false;
              }
              object = object.buffer;
              other = other.buffer;
            case arrayBufferTag:
              if (
                object.byteLength != other.byteLength ||
                !equalFunc(new Uint8Array(object), new Uint8Array(other))
              ) {
                return false;
              }
              return true;
            case boolTag:
            case dateTag:
            case numberTag:
              return eq(+object, +other);
            case errorTag:
              return (
                object.name == other.name && object.message == other.message
              );
            case regexpTag:
            case stringTag:
              return object == other + "";
            case mapTag:
              var convert = mapToArray;
            case setTag:
              var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
              convert || (convert = setToArray);
              if (object.size != other.size && !isPartial) {
                return false;
              }
              var stacked = stack.get(object);
              if (stacked) {
                return stacked == other;
              }
              bitmask |= COMPARE_UNORDERED_FLAG;
              stack.set(object, other);
              var result2 = equalArrays(
                convert(object),
                convert(other),
                bitmask,
                customizer,
                equalFunc,
                stack
              );
              stack["delete"](object);
              return result2;
            case symbolTag:
              if (symbolValueOf) {
                return symbolValueOf.call(object) == symbolValueOf.call(other);
              }
          }
          return false;
        }
        function equalObjects(
          object,
          other,
          bitmask,
          customizer,
          equalFunc,
          stack
        ) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
            objProps = getAllKeys(object),
            objLength = objProps.length,
            othProps = getAllKeys(other),
            othLength = othProps.length;
          if (objLength != othLength && !isPartial) {
            return false;
          }
          var index = objLength;
          while (index--) {
            var key = objProps[index];
            if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
              return false;
            }
          }
          var objStacked = stack.get(object);
          var othStacked = stack.get(other);
          if (objStacked && othStacked) {
            return objStacked == other && othStacked == object;
          }
          var result2 = true;
          stack.set(object, other);
          stack.set(other, object);
          var skipCtor = isPartial;
          while (++index < objLength) {
            key = objProps[index];
            var objValue = object[key],
              othValue = other[key];
            if (customizer) {
              var compared = isPartial
                ? customizer(othValue, objValue, key, other, object, stack)
                : customizer(objValue, othValue, key, object, other, stack);
            }
            if (
              !(compared === undefined$1
                ? objValue === othValue ||
                  equalFunc(objValue, othValue, bitmask, customizer, stack)
                : compared)
            ) {
              result2 = false;
              break;
            }
            skipCtor || (skipCtor = key == "constructor");
          }
          if (result2 && !skipCtor) {
            var objCtor = object.constructor,
              othCtor = other.constructor;
            if (
              objCtor != othCtor &&
              "constructor" in object &&
              "constructor" in other &&
              !(
                typeof objCtor == "function" &&
                objCtor instanceof objCtor &&
                typeof othCtor == "function" &&
                othCtor instanceof othCtor
              )
            ) {
              result2 = false;
            }
          }
          stack["delete"](object);
          stack["delete"](other);
          return result2;
        }
        function flatRest(func) {
          return setToString(overRest(func, undefined$1, flatten), func + "");
        }
        function getAllKeys(object) {
          return baseGetAllKeys(object, keys, getSymbols);
        }
        function getAllKeysIn(object) {
          return baseGetAllKeys(object, keysIn, getSymbolsIn);
        }
        var getData = !metaMap
          ? noop
          : function (func) {
              return metaMap.get(func);
            };
        function getFuncName(func) {
          var result2 = func.name + "",
            array = realNames[result2],
            length = hasOwnProperty.call(realNames, result2) ? array.length : 0;
          while (length--) {
            var data = array[length],
              otherFunc = data.func;
            if (otherFunc == null || otherFunc == func) {
              return data.name;
            }
          }
          return result2;
        }
        function getHolder(func) {
          var object = hasOwnProperty.call(lodash, "placeholder")
            ? lodash
            : func;
          return object.placeholder;
        }
        function getIteratee() {
          var result2 = lodash.iteratee || iteratee;
          result2 = result2 === iteratee ? baseIteratee : result2;
          return arguments.length
            ? result2(arguments[0], arguments[1])
            : result2;
        }
        function getMapData(map2, key) {
          var data = map2.__data__;
          return isKeyable(key)
            ? data[typeof key == "string" ? "string" : "hash"]
            : data.map;
        }
        function getMatchData(object) {
          var result2 = keys(object),
            length = result2.length;
          while (length--) {
            var key = result2[length],
              value = object[key];
            result2[length] = [key, value, isStrictComparable(value)];
          }
          return result2;
        }
        function getNative(object, key) {
          var value = getValue(object, key);
          return baseIsNative(value) ? value : undefined$1;
        }
        function getRawTag(value) {
          var isOwn = hasOwnProperty.call(value, symToStringTag),
            tag = value[symToStringTag];
          try {
            value[symToStringTag] = undefined$1;
            var unmasked = true;
          } catch (e) {}
          var result2 = nativeObjectToString.call(value);
          if (unmasked) {
            if (isOwn) {
              value[symToStringTag] = tag;
            } else {
              delete value[symToStringTag];
            }
          }
          return result2;
        }
        var getSymbols = !nativeGetSymbols
          ? stubArray
          : function (object) {
              if (object == null) {
                return [];
              }
              object = Object2(object);
              return arrayFilter(nativeGetSymbols(object), function (symbol) {
                return propertyIsEnumerable.call(object, symbol);
              });
            };
        var getSymbolsIn = !nativeGetSymbols
          ? stubArray
          : function (object) {
              var result2 = [];
              while (object) {
                arrayPush(result2, getSymbols(object));
                object = getPrototype(object);
              }
              return result2;
            };
        var getTag = baseGetTag;
        if (
          (DataView &&
            getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
          (Map && getTag(new Map()) != mapTag) ||
          (Promise2 && getTag(Promise2.resolve()) != promiseTag) ||
          (Set && getTag(new Set()) != setTag) ||
          (WeakMap && getTag(new WeakMap()) != weakMapTag)
        ) {
          getTag = function (value) {
            var result2 = baseGetTag(value),
              Ctor = result2 == objectTag ? value.constructor : undefined$1,
              ctorString = Ctor ? toSource(Ctor) : "";
            if (ctorString) {
              switch (ctorString) {
                case dataViewCtorString:
                  return dataViewTag;
                case mapCtorString:
                  return mapTag;
                case promiseCtorString:
                  return promiseTag;
                case setCtorString:
                  return setTag;
                case weakMapCtorString:
                  return weakMapTag;
              }
            }
            return result2;
          };
        }
        function getView(start, end, transforms) {
          var index = -1,
            length = transforms.length;
          while (++index < length) {
            var data = transforms[index],
              size2 = data.size;
            switch (data.type) {
              case "drop":
                start += size2;
                break;
              case "dropRight":
                end -= size2;
                break;
              case "take":
                end = nativeMin(end, start + size2);
                break;
              case "takeRight":
                start = nativeMax(start, end - size2);
                break;
            }
          }
          return { start: start, end: end };
        }
        function getWrapDetails(source) {
          var match = source.match(reWrapDetails);
          return match ? match[1].split(reSplitDetails) : [];
        }
        function hasPath(object, path, hasFunc) {
          path = castPath(path, object);
          var index = -1,
            length = path.length,
            result2 = false;
          while (++index < length) {
            var key = toKey(path[index]);
            if (!(result2 = object != null && hasFunc(object, key))) {
              break;
            }
            object = object[key];
          }
          if (result2 || ++index != length) {
            return result2;
          }
          length = object == null ? 0 : object.length;
          return (
            !!length &&
            isLength(length) &&
            isIndex(key, length) &&
            (isArray(object) || isArguments(object))
          );
        }
        function initCloneArray(array) {
          var length = array.length,
            result2 = new array.constructor(length);
          if (
            length &&
            typeof array[0] == "string" &&
            hasOwnProperty.call(array, "index")
          ) {
            result2.index = array.index;
            result2.input = array.input;
          }
          return result2;
        }
        function initCloneObject(object) {
          return typeof object.constructor == "function" && !isPrototype(object)
            ? baseCreate(getPrototype(object))
            : {};
        }
        function initCloneByTag(object, tag, isDeep) {
          var Ctor = object.constructor;
          switch (tag) {
            case arrayBufferTag:
              return cloneArrayBuffer(object);
            case boolTag:
            case dateTag:
              return new Ctor(+object);
            case dataViewTag:
              return cloneDataView(object, isDeep);
            case float32Tag:
            case float64Tag:
            case int8Tag:
            case int16Tag:
            case int32Tag:
            case uint8Tag:
            case uint8ClampedTag:
            case uint16Tag:
            case uint32Tag:
              return cloneTypedArray(object, isDeep);
            case mapTag:
              return new Ctor();
            case numberTag:
            case stringTag:
              return new Ctor(object);
            case regexpTag:
              return cloneRegExp(object);
            case setTag:
              return new Ctor();
            case symbolTag:
              return cloneSymbol(object);
          }
        }
        function insertWrapDetails(source, details) {
          var length = details.length;
          if (!length) {
            return source;
          }
          var lastIndex = length - 1;
          details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
          details = details.join(length > 2 ? ", " : " ");
          return source.replace(
            reWrapComment,
            "{\n/* [wrapped with " + details + "] */\n"
          );
        }
        function isFlattenable(value) {
          return (
            isArray(value) ||
            isArguments(value) ||
            !!(spreadableSymbol && value && value[spreadableSymbol])
          );
        }
        function isIndex(value, length) {
          var type = typeof value;
          length = length == null ? MAX_SAFE_INTEGER : length;
          return (
            !!length &&
            (type == "number" || (type != "symbol" && reIsUint.test(value))) &&
            value > -1 &&
            value % 1 == 0 &&
            value < length
          );
        }
        function isIterateeCall(value, index, object) {
          if (!isObject(object)) {
            return false;
          }
          var type = typeof index;
          if (
            type == "number"
              ? isArrayLike(object) && isIndex(index, object.length)
              : type == "string" && index in object
          ) {
            return eq(object[index], value);
          }
          return false;
        }
        function isKey(value, object) {
          if (isArray(value)) {
            return false;
          }
          var type = typeof value;
          if (
            type == "number" ||
            type == "symbol" ||
            type == "boolean" ||
            value == null ||
            isSymbol(value)
          ) {
            return true;
          }
          return (
            reIsPlainProp.test(value) ||
            !reIsDeepProp.test(value) ||
            (object != null && value in Object2(object))
          );
        }
        function isKeyable(value) {
          var type = typeof value;
          return type == "string" ||
            type == "number" ||
            type == "symbol" ||
            type == "boolean"
            ? value !== "__proto__"
            : value === null;
        }
        function isLaziable(func) {
          var funcName = getFuncName(func),
            other = lodash[funcName];
          if (
            typeof other != "function" ||
            !(funcName in LazyWrapper.prototype)
          ) {
            return false;
          }
          if (func === other) {
            return true;
          }
          var data = getData(other);
          return !!data && func === data[0];
        }
        function isMasked(func) {
          return !!maskSrcKey && maskSrcKey in func;
        }
        var isMaskable = coreJsData ? isFunction : stubFalse;
        function isPrototype(value) {
          var Ctor = value && value.constructor,
            proto =
              (typeof Ctor == "function" && Ctor.prototype) || objectProto;
          return value === proto;
        }
        function isStrictComparable(value) {
          return value === value && !isObject(value);
        }
        function matchesStrictComparable(key, srcValue) {
          return function (object) {
            if (object == null) {
              return false;
            }
            return (
              object[key] === srcValue &&
              (srcValue !== undefined$1 || key in Object2(object))
            );
          };
        }
        function memoizeCapped(func) {
          var result2 = memoize(func, function (key) {
            if (cache.size === MAX_MEMOIZE_SIZE) {
              cache.clear();
            }
            return key;
          });
          var cache = result2.cache;
          return result2;
        }
        function mergeData(data, source) {
          var bitmask = data[1],
            srcBitmask = source[1],
            newBitmask = bitmask | srcBitmask,
            isCommon =
              newBitmask <
              (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
          var isCombo =
            (srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG) ||
            (srcBitmask == WRAP_ARY_FLAG &&
              bitmask == WRAP_REARG_FLAG &&
              data[7].length <= source[8]) ||
            (srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) &&
              source[7].length <= source[8] &&
              bitmask == WRAP_CURRY_FLAG);
          if (!(isCommon || isCombo)) {
            return data;
          }
          if (srcBitmask & WRAP_BIND_FLAG) {
            data[2] = source[2];
            newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
          }
          var value = source[3];
          if (value) {
            var partials = data[3];
            data[3] = partials
              ? composeArgs(partials, value, source[4])
              : value;
            data[4] = partials
              ? replaceHolders(data[3], PLACEHOLDER)
              : source[4];
          }
          value = source[5];
          if (value) {
            partials = data[5];
            data[5] = partials
              ? composeArgsRight(partials, value, source[6])
              : value;
            data[6] = partials
              ? replaceHolders(data[5], PLACEHOLDER)
              : source[6];
          }
          value = source[7];
          if (value) {
            data[7] = value;
          }
          if (srcBitmask & WRAP_ARY_FLAG) {
            data[8] =
              data[8] == null ? source[8] : nativeMin(data[8], source[8]);
          }
          if (data[9] == null) {
            data[9] = source[9];
          }
          data[0] = source[0];
          data[1] = newBitmask;
          return data;
        }
        function nativeKeysIn(object) {
          var result2 = [];
          if (object != null) {
            for (var key in Object2(object)) {
              result2.push(key);
            }
          }
          return result2;
        }
        function objectToString(value) {
          return nativeObjectToString.call(value);
        }
        function overRest(func, start, transform2) {
          start = nativeMax(start === undefined$1 ? func.length - 1 : start, 0);
          return function () {
            var args = arguments,
              index = -1,
              length = nativeMax(args.length - start, 0),
              array = Array2(length);
            while (++index < length) {
              array[index] = args[start + index];
            }
            index = -1;
            var otherArgs = Array2(start + 1);
            while (++index < start) {
              otherArgs[index] = args[index];
            }
            otherArgs[start] = transform2(array);
            return apply(func, this, otherArgs);
          };
        }
        function parent(object, path) {
          return path.length < 2
            ? object
            : baseGet(object, baseSlice(path, 0, -1));
        }
        function reorder(array, indexes) {
          var arrLength = array.length,
            length = nativeMin(indexes.length, arrLength),
            oldArray = copyArray(array);
          while (length--) {
            var index = indexes[length];
            array[length] = isIndex(index, arrLength)
              ? oldArray[index]
              : undefined$1;
          }
          return array;
        }
        function safeGet(object, key) {
          if (key === "constructor" && typeof object[key] === "function") {
            return;
          }
          if (key == "__proto__") {
            return;
          }
          return object[key];
        }
        var setData = shortOut(baseSetData);
        var setTimeout =
          ctxSetTimeout ||
          function (func, wait) {
            return root.setTimeout(func, wait);
          };
        var setToString = shortOut(baseSetToString);
        function setWrapToString(wrapper, reference, bitmask) {
          var source = reference + "";
          return setToString(
            wrapper,
            insertWrapDetails(
              source,
              updateWrapDetails(getWrapDetails(source), bitmask)
            )
          );
        }
        function shortOut(func) {
          var count = 0,
            lastCalled = 0;
          return function () {
            var stamp = nativeNow(),
              remaining = HOT_SPAN - (stamp - lastCalled);
            lastCalled = stamp;
            if (remaining > 0) {
              if (++count >= HOT_COUNT) {
                return arguments[0];
              }
            } else {
              count = 0;
            }
            return func.apply(undefined$1, arguments);
          };
        }
        function shuffleSelf(array, size2) {
          var index = -1,
            length = array.length,
            lastIndex = length - 1;
          size2 = size2 === undefined$1 ? length : size2;
          while (++index < size2) {
            var rand = baseRandom(index, lastIndex),
              value = array[rand];
            array[rand] = array[index];
            array[index] = value;
          }
          array.length = size2;
          return array;
        }
        var stringToPath = memoizeCapped(function (string) {
          var result2 = [];
          if (string.charCodeAt(0) === 46) {
            result2.push("");
          }
          string.replace(
            rePropName,
            function (match, number, quote, subString) {
              result2.push(
                quote ? subString.replace(reEscapeChar, "$1") : number || match
              );
            }
          );
          return result2;
        });
        function toKey(value) {
          if (typeof value == "string" || isSymbol(value)) {
            return value;
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function toSource(func) {
          if (func != null) {
            try {
              return funcToString.call(func);
            } catch (e) {}
            try {
              return func + "";
            } catch (e) {}
          }
          return "";
        }
        function updateWrapDetails(details, bitmask) {
          arrayEach(wrapFlags, function (pair) {
            var value = "_." + pair[0];
            if (bitmask & pair[1] && !arrayIncludes(details, value)) {
              details.push(value);
            }
          });
          return details.sort();
        }
        function wrapperClone(wrapper) {
          if (wrapper instanceof LazyWrapper) {
            return wrapper.clone();
          }
          var result2 = new LodashWrapper(
            wrapper.__wrapped__,
            wrapper.__chain__
          );
          result2.__actions__ = copyArray(wrapper.__actions__);
          result2.__index__ = wrapper.__index__;
          result2.__values__ = wrapper.__values__;
          return result2;
        }
        function chunk(array, size2, guard) {
          if (
            guard ? isIterateeCall(array, size2, guard) : size2 === undefined$1
          ) {
            size2 = 1;
          } else {
            size2 = nativeMax(toInteger(size2), 0);
          }
          var length = array == null ? 0 : array.length;
          if (!length || size2 < 1) {
            return [];
          }
          var index = 0,
            resIndex = 0,
            result2 = Array2(nativeCeil(length / size2));
          while (index < length) {
            result2[resIndex++] = baseSlice(array, index, (index += size2));
          }
          return result2;
        }
        function compact(array) {
          var index = -1,
            length = array == null ? 0 : array.length,
            resIndex = 0,
            result2 = [];
          while (++index < length) {
            var value = array[index];
            if (value) {
              result2[resIndex++] = value;
            }
          }
          return result2;
        }
        function concat() {
          var length = arguments.length;
          if (!length) {
            return [];
          }
          var args = Array2(length - 1),
            array = arguments[0],
            index = length;
          while (index--) {
            args[index - 1] = arguments[index];
          }
          return arrayPush(
            isArray(array) ? copyArray(array) : [array],
            baseFlatten(args, 1)
          );
        }
        var difference = baseRest(function (array, values2) {
          return isArrayLikeObject(array)
            ? baseDifference(
                array,
                baseFlatten(values2, 1, isArrayLikeObject, true)
              )
            : [];
        });
        var differenceBy = baseRest(function (array, values2) {
          var iteratee2 = last(values2);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined$1;
          }
          return isArrayLikeObject(array)
            ? baseDifference(
                array,
                baseFlatten(values2, 1, isArrayLikeObject, true),
                getIteratee(iteratee2, 2)
              )
            : [];
        });
        var differenceWith = baseRest(function (array, values2) {
          var comparator = last(values2);
          if (isArrayLikeObject(comparator)) {
            comparator = undefined$1;
          }
          return isArrayLikeObject(array)
            ? baseDifference(
                array,
                baseFlatten(values2, 1, isArrayLikeObject, true),
                undefined$1,
                comparator
              )
            : [];
        });
        function drop(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined$1 ? 1 : toInteger(n);
          return baseSlice(array, n < 0 ? 0 : n, length);
        }
        function dropRight(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined$1 ? 1 : toInteger(n);
          n = length - n;
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function dropRightWhile(array, predicate) {
          return array && array.length
            ? baseWhile(array, getIteratee(predicate, 3), true, true)
            : [];
        }
        function dropWhile(array, predicate) {
          return array && array.length
            ? baseWhile(array, getIteratee(predicate, 3), true)
            : [];
        }
        function fill(array, value, start, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (
            start &&
            typeof start != "number" &&
            isIterateeCall(array, value, start)
          ) {
            start = 0;
            end = length;
          }
          return baseFill(array, value, start, end);
        }
        function findIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index);
        }
        function findLastIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = length - 1;
          if (fromIndex !== undefined$1) {
            index = toInteger(fromIndex);
            index =
              fromIndex < 0
                ? nativeMax(length + index, 0)
                : nativeMin(index, length - 1);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index, true);
        }
        function flatten(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, 1) : [];
        }
        function flattenDeep(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, INFINITY) : [];
        }
        function flattenDepth(array, depth) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          depth = depth === undefined$1 ? 1 : toInteger(depth);
          return baseFlatten(array, depth);
        }
        function fromPairs(pairs) {
          var index = -1,
            length = pairs == null ? 0 : pairs.length,
            result2 = {};
          while (++index < length) {
            var pair = pairs[index];
            result2[pair[0]] = pair[1];
          }
          return result2;
        }
        function head(array) {
          return array && array.length ? array[0] : undefined$1;
        }
        function indexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseIndexOf(array, value, index);
        }
        function initial(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 0, -1) : [];
        }
        var intersection = baseRest(function (arrays) {
          var mapped = arrayMap(arrays, castArrayLikeObject);
          return mapped.length && mapped[0] === arrays[0]
            ? baseIntersection(mapped)
            : [];
        });
        var intersectionBy = baseRest(function (arrays) {
          var iteratee2 = last(arrays),
            mapped = arrayMap(arrays, castArrayLikeObject);
          if (iteratee2 === last(mapped)) {
            iteratee2 = undefined$1;
          } else {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0]
            ? baseIntersection(mapped, getIteratee(iteratee2, 2))
            : [];
        });
        var intersectionWith = baseRest(function (arrays) {
          var comparator = last(arrays),
            mapped = arrayMap(arrays, castArrayLikeObject);
          comparator =
            typeof comparator == "function" ? comparator : undefined$1;
          if (comparator) {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0]
            ? baseIntersection(mapped, undefined$1, comparator)
            : [];
        });
        function join(array, separator) {
          return array == null ? "" : nativeJoin.call(array, separator);
        }
        function last(array) {
          var length = array == null ? 0 : array.length;
          return length ? array[length - 1] : undefined$1;
        }
        function lastIndexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = length;
          if (fromIndex !== undefined$1) {
            index = toInteger(fromIndex);
            index =
              index < 0
                ? nativeMax(length + index, 0)
                : nativeMin(index, length - 1);
          }
          return value === value
            ? strictLastIndexOf(array, value, index)
            : baseFindIndex(array, baseIsNaN, index, true);
        }
        function nth(array, n) {
          return array && array.length
            ? baseNth(array, toInteger(n))
            : undefined$1;
        }
        var pull = baseRest(pullAll);
        function pullAll(array, values2) {
          return array && array.length && values2 && values2.length
            ? basePullAll(array, values2)
            : array;
        }
        function pullAllBy(array, values2, iteratee2) {
          return array && array.length && values2 && values2.length
            ? basePullAll(array, values2, getIteratee(iteratee2, 2))
            : array;
        }
        function pullAllWith(array, values2, comparator) {
          return array && array.length && values2 && values2.length
            ? basePullAll(array, values2, undefined$1, comparator)
            : array;
        }
        var pullAt = flatRest(function (array, indexes) {
          var length = array == null ? 0 : array.length,
            result2 = baseAt(array, indexes);
          basePullAt(
            array,
            arrayMap(indexes, function (index) {
              return isIndex(index, length) ? +index : index;
            }).sort(compareAscending)
          );
          return result2;
        });
        function remove(array, predicate) {
          var result2 = [];
          if (!(array && array.length)) {
            return result2;
          }
          var index = -1,
            indexes = [],
            length = array.length;
          predicate = getIteratee(predicate, 3);
          while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
              result2.push(value);
              indexes.push(index);
            }
          }
          basePullAt(array, indexes);
          return result2;
        }
        function reverse(array) {
          return array == null ? array : nativeReverse.call(array);
        }
        function slice(array, start, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (
            end &&
            typeof end != "number" &&
            isIterateeCall(array, start, end)
          ) {
            start = 0;
            end = length;
          } else {
            start = start == null ? 0 : toInteger(start);
            end = end === undefined$1 ? length : toInteger(end);
          }
          return baseSlice(array, start, end);
        }
        function sortedIndex(array, value) {
          return baseSortedIndex(array, value);
        }
        function sortedIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
        }
        function sortedIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index = baseSortedIndex(array, value);
            if (index < length && eq(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function sortedLastIndex(array, value) {
          return baseSortedIndex(array, value, true);
        }
        function sortedLastIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(
            array,
            value,
            getIteratee(iteratee2, 2),
            true
          );
        }
        function sortedLastIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index = baseSortedIndex(array, value, true) - 1;
            if (eq(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function sortedUniq(array) {
          return array && array.length ? baseSortedUniq(array) : [];
        }
        function sortedUniqBy(array, iteratee2) {
          return array && array.length
            ? baseSortedUniq(array, getIteratee(iteratee2, 2))
            : [];
        }
        function tail(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 1, length) : [];
        }
        function take(array, n, guard) {
          if (!(array && array.length)) {
            return [];
          }
          n = guard || n === undefined$1 ? 1 : toInteger(n);
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function takeRight(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined$1 ? 1 : toInteger(n);
          n = length - n;
          return baseSlice(array, n < 0 ? 0 : n, length);
        }
        function takeRightWhile(array, predicate) {
          return array && array.length
            ? baseWhile(array, getIteratee(predicate, 3), false, true)
            : [];
        }
        function takeWhile(array, predicate) {
          return array && array.length
            ? baseWhile(array, getIteratee(predicate, 3))
            : [];
        }
        var union = baseRest(function (arrays) {
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
        });
        var unionBy = baseRest(function (arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined$1;
          }
          return baseUniq(
            baseFlatten(arrays, 1, isArrayLikeObject, true),
            getIteratee(iteratee2, 2)
          );
        });
        var unionWith = baseRest(function (arrays) {
          var comparator = last(arrays);
          comparator =
            typeof comparator == "function" ? comparator : undefined$1;
          return baseUniq(
            baseFlatten(arrays, 1, isArrayLikeObject, true),
            undefined$1,
            comparator
          );
        });
        function uniq(array) {
          return array && array.length ? baseUniq(array) : [];
        }
        function uniqBy(array, iteratee2) {
          return array && array.length
            ? baseUniq(array, getIteratee(iteratee2, 2))
            : [];
        }
        function uniqWith(array, comparator) {
          comparator =
            typeof comparator == "function" ? comparator : undefined$1;
          return array && array.length
            ? baseUniq(array, undefined$1, comparator)
            : [];
        }
        function unzip(array) {
          if (!(array && array.length)) {
            return [];
          }
          var length = 0;
          array = arrayFilter(array, function (group) {
            if (isArrayLikeObject(group)) {
              length = nativeMax(group.length, length);
              return true;
            }
          });
          return baseTimes(length, function (index) {
            return arrayMap(array, baseProperty(index));
          });
        }
        function unzipWith(array, iteratee2) {
          if (!(array && array.length)) {
            return [];
          }
          var result2 = unzip(array);
          if (iteratee2 == null) {
            return result2;
          }
          return arrayMap(result2, function (group) {
            return apply(iteratee2, undefined$1, group);
          });
        }
        var without = baseRest(function (array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
        });
        var xor = baseRest(function (arrays) {
          return baseXor(arrayFilter(arrays, isArrayLikeObject));
        });
        var xorBy = baseRest(function (arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined$1;
          }
          return baseXor(
            arrayFilter(arrays, isArrayLikeObject),
            getIteratee(iteratee2, 2)
          );
        });
        var xorWith = baseRest(function (arrays) {
          var comparator = last(arrays);
          comparator =
            typeof comparator == "function" ? comparator : undefined$1;
          return baseXor(
            arrayFilter(arrays, isArrayLikeObject),
            undefined$1,
            comparator
          );
        });
        var zip = baseRest(unzip);
        function zipObject(props, values2) {
          return baseZipObject(props || [], values2 || [], assignValue);
        }
        function zipObjectDeep(props, values2) {
          return baseZipObject(props || [], values2 || [], baseSet);
        }
        var zipWith = baseRest(function (arrays) {
          var length = arrays.length,
            iteratee2 = length > 1 ? arrays[length - 1] : undefined$1;
          iteratee2 =
            typeof iteratee2 == "function"
              ? (arrays.pop(), iteratee2)
              : undefined$1;
          return unzipWith(arrays, iteratee2);
        });
        function chain(value) {
          var result2 = lodash(value);
          result2.__chain__ = true;
          return result2;
        }
        function tap(value, interceptor) {
          interceptor(value);
          return value;
        }
        function thru(value, interceptor) {
          return interceptor(value);
        }
        var wrapperAt = flatRest(function (paths) {
          var length = paths.length,
            start = length ? paths[0] : 0,
            value = this.__wrapped__,
            interceptor = function (object) {
              return baseAt(object, paths);
            };
          if (
            length > 1 ||
            this.__actions__.length ||
            !(value instanceof LazyWrapper) ||
            !isIndex(start)
          ) {
            return this.thru(interceptor);
          }
          value = value.slice(start, +start + (length ? 1 : 0));
          value.__actions__.push({
            func: thru,
            args: [interceptor],
            thisArg: undefined$1,
          });
          return new LodashWrapper(value, this.__chain__).thru(function (
            array
          ) {
            if (length && !array.length) {
              array.push(undefined$1);
            }
            return array;
          });
        });
        function wrapperChain() {
          return chain(this);
        }
        function wrapperCommit() {
          return new LodashWrapper(this.value(), this.__chain__);
        }
        function wrapperNext() {
          if (this.__values__ === undefined$1) {
            this.__values__ = toArray(this.value());
          }
          var done = this.__index__ >= this.__values__.length,
            value = done ? undefined$1 : this.__values__[this.__index__++];
          return { done: done, value: value };
        }
        function wrapperToIterator() {
          return this;
        }
        function wrapperPlant(value) {
          var result2,
            parent2 = this;
          while (parent2 instanceof baseLodash) {
            var clone2 = wrapperClone(parent2);
            clone2.__index__ = 0;
            clone2.__values__ = undefined$1;
            if (result2) {
              previous.__wrapped__ = clone2;
            } else {
              result2 = clone2;
            }
            var previous = clone2;
            parent2 = parent2.__wrapped__;
          }
          previous.__wrapped__ = value;
          return result2;
        }
        function wrapperReverse() {
          var value = this.__wrapped__;
          if (value instanceof LazyWrapper) {
            var wrapped = value;
            if (this.__actions__.length) {
              wrapped = new LazyWrapper(this);
            }
            wrapped = wrapped.reverse();
            wrapped.__actions__.push({
              func: thru,
              args: [reverse],
              thisArg: undefined$1,
            });
            return new LodashWrapper(wrapped, this.__chain__);
          }
          return this.thru(reverse);
        }
        function wrapperValue() {
          return baseWrapperValue(this.__wrapped__, this.__actions__);
        }
        var countBy = createAggregator(function (result2, value, key) {
          if (hasOwnProperty.call(result2, key)) {
            ++result2[key];
          } else {
            baseAssignValue(result2, key, 1);
          }
        });
        function every(collection, predicate, guard) {
          var func = isArray(collection) ? arrayEvery : baseEvery;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined$1;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        function filter(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, getIteratee(predicate, 3));
        }
        var find = createFind(findIndex);
        var findLast = createFind(findLastIndex);
        function flatMap(collection, iteratee2) {
          return baseFlatten(map(collection, iteratee2), 1);
        }
        function flatMapDeep(collection, iteratee2) {
          return baseFlatten(map(collection, iteratee2), INFINITY);
        }
        function flatMapDepth(collection, iteratee2, depth) {
          depth = depth === undefined$1 ? 1 : toInteger(depth);
          return baseFlatten(map(collection, iteratee2), depth);
        }
        function forEach(collection, iteratee2) {
          var func = isArray(collection) ? arrayEach : baseEach;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function forEachRight(collection, iteratee2) {
          var func = isArray(collection) ? arrayEachRight : baseEachRight;
          return func(collection, getIteratee(iteratee2, 3));
        }
        var groupBy = createAggregator(function (result2, value, key) {
          if (hasOwnProperty.call(result2, key)) {
            result2[key].push(value);
          } else {
            baseAssignValue(result2, key, [value]);
          }
        });
        function includes(collection, value, fromIndex, guard) {
          collection = isArrayLike(collection)
            ? collection
            : values(collection);
          fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
          var length = collection.length;
          if (fromIndex < 0) {
            fromIndex = nativeMax(length + fromIndex, 0);
          }
          return isString(collection)
            ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1
            : !!length && baseIndexOf(collection, value, fromIndex) > -1;
        }
        var invokeMap = baseRest(function (collection, path, args) {
          var index = -1,
            isFunc = typeof path == "function",
            result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function (value) {
            result2[++index] = isFunc
              ? apply(path, value, args)
              : baseInvoke(value, path, args);
          });
          return result2;
        });
        var keyBy = createAggregator(function (result2, value, key) {
          baseAssignValue(result2, key, value);
        });
        function map(collection, iteratee2) {
          var func = isArray(collection) ? arrayMap : baseMap;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function orderBy(collection, iteratees, orders, guard) {
          if (collection == null) {
            return [];
          }
          if (!isArray(iteratees)) {
            iteratees = iteratees == null ? [] : [iteratees];
          }
          orders = guard ? undefined$1 : orders;
          if (!isArray(orders)) {
            orders = orders == null ? [] : [orders];
          }
          return baseOrderBy(collection, iteratees, orders);
        }
        var partition = createAggregator(
          function (result2, value, key) {
            result2[key ? 0 : 1].push(value);
          },
          function () {
            return [[], []];
          }
        );
        function reduce(collection, iteratee2, accumulator) {
          var func = isArray(collection) ? arrayReduce : baseReduce,
            initAccum = arguments.length < 3;
          return func(
            collection,
            getIteratee(iteratee2, 4),
            accumulator,
            initAccum,
            baseEach
          );
        }
        function reduceRight(collection, iteratee2, accumulator) {
          var func = isArray(collection) ? arrayReduceRight : baseReduce,
            initAccum = arguments.length < 3;
          return func(
            collection,
            getIteratee(iteratee2, 4),
            accumulator,
            initAccum,
            baseEachRight
          );
        }
        function reject(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, negate(getIteratee(predicate, 3)));
        }
        function sample(collection) {
          var func = isArray(collection) ? arraySample : baseSample;
          return func(collection);
        }
        function sampleSize(collection, n, guard) {
          if (
            guard ? isIterateeCall(collection, n, guard) : n === undefined$1
          ) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          var func = isArray(collection) ? arraySampleSize : baseSampleSize;
          return func(collection, n);
        }
        function shuffle(collection) {
          var func = isArray(collection) ? arrayShuffle : baseShuffle;
          return func(collection);
        }
        function size(collection) {
          if (collection == null) {
            return 0;
          }
          if (isArrayLike(collection)) {
            return isString(collection)
              ? stringSize(collection)
              : collection.length;
          }
          var tag = getTag(collection);
          if (tag == mapTag || tag == setTag) {
            return collection.size;
          }
          return baseKeys(collection).length;
        }
        function some(collection, predicate, guard) {
          var func = isArray(collection) ? arraySome : baseSome;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined$1;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        var sortBy = baseRest(function (collection, iteratees) {
          if (collection == null) {
            return [];
          }
          var length = iteratees.length;
          if (
            length > 1 &&
            isIterateeCall(collection, iteratees[0], iteratees[1])
          ) {
            iteratees = [];
          } else if (
            length > 2 &&
            isIterateeCall(iteratees[0], iteratees[1], iteratees[2])
          ) {
            iteratees = [iteratees[0]];
          }
          return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
        });
        var now =
          ctxNow ||
          function () {
            return root.Date.now();
          };
        function after(n, func) {
          if (typeof func != "function") {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function () {
            if (--n < 1) {
              return func.apply(this, arguments);
            }
          };
        }
        function ary(func, n, guard) {
          n = guard ? undefined$1 : n;
          n = func && n == null ? func.length : n;
          return createWrap(
            func,
            WRAP_ARY_FLAG,
            undefined$1,
            undefined$1,
            undefined$1,
            undefined$1,
            n
          );
        }
        function before(n, func) {
          var result2;
          if (typeof func != "function") {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function () {
            if (--n > 0) {
              result2 = func.apply(this, arguments);
            }
            if (n <= 1) {
              func = undefined$1;
            }
            return result2;
          };
        }
        var bind = baseRest(function (func, thisArg, partials) {
          var bitmask = WRAP_BIND_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bind));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(func, bitmask, thisArg, partials, holders);
        });
        var bindKey = baseRest(function (object, key, partials) {
          var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bindKey));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(key, bitmask, object, partials, holders);
        });
        function curry(func, arity, guard) {
          arity = guard ? undefined$1 : arity;
          var result2 = createWrap(
            func,
            WRAP_CURRY_FLAG,
            undefined$1,
            undefined$1,
            undefined$1,
            undefined$1,
            undefined$1,
            arity
          );
          result2.placeholder = curry.placeholder;
          return result2;
        }
        function curryRight(func, arity, guard) {
          arity = guard ? undefined$1 : arity;
          var result2 = createWrap(
            func,
            WRAP_CURRY_RIGHT_FLAG,
            undefined$1,
            undefined$1,
            undefined$1,
            undefined$1,
            undefined$1,
            arity
          );
          result2.placeholder = curryRight.placeholder;
          return result2;
        }
        function debounce(func, wait, options) {
          var lastArgs,
            lastThis,
            maxWait,
            result2,
            timerId,
            lastCallTime,
            lastInvokeTime = 0,
            leading = false,
            maxing = false,
            trailing = true;
          if (typeof func != "function") {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          wait = toNumber(wait) || 0;
          if (isObject(options)) {
            leading = !!options.leading;
            maxing = "maxWait" in options;
            maxWait = maxing
              ? nativeMax(toNumber(options.maxWait) || 0, wait)
              : maxWait;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          function invokeFunc(time) {
            var args = lastArgs,
              thisArg = lastThis;
            lastArgs = lastThis = undefined$1;
            lastInvokeTime = time;
            result2 = func.apply(thisArg, args);
            return result2;
          }
          function leadingEdge(time) {
            lastInvokeTime = time;
            timerId = setTimeout(timerExpired, wait);
            return leading ? invokeFunc(time) : result2;
          }
          function remainingWait(time) {
            var timeSinceLastCall = time - lastCallTime,
              timeSinceLastInvoke = time - lastInvokeTime,
              timeWaiting = wait - timeSinceLastCall;
            return maxing
              ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
              : timeWaiting;
          }
          function shouldInvoke(time) {
            var timeSinceLastCall = time - lastCallTime,
              timeSinceLastInvoke = time - lastInvokeTime;
            return (
              lastCallTime === undefined$1 ||
              timeSinceLastCall >= wait ||
              timeSinceLastCall < 0 ||
              (maxing && timeSinceLastInvoke >= maxWait)
            );
          }
          function timerExpired() {
            var time = now();
            if (shouldInvoke(time)) {
              return trailingEdge(time);
            }
            timerId = setTimeout(timerExpired, remainingWait(time));
          }
          function trailingEdge(time) {
            timerId = undefined$1;
            if (trailing && lastArgs) {
              return invokeFunc(time);
            }
            lastArgs = lastThis = undefined$1;
            return result2;
          }
          function cancel() {
            if (timerId !== undefined$1) {
              clearTimeout(timerId);
            }
            lastInvokeTime = 0;
            lastArgs = lastCallTime = lastThis = timerId = undefined$1;
          }
          function flush() {
            return timerId === undefined$1 ? result2 : trailingEdge(now());
          }
          function debounced() {
            var time = now(),
              isInvoking = shouldInvoke(time);
            lastArgs = arguments;
            lastThis = this;
            lastCallTime = time;
            if (isInvoking) {
              if (timerId === undefined$1) {
                return leadingEdge(lastCallTime);
              }
              if (maxing) {
                clearTimeout(timerId);
                timerId = setTimeout(timerExpired, wait);
                return invokeFunc(lastCallTime);
              }
            }
            if (timerId === undefined$1) {
              timerId = setTimeout(timerExpired, wait);
            }
            return result2;
          }
          debounced.cancel = cancel;
          debounced.flush = flush;
          return debounced;
        }
        var defer = baseRest(function (func, args) {
          return baseDelay(func, 1, args);
        });
        var delay = baseRest(function (func, wait, args) {
          return baseDelay(func, toNumber(wait) || 0, args);
        });
        function flip(func) {
          return createWrap(func, WRAP_FLIP_FLAG);
        }
        function memoize(func, resolver) {
          if (
            typeof func != "function" ||
            (resolver != null && typeof resolver != "function")
          ) {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          var memoized = function () {
            var args = arguments,
              key = resolver ? resolver.apply(this, args) : args[0],
              cache = memoized.cache;
            if (cache.has(key)) {
              return cache.get(key);
            }
            var result2 = func.apply(this, args);
            memoized.cache = cache.set(key, result2) || cache;
            return result2;
          };
          memoized.cache = new (memoize.Cache || MapCache)();
          return memoized;
        }
        memoize.Cache = MapCache;
        function negate(predicate) {
          if (typeof predicate != "function") {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          return function () {
            var args = arguments;
            switch (args.length) {
              case 0:
                return !predicate.call(this);
              case 1:
                return !predicate.call(this, args[0]);
              case 2:
                return !predicate.call(this, args[0], args[1]);
              case 3:
                return !predicate.call(this, args[0], args[1], args[2]);
            }
            return !predicate.apply(this, args);
          };
        }
        function once(func) {
          return before(2, func);
        }
        var overArgs = castRest(function (func, transforms) {
          transforms =
            transforms.length == 1 && isArray(transforms[0])
              ? arrayMap(transforms[0], baseUnary(getIteratee()))
              : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
          var funcsLength = transforms.length;
          return baseRest(function (args) {
            var index = -1,
              length = nativeMin(args.length, funcsLength);
            while (++index < length) {
              args[index] = transforms[index].call(this, args[index]);
            }
            return apply(func, this, args);
          });
        });
        var partial = baseRest(function (func, partials) {
          var holders = replaceHolders(partials, getHolder(partial));
          return createWrap(
            func,
            WRAP_PARTIAL_FLAG,
            undefined$1,
            partials,
            holders
          );
        });
        var partialRight = baseRest(function (func, partials) {
          var holders = replaceHolders(partials, getHolder(partialRight));
          return createWrap(
            func,
            WRAP_PARTIAL_RIGHT_FLAG,
            undefined$1,
            partials,
            holders
          );
        });
        var rearg = flatRest(function (func, indexes) {
          return createWrap(
            func,
            WRAP_REARG_FLAG,
            undefined$1,
            undefined$1,
            undefined$1,
            indexes
          );
        });
        function rest(func, start) {
          if (typeof func != "function") {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          start = start === undefined$1 ? start : toInteger(start);
          return baseRest(func, start);
        }
        function spread(func, start) {
          if (typeof func != "function") {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          start = start == null ? 0 : nativeMax(toInteger(start), 0);
          return baseRest(function (args) {
            var array = args[start],
              otherArgs = castSlice(args, 0, start);
            if (array) {
              arrayPush(otherArgs, array);
            }
            return apply(func, this, otherArgs);
          });
        }
        function throttle(func, wait, options) {
          var leading = true,
            trailing = true;
          if (typeof func != "function") {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          if (isObject(options)) {
            leading = "leading" in options ? !!options.leading : leading;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          return debounce(func, wait, {
            leading: leading,
            maxWait: wait,
            trailing: trailing,
          });
        }
        function unary(func) {
          return ary(func, 1);
        }
        function wrap(value, wrapper) {
          return partial(castFunction(wrapper), value);
        }
        function castArray() {
          if (!arguments.length) {
            return [];
          }
          var value = arguments[0];
          return isArray(value) ? value : [value];
        }
        function clone(value) {
          return baseClone(value, CLONE_SYMBOLS_FLAG);
        }
        function cloneWith(value, customizer) {
          customizer =
            typeof customizer == "function" ? customizer : undefined$1;
          return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
        }
        function cloneDeep(value) {
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
        }
        function cloneDeepWith(value, customizer) {
          customizer =
            typeof customizer == "function" ? customizer : undefined$1;
          return baseClone(
            value,
            CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG,
            customizer
          );
        }
        function conformsTo(object, source) {
          return source == null || baseConformsTo(object, source, keys(source));
        }
        function eq(value, other) {
          return value === other || (value !== value && other !== other);
        }
        var gt = createRelationalOperation(baseGt);
        var gte = createRelationalOperation(function (value, other) {
          return value >= other;
        });
        var isArguments = baseIsArguments(
          (function () {
            return arguments;
          })()
        )
          ? baseIsArguments
          : function (value) {
              return (
                isObjectLike(value) &&
                hasOwnProperty.call(value, "callee") &&
                !propertyIsEnumerable.call(value, "callee")
              );
            };
        var isArray = Array2.isArray;
        var isArrayBuffer = nodeIsArrayBuffer
          ? baseUnary(nodeIsArrayBuffer)
          : baseIsArrayBuffer;
        function isArrayLike(value) {
          return value != null && isLength(value.length) && !isFunction(value);
        }
        function isArrayLikeObject(value) {
          return isObjectLike(value) && isArrayLike(value);
        }
        function isBoolean(value) {
          return (
            value === true ||
            value === false ||
            (isObjectLike(value) && baseGetTag(value) == boolTag)
          );
        }
        var isBuffer = nativeIsBuffer || stubFalse;
        var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
        function isElement(value) {
          return (
            isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value)
          );
        }
        function isEmpty(value) {
          if (value == null) {
            return true;
          }
          if (
            isArrayLike(value) &&
            (isArray(value) ||
              typeof value == "string" ||
              typeof value.splice == "function" ||
              isBuffer(value) ||
              isTypedArray(value) ||
              isArguments(value))
          ) {
            return !value.length;
          }
          var tag = getTag(value);
          if (tag == mapTag || tag == setTag) {
            return !value.size;
          }
          if (isPrototype(value)) {
            return !baseKeys(value).length;
          }
          for (var key in value) {
            if (hasOwnProperty.call(value, key)) {
              return false;
            }
          }
          return true;
        }
        function isEqual(value, other) {
          return baseIsEqual(value, other);
        }
        function isEqualWith(value, other, customizer) {
          customizer =
            typeof customizer == "function" ? customizer : undefined$1;
          var result2 = customizer ? customizer(value, other) : undefined$1;
          return result2 === undefined$1
            ? baseIsEqual(value, other, undefined$1, customizer)
            : !!result2;
        }
        function isError(value) {
          if (!isObjectLike(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return (
            tag == errorTag ||
            tag == domExcTag ||
            (typeof value.message == "string" &&
              typeof value.name == "string" &&
              !isPlainObject(value))
          );
        }
        function isFinite(value) {
          return typeof value == "number" && nativeIsFinite(value);
        }
        function isFunction(value) {
          if (!isObject(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return (
            tag == funcTag ||
            tag == genTag ||
            tag == asyncTag ||
            tag == proxyTag
          );
        }
        function isInteger(value) {
          return typeof value == "number" && value == toInteger(value);
        }
        function isLength(value) {
          return (
            typeof value == "number" &&
            value > -1 &&
            value % 1 == 0 &&
            value <= MAX_SAFE_INTEGER
          );
        }
        function isObject(value) {
          var type = typeof value;
          return value != null && (type == "object" || type == "function");
        }
        function isObjectLike(value) {
          return value != null && typeof value == "object";
        }
        var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
        function isMatch(object, source) {
          return (
            object === source ||
            baseIsMatch(object, source, getMatchData(source))
          );
        }
        function isMatchWith(object, source, customizer) {
          customizer =
            typeof customizer == "function" ? customizer : undefined$1;
          return baseIsMatch(object, source, getMatchData(source), customizer);
        }
        function isNaN(value) {
          return isNumber(value) && value != +value;
        }
        function isNative(value) {
          if (isMaskable(value)) {
            throw new Error(CORE_ERROR_TEXT);
          }
          return baseIsNative(value);
        }
        function isNull(value) {
          return value === null;
        }
        function isNil(value) {
          return value == null;
        }
        function isNumber(value) {
          return (
            typeof value == "number" ||
            (isObjectLike(value) && baseGetTag(value) == numberTag)
          );
        }
        function isPlainObject(value) {
          if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
            return false;
          }
          var proto = getPrototype(value);
          if (proto === null) {
            return true;
          }
          var Ctor =
            hasOwnProperty.call(proto, "constructor") && proto.constructor;
          return (
            typeof Ctor == "function" &&
            Ctor instanceof Ctor &&
            funcToString.call(Ctor) == objectCtorString
          );
        }
        var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
        function isSafeInteger(value) {
          return (
            isInteger(value) &&
            value >= -MAX_SAFE_INTEGER &&
            value <= MAX_SAFE_INTEGER
          );
        }
        var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
        function isString(value) {
          return (
            typeof value == "string" ||
            (!isArray(value) &&
              isObjectLike(value) &&
              baseGetTag(value) == stringTag)
          );
        }
        function isSymbol(value) {
          return (
            typeof value == "symbol" ||
            (isObjectLike(value) && baseGetTag(value) == symbolTag)
          );
        }
        var isTypedArray = nodeIsTypedArray
          ? baseUnary(nodeIsTypedArray)
          : baseIsTypedArray;
        function isUndefined(value) {
          return value === undefined$1;
        }
        function isWeakMap(value) {
          return isObjectLike(value) && getTag(value) == weakMapTag;
        }
        function isWeakSet(value) {
          return isObjectLike(value) && baseGetTag(value) == weakSetTag;
        }
        var lt = createRelationalOperation(baseLt);
        var lte = createRelationalOperation(function (value, other) {
          return value <= other;
        });
        function toArray(value) {
          if (!value) {
            return [];
          }
          if (isArrayLike(value)) {
            return isString(value) ? stringToArray(value) : copyArray(value);
          }
          if (symIterator && value[symIterator]) {
            return iteratorToArray(value[symIterator]());
          }
          var tag = getTag(value),
            func =
              tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
          return func(value);
        }
        function toFinite(value) {
          if (!value) {
            return value === 0 ? value : 0;
          }
          value = toNumber(value);
          if (value === INFINITY || value === -INFINITY) {
            var sign = value < 0 ? -1 : 1;
            return sign * MAX_INTEGER;
          }
          return value === value ? value : 0;
        }
        function toInteger(value) {
          var result2 = toFinite(value),
            remainder = result2 % 1;
          return result2 === result2
            ? remainder
              ? result2 - remainder
              : result2
            : 0;
        }
        function toLength(value) {
          return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
        }
        function toNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          if (isObject(value)) {
            var other =
              typeof value.valueOf == "function" ? value.valueOf() : value;
            value = isObject(other) ? other + "" : other;
          }
          if (typeof value != "string") {
            return value === 0 ? value : +value;
          }
          value = baseTrim(value);
          var isBinary = reIsBinary.test(value);
          return isBinary || reIsOctal.test(value)
            ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
            : reIsBadHex.test(value)
            ? NAN
            : +value;
        }
        function toPlainObject(value) {
          return copyObject(value, keysIn(value));
        }
        function toSafeInteger(value) {
          return value
            ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER)
            : value === 0
            ? value
            : 0;
        }
        function toString(value) {
          return value == null ? "" : baseToString(value);
        }
        var assign = createAssigner(function (object, source) {
          if (isPrototype(source) || isArrayLike(source)) {
            copyObject(source, keys(source), object);
            return;
          }
          for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
              assignValue(object, key, source[key]);
            }
          }
        });
        var assignIn = createAssigner(function (object, source) {
          copyObject(source, keysIn(source), object);
        });
        var assignInWith = createAssigner(function (
          object,
          source,
          srcIndex,
          customizer
        ) {
          copyObject(source, keysIn(source), object, customizer);
        });
        var assignWith = createAssigner(function (
          object,
          source,
          srcIndex,
          customizer
        ) {
          copyObject(source, keys(source), object, customizer);
        });
        var at = flatRest(baseAt);
        function create(prototype, properties) {
          var result2 = baseCreate(prototype);
          return properties == null ? result2 : baseAssign(result2, properties);
        }
        var defaults = baseRest(function (object, sources) {
          object = Object2(object);
          var index = -1;
          var length = sources.length;
          var guard = length > 2 ? sources[2] : undefined$1;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            length = 1;
          }
          while (++index < length) {
            var source = sources[index];
            var props = keysIn(source);
            var propsIndex = -1;
            var propsLength = props.length;
            while (++propsIndex < propsLength) {
              var key = props[propsIndex];
              var value = object[key];
              if (
                value === undefined$1 ||
                (eq(value, objectProto[key]) &&
                  !hasOwnProperty.call(object, key))
              ) {
                object[key] = source[key];
              }
            }
          }
          return object;
        });
        var defaultsDeep = baseRest(function (args) {
          args.push(undefined$1, customDefaultsMerge);
          return apply(mergeWith, undefined$1, args);
        });
        function findKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
        }
        function findLastKey(object, predicate) {
          return baseFindKey(
            object,
            getIteratee(predicate, 3),
            baseForOwnRight
          );
        }
        function forIn(object, iteratee2) {
          return object == null
            ? object
            : baseFor(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forInRight(object, iteratee2) {
          return object == null
            ? object
            : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forOwn(object, iteratee2) {
          return object && baseForOwn(object, getIteratee(iteratee2, 3));
        }
        function forOwnRight(object, iteratee2) {
          return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
        }
        function functions(object) {
          return object == null ? [] : baseFunctions(object, keys(object));
        }
        function functionsIn(object) {
          return object == null ? [] : baseFunctions(object, keysIn(object));
        }
        function get(object, path, defaultValue) {
          var result2 = object == null ? undefined$1 : baseGet(object, path);
          return result2 === undefined$1 ? defaultValue : result2;
        }
        function has(object, path) {
          return object != null && hasPath(object, path, baseHas);
        }
        function hasIn(object, path) {
          return object != null && hasPath(object, path, baseHasIn);
        }
        var invert = createInverter(function (result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          result2[value] = key;
        }, constant(identity));
        var invertBy = createInverter(function (result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          if (hasOwnProperty.call(result2, value)) {
            result2[value].push(key);
          } else {
            result2[value] = [key];
          }
        }, getIteratee);
        var invoke = baseRest(baseInvoke);
        function keys(object) {
          return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
        }
        function keysIn(object) {
          return isArrayLike(object)
            ? arrayLikeKeys(object, true)
            : baseKeysIn(object);
        }
        function mapKeys(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function (value, key, object2) {
            baseAssignValue(result2, iteratee2(value, key, object2), value);
          });
          return result2;
        }
        function mapValues(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function (value, key, object2) {
            baseAssignValue(result2, key, iteratee2(value, key, object2));
          });
          return result2;
        }
        var merge = createAssigner(function (object, source, srcIndex) {
          baseMerge(object, source, srcIndex);
        });
        var mergeWith = createAssigner(function (
          object,
          source,
          srcIndex,
          customizer
        ) {
          baseMerge(object, source, srcIndex, customizer);
        });
        var omit = flatRest(function (object, paths) {
          var result2 = {};
          if (object == null) {
            return result2;
          }
          var isDeep = false;
          paths = arrayMap(paths, function (path) {
            path = castPath(path, object);
            isDeep || (isDeep = path.length > 1);
            return path;
          });
          copyObject(object, getAllKeysIn(object), result2);
          if (isDeep) {
            result2 = baseClone(
              result2,
              CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG,
              customOmitClone
            );
          }
          var length = paths.length;
          while (length--) {
            baseUnset(result2, paths[length]);
          }
          return result2;
        });
        function omitBy(object, predicate) {
          return pickBy(object, negate(getIteratee(predicate)));
        }
        var pick = flatRest(function (object, paths) {
          return object == null ? {} : basePick(object, paths);
        });
        function pickBy(object, predicate) {
          if (object == null) {
            return {};
          }
          var props = arrayMap(getAllKeysIn(object), function (prop) {
            return [prop];
          });
          predicate = getIteratee(predicate);
          return basePickBy(object, props, function (value, path) {
            return predicate(value, path[0]);
          });
        }
        function result(object, path, defaultValue) {
          path = castPath(path, object);
          var index = -1,
            length = path.length;
          if (!length) {
            length = 1;
            object = undefined$1;
          }
          while (++index < length) {
            var value =
              object == null ? undefined$1 : object[toKey(path[index])];
            if (value === undefined$1) {
              index = length;
              value = defaultValue;
            }
            object = isFunction(value) ? value.call(object) : value;
          }
          return object;
        }
        function set(object, path, value) {
          return object == null ? object : baseSet(object, path, value);
        }
        function setWith(object, path, value, customizer) {
          customizer =
            typeof customizer == "function" ? customizer : undefined$1;
          return object == null
            ? object
            : baseSet(object, path, value, customizer);
        }
        var toPairs = createToPairs(keys);
        var toPairsIn = createToPairs(keysIn);
        function transform(object, iteratee2, accumulator) {
          var isArr = isArray(object),
            isArrLike = isArr || isBuffer(object) || isTypedArray(object);
          iteratee2 = getIteratee(iteratee2, 4);
          if (accumulator == null) {
            var Ctor = object && object.constructor;
            if (isArrLike) {
              accumulator = isArr ? new Ctor() : [];
            } else if (isObject(object)) {
              accumulator = isFunction(Ctor)
                ? baseCreate(getPrototype(object))
                : {};
            } else {
              accumulator = {};
            }
          }
          (isArrLike ? arrayEach : baseForOwn)(
            object,
            function (value, index, object2) {
              return iteratee2(accumulator, value, index, object2);
            }
          );
          return accumulator;
        }
        function unset(object, path) {
          return object == null ? true : baseUnset(object, path);
        }
        function update(object, path, updater) {
          return object == null
            ? object
            : baseUpdate(object, path, castFunction(updater));
        }
        function updateWith(object, path, updater, customizer) {
          customizer =
            typeof customizer == "function" ? customizer : undefined$1;
          return object == null
            ? object
            : baseUpdate(object, path, castFunction(updater), customizer);
        }
        function values(object) {
          return object == null ? [] : baseValues(object, keys(object));
        }
        function valuesIn(object) {
          return object == null ? [] : baseValues(object, keysIn(object));
        }
        function clamp(number, lower, upper) {
          if (upper === undefined$1) {
            upper = lower;
            lower = undefined$1;
          }
          if (upper !== undefined$1) {
            upper = toNumber(upper);
            upper = upper === upper ? upper : 0;
          }
          if (lower !== undefined$1) {
            lower = toNumber(lower);
            lower = lower === lower ? lower : 0;
          }
          return baseClamp(toNumber(number), lower, upper);
        }
        function inRange(number, start, end) {
          start = toFinite(start);
          if (end === undefined$1) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          number = toNumber(number);
          return baseInRange(number, start, end);
        }
        function random(lower, upper, floating) {
          if (
            floating &&
            typeof floating != "boolean" &&
            isIterateeCall(lower, upper, floating)
          ) {
            upper = floating = undefined$1;
          }
          if (floating === undefined$1) {
            if (typeof upper == "boolean") {
              floating = upper;
              upper = undefined$1;
            } else if (typeof lower == "boolean") {
              floating = lower;
              lower = undefined$1;
            }
          }
          if (lower === undefined$1 && upper === undefined$1) {
            lower = 0;
            upper = 1;
          } else {
            lower = toFinite(lower);
            if (upper === undefined$1) {
              upper = lower;
              lower = 0;
            } else {
              upper = toFinite(upper);
            }
          }
          if (lower > upper) {
            var temp = lower;
            lower = upper;
            upper = temp;
          }
          if (floating || lower % 1 || upper % 1) {
            var rand = nativeRandom();
            return nativeMin(
              lower +
                rand *
                  (upper -
                    lower +
                    freeParseFloat("1e-" + ((rand + "").length - 1))),
              upper
            );
          }
          return baseRandom(lower, upper);
        }
        var camelCase = createCompounder(function (result2, word, index) {
          word = word.toLowerCase();
          return result2 + (index ? capitalize(word) : word);
        });
        function capitalize(string) {
          return upperFirst(toString(string).toLowerCase());
        }
        function deburr(string) {
          string = toString(string);
          return (
            string &&
            string.replace(reLatin, deburrLetter).replace(reComboMark, "")
          );
        }
        function endsWith(string, target, position) {
          string = toString(string);
          target = baseToString(target);
          var length = string.length;
          position =
            position === undefined$1
              ? length
              : baseClamp(toInteger(position), 0, length);
          var end = position;
          position -= target.length;
          return position >= 0 && string.slice(position, end) == target;
        }
        function escape(string) {
          string = toString(string);
          return string && reHasUnescapedHtml.test(string)
            ? string.replace(reUnescapedHtml, escapeHtmlChar)
            : string;
        }
        function escapeRegExp(string) {
          string = toString(string);
          return string && reHasRegExpChar.test(string)
            ? string.replace(reRegExpChar, "\\$&")
            : string;
        }
        var kebabCase = createCompounder(function (result2, word, index) {
          return result2 + (index ? "-" : "") + word.toLowerCase();
        });
        var lowerCase = createCompounder(function (result2, word, index) {
          return result2 + (index ? " " : "") + word.toLowerCase();
        });
        var lowerFirst = createCaseFirst("toLowerCase");
        function pad(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          if (!length || strLength >= length) {
            return string;
          }
          var mid = (length - strLength) / 2;
          return (
            createPadding(nativeFloor(mid), chars) +
            string +
            createPadding(nativeCeil(mid), chars)
          );
        }
        function padEnd(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          return length && strLength < length
            ? string + createPadding(length - strLength, chars)
            : string;
        }
        function padStart(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          return length && strLength < length
            ? createPadding(length - strLength, chars) + string
            : string;
        }
        function parseInt2(string, radix, guard) {
          if (guard || radix == null) {
            radix = 0;
          } else if (radix) {
            radix = +radix;
          }
          return nativeParseInt(
            toString(string).replace(reTrimStart, ""),
            radix || 0
          );
        }
        function repeat(string, n, guard) {
          if (guard ? isIterateeCall(string, n, guard) : n === undefined$1) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          return baseRepeat(toString(string), n);
        }
        function replace() {
          var args = arguments,
            string = toString(args[0]);
          return args.length < 3 ? string : string.replace(args[1], args[2]);
        }
        var snakeCase = createCompounder(function (result2, word, index) {
          return result2 + (index ? "_" : "") + word.toLowerCase();
        });
        function split(string, separator, limit) {
          if (
            limit &&
            typeof limit != "number" &&
            isIterateeCall(string, separator, limit)
          ) {
            separator = limit = undefined$1;
          }
          limit = limit === undefined$1 ? MAX_ARRAY_LENGTH : limit >>> 0;
          if (!limit) {
            return [];
          }
          string = toString(string);
          if (
            string &&
            (typeof separator == "string" ||
              (separator != null && !isRegExp(separator)))
          ) {
            separator = baseToString(separator);
            if (!separator && hasUnicode(string)) {
              return castSlice(stringToArray(string), 0, limit);
            }
          }
          return string.split(separator, limit);
        }
        var startCase = createCompounder(function (result2, word, index) {
          return result2 + (index ? " " : "") + upperFirst(word);
        });
        function startsWith(string, target, position) {
          string = toString(string);
          position =
            position == null
              ? 0
              : baseClamp(toInteger(position), 0, string.length);
          target = baseToString(target);
          return string.slice(position, position + target.length) == target;
        }
        function template(string, options, guard) {
          var settings = lodash.templateSettings;
          if (guard && isIterateeCall(string, options, guard)) {
            options = undefined$1;
          }
          string = toString(string);
          options = assignInWith({}, options, settings, customDefaultsAssignIn);
          var imports = assignInWith(
              {},
              options.imports,
              settings.imports,
              customDefaultsAssignIn
            ),
            importsKeys = keys(imports),
            importsValues = baseValues(imports, importsKeys);
          var isEscaping,
            isEvaluating,
            index = 0,
            interpolate = options.interpolate || reNoMatch,
            source = "__p += '";
          var reDelimiters = RegExp2(
            (options.escape || reNoMatch).source +
              "|" +
              interpolate.source +
              "|" +
              (interpolate === reInterpolate ? reEsTemplate : reNoMatch)
                .source +
              "|" +
              (options.evaluate || reNoMatch).source +
              "|$",
            "g"
          );
          var sourceURL =
            "//# sourceURL=" +
            (hasOwnProperty.call(options, "sourceURL")
              ? (options.sourceURL + "").replace(/\s/g, " ")
              : "lodash.templateSources[" + ++templateCounter + "]") +
            "\n";
          string.replace(
            reDelimiters,
            function (
              match,
              escapeValue,
              interpolateValue,
              esTemplateValue,
              evaluateValue,
              offset
            ) {
              interpolateValue || (interpolateValue = esTemplateValue);
              source += string
                .slice(index, offset)
                .replace(reUnescapedString, escapeStringChar);
              if (escapeValue) {
                isEscaping = true;
                source += "' +\n__e(" + escapeValue + ") +\n'";
              }
              if (evaluateValue) {
                isEvaluating = true;
                source += "';\n" + evaluateValue + ";\n__p += '";
              }
              if (interpolateValue) {
                source +=
                  "' +\n((__t = (" +
                  interpolateValue +
                  ")) == null ? '' : __t) +\n'";
              }
              index = offset + match.length;
              return match;
            }
          );
          source += "';\n";
          var variable =
            hasOwnProperty.call(options, "variable") && options.variable;
          if (!variable) {
            source = "with (obj) {\n" + source + "\n}\n";
          } else if (reForbiddenIdentifierChars.test(variable)) {
            throw new Error(INVALID_TEMPL_VAR_ERROR_TEXT);
          }
          source = (
            isEvaluating ? source.replace(reEmptyStringLeading, "") : source
          )
            .replace(reEmptyStringMiddle, "$1")
            .replace(reEmptyStringTrailing, "$1;");
          source =
            "function(" +
            (variable || "obj") +
            ") {\n" +
            (variable ? "" : "obj || (obj = {});\n") +
            "var __t, __p = ''" +
            (isEscaping ? ", __e = _.escape" : "") +
            (isEvaluating
              ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n"
              : ";\n") +
            source +
            "return __p\n}";
          var result2 = attempt(function () {
            return Function2(importsKeys, sourceURL + "return " + source).apply(
              undefined$1,
              importsValues
            );
          });
          result2.source = source;
          if (isError(result2)) {
            throw result2;
          }
          return result2;
        }
        function toLower(value) {
          return toString(value).toLowerCase();
        }
        function toUpper(value) {
          return toString(value).toUpperCase();
        }
        function trim(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined$1)) {
            return baseTrim(string);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string),
            chrSymbols = stringToArray(chars),
            start = charsStartIndex(strSymbols, chrSymbols),
            end = charsEndIndex(strSymbols, chrSymbols) + 1;
          return castSlice(strSymbols, start, end).join("");
        }
        function trimEnd(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined$1)) {
            return string.slice(0, trimmedEndIndex(string) + 1);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string),
            end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
          return castSlice(strSymbols, 0, end).join("");
        }
        function trimStart(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined$1)) {
            return string.replace(reTrimStart, "");
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string),
            start = charsStartIndex(strSymbols, stringToArray(chars));
          return castSlice(strSymbols, start).join("");
        }
        function truncate(string, options) {
          var length = DEFAULT_TRUNC_LENGTH,
            omission = DEFAULT_TRUNC_OMISSION;
          if (isObject(options)) {
            var separator =
              "separator" in options ? options.separator : separator;
            length = "length" in options ? toInteger(options.length) : length;
            omission =
              "omission" in options ? baseToString(options.omission) : omission;
          }
          string = toString(string);
          var strLength = string.length;
          if (hasUnicode(string)) {
            var strSymbols = stringToArray(string);
            strLength = strSymbols.length;
          }
          if (length >= strLength) {
            return string;
          }
          var end = length - stringSize(omission);
          if (end < 1) {
            return omission;
          }
          var result2 = strSymbols
            ? castSlice(strSymbols, 0, end).join("")
            : string.slice(0, end);
          if (separator === undefined$1) {
            return result2 + omission;
          }
          if (strSymbols) {
            end += result2.length - end;
          }
          if (isRegExp(separator)) {
            if (string.slice(end).search(separator)) {
              var match,
                substring = result2;
              if (!separator.global) {
                separator = RegExp2(
                  separator.source,
                  toString(reFlags.exec(separator)) + "g"
                );
              }
              separator.lastIndex = 0;
              while ((match = separator.exec(substring))) {
                var newEnd = match.index;
              }
              result2 = result2.slice(0, newEnd === undefined$1 ? end : newEnd);
            }
          } else if (string.indexOf(baseToString(separator), end) != end) {
            var index = result2.lastIndexOf(separator);
            if (index > -1) {
              result2 = result2.slice(0, index);
            }
          }
          return result2 + omission;
        }
        function unescape(string) {
          string = toString(string);
          return string && reHasEscapedHtml.test(string)
            ? string.replace(reEscapedHtml, unescapeHtmlChar)
            : string;
        }
        var upperCase = createCompounder(function (result2, word, index) {
          return result2 + (index ? " " : "") + word.toUpperCase();
        });
        var upperFirst = createCaseFirst("toUpperCase");
        function words(string, pattern, guard) {
          string = toString(string);
          pattern = guard ? undefined$1 : pattern;
          if (pattern === undefined$1) {
            return hasUnicodeWord(string)
              ? unicodeWords(string)
              : asciiWords(string);
          }
          return string.match(pattern) || [];
        }
        var attempt = baseRest(function (func, args) {
          try {
            return apply(func, undefined$1, args);
          } catch (e) {
            return isError(e) ? e : new Error(e);
          }
        });
        var bindAll = flatRest(function (object, methodNames) {
          arrayEach(methodNames, function (key) {
            key = toKey(key);
            baseAssignValue(object, key, bind(object[key], object));
          });
          return object;
        });
        function cond(pairs) {
          var length = pairs == null ? 0 : pairs.length,
            toIteratee = getIteratee();
          pairs = !length
            ? []
            : arrayMap(pairs, function (pair) {
                if (typeof pair[1] != "function") {
                  throw new TypeError(FUNC_ERROR_TEXT);
                }
                return [toIteratee(pair[0]), pair[1]];
              });
          return baseRest(function (args) {
            var index = -1;
            while (++index < length) {
              var pair = pairs[index];
              if (apply(pair[0], this, args)) {
                return apply(pair[1], this, args);
              }
            }
          });
        }
        function conforms(source) {
          return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
        }
        function constant(value) {
          return function () {
            return value;
          };
        }
        function defaultTo(value, defaultValue) {
          return value == null || value !== value ? defaultValue : value;
        }
        var flow = createFlow();
        var flowRight = createFlow(true);
        function identity(value) {
          return value;
        }
        function iteratee(func) {
          return baseIteratee(
            typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG)
          );
        }
        function matches(source) {
          return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
        }
        function matchesProperty(path, srcValue) {
          return baseMatchesProperty(
            path,
            baseClone(srcValue, CLONE_DEEP_FLAG)
          );
        }
        var method = baseRest(function (path, args) {
          return function (object) {
            return baseInvoke(object, path, args);
          };
        });
        var methodOf = baseRest(function (object, args) {
          return function (path) {
            return baseInvoke(object, path, args);
          };
        });
        function mixin(object, source, options) {
          var props = keys(source),
            methodNames = baseFunctions(source, props);
          if (
            options == null &&
            !(isObject(source) && (methodNames.length || !props.length))
          ) {
            options = source;
            source = object;
            object = this;
            methodNames = baseFunctions(source, keys(source));
          }
          var chain2 =
              !(isObject(options) && "chain" in options) || !!options.chain,
            isFunc = isFunction(object);
          arrayEach(methodNames, function (methodName) {
            var func = source[methodName];
            object[methodName] = func;
            if (isFunc) {
              object.prototype[methodName] = function () {
                var chainAll = this.__chain__;
                if (chain2 || chainAll) {
                  var result2 = object(this.__wrapped__),
                    actions = (result2.__actions__ = copyArray(
                      this.__actions__
                    ));
                  actions.push({
                    func: func,
                    args: arguments,
                    thisArg: object,
                  });
                  result2.__chain__ = chainAll;
                  return result2;
                }
                return func.apply(object, arrayPush([this.value()], arguments));
              };
            }
          });
          return object;
        }
        function noConflict() {
          if (root._ === this) {
            root._ = oldDash;
          }
          return this;
        }
        function noop() {}
        function nthArg(n) {
          n = toInteger(n);
          return baseRest(function (args) {
            return baseNth(args, n);
          });
        }
        var over = createOver(arrayMap);
        var overEvery = createOver(arrayEvery);
        var overSome = createOver(arraySome);
        function property(path) {
          return isKey(path)
            ? baseProperty(toKey(path))
            : basePropertyDeep(path);
        }
        function propertyOf(object) {
          return function (path) {
            return object == null ? undefined$1 : baseGet(object, path);
          };
        }
        var range = createRange();
        var rangeRight = createRange(true);
        function stubArray() {
          return [];
        }
        function stubFalse() {
          return false;
        }
        function stubObject() {
          return {};
        }
        function stubString() {
          return "";
        }
        function stubTrue() {
          return true;
        }
        function times(n, iteratee2) {
          n = toInteger(n);
          if (n < 1 || n > MAX_SAFE_INTEGER) {
            return [];
          }
          var index = MAX_ARRAY_LENGTH,
            length = nativeMin(n, MAX_ARRAY_LENGTH);
          iteratee2 = getIteratee(iteratee2);
          n -= MAX_ARRAY_LENGTH;
          var result2 = baseTimes(length, iteratee2);
          while (++index < n) {
            iteratee2(index);
          }
          return result2;
        }
        function toPath(value) {
          if (isArray(value)) {
            return arrayMap(value, toKey);
          }
          return isSymbol(value)
            ? [value]
            : copyArray(stringToPath(toString(value)));
        }
        function uniqueId(prefix) {
          var id = ++idCounter;
          return toString(prefix) + id;
        }
        var add = createMathOperation(function (augend, addend) {
          return augend + addend;
        }, 0);
        var ceil = createRound("ceil");
        var divide = createMathOperation(function (dividend, divisor) {
          return dividend / divisor;
        }, 1);
        var floor = createRound("floor");
        function max(array) {
          return array && array.length
            ? baseExtremum(array, identity, baseGt)
            : undefined$1;
        }
        function maxBy(array, iteratee2) {
          return array && array.length
            ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt)
            : undefined$1;
        }
        function mean(array) {
          return baseMean(array, identity);
        }
        function meanBy(array, iteratee2) {
          return baseMean(array, getIteratee(iteratee2, 2));
        }
        function min(array) {
          return array && array.length
            ? baseExtremum(array, identity, baseLt)
            : undefined$1;
        }
        function minBy(array, iteratee2) {
          return array && array.length
            ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt)
            : undefined$1;
        }
        var multiply = createMathOperation(function (multiplier, multiplicand) {
          return multiplier * multiplicand;
        }, 1);
        var round = createRound("round");
        var subtract = createMathOperation(function (minuend, subtrahend) {
          return minuend - subtrahend;
        }, 0);
        function sum(array) {
          return array && array.length ? baseSum(array, identity) : 0;
        }
        function sumBy(array, iteratee2) {
          return array && array.length
            ? baseSum(array, getIteratee(iteratee2, 2))
            : 0;
        }
        lodash.after = after;
        lodash.ary = ary;
        lodash.assign = assign;
        lodash.assignIn = assignIn;
        lodash.assignInWith = assignInWith;
        lodash.assignWith = assignWith;
        lodash.at = at;
        lodash.before = before;
        lodash.bind = bind;
        lodash.bindAll = bindAll;
        lodash.bindKey = bindKey;
        lodash.castArray = castArray;
        lodash.chain = chain;
        lodash.chunk = chunk;
        lodash.compact = compact;
        lodash.concat = concat;
        lodash.cond = cond;
        lodash.conforms = conforms;
        lodash.constant = constant;
        lodash.countBy = countBy;
        lodash.create = create;
        lodash.curry = curry;
        lodash.curryRight = curryRight;
        lodash.debounce = debounce;
        lodash.defaults = defaults;
        lodash.defaultsDeep = defaultsDeep;
        lodash.defer = defer;
        lodash.delay = delay;
        lodash.difference = difference;
        lodash.differenceBy = differenceBy;
        lodash.differenceWith = differenceWith;
        lodash.drop = drop;
        lodash.dropRight = dropRight;
        lodash.dropRightWhile = dropRightWhile;
        lodash.dropWhile = dropWhile;
        lodash.fill = fill;
        lodash.filter = filter;
        lodash.flatMap = flatMap;
        lodash.flatMapDeep = flatMapDeep;
        lodash.flatMapDepth = flatMapDepth;
        lodash.flatten = flatten;
        lodash.flattenDeep = flattenDeep;
        lodash.flattenDepth = flattenDepth;
        lodash.flip = flip;
        lodash.flow = flow;
        lodash.flowRight = flowRight;
        lodash.fromPairs = fromPairs;
        lodash.functions = functions;
        lodash.functionsIn = functionsIn;
        lodash.groupBy = groupBy;
        lodash.initial = initial;
        lodash.intersection = intersection;
        lodash.intersectionBy = intersectionBy;
        lodash.intersectionWith = intersectionWith;
        lodash.invert = invert;
        lodash.invertBy = invertBy;
        lodash.invokeMap = invokeMap;
        lodash.iteratee = iteratee;
        lodash.keyBy = keyBy;
        lodash.keys = keys;
        lodash.keysIn = keysIn;
        lodash.map = map;
        lodash.mapKeys = mapKeys;
        lodash.mapValues = mapValues;
        lodash.matches = matches;
        lodash.matchesProperty = matchesProperty;
        lodash.memoize = memoize;
        lodash.merge = merge;
        lodash.mergeWith = mergeWith;
        lodash.method = method;
        lodash.methodOf = methodOf;
        lodash.mixin = mixin;
        lodash.negate = negate;
        lodash.nthArg = nthArg;
        lodash.omit = omit;
        lodash.omitBy = omitBy;
        lodash.once = once;
        lodash.orderBy = orderBy;
        lodash.over = over;
        lodash.overArgs = overArgs;
        lodash.overEvery = overEvery;
        lodash.overSome = overSome;
        lodash.partial = partial;
        lodash.partialRight = partialRight;
        lodash.partition = partition;
        lodash.pick = pick;
        lodash.pickBy = pickBy;
        lodash.property = property;
        lodash.propertyOf = propertyOf;
        lodash.pull = pull;
        lodash.pullAll = pullAll;
        lodash.pullAllBy = pullAllBy;
        lodash.pullAllWith = pullAllWith;
        lodash.pullAt = pullAt;
        lodash.range = range;
        lodash.rangeRight = rangeRight;
        lodash.rearg = rearg;
        lodash.reject = reject;
        lodash.remove = remove;
        lodash.rest = rest;
        lodash.reverse = reverse;
        lodash.sampleSize = sampleSize;
        lodash.set = set;
        lodash.setWith = setWith;
        lodash.shuffle = shuffle;
        lodash.slice = slice;
        lodash.sortBy = sortBy;
        lodash.sortedUniq = sortedUniq;
        lodash.sortedUniqBy = sortedUniqBy;
        lodash.split = split;
        lodash.spread = spread;
        lodash.tail = tail;
        lodash.take = take;
        lodash.takeRight = takeRight;
        lodash.takeRightWhile = takeRightWhile;
        lodash.takeWhile = takeWhile;
        lodash.tap = tap;
        lodash.throttle = throttle;
        lodash.thru = thru;
        lodash.toArray = toArray;
        lodash.toPairs = toPairs;
        lodash.toPairsIn = toPairsIn;
        lodash.toPath = toPath;
        lodash.toPlainObject = toPlainObject;
        lodash.transform = transform;
        lodash.unary = unary;
        lodash.union = union;
        lodash.unionBy = unionBy;
        lodash.unionWith = unionWith;
        lodash.uniq = uniq;
        lodash.uniqBy = uniqBy;
        lodash.uniqWith = uniqWith;
        lodash.unset = unset;
        lodash.unzip = unzip;
        lodash.unzipWith = unzipWith;
        lodash.update = update;
        lodash.updateWith = updateWith;
        lodash.values = values;
        lodash.valuesIn = valuesIn;
        lodash.without = without;
        lodash.words = words;
        lodash.wrap = wrap;
        lodash.xor = xor;
        lodash.xorBy = xorBy;
        lodash.xorWith = xorWith;
        lodash.zip = zip;
        lodash.zipObject = zipObject;
        lodash.zipObjectDeep = zipObjectDeep;
        lodash.zipWith = zipWith;
        lodash.entries = toPairs;
        lodash.entriesIn = toPairsIn;
        lodash.extend = assignIn;
        lodash.extendWith = assignInWith;
        mixin(lodash, lodash);
        lodash.add = add;
        lodash.attempt = attempt;
        lodash.camelCase = camelCase;
        lodash.capitalize = capitalize;
        lodash.ceil = ceil;
        lodash.clamp = clamp;
        lodash.clone = clone;
        lodash.cloneDeep = cloneDeep;
        lodash.cloneDeepWith = cloneDeepWith;
        lodash.cloneWith = cloneWith;
        lodash.conformsTo = conformsTo;
        lodash.deburr = deburr;
        lodash.defaultTo = defaultTo;
        lodash.divide = divide;
        lodash.endsWith = endsWith;
        lodash.eq = eq;
        lodash.escape = escape;
        lodash.escapeRegExp = escapeRegExp;
        lodash.every = every;
        lodash.find = find;
        lodash.findIndex = findIndex;
        lodash.findKey = findKey;
        lodash.findLast = findLast;
        lodash.findLastIndex = findLastIndex;
        lodash.findLastKey = findLastKey;
        lodash.floor = floor;
        lodash.forEach = forEach;
        lodash.forEachRight = forEachRight;
        lodash.forIn = forIn;
        lodash.forInRight = forInRight;
        lodash.forOwn = forOwn;
        lodash.forOwnRight = forOwnRight;
        lodash.get = get;
        lodash.gt = gt;
        lodash.gte = gte;
        lodash.has = has;
        lodash.hasIn = hasIn;
        lodash.head = head;
        lodash.identity = identity;
        lodash.includes = includes;
        lodash.indexOf = indexOf;
        lodash.inRange = inRange;
        lodash.invoke = invoke;
        lodash.isArguments = isArguments;
        lodash.isArray = isArray;
        lodash.isArrayBuffer = isArrayBuffer;
        lodash.isArrayLike = isArrayLike;
        lodash.isArrayLikeObject = isArrayLikeObject;
        lodash.isBoolean = isBoolean;
        lodash.isBuffer = isBuffer;
        lodash.isDate = isDate;
        lodash.isElement = isElement;
        lodash.isEmpty = isEmpty;
        lodash.isEqual = isEqual;
        lodash.isEqualWith = isEqualWith;
        lodash.isError = isError;
        lodash.isFinite = isFinite;
        lodash.isFunction = isFunction;
        lodash.isInteger = isInteger;
        lodash.isLength = isLength;
        lodash.isMap = isMap;
        lodash.isMatch = isMatch;
        lodash.isMatchWith = isMatchWith;
        lodash.isNaN = isNaN;
        lodash.isNative = isNative;
        lodash.isNil = isNil;
        lodash.isNull = isNull;
        lodash.isNumber = isNumber;
        lodash.isObject = isObject;
        lodash.isObjectLike = isObjectLike;
        lodash.isPlainObject = isPlainObject;
        lodash.isRegExp = isRegExp;
        lodash.isSafeInteger = isSafeInteger;
        lodash.isSet = isSet;
        lodash.isString = isString;
        lodash.isSymbol = isSymbol;
        lodash.isTypedArray = isTypedArray;
        lodash.isUndefined = isUndefined;
        lodash.isWeakMap = isWeakMap;
        lodash.isWeakSet = isWeakSet;
        lodash.join = join;
        lodash.kebabCase = kebabCase;
        lodash.last = last;
        lodash.lastIndexOf = lastIndexOf;
        lodash.lowerCase = lowerCase;
        lodash.lowerFirst = lowerFirst;
        lodash.lt = lt;
        lodash.lte = lte;
        lodash.max = max;
        lodash.maxBy = maxBy;
        lodash.mean = mean;
        lodash.meanBy = meanBy;
        lodash.min = min;
        lodash.minBy = minBy;
        lodash.stubArray = stubArray;
        lodash.stubFalse = stubFalse;
        lodash.stubObject = stubObject;
        lodash.stubString = stubString;
        lodash.stubTrue = stubTrue;
        lodash.multiply = multiply;
        lodash.nth = nth;
        lodash.noConflict = noConflict;
        lodash.noop = noop;
        lodash.now = now;
        lodash.pad = pad;
        lodash.padEnd = padEnd;
        lodash.padStart = padStart;
        lodash.parseInt = parseInt2;
        lodash.random = random;
        lodash.reduce = reduce;
        lodash.reduceRight = reduceRight;
        lodash.repeat = repeat;
        lodash.replace = replace;
        lodash.result = result;
        lodash.round = round;
        lodash.runInContext = runInContext2;
        lodash.sample = sample;
        lodash.size = size;
        lodash.snakeCase = snakeCase;
        lodash.some = some;
        lodash.sortedIndex = sortedIndex;
        lodash.sortedIndexBy = sortedIndexBy;
        lodash.sortedIndexOf = sortedIndexOf;
        lodash.sortedLastIndex = sortedLastIndex;
        lodash.sortedLastIndexBy = sortedLastIndexBy;
        lodash.sortedLastIndexOf = sortedLastIndexOf;
        lodash.startCase = startCase;
        lodash.startsWith = startsWith;
        lodash.subtract = subtract;
        lodash.sum = sum;
        lodash.sumBy = sumBy;
        lodash.template = template;
        lodash.times = times;
        lodash.toFinite = toFinite;
        lodash.toInteger = toInteger;
        lodash.toLength = toLength;
        lodash.toLower = toLower;
        lodash.toNumber = toNumber;
        lodash.toSafeInteger = toSafeInteger;
        lodash.toString = toString;
        lodash.toUpper = toUpper;
        lodash.trim = trim;
        lodash.trimEnd = trimEnd;
        lodash.trimStart = trimStart;
        lodash.truncate = truncate;
        lodash.unescape = unescape;
        lodash.uniqueId = uniqueId;
        lodash.upperCase = upperCase;
        lodash.upperFirst = upperFirst;
        lodash.each = forEach;
        lodash.eachRight = forEachRight;
        lodash.first = head;
        mixin(
          lodash,
          (function () {
            var source = {};
            baseForOwn(lodash, function (func, methodName) {
              if (!hasOwnProperty.call(lodash.prototype, methodName)) {
                source[methodName] = func;
              }
            });
            return source;
          })(),
          { chain: false }
        );
        lodash.VERSION = VERSION;
        arrayEach(
          ["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"],
          function (methodName) {
            lodash[methodName].placeholder = lodash;
          }
        );
        arrayEach(["drop", "take"], function (methodName, index) {
          LazyWrapper.prototype[methodName] = function (n) {
            n = n === undefined$1 ? 1 : nativeMax(toInteger(n), 0);
            var result2 =
              this.__filtered__ && !index
                ? new LazyWrapper(this)
                : this.clone();
            if (result2.__filtered__) {
              result2.__takeCount__ = nativeMin(n, result2.__takeCount__);
            } else {
              result2.__views__.push({
                size: nativeMin(n, MAX_ARRAY_LENGTH),
                type: methodName + (result2.__dir__ < 0 ? "Right" : ""),
              });
            }
            return result2;
          };
          LazyWrapper.prototype[methodName + "Right"] = function (n) {
            return this.reverse()[methodName](n).reverse();
          };
        });
        arrayEach(["filter", "map", "takeWhile"], function (methodName, index) {
          var type = index + 1,
            isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
          LazyWrapper.prototype[methodName] = function (iteratee2) {
            var result2 = this.clone();
            result2.__iteratees__.push({
              iteratee: getIteratee(iteratee2, 3),
              type: type,
            });
            result2.__filtered__ = result2.__filtered__ || isFilter;
            return result2;
          };
        });
        arrayEach(["head", "last"], function (methodName, index) {
          var takeName = "take" + (index ? "Right" : "");
          LazyWrapper.prototype[methodName] = function () {
            return this[takeName](1).value()[0];
          };
        });
        arrayEach(["initial", "tail"], function (methodName, index) {
          var dropName = "drop" + (index ? "" : "Right");
          LazyWrapper.prototype[methodName] = function () {
            return this.__filtered__
              ? new LazyWrapper(this)
              : this[dropName](1);
          };
        });
        LazyWrapper.prototype.compact = function () {
          return this.filter(identity);
        };
        LazyWrapper.prototype.find = function (predicate) {
          return this.filter(predicate).head();
        };
        LazyWrapper.prototype.findLast = function (predicate) {
          return this.reverse().find(predicate);
        };
        LazyWrapper.prototype.invokeMap = baseRest(function (path, args) {
          if (typeof path == "function") {
            return new LazyWrapper(this);
          }
          return this.map(function (value) {
            return baseInvoke(value, path, args);
          });
        });
        LazyWrapper.prototype.reject = function (predicate) {
          return this.filter(negate(getIteratee(predicate)));
        };
        LazyWrapper.prototype.slice = function (start, end) {
          start = toInteger(start);
          var result2 = this;
          if (result2.__filtered__ && (start > 0 || end < 0)) {
            return new LazyWrapper(result2);
          }
          if (start < 0) {
            result2 = result2.takeRight(-start);
          } else if (start) {
            result2 = result2.drop(start);
          }
          if (end !== undefined$1) {
            end = toInteger(end);
            result2 =
              end < 0 ? result2.dropRight(-end) : result2.take(end - start);
          }
          return result2;
        };
        LazyWrapper.prototype.takeRightWhile = function (predicate) {
          return this.reverse().takeWhile(predicate).reverse();
        };
        LazyWrapper.prototype.toArray = function () {
          return this.take(MAX_ARRAY_LENGTH);
        };
        baseForOwn(LazyWrapper.prototype, function (func, methodName) {
          var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(
              methodName
            ),
            isTaker = /^(?:head|last)$/.test(methodName),
            lodashFunc =
              lodash[
                isTaker
                  ? "take" + (methodName == "last" ? "Right" : "")
                  : methodName
              ],
            retUnwrapped = isTaker || /^find/.test(methodName);
          if (!lodashFunc) {
            return;
          }
          lodash.prototype[methodName] = function () {
            var value = this.__wrapped__,
              args = isTaker ? [1] : arguments,
              isLazy = value instanceof LazyWrapper,
              iteratee2 = args[0],
              useLazy = isLazy || isArray(value);
            var interceptor = function (value2) {
              var result3 = lodashFunc.apply(lodash, arrayPush([value2], args));
              return isTaker && chainAll ? result3[0] : result3;
            };
            if (
              useLazy &&
              checkIteratee &&
              typeof iteratee2 == "function" &&
              iteratee2.length != 1
            ) {
              isLazy = useLazy = false;
            }
            var chainAll = this.__chain__,
              isHybrid = !!this.__actions__.length,
              isUnwrapped = retUnwrapped && !chainAll,
              onlyLazy = isLazy && !isHybrid;
            if (!retUnwrapped && useLazy) {
              value = onlyLazy ? value : new LazyWrapper(this);
              var result2 = func.apply(value, args);
              result2.__actions__.push({
                func: thru,
                args: [interceptor],
                thisArg: undefined$1,
              });
              return new LodashWrapper(result2, chainAll);
            }
            if (isUnwrapped && onlyLazy) {
              return func.apply(this, args);
            }
            result2 = this.thru(interceptor);
            return isUnwrapped
              ? isTaker
                ? result2.value()[0]
                : result2.value()
              : result2;
          };
        });
        arrayEach(
          ["pop", "push", "shift", "sort", "splice", "unshift"],
          function (methodName) {
            var func = arrayProto[methodName],
              chainName = /^(?:push|sort|unshift)$/.test(methodName)
                ? "tap"
                : "thru",
              retUnwrapped = /^(?:pop|shift)$/.test(methodName);
            lodash.prototype[methodName] = function () {
              var args = arguments;
              if (retUnwrapped && !this.__chain__) {
                var value = this.value();
                return func.apply(isArray(value) ? value : [], args);
              }
              return this[chainName](function (value2) {
                return func.apply(isArray(value2) ? value2 : [], args);
              });
            };
          }
        );
        baseForOwn(LazyWrapper.prototype, function (func, methodName) {
          var lodashFunc = lodash[methodName];
          if (lodashFunc) {
            var key = lodashFunc.name + "";
            if (!hasOwnProperty.call(realNames, key)) {
              realNames[key] = [];
            }
            realNames[key].push({ name: methodName, func: lodashFunc });
          }
        });
        realNames[createHybrid(undefined$1, WRAP_BIND_KEY_FLAG).name] = [
          {
            name: "wrapper",
            func: undefined$1,
          },
        ];
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;
        lodash.prototype.at = wrapperAt;
        lodash.prototype.chain = wrapperChain;
        lodash.prototype.commit = wrapperCommit;
        lodash.prototype.next = wrapperNext;
        lodash.prototype.plant = wrapperPlant;
        lodash.prototype.reverse = wrapperReverse;
        lodash.prototype.toJSON =
          lodash.prototype.valueOf =
          lodash.prototype.value =
            wrapperValue;
        lodash.prototype.first = lodash.prototype.head;
        if (symIterator) {
          lodash.prototype[symIterator] = wrapperToIterator;
        }
        return lodash;
      };
      var _ = runInContext();
      if (
        typeof define == "function" &&
        typeof define.amd == "object" &&
        define.amd
      ) {
        root._ = _;
        define(function () {
          return _;
        });
      } else if (freeModule) {
        (freeModule.exports = _)._ = _;
        freeExports._ = _;
      } else {
        root._ = _;
      }
    }.call(exports));
  },
});
const __vite__cjsImport0_lodash = require_lodash();
/*! Bundled license information:

lodash/lodash.js:
  (**
   * @license
   * Lodash <https://lodash.com/>
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)
*/

const Dropdown_vue_vue_type_style_index_0_scoped_bc79f4f9_lang = "";

const lo$1 = __vite__cjsImport0_lodash.__esModule
  ? __vite__cjsImport0_lodash.default
  : __vite__cjsImport0_lodash;

const _sfc_main$2 = {
  name: "dropdown",
  data: () => ({
    lo: lo$1,
    showMenu: false,
  }),

  props: ["rawHtml", "items", "width", "mode", "right"],

  mounted() {},

  methods: {
    toggleShow() {
      this.showMenu = !this.showMenu;
    },

    itemClicked(item) {
      this.toggleShow();
      this.$emit("chooseItem", item);
    },

    onClickAway() {
      if (!this.showMenu) return;
      this.showMenu = false;
    },
  },
};
const _hoisted_1$2 = { class: "dropdown-background" };
const _hoisted_2$2 = ["innerHTML"];
const _hoisted_3$2 = ["onClick"];

function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
  const _directive_click_away = resolveDirective("click-away");

  return (
    openBlock(),
    createElementBlock("div", _hoisted_1$2, [
      createBaseVNode(
        "button",
        {
          onClick:
            _cache[0] ||
            (_cache[0] = (...args) =>
              $options.toggleShow && $options.toggleShow(...args)),
          class: "anchor",
          style: { padding: "0", color: "#6295f9" },
          innerHTML: $props.rawHtml,
          directives: "",
        },
        null,
        8,
        _hoisted_2$2
      ),
      _ctx.showMenu
        ? withDirectives(
            (openBlock(),
            createElementBlock(
              "div",
              {
                key: 0,
                class: normalizeClass(["menu", { "menu-right": $props.right }]),
              },
              [
                (openBlock(true),
                createElementBlock(
                  Fragment,
                  null,
                  renderList($props.items, (item) => {
                    return (
                      openBlock(),
                      createElementBlock(
                        "div",
                        {
                          class: "menu-item",
                          onClick: ($event) => $options.itemClicked(item),
                        },
                        toDisplayString(_ctx.lo.get(item, "value")),
                        9,
                        _hoisted_3$2
                      )
                    );
                  }),
                  256
                )),
              ],
              2
            )),
            [[_directive_click_away, $options.onClickAway]]
          )
        : createCommentVNode("", true),
    ])
  );
}
const Dropdown = /*#__PURE__*/ _export_sfc(_sfc_main$2, [
  ["render", _sfc_render$2],
  ["__scopeId", "data-v-bc79f4f9"],
]);

// node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "node_modules/base64-js/index.js"(exports) {
    exports.byteLength = byteLength;
    exports.toByteArray = toByteArray;
    exports.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code =
      "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }
    var i;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1) validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - (validLen % 4);
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return ((validLen + placeHoldersLen) * 3) / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return ((validLen + placeHoldersLen) * 3) / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i2;
      for (i2 = 0; i2 < len2; i2 += 4) {
        tmp =
          (revLookup[b64.charCodeAt(i2)] << 18) |
          (revLookup[b64.charCodeAt(i2 + 1)] << 12) |
          (revLookup[b64.charCodeAt(i2 + 2)] << 6) |
          revLookup[b64.charCodeAt(i2 + 3)];
        arr[curByte++] = (tmp >> 16) & 255;
        arr[curByte++] = (tmp >> 8) & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp =
          (revLookup[b64.charCodeAt(i2)] << 2) |
          (revLookup[b64.charCodeAt(i2 + 1)] >> 4);
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp =
          (revLookup[b64.charCodeAt(i2)] << 10) |
          (revLookup[b64.charCodeAt(i2 + 1)] << 4) |
          (revLookup[b64.charCodeAt(i2 + 2)] >> 2);
        arr[curByte++] = (tmp >> 8) & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return (
        lookup[(num >> 18) & 63] +
        lookup[(num >> 12) & 63] +
        lookup[(num >> 6) & 63] +
        lookup[num & 63]
      );
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i2 = start; i2 < end; i2 += 3) {
        tmp =
          ((uint8[i2] << 16) & 16711680) +
          ((uint8[i2 + 1] << 8) & 65280) +
          (uint8[i2 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (
        var i2 = 0, len22 = len2 - extraBytes;
        i2 < len22;
        i2 += maxChunkLength
      ) {
        parts.push(
          encodeChunk(
            uint8,
            i2,
            i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength
          )
        );
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(lookup[tmp >> 2] + lookup[(tmp << 4) & 63] + "==");
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 10] +
            lookup[(tmp >> 4) & 63] +
            lookup[(tmp << 2) & 63] +
            "="
        );
      }
      return parts.join("");
    }
  },
});

// node_modules/ieee754/index.js
var require_ieee754 = __commonJS({
  "node_modules/ieee754/index.js"(exports) {
    exports.read = function (buffer, offset, isLE, mLen, nBytes) {
      var e, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i = isLE ? nBytes - 1 : 0;
      var d = isLE ? -1 : 1;
      var s = buffer[offset + i];
      i += d;
      e = s & ((1 << -nBits) - 1);
      s >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}
      m = e & ((1 << -nBits) - 1);
      e >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}
      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : (s ? -1 : 1) * Infinity;
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    };
    exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
      var e, m, c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i = isLE ? 0 : nBytes - 1;
      var d = isLE ? 1 : -1;
      var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }
        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }
      for (
        ;
        mLen >= 8;
        buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8
      ) {}
      e = (e << mLen) | m;
      eLen += mLen;
      for (
        ;
        eLen > 0;
        buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8
      ) {}
      buffer[offset + i - d] |= s * 128;
    };
  },
});

// node_modules/buffer/index.js
var require_buffer = __commonJS({
  "node_modules/buffer/index.js"(exports) {
    var base64 = require_base64_js();
    var ieee754 = require_ieee754();
    var customInspectSymbol =
      typeof Symbol === "function" && typeof Symbol["for"] === "function"
        ? Symbol["for"]("nodejs.util.inspect.custom")
        : null;
    exports.Buffer = Buffer;
    exports.SlowBuffer = SlowBuffer;
    exports.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 2147483647;
    exports.kMaxLength = K_MAX_LENGTH;
    Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (
      !Buffer.TYPED_ARRAY_SUPPORT &&
      typeof console !== "undefined" &&
      typeof console.error === "function"
    ) {
      console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
    }
    function typedArraySupport() {
      try {
        const arr = new Uint8Array(1);
        const proto = {
          foo: function () {
            return 42;
          },
        };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e) {
        return false;
      }
    }
    Object.defineProperty(Buffer.prototype, "parent", {
      enumerable: true,
      get: function () {
        if (!Buffer.isBuffer(this)) return void 0;
        return this.buffer;
      },
    });
    Object.defineProperty(Buffer.prototype, "offset", {
      enumerable: true,
      get: function () {
        if (!Buffer.isBuffer(this)) return void 0;
        return this.byteOffset;
      },
    });
    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError(
          'The value "' + length + '" is invalid for option "size"'
        );
      }
      const buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer.prototype);
      return buf;
    }
    function Buffer(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        }
        return allocUnsafe(arg);
      }
      return from(arg, encodingOrOffset, length);
    }
    Buffer.poolSize = 8192;
    function from(value, encodingOrOffset, length) {
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " +
            typeof value
        );
      }
      if (
        isInstance(value, ArrayBuffer) ||
        (value && isInstance(value.buffer, ArrayBuffer))
      ) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (
        typeof SharedArrayBuffer !== "undefined" &&
        (isInstance(value, SharedArrayBuffer) ||
          (value && isInstance(value.buffer, SharedArrayBuffer)))
      ) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "number") {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      }
      const valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer.from(valueOf, encodingOrOffset, length);
      }
      const b = fromObject(value);
      if (b) return b;
      if (
        typeof Symbol !== "undefined" &&
        Symbol.toPrimitive != null &&
        typeof value[Symbol.toPrimitive] === "function"
      ) {
        return Buffer.from(
          value[Symbol.toPrimitive]("string"),
          encodingOrOffset,
          length
        );
      }
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " +
          typeof value
      );
    }
    Buffer.from = function (value, encodingOrOffset, length) {
      return from(value, encodingOrOffset, length);
    };
    Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError(
          'The value "' + size + '" is invalid for option "size"'
        );
      }
    }
    function alloc(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string"
          ? createBuffer(size).fill(fill, encoding)
          : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer.alloc = function (size, fill, encoding) {
      return alloc(size, fill, encoding);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer.allocUnsafe = function (size) {
      return allocUnsafe(size);
    };
    Buffer.allocUnsafeSlow = function (size) {
      return allocUnsafe(size);
    };
    function fromString(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      const length = byteLength(string, encoding) | 0;
      let buf = createBuffer(length);
      const actual = buf.write(string, encoding);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(array) {
      const length = array.length < 0 ? 0 : checked(array.length) | 0;
      const buf = createBuffer(length);
      for (let i = 0; i < length; i += 1) {
        buf[i] = array[i] & 255;
      }
      return buf;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      let buf;
      if (byteOffset === void 0 && length === void 0) {
        buf = new Uint8Array(array);
      } else if (length === void 0) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length);
      }
      Object.setPrototypeOf(buf, Buffer.prototype);
      return buf;
    }
    function fromObject(obj) {
      if (Buffer.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError(
          "Attempt to allocate Buffer larger than maximum size: 0x" +
            K_MAX_LENGTH.toString(16) +
            " bytes"
        );
      }
      return length | 0;
    }
    function SlowBuffer(length) {
      if (+length != length) {
        length = 0;
      }
      return Buffer.alloc(+length);
    }
    Buffer.isBuffer = function isBuffer(b) {
      return b != null && b._isBuffer === true && b !== Buffer.prototype;
    };
    Buffer.compare = function compare(a, b) {
      if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
      if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);
      if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      }
      if (a === b) return 0;
      let x = a.length;
      let y = b.length;
      for (let i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }
      if (x < y) return -1;
      if (y < x) return 1;
      return 0;
    };
    Buffer.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer.concat = function concat(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer.alloc(0);
      }
      let i;
      if (length === void 0) {
        length = 0;
        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }
      const buffer = Buffer.allocUnsafe(length);
      let pos = 0;
      for (i = 0; i < list.length; ++i) {
        let buf = list[i];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer.length) {
            if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf);
            buf.copy(buffer, pos);
          } else {
            Uint8Array.prototype.set.call(buffer, buf, pos);
          }
        } else if (!Buffer.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer, pos);
        }
        pos += buf.length;
      }
      return buffer;
    };
    function byteLength(string, encoding) {
      if (Buffer.isBuffer(string)) {
        return string.length;
      }
      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== "string") {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' +
            typeof string
        );
      }
      const len = string.length;
      const mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0) return 0;
      let loweredCase = false;
      for (;;) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      let loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding) encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer.prototype._isBuffer = true;
    function swap(b, n, m) {
      const i = b[n];
      b[n] = b[m];
      b[m] = i;
    }
    Buffer.prototype.swap16 = function swap16() {
      const len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (let i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this;
    };
    Buffer.prototype.swap32 = function swap32() {
      const len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (let i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this;
    };
    Buffer.prototype.swap64 = function swap64() {
      const len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (let i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this;
    };
    Buffer.prototype.toString = function toString() {
      const length = this.length;
      if (length === 0) return "";
      if (arguments.length === 0) return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer.prototype.toLocaleString = Buffer.prototype.toString;
    Buffer.prototype.equals = function equals(b) {
      if (!Buffer.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
      if (this === b) return true;
      return Buffer.compare(this, b) === 0;
    };
    Buffer.prototype.inspect = function inspect() {
      let str = "";
      const max = exports.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max)
        .replace(/(.{2})/g, "$1 ")
        .trim();
      if (this.length > max) str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
    }
    Buffer.prototype.compare = function compare(
      target,
      start,
      end,
      thisStart,
      thisEnd
    ) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer.from(target, target.offset, target.byteLength);
      }
      if (!Buffer.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' +
            typeof target
        );
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (
        start < 0 ||
        end > target.length ||
        thisStart < 0 ||
        thisEnd > this.length
      ) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target) return 0;
      let x = thisEnd - thisStart;
      let y = end - start;
      const len = Math.min(x, y);
      const thisCopy = this.slice(thisStart, thisEnd);
      const targetCopy = target.slice(start, end);
      for (let i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break;
        }
      }
      if (x < y) return -1;
      if (y < x) return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
      if (buffer.length === 0) return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer.length - 1;
      }
      if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
      if (byteOffset >= buffer.length) {
        if (dir) return -1;
        else byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1;
      }
      if (typeof val === "string") {
        val = Buffer.from(val, encoding);
      }
      if (Buffer.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(
              buffer,
              val,
              byteOffset
            );
          }
        }
        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      let indexSize = 1;
      let arrLength = arr.length;
      let valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (
          encoding === "ucs2" ||
          encoding === "ucs-2" ||
          encoding === "utf16le" ||
          encoding === "utf-16le"
        ) {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read(buf, i2) {
        if (indexSize === 1) {
          return buf[i2];
        } else {
          return buf.readUInt16BE(i2 * indexSize);
        }
      }
      let i;
      if (dir) {
        let foundIndex = -1;
        for (i = byteOffset; i < arrLength; i++) {
          if (
            read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)
          ) {
            if (foundIndex === -1) foundIndex = i;
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1) i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength)
          byteOffset = arrLength - valLength;
        for (i = byteOffset; i >= 0; i--) {
          let found = true;
          for (let j = 0; j < valLength; j++) {
            if (read(arr, i + j) !== read(val, j)) {
              found = false;
              break;
            }
          }
          if (found) return i;
        }
      }
      return -1;
    }
    Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer.prototype.lastIndexOf = function lastIndexOf(
      val,
      byteOffset,
      encoding
    ) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf, string, offset, length) {
      offset = Number(offset) || 0;
      const remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      const strLen = string.length;
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      let i;
      for (i = 0; i < length; ++i) {
        const parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed)) return i;
        buf[offset + i] = parsed;
      }
      return i;
    }
    function utf8Write(buf, string, offset, length) {
      return blitBuffer(
        utf8ToBytes(string, buf.length - offset),
        buf,
        offset,
        length
      );
    }
    function asciiWrite(buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length);
    }
    function base64Write(buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length);
    }
    function ucs2Write(buf, string, offset, length) {
      return blitBuffer(
        utf16leToBytes(string, buf.length - offset),
        buf,
        offset,
        length
      );
    }
    Buffer.prototype.write = function write(string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === void 0) encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      const remaining = this.length - offset;
      if (length === void 0 || length > remaining) length = remaining;
      if (
        (string.length > 0 && (length < 0 || offset < 0)) ||
        offset > this.length
      ) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding) encoding = "utf8";
      let loweredCase = false;
      for (;;) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string, offset, length);
          case "base64":
            return base64Write(this, string, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0),
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      const res = [];
      let i = start;
      while (i < end) {
        const firstByte = buf[i];
        let codePoint = null;
        let bytesPerSequence =
          firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i + bytesPerSequence <= end) {
          let secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = ((firstByte & 31) << 6) | (secondByte & 63);
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint =
                  ((firstByte & 15) << 12) |
                  ((secondByte & 63) << 6) |
                  (thirdByte & 63);
                if (
                  tempCodePoint > 2047 &&
                  (tempCodePoint < 55296 || tempCodePoint > 57343)
                ) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              fourthByte = buf[i + 3];
              if (
                (secondByte & 192) === 128 &&
                (thirdByte & 192) === 128 &&
                (fourthByte & 192) === 128
              ) {
                tempCodePoint =
                  ((firstByte & 15) << 18) |
                  ((secondByte & 63) << 12) |
                  ((thirdByte & 63) << 6) |
                  (fourthByte & 63);
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(((codePoint >>> 10) & 1023) | 55296);
          codePoint = 56320 | (codePoint & 1023);
        }
        res.push(codePoint);
        i += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    var MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      const len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      let res = "";
      let i = 0;
      while (i < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i, (i += MAX_ARGUMENTS_LENGTH))
        );
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i] & 127);
      }
      return ret;
    }
    function latin1Slice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i]);
      }
      return ret;
    }
    function hexSlice(buf, start, end) {
      const len = buf.length;
      if (!start || start < 0) start = 0;
      if (!end || end < 0 || end > len) end = len;
      let out = "";
      for (let i = start; i < end; ++i) {
        out += hexSliceLookupTable[buf[i]];
      }
      return out;
    }
    function utf16leSlice(buf, start, end) {
      const bytes = buf.slice(start, end);
      let res = "";
      for (let i = 0; i < bytes.length - 1; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
      }
      return res;
    }
    Buffer.prototype.slice = function slice(start, end) {
      const len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0) start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0) end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start) end = start;
      const newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0)
        throw new RangeError("offset is not uint");
      if (offset + ext > length)
        throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE =
      function readUIntLE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) checkOffset(offset, byteLength2, this.length);
        let val = this[offset];
        let mul = 1;
        let i = 0;
        while (++i < byteLength2 && (mul *= 256)) {
          val += this[offset + i] * mul;
        }
        return val;
      };
    Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE =
      function readUIntBE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          checkOffset(offset, byteLength2, this.length);
        }
        let val = this[offset + --byteLength2];
        let mul = 1;
        while (byteLength2 > 0 && (mul *= 256)) {
          val += this[offset + --byteLength2] * mul;
        }
        return val;
      };
    Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 =
      function readUInt8(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 1, this.length);
        return this[offset];
      };
    Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE =
      function readUInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 2, this.length);
        return this[offset] | (this[offset + 1] << 8);
      };
    Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE =
      function readUInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 2, this.length);
        return (this[offset] << 8) | this[offset + 1];
      };
    Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE =
      function readUInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 4, this.length);
        return (
          (this[offset] | (this[offset + 1] << 8) | (this[offset + 2] << 16)) +
          this[offset + 3] * 16777216
        );
      };
    Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE =
      function readUInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 4, this.length);
        return (
          this[offset] * 16777216 +
          ((this[offset + 1] << 16) |
            (this[offset + 2] << 8) |
            this[offset + 3])
        );
      };
    Buffer.prototype.readBigUInt64LE = defineBigIntMethod(
      function readBigUInt64LE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const lo =
          first +
          this[++offset] * 2 ** 8 +
          this[++offset] * 2 ** 16 +
          this[++offset] * 2 ** 24;
        const hi =
          this[++offset] +
          this[++offset] * 2 ** 8 +
          this[++offset] * 2 ** 16 +
          last * 2 ** 24;
        return BigInt(lo) + (BigInt(hi) << BigInt(32));
      }
    );
    Buffer.prototype.readBigUInt64BE = defineBigIntMethod(
      function readBigUInt64BE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const hi =
          first * 2 ** 24 +
          this[++offset] * 2 ** 16 +
          this[++offset] * 2 ** 8 +
          this[++offset];
        const lo =
          this[++offset] * 2 ** 24 +
          this[++offset] * 2 ** 16 +
          this[++offset] * 2 ** 8 +
          last;
        return (BigInt(hi) << BigInt(32)) + BigInt(lo);
      }
    );
    Buffer.prototype.readIntLE = function readIntLE(
      offset,
      byteLength2,
      noAssert
    ) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      mul *= 128;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer.prototype.readIntBE = function readIntBE(
      offset,
      byteLength2,
      noAssert
    ) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      let i = byteLength2;
      let mul = 1;
      let val = this[offset + --i];
      while (i > 0 && (mul *= 256)) {
        val += this[offset + --i] * mul;
      }
      mul *= 128;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128)) return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      const val = this[offset] | (this[offset + 1] << 8);
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      const val = this[offset + 1] | (this[offset] << 8);
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return (
        this[offset] |
        (this[offset + 1] << 8) |
        (this[offset + 2] << 16) |
        (this[offset + 3] << 24)
      );
    };
    Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return (
        (this[offset] << 24) |
        (this[offset + 1] << 16) |
        (this[offset + 2] << 8) |
        this[offset + 3]
      );
    };
    Buffer.prototype.readBigInt64LE = defineBigIntMethod(
      function readBigInt64LE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const val =
          this[offset + 4] +
          this[offset + 5] * 2 ** 8 +
          this[offset + 6] * 2 ** 16 +
          (last << 24);
        return (
          (BigInt(val) << BigInt(32)) +
          BigInt(
            first +
              this[++offset] * 2 ** 8 +
              this[++offset] * 2 ** 16 +
              this[++offset] * 2 ** 24
          )
        );
      }
    );
    Buffer.prototype.readBigInt64BE = defineBigIntMethod(
      function readBigInt64BE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const val =
          (first << 24) + // Overflow
          this[++offset] * 2 ** 16 +
          this[++offset] * 2 ** 8 +
          this[++offset];
        return (
          (BigInt(val) << BigInt(32)) +
          BigInt(
            this[++offset] * 2 ** 24 +
              this[++offset] * 2 ** 16 +
              this[++offset] * 2 ** 8 +
              last
          )
        );
      }
    );
    Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4);
    };
    Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4);
    };
    Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8);
    };
    Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8);
    };
    function checkInt(buf, value, offset, ext, max, min) {
      if (!Buffer.isBuffer(buf))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min)
        throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length) throw new RangeError("Index out of range");
    }
    Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE =
      function writeUIntLE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset, byteLength2, maxBytes, 0);
        }
        let mul = 1;
        let i = 0;
        this[offset] = value & 255;
        while (++i < byteLength2 && (mul *= 256)) {
          this[offset + i] = (value / mul) & 255;
        }
        return offset + byteLength2;
      };
    Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE =
      function writeUIntBE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset, byteLength2, maxBytes, 0);
        }
        let i = byteLength2 - 1;
        let mul = 1;
        this[offset + i] = value & 255;
        while (--i >= 0 && (mul *= 256)) {
          this[offset + i] = (value / mul) & 255;
        }
        return offset + byteLength2;
      };
    Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 =
      function writeUInt8(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
        this[offset] = value & 255;
        return offset + 1;
      };
    Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE =
      function writeUInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        return offset + 2;
      };
    Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE =
      function writeUInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
        return offset + 2;
      };
    Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE =
      function writeUInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
        this[offset + 3] = value >>> 24;
        this[offset + 2] = value >>> 16;
        this[offset + 1] = value >>> 8;
        this[offset] = value & 255;
        return offset + 4;
      };
    Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE =
      function writeUInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
        return offset + 4;
      };
    function wrtBigUInt64LE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      let hi = Number((value >> BigInt(32)) & BigInt(4294967295));
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      return offset;
    }
    function wrtBigUInt64BE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset + 7] = lo;
      lo = lo >> 8;
      buf[offset + 6] = lo;
      lo = lo >> 8;
      buf[offset + 5] = lo;
      lo = lo >> 8;
      buf[offset + 4] = lo;
      let hi = Number((value >> BigInt(32)) & BigInt(4294967295));
      buf[offset + 3] = hi;
      hi = hi >> 8;
      buf[offset + 2] = hi;
      hi = hi >> 8;
      buf[offset + 1] = hi;
      hi = hi >> 8;
      buf[offset] = hi;
      return offset + 8;
    }
    Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(
      function writeBigUInt64LE(value, offset = 0) {
        return wrtBigUInt64LE(
          this,
          value,
          offset,
          BigInt(0),
          BigInt("0xffffffffffffffff")
        );
      }
    );
    Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(
      function writeBigUInt64BE(value, offset = 0) {
        return wrtBigUInt64BE(
          this,
          value,
          offset,
          BigInt(0),
          BigInt("0xffffffffffffffff")
        );
      }
    );
    Buffer.prototype.writeIntLE = function writeIntLE(
      value,
      offset,
      byteLength2,
      noAssert
    ) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i = 0;
      let mul = 1;
      let sub = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (((value / mul) >> 0) - sub) & 255;
      }
      return offset + byteLength2;
    };
    Buffer.prototype.writeIntBE = function writeIntBE(
      value,
      offset,
      byteLength2,
      noAssert
    ) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i = byteLength2 - 1;
      let mul = 1;
      let sub = 0;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (((value / mul) >> 0) - sub) & 255;
      }
      return offset + byteLength2;
    };
    Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
      if (value < 0) value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer.prototype.writeInt16LE = function writeInt16LE(
      value,
      offset,
      noAssert
    ) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer.prototype.writeInt16BE = function writeInt16BE(
      value,
      offset,
      noAssert
    ) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer.prototype.writeInt32LE = function writeInt32LE(
      value,
      offset,
      noAssert
    ) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };
    Buffer.prototype.writeInt32BE = function writeInt32BE(
      value,
      offset,
      noAssert
    ) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0) value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    Buffer.prototype.writeBigInt64LE = defineBigIntMethod(
      function writeBigInt64LE(value, offset = 0) {
        return wrtBigUInt64LE(
          this,
          value,
          offset,
          -BigInt("0x8000000000000000"),
          BigInt("0x7fffffffffffffff")
        );
      }
    );
    Buffer.prototype.writeBigInt64BE = defineBigIntMethod(
      function writeBigInt64BE(value, offset = 0) {
        return wrtBigUInt64BE(
          this,
          value,
          offset,
          -BigInt("0x8000000000000000"),
          BigInt("0x7fffffffffffffff")
        );
      }
    );
    function checkIEEE754(buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length) throw new RangeError("Index out of range");
      if (offset < 0) throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4);
      }
      ieee754.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer.prototype.writeFloatLE = function writeFloatLE(
      value,
      offset,
      noAssert
    ) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer.prototype.writeFloatBE = function writeFloatBE(
      value,
      offset,
      noAssert
    ) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8);
      }
      ieee754.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer.prototype.writeDoubleLE = function writeDoubleLE(
      value,
      offset,
      noAssert
    ) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer.prototype.writeDoubleBE = function writeDoubleBE(
      value,
      offset,
      noAssert
    ) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer.isBuffer(target))
        throw new TypeError("argument should be a Buffer");
      if (!start) start = 0;
      if (!end && end !== 0) end = this.length;
      if (targetStart >= target.length) targetStart = target.length;
      if (!targetStart) targetStart = 0;
      if (end > 0 && end < start) end = start;
      if (end === start) return 0;
      if (target.length === 0 || this.length === 0) return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("Index out of range");
      if (end < 0) throw new RangeError("sourceEnd out of bounds");
      if (end > this.length) end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      const len = end - start;
      if (
        this === target &&
        typeof Uint8Array.prototype.copyWithin === "function"
      ) {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, end),
          targetStart
        );
      }
      return len;
    };
    Buffer.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          const code = val.charCodeAt(0);
          if ((encoding === "utf8" && code < 128) || encoding === "latin1") {
            val = code;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val) val = 0;
      let i;
      if (typeof val === "number") {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        const bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
        const len = bytes.length;
        if (len === 0) {
          throw new TypeError(
            'The value "' + val + '" is invalid for argument "value"'
          );
        }
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }
      return this;
    };
    var errors = {};
    function E(sym, getMessage, Base) {
      errors[sym] = class NodeError extends Base {
        constructor() {
          super();
          Object.defineProperty(this, "message", {
            value: getMessage.apply(this, arguments),
            writable: true,
            configurable: true,
          });
          this.name = `${this.name} [${sym}]`;
          this.stack;
          delete this.name;
        }
        get code() {
          return sym;
        }
        set code(value) {
          Object.defineProperty(this, "code", {
            configurable: true,
            enumerable: true,
            value,
            writable: true,
          });
        }
        toString() {
          return `${this.name} [${sym}]: ${this.message}`;
        }
      };
    }
    E(
      "ERR_BUFFER_OUT_OF_BOUNDS",
      function (name) {
        if (name) {
          return `${name} is outside of buffer bounds`;
        }
        return "Attempt to access memory outside buffer bounds";
      },
      RangeError
    );
    E(
      "ERR_INVALID_ARG_TYPE",
      function (name, actual) {
        return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
      },
      TypeError
    );
    E(
      "ERR_OUT_OF_RANGE",
      function (str, range, input) {
        let msg = `The value of "${str}" is out of range.`;
        let received = input;
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
          received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
          received = String(input);
          if (
            input > BigInt(2) ** BigInt(32) ||
            input < -(BigInt(2) ** BigInt(32))
          ) {
            received = addNumericalSeparator(received);
          }
          received += "n";
        }
        msg += ` It must be ${range}. Received ${received}`;
        return msg;
      },
      RangeError
    );
    function addNumericalSeparator(val) {
      let res = "";
      let i = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i >= start + 4; i -= 3) {
        res = `_${val.slice(i - 3, i)}${res}`;
      }
      return `${val.slice(0, i)}${res}`;
    }
    function checkBounds(buf, offset, byteLength2) {
      validateNumber(offset, "offset");
      if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
        boundsError(offset, buf.length - (byteLength2 + 1));
      }
    }
    function checkIntBI(value, min, max, buf, offset, byteLength2) {
      if (value > max || value < min) {
        const n = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength2 > 3) {
          if (min === 0 || min === BigInt(0)) {
            range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
          } else {
            range = `>= -(2${n} ** ${
              (byteLength2 + 1) * 8 - 1
            }${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;
          }
        } else {
          range = `>= ${min}${n} and <= ${max}${n}`;
        }
        throw new errors.ERR_OUT_OF_RANGE("value", range, value);
      }
      checkBounds(buf, offset, byteLength2);
    }
    function validateNumber(value, name) {
      if (typeof value !== "number") {
        throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
      }
    }
    function boundsError(value, length, type) {
      if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new errors.ERR_OUT_OF_RANGE(
          type || "offset",
          "an integer",
          value
        );
      }
      if (length < 0) {
        throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
      }
      throw new errors.ERR_OUT_OF_RANGE(
        type || "offset",
        `>= ${type ? 1 : 0} and <= ${length}`,
        value
      );
    }
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2) return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes(string, units) {
      units = units || Infinity;
      let codePoint;
      const length = string.length;
      let leadSurrogate = null;
      const bytes = [];
      for (let i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              continue;
            } else if (i + 1 === length) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint =
            (((leadSurrogate - 55296) << 10) | (codePoint - 56320)) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0) break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0) break;
          bytes.push((codePoint >> 6) | 192, (codePoint & 63) | 128);
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0) break;
          bytes.push(
            (codePoint >> 12) | 224,
            ((codePoint >> 6) & 63) | 128,
            (codePoint & 63) | 128
          );
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0) break;
          bytes.push(
            (codePoint >> 18) | 240,
            ((codePoint >> 12) & 63) | 128,
            ((codePoint >> 6) & 63) | 128,
            (codePoint & 63) | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        byteArray.push(str.charCodeAt(i) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      let c, hi, lo;
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0) break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }
    function blitBuffer(src, dst, offset, length) {
      let i;
      for (i = 0; i < length; ++i) {
        if (i + offset >= dst.length || i >= src.length) break;
        dst[i + offset] = src[i];
      }
      return i;
    }
    function isInstance(obj, type) {
      return (
        obj instanceof type ||
        (obj != null &&
          obj.constructor != null &&
          obj.constructor.name != null &&
          obj.constructor.name === type.name)
      );
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    var hexSliceLookupTable = (function () {
      const alphabet = "0123456789abcdef";
      const table = new Array(256);
      for (let i = 0; i < 16; ++i) {
        const i16 = i * 16;
        for (let j = 0; j < 16; ++j) {
          table[i16 + j] = alphabet[i] + alphabet[j];
        }
      }
      return table;
    })();
    function defineBigIntMethod(fn) {
      return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
    }
    function BufferBigIntNotDefined() {
      throw new Error("BigInt not supported");
    }
  },
});
/*! Bundled license information:

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)
*/

// node_modules/@near-js/crypto/lib/constants.js
var require_constants = __commonJS({
  "node_modules/@near-js/crypto/lib/constants.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.KeyType = void 0;
    (function (KeyType2) {
      KeyType2[(KeyType2["ED25519"] = 0)] = "ED25519";
    })(exports2.KeyType || (exports2.KeyType = {}));
  },
});

// node_modules/@near-js/crypto/lib/key_pair_base.js
var require_key_pair_base = __commonJS({
  "node_modules/@near-js/crypto/lib/key_pair_base.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.KeyPairBase = void 0;
    var KeyPairBase = class {};
    exports2.KeyPairBase = KeyPairBase;
  },
});

// browser-external:buffer
var require_buffer2 = __commonJS({
  "browser-external:buffer"(exports2, module2) {
    module2.exports = {};
  },
});

// node_modules/bn.js/lib/bn.js
var require_bn = __commonJS({
  "node_modules/bn.js/lib/bn.js"(exports2, module2) {
    (function (module3, exports3) {
      function assert(val, msg) {
        if (!val) throw new Error(msg || "Assertion failed");
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function () {};
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN(number, base, endian) {
        if (BN.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base === "le" || base === "be") {
            endian = base;
            base = 10;
          }
          this._init(number || 0, base || 10, endian || "be");
        }
      }
      if (typeof module3 === "object") {
        module3.exports = BN;
      } else {
        exports3.BN = BN;
      }
      BN.BN = BN;
      BN.wordSize = 26;
      var Buffer2;
      try {
        if (
          typeof window !== "undefined" &&
          typeof window.Buffer !== "undefined"
        ) {
          Buffer2 = window.Buffer;
        } else {
          Buffer2 = require_buffer2().Buffer;
        }
      } catch (e) {}
      BN.isBN = function isBN(num) {
        if (num instanceof BN) {
          return true;
        }
        return (
          num !== null &&
          typeof num === "object" &&
          num.constructor.wordSize === BN.wordSize &&
          Array.isArray(num.words)
        );
      };
      BN.max = function max(left, right) {
        if (left.cmp(right) > 0) return left;
        return right;
      };
      BN.min = function min(left, right) {
        if (left.cmp(right) < 0) return left;
        return right;
      };
      BN.prototype._init = function init(number, base, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base, endian);
        }
        if (base === "hex") {
          base = 16;
        }
        assert(base === (base | 0) && base >= 2 && base <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number.length) {
          if (base === 16) {
            this._parseHex(number, start, endian);
          } else {
            this._parseBase(number, base, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base, endian);
            }
          }
        }
      };
      BN.prototype._initNumber = function _initNumber(number, base, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [number & 67108863, (number / 67108864) & 67108863];
          this.length = 2;
        } else {
          assert(number < 9007199254740992);
          this.words = [number & 67108863, (number / 67108864) & 67108863, 1];
          this.length = 3;
        }
        if (endian !== "le") return;
        this._initArray(this.toArray(), base, endian);
      };
      BN.prototype._initArray = function _initArray(number, base, endian) {
        assert(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var j, w;
        var off = 0;
        if (endian === "be") {
          for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
            w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
            this.words[j] |= (w << off) & 67108863;
            this.words[j + 1] = (w >>> (26 - off)) & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        } else if (endian === "le") {
          for (i = 0, j = 0; i < number.length; i += 3) {
            w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
            this.words[j] |= (w << off) & 67108863;
            this.words[j + 1] = (w >>> (26 - off)) & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        }
        return this._strip();
      };
      function parseHex4Bits(string, index) {
        var c = string.charCodeAt(index);
        if (c >= 48 && c <= 57) {
          return c - 48;
        } else if (c >= 65 && c <= 70) {
          return c - 55;
        } else if (c >= 97 && c <= 102) {
          return c - 87;
        } else {
          assert(false, "Invalid character in " + string);
        }
      }
      function parseHexByte(string, lowerBound, index) {
        var r = parseHex4Bits(string, index);
        if (index - 1 >= lowerBound) {
          r |= parseHex4Bits(string, index - 1) << 4;
        }
        return r;
      }
      BN.prototype._parseHex = function _parseHex(number, start, endian) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var off = 0;
        var j = 0;
        var w;
        if (endian === "be") {
          for (i = number.length - 1; i >= start; i -= 2) {
            w = parseHexByte(number, start, i) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        } else {
          var parseLength = number.length - start;
          for (
            i = parseLength % 2 === 0 ? start + 1 : start;
            i < number.length;
            i += 2
          ) {
            w = parseHexByte(number, start, i) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        }
        this._strip();
      };
      function parseBase(str, start, end, mul) {
        var r = 0;
        var b = 0;
        var len = Math.min(str.length, end);
        for (var i = start; i < len; i++) {
          var c = str.charCodeAt(i) - 48;
          r *= mul;
          if (c >= 49) {
            b = c - 49 + 10;
          } else if (c >= 17) {
            b = c - 17 + 10;
          } else {
            b = c;
          }
          assert(c >= 0 && b < mul, "Invalid character");
          r += b;
        }
        return r;
      }
      BN.prototype._parseBase = function _parseBase(number, base, start) {
        this.words = [0];
        this.length = 1;
        for (
          var limbLen = 0, limbPow = 1;
          limbPow <= 67108863;
          limbPow *= base
        ) {
          limbLen++;
        }
        limbLen--;
        limbPow = (limbPow / base) | 0;
        var total = number.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for (var i = start; i < end; i += limbLen) {
          word = parseBase(number, i, i + limbLen, base);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number, i, number.length, base);
          for (i = 0; i < mod; i++) {
            pow *= base;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this._strip();
      };
      BN.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          dest.words[i] = this.words[i];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      function move(dest, src) {
        dest.words = src.words;
        dest.length = src.length;
        dest.negative = src.negative;
        dest.red = src.red;
      }
      BN.prototype._move = function _move(dest) {
        move(dest, this);
      };
      BN.prototype.clone = function clone() {
        var r = new BN(null);
        this.copy(r);
        return r;
      };
      BN.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN.prototype._strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
        try {
          BN.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect;
        } catch (e) {
          BN.prototype.inspect = inspect;
        }
      } else {
        BN.prototype.inspect = inspect;
      }
      function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000",
      ];
      var groupSizes = [
        0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5,
        5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
      ];
      var groupBases = [
        0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607,
        16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536,
        11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101,
        5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368,
        20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875,
        60466176,
      ];
      BN.prototype.toString = function toString(base, padding) {
        base = base || 10;
        padding = padding | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i = 0; i < this.length; i++) {
            var w = this.words[i];
            var word = (((w << off) | carry) & 16777215).toString(16);
            carry = (w >>> (24 - off)) & 16777215;
            off += 2;
            if (off >= 26) {
              off -= 26;
              i--;
            }
            if (carry !== 0 || i !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
          var groupSize = groupSizes[base];
          var groupBase = groupBases[base];
          out = "";
          var c = this.clone();
          c.negative = 0;
          while (!c.isZero()) {
            var r = c.modrn(groupBase).toString(base);
            c = c.idivn(groupBase);
            if (!c.isZero()) {
              out = zeros[groupSize - r.length] + r + out;
            } else {
              out = r + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert(false, "Base should be between 2 and 36");
      };
      BN.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN.prototype.toJSON = function toJSON() {
        return this.toString(16, 2);
      };
      if (Buffer2) {
        BN.prototype.toBuffer = function toBuffer(endian, length) {
          return this.toArrayLike(Buffer2, endian, length);
        };
      }
      BN.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      var allocate = function allocate2(ArrayType, size) {
        if (ArrayType.allocUnsafe) {
          return ArrayType.allocUnsafe(size);
        }
        return new ArrayType(size);
      };
      BN.prototype.toArrayLike = function toArrayLike(
        ArrayType,
        endian,
        length
      ) {
        this._strip();
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert(
          byteLength <= reqLength,
          "byte array longer than desired length"
        );
        assert(reqLength > 0, "Requested array length <= 0");
        var res = allocate(ArrayType, reqLength);
        var postfix = endian === "le" ? "LE" : "BE";
        this["_toArrayLike" + postfix](res, byteLength);
        return res;
      };
      BN.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength) {
        var position = 0;
        var carry = 0;
        for (var i = 0, shift = 0; i < this.length; i++) {
          var word = (this.words[i] << shift) | carry;
          res[position++] = word & 255;
          if (position < res.length) {
            res[position++] = (word >> 8) & 255;
          }
          if (position < res.length) {
            res[position++] = (word >> 16) & 255;
          }
          if (shift === 6) {
            if (position < res.length) {
              res[position++] = (word >> 24) & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position < res.length) {
          res[position++] = carry;
          while (position < res.length) {
            res[position++] = 0;
          }
        }
      };
      BN.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength) {
        var position = res.length - 1;
        var carry = 0;
        for (var i = 0, shift = 0; i < this.length; i++) {
          var word = (this.words[i] << shift) | carry;
          res[position--] = word & 255;
          if (position >= 0) {
            res[position--] = (word >> 8) & 255;
          }
          if (position >= 0) {
            res[position--] = (word >> 16) & 255;
          }
          if (shift === 6) {
            if (position >= 0) {
              res[position--] = (word >> 24) & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position >= 0) {
          res[position--] = carry;
          while (position >= 0) {
            res[position--] = 0;
          }
        }
      };
      if (Math.clz32) {
        BN.prototype._countBits = function _countBits(w) {
          return 32 - Math.clz32(w);
        };
      } else {
        BN.prototype._countBits = function _countBits(w) {
          var t = w;
          var r = 0;
          if (t >= 4096) {
            r += 13;
            t >>>= 13;
          }
          if (t >= 64) {
            r += 7;
            t >>>= 7;
          }
          if (t >= 8) {
            r += 4;
            t >>>= 4;
          }
          if (t >= 2) {
            r += 2;
            t >>>= 2;
          }
          return r + t;
        };
      }
      BN.prototype._zeroBits = function _zeroBits(w) {
        if (w === 0) return 26;
        var t = w;
        var r = 0;
        if ((t & 8191) === 0) {
          r += 13;
          t >>>= 13;
        }
        if ((t & 127) === 0) {
          r += 7;
          t >>>= 7;
        }
        if ((t & 15) === 0) {
          r += 4;
          t >>>= 4;
        }
        if ((t & 3) === 0) {
          r += 2;
          t >>>= 2;
        }
        if ((t & 1) === 0) {
          r++;
        }
        return r;
      };
      BN.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1];
        var hi = this._countBits(w);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w = new Array(num.bitLength());
        for (var bit = 0; bit < w.length; bit++) {
          var off = (bit / 26) | 0;
          var wbit = bit % 26;
          w[bit] = (num.words[off] >>> wbit) & 1;
        }
        return w;
      }
      BN.prototype.zeroBits = function zeroBits() {
        if (this.isZero()) return 0;
        var r = 0;
        for (var i = 0; i < this.length; i++) {
          var b = this._zeroBits(this.words[i]);
          r += b;
          if (b !== 26) break;
        }
        return r;
      };
      BN.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i = 0; i < num.length; i++) {
          this.words[i] = this.words[i] | num.words[i];
        }
        return this._strip();
      };
      BN.prototype.ior = function ior(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN.prototype.or = function or(num) {
        if (this.length > num.length) return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN.prototype.uor = function uor(num) {
        if (this.length > num.length) return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN.prototype.iuand = function iuand(num) {
        var b;
        if (this.length > num.length) {
          b = num;
        } else {
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = this.words[i] & num.words[i];
        }
        this.length = b.length;
        return this._strip();
      };
      BN.prototype.iand = function iand(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN.prototype.and = function and(num) {
        if (this.length > num.length) return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN.prototype.uand = function uand(num) {
        if (this.length > num.length) return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN.prototype.iuxor = function iuxor(num) {
        var a;
        var b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = a.words[i] ^ b.words[i];
        }
        if (this !== a) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = a.length;
        return this._strip();
      };
      BN.prototype.ixor = function ixor(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN.prototype.xor = function xor(num) {
        if (this.length > num.length) return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN.prototype.uxor = function uxor(num) {
        if (this.length > num.length) return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN.prototype.inotn = function inotn(width) {
        assert(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i = 0; i < bytesNeeded; i++) {
          this.words[i] = ~this.words[i] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i] = ~this.words[i] & (67108863 >> (26 - bitsLeft));
        }
        return this._strip();
      };
      BN.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN.prototype.setn = function setn(bit, val) {
        assert(typeof bit === "number" && bit >= 0);
        var off = (bit / 26) | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | (1 << wbit);
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this._strip();
      };
      BN.prototype.iadd = function iadd(num) {
        var r;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r = this.isub(num);
          num.negative = 1;
          return r._normSign();
        }
        var a, b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        this.length = a.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        return this;
      };
      BN.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length) return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r = this.iadd(num);
          num.negative = 1;
          return r._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a, b;
        if (cmp > 0) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        if (carry === 0 && i < a.length && a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = Math.max(this.length, i);
        if (a !== this) {
          this.negative = 1;
        }
        return this._strip();
      };
      BN.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = (self2.length + num.length) | 0;
        out.length = len;
        len = (len - 1) | 0;
        var a = self2.words[0] | 0;
        var b = num.words[0] | 0;
        var r = a * b;
        var lo = r & 67108863;
        var carry = (r / 67108864) | 0;
        out.words[0] = lo;
        for (var k = 1; k < len; k++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = (k - j) | 0;
            a = self2.words[i] | 0;
            b = num.words[j] | 0;
            r = a * b + rword;
            ncarry += (r / 67108864) | 0;
            rword = r & 67108863;
          }
          out.words[k] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k] = carry | 0;
        } else {
          out.length--;
        }
        return out._strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a = self2.words;
        var b = num.words;
        var o = out.words;
        var c = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a2 = a[2] | 0;
        var al2 = a2 & 8191;
        var ah2 = a2 >>> 13;
        var a3 = a[3] | 0;
        var al3 = a3 & 8191;
        var ah3 = a3 >>> 13;
        var a4 = a[4] | 0;
        var al4 = a4 & 8191;
        var ah4 = a4 >>> 13;
        var a5 = a[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b2 = b[2] | 0;
        var bl2 = b2 & 8191;
        var bh2 = b2 >>> 13;
        var b3 = b[3] | 0;
        var bl3 = b3 & 8191;
        var bh3 = b3 >>> 13;
        var b4 = b[4] | 0;
        var bl4 = b4 & 8191;
        var bh4 = b4 >>> 13;
        var b5 = b[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = (mid + Math.imul(ah0, bl0)) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (((c + lo) | 0) + ((mid & 8191) << 13)) | 0;
        c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = (mid + Math.imul(ah1, bl0)) | 0;
        hi = Math.imul(ah1, bh0);
        lo = (lo + Math.imul(al0, bl1)) | 0;
        mid = (mid + Math.imul(al0, bh1)) | 0;
        mid = (mid + Math.imul(ah0, bl1)) | 0;
        hi = (hi + Math.imul(ah0, bh1)) | 0;
        var w1 = (((c + lo) | 0) + ((mid & 8191) << 13)) | 0;
        c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = (mid + Math.imul(ah2, bl0)) | 0;
        hi = Math.imul(ah2, bh0);
        lo = (lo + Math.imul(al1, bl1)) | 0;
        mid = (mid + Math.imul(al1, bh1)) | 0;
        mid = (mid + Math.imul(ah1, bl1)) | 0;
        hi = (hi + Math.imul(ah1, bh1)) | 0;
        lo = (lo + Math.imul(al0, bl2)) | 0;
        mid = (mid + Math.imul(al0, bh2)) | 0;
        mid = (mid + Math.imul(ah0, bl2)) | 0;
        hi = (hi + Math.imul(ah0, bh2)) | 0;
        var w2 = (((c + lo) | 0) + ((mid & 8191) << 13)) | 0;
        c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
        w2 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = (mid + Math.imul(ah3, bl0)) | 0;
        hi = Math.imul(ah3, bh0);
        lo = (lo + Math.imul(al2, bl1)) | 0;
        mid = (mid + Math.imul(al2, bh1)) | 0;
        mid = (mid + Math.imul(ah2, bl1)) | 0;
        hi = (hi + Math.imul(ah2, bh1)) | 0;
        lo = (lo + Math.imul(al1, bl2)) | 0;
        mid = (mid + Math.imul(al1, bh2)) | 0;
        mid = (mid + Math.imul(ah1, bl2)) | 0;
        hi = (hi + Math.imul(ah1, bh2)) | 0;
        lo = (lo + Math.imul(al0, bl3)) | 0;
        mid = (mid + Math.imul(al0, bh3)) | 0;
        mid = (mid + Math.imul(ah0, bl3)) | 0;
        hi = (hi + Math.imul(ah0, bh3)) | 0;
        var w3 = (((c + lo) | 0) + ((mid & 8191) << 13)) | 0;
        c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
        w3 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = (mid + Math.imul(ah4, bl0)) | 0;
        hi = Math.imul(ah4, bh0);
        lo = (lo + Math.imul(al3, bl1)) | 0;
        mid = (mid + Math.imul(al3, bh1)) | 0;
        mid = (mid + Math.imul(ah3, bl1)) | 0;
        hi = (hi + Math.imul(ah3, bh1)) | 0;
        lo = (lo + Math.imul(al2, bl2)) | 0;
        mid = (mid + Math.imul(al2, bh2)) | 0;
        mid = (mid + Math.imul(ah2, bl2)) | 0;
        hi = (hi + Math.imul(ah2, bh2)) | 0;
        lo = (lo + Math.imul(al1, bl3)) | 0;
        mid = (mid + Math.imul(al1, bh3)) | 0;
        mid = (mid + Math.imul(ah1, bl3)) | 0;
        hi = (hi + Math.imul(ah1, bh3)) | 0;
        lo = (lo + Math.imul(al0, bl4)) | 0;
        mid = (mid + Math.imul(al0, bh4)) | 0;
        mid = (mid + Math.imul(ah0, bl4)) | 0;
        hi = (hi + Math.imul(ah0, bh4)) | 0;
        var w4 = (((c + lo) | 0) + ((mid & 8191) << 13)) | 0;
        c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
        w4 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = (mid + Math.imul(ah5, bl0)) | 0;
        hi = Math.imul(ah5, bh0);
        lo = (lo + Math.imul(al4, bl1)) | 0;
        mid = (mid + Math.imul(al4, bh1)) | 0;
        mid = (mid + Math.imul(ah4, bl1)) | 0;
        hi = (hi + Math.imul(ah4, bh1)) | 0;
        lo = (lo + Math.imul(al3, bl2)) | 0;
        mid = (mid + Math.imul(al3, bh2)) | 0;
        mid = (mid + Math.imul(ah3, bl2)) | 0;
        hi = (hi + Math.imul(ah3, bh2)) | 0;
        lo = (lo + Math.imul(al2, bl3)) | 0;
        mid = (mid + Math.imul(al2, bh3)) | 0;
        mid = (mid + Math.imul(ah2, bl3)) | 0;
        hi = (hi + Math.imul(ah2, bh3)) | 0;
        lo = (lo + Math.imul(al1, bl4)) | 0;
        mid = (mid + Math.imul(al1, bh4)) | 0;
        mid = (mid + Math.imul(ah1, bl4)) | 0;
        hi = (hi + Math.imul(ah1, bh4)) | 0;
        lo = (lo + Math.imul(al0, bl5)) | 0;
        mid = (mid + Math.imul(al0, bh5)) | 0;
        mid = (mid + Math.imul(ah0, bl5)) | 0;
        hi = (hi + Math.imul(ah0, bh5)) | 0;
        var w5 = (((c + lo) | 0) + ((mid & 8191) << 13)) | 0;
        c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
        w5 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = (mid + Math.imul(ah6, bl0)) | 0;
        hi = Math.imul(ah6, bh0);
        lo = (lo + Math.imul(al5, bl1)) | 0;
        mid = (mid + Math.imul(al5, bh1)) | 0;
        mid = (mid + Math.imul(ah5, bl1)) | 0;
        hi = (hi + Math.imul(ah5, bh1)) | 0;
        lo = (lo + Math.imul(al4, bl2)) | 0;
        mid = (mid + Math.imul(al4, bh2)) | 0;
        mid = (mid + Math.imul(ah4, bl2)) | 0;
        hi = (hi + Math.imul(ah4, bh2)) | 0;
        lo = (lo + Math.imul(al3, bl3)) | 0;
        mid = (mid + Math.imul(al3, bh3)) | 0;
        mid = (mid + Math.imul(ah3, bl3)) | 0;
        hi = (hi + Math.imul(ah3, bh3)) | 0;
        lo = (lo + Math.imul(al2, bl4)) | 0;
        mid = (mid + Math.imul(al2, bh4)) | 0;
        mid = (mid + Math.imul(ah2, bl4)) | 0;
        hi = (hi + Math.imul(ah2, bh4)) | 0;
        lo = (lo + Math.imul(al1, bl5)) | 0;
        mid = (mid + Math.imul(al1, bh5)) | 0;
        mid = (mid + Math.imul(ah1, bl5)) | 0;
        hi = (hi + Math.imul(ah1, bh5)) | 0;
        lo = (lo + Math.imul(al0, bl6)) | 0;
        mid = (mid + Math.imul(al0, bh6)) | 0;
        mid = (mid + Math.imul(ah0, bl6)) | 0;
        hi = (hi + Math.imul(ah0, bh6)) | 0;
        var w6 = (((c + lo) | 0) + ((mid & 8191) << 13)) | 0;
        c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = (mid + Math.imul(ah7, bl0)) | 0;
        hi = Math.imul(ah7, bh0);
        lo = (lo + Math.imul(al6, bl1)) | 0;
        mid = (mid + Math.imul(al6, bh1)) | 0;
        mid = (mid + Math.imul(ah6, bl1)) | 0;
        hi = (hi + Math.imul(ah6, bh1)) | 0;
        lo = (lo + Math.imul(al5, bl2)) | 0;
        mid = (mid + Math.imul(al5, bh2)) | 0;
        mid = (mid + Math.imul(ah5, bl2)) | 0;
        hi = (hi + Math.imul(ah5, bh2)) | 0;
        lo = (lo + Math.imul(al4, bl3)) | 0;
        mid = (mid + Math.imul(al4, bh3)) | 0;
        mid = (mid + Math.imul(ah4, bl3)) | 0;
        hi = (hi + Math.imul(ah4, bh3)) | 0;
        lo = (lo + Math.imul(al3, bl4)) | 0;
        mid = (mid + Math.imul(al3, bh4)) | 0;
        mid = (mid + Math.imul(ah3, bl4)) | 0;
        hi = (hi + Math.imul(ah3, bh4)) | 0;
        lo = (lo + Math.imul(al2, bl5)) | 0;
        mid = (mid + Math.imul(al2, bh5)) | 0;
        mid = (mid + Math.imul(ah2, bl5)) | 0;
        hi = (hi + Math.imul(ah2, bh5)) | 0;
        lo = (lo + Math.imul(al1, bl6)) | 0;
        mid = (mid + Math.imul(al1, bh6)) | 0;
        mid = (mid + Math.imul(ah1, bl6)) | 0;
        hi = (hi + Math.imul(ah1, bh6)) | 0;
        lo = (lo + Math.imul(al0, bl7)) | 0;
        mid = (mid + Math.imul(al0, bh7)) | 0;
        mid = (mid + Math.imul(ah0, bl7)) | 0;
        hi = (hi + Math.imul(ah0, bh7)) | 0;
        var w7 = (((c + lo) | 0) + ((mid & 8191) << 13)) | 0;
        c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = (mid + Math.imul(ah8, bl0)) | 0;
        hi = Math.imul(ah8, bh0);
        lo = (lo + Math.imul(al7, bl1)) | 0;
        mid = (mid + Math.imul(al7, bh1)) | 0;
        mid = (mid + Math.imul(ah7, bl1)) | 0;
        hi = (hi + Math.imul(ah7, bh1)) | 0;
        lo = (lo + Math.imul(al6, bl2)) | 0;
        mid = (mid + Math.imul(al6, bh2)) | 0;
        mid = (mid + Math.imul(ah6, bl2)) | 0;
        hi = (hi + Math.imul(ah6, bh2)) | 0;
        lo = (lo + Math.imul(al5, bl3)) | 0;
        mid = (mid + Math.imul(al5, bh3)) | 0;
        mid = (mid + Math.imul(ah5, bl3)) | 0;
        hi = (hi + Math.imul(ah5, bh3)) | 0;
        lo = (lo + Math.imul(al4, bl4)) | 0;
        mid = (mid + Math.imul(al4, bh4)) | 0;
        mid = (mid + Math.imul(ah4, bl4)) | 0;
        hi = (hi + Math.imul(ah4, bh4)) | 0;
        lo = (lo + Math.imul(al3, bl5)) | 0;
        mid = (mid + Math.imul(al3, bh5)) | 0;
        mid = (mid + Math.imul(ah3, bl5)) | 0;
        hi = (hi + Math.imul(ah3, bh5)) | 0;
        lo = (lo + Math.imul(al2, bl6)) | 0;
        mid = (mid + Math.imul(al2, bh6)) | 0;
        mid = (mid + Math.imul(ah2, bl6)) | 0;
        hi = (hi + Math.imul(ah2, bh6)) | 0;
        lo = (lo + Math.imul(al1, bl7)) | 0;
        mid = (mid + Math.imul(al1, bh7)) | 0;
        mid = (mid + Math.imul(ah1, bl7)) | 0;
        hi = (hi + Math.imul(ah1, bh7)) | 0;
        lo = (lo + Math.imul(al0, bl8)) | 0;
        mid = (mid + Math.imul(al0, bh8)) | 0;
        mid = (mid + Math.imul(ah0, bl8)) | 0;
        hi = (hi + Math.imul(ah0, bh8)) | 0;
        var w8 = (((c + lo) | 0) + ((mid & 8191) << 13)) | 0;
        c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = (mid + Math.imul(ah9, bl0)) | 0;
        hi = Math.imul(ah9, bh0);
        lo = (lo + Math.imul(al8, bl1)) | 0;
        mid = (mid + Math.imul(al8, bh1)) | 0;
        mid = (mid + Math.imul(ah8, bl1)) | 0;
        hi = (hi + Math.imul(ah8, bh1)) | 0;
        lo = (lo + Math.imul(al7, bl2)) | 0;
        mid = (mid + Math.imul(al7, bh2)) | 0;
        mid = (mid + Math.imul(ah7, bl2)) | 0;
        hi = (hi + Math.imul(ah7, bh2)) | 0;
        lo = (lo + Math.imul(al6, bl3)) | 0;
        mid = (mid + Math.imul(al6, bh3)) | 0;
        mid = (mid + Math.imul(ah6, bl3)) | 0;
        hi = (hi + Math.imul(ah6, bh3)) | 0;
        lo = (lo + Math.imul(al5, bl4)) | 0;
        mid = (mid + Math.imul(al5, bh4)) | 0;
        mid = (mid + Math.imul(ah5, bl4)) | 0;
        hi = (hi + Math.imul(ah5, bh4)) | 0;
        lo = (lo + Math.imul(al4, bl5)) | 0;
        mid = (mid + Math.imul(al4, bh5)) | 0;
        mid = (mid + Math.imul(ah4, bl5)) | 0;
        hi = (hi + Math.imul(ah4, bh5)) | 0;
        lo = (lo + Math.imul(al3, bl6)) | 0;
        mid = (mid + Math.imul(al3, bh6)) | 0;
        mid = (mid + Math.imul(ah3, bl6)) | 0;
        hi = (hi + Math.imul(ah3, bh6)) | 0;
        lo = (lo + Math.imul(al2, bl7)) | 0;
        mid = (mid + Math.imul(al2, bh7)) | 0;
        mid = (mid + Math.imul(ah2, bl7)) | 0;
        hi = (hi + Math.imul(ah2, bh7)) | 0;
        lo = (lo + Math.imul(al1, bl8)) | 0;
        mid = (mid + Math.imul(al1, bh8)) | 0;
        mid = (mid + Math.imul(ah1, bl8)) | 0;
        hi = (hi + Math.imul(ah1, bh8)) | 0;
        lo = (lo + Math.imul(al0, bl9)) | 0;
        mid = (mid + Math.imul(al0, bh9)) | 0;
        mid = (mid + Math.imul(ah0, bl9)) | 0;
        hi = (hi + Math.imul(ah0, bh9)) | 0;
        var w9 = (((c + lo) | 0) + ((mid & 8191) << 13)) | 0;
        c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = (mid + Math.imul(ah9, bl1)) | 0;
        hi = Math.imul(ah9, bh1);
        lo = (lo + Math.imul(al8, bl2)) | 0;
        mid = (mid + Math.imul(al8, bh2)) | 0;
        mid = (mid + Math.imul(ah8, bl2)) | 0;
        hi = (hi + Math.imul(ah8, bh2)) | 0;
        lo = (lo + Math.imul(al7, bl3)) | 0;
        mid = (mid + Math.imul(al7, bh3)) | 0;
        mid = (mid + Math.imul(ah7, bl3)) | 0;
        hi = (hi + Math.imul(ah7, bh3)) | 0;
        lo = (lo + Math.imul(al6, bl4)) | 0;
        mid = (mid + Math.imul(al6, bh4)) | 0;
        mid = (mid + Math.imul(ah6, bl4)) | 0;
        hi = (hi + Math.imul(ah6, bh4)) | 0;
        lo = (lo + Math.imul(al5, bl5)) | 0;
        mid = (mid + Math.imul(al5, bh5)) | 0;
        mid = (mid + Math.imul(ah5, bl5)) | 0;
        hi = (hi + Math.imul(ah5, bh5)) | 0;
        lo = (lo + Math.imul(al4, bl6)) | 0;
        mid = (mid + Math.imul(al4, bh6)) | 0;
        mid = (mid + Math.imul(ah4, bl6)) | 0;
        hi = (hi + Math.imul(ah4, bh6)) | 0;
        lo = (lo + Math.imul(al3, bl7)) | 0;
        mid = (mid + Math.imul(al3, bh7)) | 0;
        mid = (mid + Math.imul(ah3, bl7)) | 0;
        hi = (hi + Math.imul(ah3, bh7)) | 0;
        lo = (lo + Math.imul(al2, bl8)) | 0;
        mid = (mid + Math.imul(al2, bh8)) | 0;
        mid = (mid + Math.imul(ah2, bl8)) | 0;
        hi = (hi + Math.imul(ah2, bh8)) | 0;
        lo = (lo + Math.imul(al1, bl9)) | 0;
        mid = (mid + Math.imul(al1, bh9)) | 0;
        mid = (mid + Math.imul(ah1, bl9)) | 0;
        hi = (hi + Math.imul(ah1, bh9)) | 0;
        var w10 = (((c + lo) | 0) + ((mid & 8191) << 13)) | 0;
        c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = (mid + Math.imul(ah9, bl2)) | 0;
        hi = Math.imul(ah9, bh2);
        lo = (lo + Math.imul(al8, bl3)) | 0;
        mid = (mid + Math.imul(al8, bh3)) | 0;
        mid = (mid + Math.imul(ah8, bl3)) | 0;
        hi = (hi + Math.imul(ah8, bh3)) | 0;
        lo = (lo + Math.imul(al7, bl4)) | 0;
        mid = (mid + Math.imul(al7, bh4)) | 0;
        mid = (mid + Math.imul(ah7, bl4)) | 0;
        hi = (hi + Math.imul(ah7, bh4)) | 0;
        lo = (lo + Math.imul(al6, bl5)) | 0;
        mid = (mid + Math.imul(al6, bh5)) | 0;
        mid = (mid + Math.imul(ah6, bl5)) | 0;
        hi = (hi + Math.imul(ah6, bh5)) | 0;
        lo = (lo + Math.imul(al5, bl6)) | 0;
        mid = (mid + Math.imul(al5, bh6)) | 0;
        mid = (mid + Math.imul(ah5, bl6)) | 0;
        hi = (hi + Math.imul(ah5, bh6)) | 0;
        lo = (lo + Math.imul(al4, bl7)) | 0;
        mid = (mid + Math.imul(al4, bh7)) | 0;
        mid = (mid + Math.imul(ah4, bl7)) | 0;
        hi = (hi + Math.imul(ah4, bh7)) | 0;
        lo = (lo + Math.imul(al3, bl8)) | 0;
        mid = (mid + Math.imul(al3, bh8)) | 0;
        mid = (mid + Math.imul(ah3, bl8)) | 0;
        hi = (hi + Math.imul(ah3, bh8)) | 0;
        lo = (lo + Math.imul(al2, bl9)) | 0;
        mid = (mid + Math.imul(al2, bh9)) | 0;
        mid = (mid + Math.imul(ah2, bl9)) | 0;
        hi = (hi + Math.imul(ah2, bh9)) | 0;
        var w11 = (((c + lo) | 0) + ((mid & 8191) << 13)) | 0;
        c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = (mid + Math.imul(ah9, bl3)) | 0;
        hi = Math.imul(ah9, bh3);
        lo = (lo + Math.imul(al8, bl4)) | 0;
        mid = (mid + Math.imul(al8, bh4)) | 0;
        mid = (mid + Math.imul(ah8, bl4)) | 0;
        hi = (hi + Math.imul(ah8, bh4)) | 0;
        lo = (lo + Math.imul(al7, bl5)) | 0;
        mid = (mid + Math.imul(al7, bh5)) | 0;
        mid = (mid + Math.imul(ah7, bl5)) | 0;
        hi = (hi + Math.imul(ah7, bh5)) | 0;
        lo = (lo + Math.imul(al6, bl6)) | 0;
        mid = (mid + Math.imul(al6, bh6)) | 0;
        mid = (mid + Math.imul(ah6, bl6)) | 0;
        hi = (hi + Math.imul(ah6, bh6)) | 0;
        lo = (lo + Math.imul(al5, bl7)) | 0;
        mid = (mid + Math.imul(al5, bh7)) | 0;
        mid = (mid + Math.imul(ah5, bl7)) | 0;
        hi = (hi + Math.imul(ah5, bh7)) | 0;
        lo = (lo + Math.imul(al4, bl8)) | 0;
        mid = (mid + Math.imul(al4, bh8)) | 0;
        mid = (mid + Math.imul(ah4, bl8)) | 0;
        hi = (hi + Math.imul(ah4, bh8)) | 0;
        lo = (lo + Math.imul(al3, bl9)) | 0;
        mid = (mid + Math.imul(al3, bh9)) | 0;
        mid = (mid + Math.imul(ah3, bl9)) | 0;
        hi = (hi + Math.imul(ah3, bh9)) | 0;
        var w12 = (((c + lo) | 0) + ((mid & 8191) << 13)) | 0;
        c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = (mid + Math.imul(ah9, bl4)) | 0;
        hi = Math.imul(ah9, bh4);
        lo = (lo + Math.imul(al8, bl5)) | 0;
        mid = (mid + Math.imul(al8, bh5)) | 0;
        mid = (mid + Math.imul(ah8, bl5)) | 0;
        hi = (hi + Math.imul(ah8, bh5)) | 0;
        lo = (lo + Math.imul(al7, bl6)) | 0;
        mid = (mid + Math.imul(al7, bh6)) | 0;
        mid = (mid + Math.imul(ah7, bl6)) | 0;
        hi = (hi + Math.imul(ah7, bh6)) | 0;
        lo = (lo + Math.imul(al6, bl7)) | 0;
        mid = (mid + Math.imul(al6, bh7)) | 0;
        mid = (mid + Math.imul(ah6, bl7)) | 0;
        hi = (hi + Math.imul(ah6, bh7)) | 0;
        lo = (lo + Math.imul(al5, bl8)) | 0;
        mid = (mid + Math.imul(al5, bh8)) | 0;
        mid = (mid + Math.imul(ah5, bl8)) | 0;
        hi = (hi + Math.imul(ah5, bh8)) | 0;
        lo = (lo + Math.imul(al4, bl9)) | 0;
        mid = (mid + Math.imul(al4, bh9)) | 0;
        mid = (mid + Math.imul(ah4, bl9)) | 0;
        hi = (hi + Math.imul(ah4, bh9)) | 0;
        var w13 = (((c + lo) | 0) + ((mid & 8191) << 13)) | 0;
        c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = (mid + Math.imul(ah9, bl5)) | 0;
        hi = Math.imul(ah9, bh5);
        lo = (lo + Math.imul(al8, bl6)) | 0;
        mid = (mid + Math.imul(al8, bh6)) | 0;
        mid = (mid + Math.imul(ah8, bl6)) | 0;
        hi = (hi + Math.imul(ah8, bh6)) | 0;
        lo = (lo + Math.imul(al7, bl7)) | 0;
        mid = (mid + Math.imul(al7, bh7)) | 0;
        mid = (mid + Math.imul(ah7, bl7)) | 0;
        hi = (hi + Math.imul(ah7, bh7)) | 0;
        lo = (lo + Math.imul(al6, bl8)) | 0;
        mid = (mid + Math.imul(al6, bh8)) | 0;
        mid = (mid + Math.imul(ah6, bl8)) | 0;
        hi = (hi + Math.imul(ah6, bh8)) | 0;
        lo = (lo + Math.imul(al5, bl9)) | 0;
        mid = (mid + Math.imul(al5, bh9)) | 0;
        mid = (mid + Math.imul(ah5, bl9)) | 0;
        hi = (hi + Math.imul(ah5, bh9)) | 0;
        var w14 = (((c + lo) | 0) + ((mid & 8191) << 13)) | 0;
        c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = (mid + Math.imul(ah9, bl6)) | 0;
        hi = Math.imul(ah9, bh6);
        lo = (lo + Math.imul(al8, bl7)) | 0;
        mid = (mid + Math.imul(al8, bh7)) | 0;
        mid = (mid + Math.imul(ah8, bl7)) | 0;
        hi = (hi + Math.imul(ah8, bh7)) | 0;
        lo = (lo + Math.imul(al7, bl8)) | 0;
        mid = (mid + Math.imul(al7, bh8)) | 0;
        mid = (mid + Math.imul(ah7, bl8)) | 0;
        hi = (hi + Math.imul(ah7, bh8)) | 0;
        lo = (lo + Math.imul(al6, bl9)) | 0;
        mid = (mid + Math.imul(al6, bh9)) | 0;
        mid = (mid + Math.imul(ah6, bl9)) | 0;
        hi = (hi + Math.imul(ah6, bh9)) | 0;
        var w15 = (((c + lo) | 0) + ((mid & 8191) << 13)) | 0;
        c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = (mid + Math.imul(ah9, bl7)) | 0;
        hi = Math.imul(ah9, bh7);
        lo = (lo + Math.imul(al8, bl8)) | 0;
        mid = (mid + Math.imul(al8, bh8)) | 0;
        mid = (mid + Math.imul(ah8, bl8)) | 0;
        hi = (hi + Math.imul(ah8, bh8)) | 0;
        lo = (lo + Math.imul(al7, bl9)) | 0;
        mid = (mid + Math.imul(al7, bh9)) | 0;
        mid = (mid + Math.imul(ah7, bl9)) | 0;
        hi = (hi + Math.imul(ah7, bh9)) | 0;
        var w16 = (((c + lo) | 0) + ((mid & 8191) << 13)) | 0;
        c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = (mid + Math.imul(ah9, bl8)) | 0;
        hi = Math.imul(ah9, bh8);
        lo = (lo + Math.imul(al8, bl9)) | 0;
        mid = (mid + Math.imul(al8, bh9)) | 0;
        mid = (mid + Math.imul(ah8, bl9)) | 0;
        hi = (hi + Math.imul(ah8, bh9)) | 0;
        var w17 = (((c + lo) | 0) + ((mid & 8191) << 13)) | 0;
        c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = (mid + Math.imul(ah9, bl9)) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (((c + lo) | 0) + ((mid & 8191) << 13)) | 0;
        c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
        w18 &= 67108863;
        o[0] = w0;
        o[1] = w1;
        o[2] = w2;
        o[3] = w3;
        o[4] = w4;
        o[5] = w5;
        o[6] = w6;
        o[7] = w7;
        o[8] = w8;
        o[9] = w9;
        o[10] = w10;
        o[11] = w11;
        o[12] = w12;
        o[13] = w13;
        o[14] = w14;
        o[15] = w15;
        o[16] = w16;
        o[17] = w17;
        o[18] = w18;
        if (c !== 0) {
          o[19] = c;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k = 0; k < out.length - 1; k++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j;
            var a = self2.words[i] | 0;
            var b = num.words[j] | 0;
            var r = a * b;
            var lo = r & 67108863;
            ncarry = (ncarry + ((r / 67108864) | 0)) | 0;
            lo = (lo + rword) | 0;
            rword = lo & 67108863;
            ncarry = (ncarry + (lo >>> 26)) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k] = carry;
        } else {
          out.length--;
        }
        return out._strip();
      }
      function jumboMulTo(self2, num, out) {
        return bigMulTo(self2, num, out);
      }
      BN.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      BN.prototype.mul = function mul(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN.prototype.mulf = function mulf(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN.prototype.imuln = function imuln(num) {
        var isNegNum = num < 0;
        if (isNegNum) num = -num;
        assert(typeof num === "number");
        assert(num < 67108864);
        var carry = 0;
        for (var i = 0; i < this.length; i++) {
          var w = (this.words[i] | 0) * num;
          var lo = (w & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += (w / 67108864) | 0;
          carry += lo >>> 26;
          this.words[i] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return isNegNum ? this.ineg() : this;
      };
      BN.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN.prototype.pow = function pow(num) {
        var w = toBitArray(num);
        if (w.length === 0) return new BN(1);
        var res = this;
        for (var i = 0; i < w.length; i++, res = res.sqr()) {
          if (w[i] !== 0) break;
        }
        if (++i < w.length) {
          for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
            if (w[i] === 0) continue;
            res = res.mul(q);
          }
        }
        return res;
      };
      BN.prototype.iushln = function iushln(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        var carryMask = (67108863 >>> (26 - r)) << (26 - r);
        var i;
        if (r !== 0) {
          var carry = 0;
          for (i = 0; i < this.length; i++) {
            var newCarry = this.words[i] & carryMask;
            var c = ((this.words[i] | 0) - newCarry) << r;
            this.words[i] = c | carry;
            carry = newCarry >>> (26 - r);
          }
          if (carry) {
            this.words[i] = carry;
            this.length++;
          }
        }
        if (s !== 0) {
          for (i = this.length - 1; i >= 0; i--) {
            this.words[i + s] = this.words[i];
          }
          for (i = 0; i < s; i++) {
            this.words[i] = 0;
          }
          this.length += s;
        }
        return this._strip();
      };
      BN.prototype.ishln = function ishln(bits) {
        assert(this.negative === 0);
        return this.iushln(bits);
      };
      BN.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert(typeof bits === "number" && bits >= 0);
        var h;
        if (hint) {
          h = (hint - (hint % 26)) / 26;
        } else {
          h = 0;
        }
        var r = bits % 26;
        var s = Math.min((bits - r) / 26, this.length);
        var mask = 67108863 ^ ((67108863 >>> r) << r);
        var maskedWords = extended;
        h -= s;
        h = Math.max(0, h);
        if (maskedWords) {
          for (var i = 0; i < s; i++) {
            maskedWords.words[i] = this.words[i];
          }
          maskedWords.length = s;
        }
        if (s === 0);
        else if (this.length > s) {
          this.length -= s;
          for (i = 0; i < this.length; i++) {
            this.words[i] = this.words[i + s];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
          var word = this.words[i] | 0;
          this.words[i] = (carry << (26 - r)) | (word >>> r);
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this._strip();
      };
      BN.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN.prototype.testn = function testn(bit) {
        assert(typeof bit === "number" && bit >= 0);
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s) return false;
        var w = this.words[s];
        return !!(w & q);
      };
      BN.prototype.imaskn = function imaskn(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        assert(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s) {
          return this;
        }
        if (r !== 0) {
          s++;
        }
        this.length = Math.min(s, this.length);
        if (r !== 0) {
          var mask = 67108863 ^ ((67108863 >>> r) << r);
          this.words[this.length - 1] &= mask;
        }
        return this._strip();
      };
      BN.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN.prototype.iaddn = function iaddn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0) return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) <= num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
          this.words[i] -= 67108864;
          if (i === this.length - 1) {
            this.words[i + 1] = 1;
          } else {
            this.words[i + 1]++;
          }
        }
        this.length = Math.max(this.length, i + 1);
        return this;
      };
      BN.prototype.isubn = function isubn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0) return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i = 0; i < this.length && this.words[i] < 0; i++) {
            this.words[i] += 67108864;
            this.words[i + 1] -= 1;
          }
        }
        return this._strip();
      };
      BN.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i;
        this._expand(len);
        var w;
        var carry = 0;
        for (i = 0; i < num.length; i++) {
          w = (this.words[i + shift] | 0) + carry;
          var right = (num.words[i] | 0) * mul;
          w -= right & 67108863;
          carry = (w >> 26) - ((right / 67108864) | 0);
          this.words[i + shift] = w & 67108863;
        }
        for (; i < this.length - shift; i++) {
          w = (this.words[i + shift] | 0) + carry;
          carry = w >> 26;
          this.words[i + shift] = w & 67108863;
        }
        if (carry === 0) return this._strip();
        assert(carry === -1);
        carry = 0;
        for (i = 0; i < this.length; i++) {
          w = -(this.words[i] | 0) + carry;
          carry = w >> 26;
          this.words[i] = w & 67108863;
        }
        this.negative = 1;
        return this._strip();
      };
      BN.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a = this.clone();
        var b = num;
        var bhi = b.words[b.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b = b.ushln(shift);
          a.iushln(shift);
          bhi = b.words[b.length - 1] | 0;
        }
        var m = a.length - b.length;
        var q;
        if (mode !== "mod") {
          q = new BN(null);
          q.length = m + 1;
          q.words = new Array(q.length);
          for (var i = 0; i < q.length; i++) {
            q.words[i] = 0;
          }
        }
        var diff = a.clone()._ishlnsubmul(b, 1, m);
        if (diff.negative === 0) {
          a = diff;
          if (q) {
            q.words[m] = 1;
          }
        }
        for (var j = m - 1; j >= 0; j--) {
          var qj =
            (a.words[b.length + j] | 0) * 67108864 +
            (a.words[b.length + j - 1] | 0);
          qj = Math.min((qj / bhi) | 0, 67108863);
          a._ishlnsubmul(b, qj, j);
          while (a.negative !== 0) {
            qj--;
            a.negative = 0;
            a._ishlnsubmul(b, 1, j);
            if (!a.isZero()) {
              a.negative ^= 1;
            }
          }
          if (q) {
            q.words[j] = qj;
          }
        }
        if (q) {
          q._strip();
        }
        a._strip();
        if (mode !== "div" && shift !== 0) {
          a.iushrn(shift);
        }
        return {
          div: q || null,
          mod: a,
        };
      };
      BN.prototype.divmod = function divmod(num, mode, positive) {
        assert(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN(0),
            mod: new BN(0),
          };
        }
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }
          return {
            div,
            mod,
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod,
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }
          return {
            div: res.div,
            mod,
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN(0),
            mod: this,
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null,
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN(this.modrn(num.words[0])),
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN(this.modrn(num.words[0])),
          };
        }
        return this._wordDiv(num, mode);
      };
      BN.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero()) return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod.cmp(half);
        if (cmp < 0 || (r2 === 1 && cmp === 0)) return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN.prototype.modrn = function modrn(num) {
        var isNegNum = num < 0;
        if (isNegNum) num = -num;
        assert(num <= 67108863);
        var p = (1 << 26) % num;
        var acc = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          acc = (p * acc + (this.words[i] | 0)) % num;
        }
        return isNegNum ? -acc : acc;
      };
      BN.prototype.modn = function modn(num) {
        return this.modrn(num);
      };
      BN.prototype.idivn = function idivn(num) {
        var isNegNum = num < 0;
        if (isNegNum) num = -num;
        assert(num <= 67108863);
        var carry = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var w = (this.words[i] | 0) + carry * 67108864;
          this.words[i] = (w / num) | 0;
          carry = w % num;
        }
        this._strip();
        return isNegNum ? this.ineg() : this;
      };
      BN.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN.prototype.egcd = function egcd(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var x = this;
        var y = p.clone();
        if (x.negative !== 0) {
          x = x.umod(p);
        } else {
          x = x.clone();
        }
        var A = new BN(1);
        var B = new BN(0);
        var C = new BN(0);
        var D = new BN(1);
        var g = 0;
        while (x.isEven() && y.isEven()) {
          x.iushrn(1);
          y.iushrn(1);
          ++g;
        }
        var yp = y.clone();
        var xp = x.clone();
        while (!x.isZero()) {
          for (
            var i = 0, im = 1;
            (x.words[0] & im) === 0 && i < 26;
            ++i, im <<= 1
          );
          if (i > 0) {
            x.iushrn(i);
            while (i-- > 0) {
              if (A.isOdd() || B.isOdd()) {
                A.iadd(yp);
                B.isub(xp);
              }
              A.iushrn(1);
              B.iushrn(1);
            }
          }
          for (
            var j = 0, jm = 1;
            (y.words[0] & jm) === 0 && j < 26;
            ++j, jm <<= 1
          );
          if (j > 0) {
            y.iushrn(j);
            while (j-- > 0) {
              if (C.isOdd() || D.isOdd()) {
                C.iadd(yp);
                D.isub(xp);
              }
              C.iushrn(1);
              D.iushrn(1);
            }
          }
          if (x.cmp(y) >= 0) {
            x.isub(y);
            A.isub(C);
            B.isub(D);
          } else {
            y.isub(x);
            C.isub(A);
            D.isub(B);
          }
        }
        return {
          a: C,
          b: D,
          gcd: y.iushln(g),
        };
      };
      BN.prototype._invmp = function _invmp(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var a = this;
        var b = p.clone();
        if (a.negative !== 0) {
          a = a.umod(p);
        } else {
          a = a.clone();
        }
        var x1 = new BN(1);
        var x2 = new BN(0);
        var delta = b.clone();
        while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
          for (
            var i = 0, im = 1;
            (a.words[0] & im) === 0 && i < 26;
            ++i, im <<= 1
          );
          if (i > 0) {
            a.iushrn(i);
            while (i-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (
            var j = 0, jm = 1;
            (b.words[0] & jm) === 0 && j < 26;
            ++j, jm <<= 1
          );
          if (j > 0) {
            b.iushrn(j);
            while (j-- > 0) {
              if (x2.isOdd()) {
                x2.iadd(delta);
              }
              x2.iushrn(1);
            }
          }
          if (a.cmp(b) >= 0) {
            a.isub(b);
            x1.isub(x2);
          } else {
            b.isub(a);
            x2.isub(x1);
          }
        }
        var res;
        if (a.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x2;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p);
        }
        return res;
      };
      BN.prototype.gcd = function gcd(num) {
        if (this.isZero()) return num.abs();
        if (num.isZero()) return this.abs();
        var a = this.clone();
        var b = num.clone();
        a.negative = 0;
        b.negative = 0;
        for (var shift = 0; a.isEven() && b.isEven(); shift++) {
          a.iushrn(1);
          b.iushrn(1);
        }
        do {
          while (a.isEven()) {
            a.iushrn(1);
          }
          while (b.isEven()) {
            b.iushrn(1);
          }
          var r = a.cmp(b);
          if (r < 0) {
            var t = a;
            a = b;
            b = t;
          } else if (r === 0 || b.cmpn(1) === 0) {
            break;
          }
          a.isub(b);
        } while (true);
        return b.iushln(shift);
      };
      BN.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN.prototype.bincn = function bincn(bit) {
        assert(typeof bit === "number");
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s) {
          this._expand(s + 1);
          this.words[s] |= q;
          return this;
        }
        var carry = q;
        for (var i = s; carry !== 0 && i < this.length; i++) {
          var w = this.words[i] | 0;
          w += carry;
          carry = w >>> 26;
          w &= 67108863;
          this.words[i] = w;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative) return -1;
        if (this.negative === 0 && negative) return 1;
        this._strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert(num <= 67108863, "Number is too big");
          var w = this.words[0] | 0;
          res = w === num ? 0 : w < num ? -1 : 1;
        }
        if (this.negative !== 0) return -res | 0;
        return res;
      };
      BN.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0) return -1;
        if (this.negative === 0 && num.negative !== 0) return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0) return -res | 0;
        return res;
      };
      BN.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length) return 1;
        if (this.length < num.length) return -1;
        var res = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var a = this.words[i] | 0;
          var b = num.words[i] | 0;
          if (a === b) continue;
          if (a < b) {
            res = -1;
          } else if (a > b) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN.red = function red(num) {
        return new Red(num);
      };
      BN.prototype.toRed = function toRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        assert(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN.prototype.fromRed = function fromRed() {
        assert(
          this.red,
          "fromRed works only with numbers in reduction context"
        );
        return this.red.convertFrom(this);
      };
      BN.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN.prototype.forceRed = function forceRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN.prototype.redAdd = function redAdd(num) {
        assert(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN.prototype.redIAdd = function redIAdd(num) {
        assert(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN.prototype.redSub = function redSub(num) {
        assert(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN.prototype.redISub = function redISub(num) {
        assert(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN.prototype.redShl = function redShl(num) {
        assert(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN.prototype.redMul = function redMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN.prototype.redIMul = function redIMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN.prototype.redSqr = function redSqr() {
        assert(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN.prototype.redISqr = function redISqr() {
        assert(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN.prototype.redSqrt = function redSqrt() {
        assert(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN.prototype.redInvm = function redInvm() {
        assert(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN.prototype.redNeg = function redNeg() {
        assert(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN.prototype.redPow = function redPow(num) {
        assert(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null,
      };
      function MPrime(name, p) {
        this.name = name;
        this.p = new BN(p, 16);
        this.n = this.p.bitLength();
        this.k = new BN(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r = num;
        var rlen;
        do {
          this.split(r, this.tmp);
          r = this.imulK(r);
          r = r.iadd(this.tmp);
          rlen = r.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
        if (cmp === 0) {
          r.words[0] = 0;
          r.length = 1;
        } else if (cmp > 0) {
          r.isub(this.p);
        } else {
          if (r.strip !== void 0) {
            r.strip();
          } else {
            r._strip();
          }
        }
        return r;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i = 0; i < outLen; i++) {
          output.words[i] = input.words[i];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i = 10; i < input.length; i++) {
          var next = input.words[i] | 0;
          input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
          prev = next;
        }
        prev >>>= 22;
        input.words[i - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i = 0; i < num.length; i++) {
          var w = num.words[i] | 0;
          lo += w * 977;
          num.words[i] = lo & 67108863;
          lo = w * 64 + ((lo / 67108864) | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i = 0; i < num.length; i++) {
          var hi = (num.words[i] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN._prime = function prime(name) {
        if (primes[name]) return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m) {
        if (typeof m === "string") {
          var prime = BN._prime(m);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert(m.gtn(1), "modulus must be greater than 1");
          this.m = m;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a) {
        assert(a.negative === 0, "red works only with positives");
        assert(a.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a, b) {
        assert(
          (a.negative | b.negative) === 0,
          "red works only with positives"
        );
        assert(a.red && a.red === b.red, "red works only with red numbers");
      };
      Red.prototype.imod = function imod(a) {
        if (this.prime) return this.prime.ireduce(a)._forceRed(this);
        move(a, a.umod(this.m)._forceRed(this));
        return a;
      };
      Red.prototype.neg = function neg(a) {
        if (a.isZero()) {
          return a.clone();
        }
        return this.m.sub(a)._forceRed(this);
      };
      Red.prototype.add = function add(a, b) {
        this._verify2(a, b);
        var res = a.add(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a, b) {
        this._verify2(a, b);
        var res = a.iadd(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a, b) {
        this._verify2(a, b);
        var res = a.sub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a, b) {
        this._verify2(a, b);
        var res = a.isub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a, num) {
        this._verify1(a);
        return this.imod(a.ushln(num));
      };
      Red.prototype.imul = function imul(a, b) {
        this._verify2(a, b);
        return this.imod(a.imul(b));
      };
      Red.prototype.mul = function mul(a, b) {
        this._verify2(a, b);
        return this.imod(a.mul(b));
      };
      Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
      };
      Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
      };
      Red.prototype.sqrt = function sqrt(a) {
        if (a.isZero()) return a.clone();
        var mod3 = this.m.andln(3);
        assert(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN(1)).iushrn(2);
          return this.pow(a, pow);
        }
        var q = this.m.subn(1);
        var s = 0;
        while (!q.isZero() && q.andln(1) === 0) {
          s++;
          q.iushrn(1);
        }
        assert(!q.isZero());
        var one = new BN(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z = this.m.bitLength();
        z = new BN(2 * z * z).toRed(this);
        while (this.pow(z, lpow).cmp(nOne) !== 0) {
          z.redIAdd(nOne);
        }
        var c = this.pow(z, q);
        var r = this.pow(a, q.addn(1).iushrn(1));
        var t = this.pow(a, q);
        var m = s;
        while (t.cmp(one) !== 0) {
          var tmp = t;
          for (var i = 0; tmp.cmp(one) !== 0; i++) {
            tmp = tmp.redSqr();
          }
          assert(i < m);
          var b = this.pow(c, new BN(1).iushln(m - i - 1));
          r = r.redMul(b);
          c = b.redSqr();
          t = t.redMul(c);
          m = i;
        }
        return r;
      };
      Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a, num) {
        if (num.isZero()) return new BN(1).toRed(this);
        if (num.cmpn(1) === 0) return a.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN(1).toRed(this);
        wnd[1] = a;
        for (var i = 2; i < wnd.length; i++) {
          wnd[i] = this.mul(wnd[i - 1], a);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i = num.length - 1; i >= 0; i--) {
          var word = num.words[i];
          for (var j = start - 1; j >= 0; j--) {
            var bit = (word >> j) & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r = num.umod(this.m);
        return r === num ? r.clone() : r;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m) {
        Red.call(this, m);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - (this.shift % 26);
        }
        this.r = new BN(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r = this.imod(num.mul(this.rinv));
        r.red = null;
        return r;
      };
      Mont.prototype.imul = function imul(a, b) {
        if (a.isZero() || b.isZero()) {
          a.words[0] = 0;
          a.length = 1;
          return a;
        }
        var t = a.imul(b);
        var c = t
          .maskn(this.shift)
          .mul(this.minv)
          .imaskn(this.shift)
          .mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a, b) {
        if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);
        var t = a.mul(b);
        var c = t
          .maskn(this.shift)
          .mul(this.minv)
          .imaskn(this.shift)
          .mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a) {
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module2 === "undefined" || module2, exports2);
  },
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/safe-buffer/index.js"(exports2, module2) {
    var buffer = require_buffer();
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (
      Buffer2.from &&
      Buffer2.alloc &&
      Buffer2.allocUnsafe &&
      Buffer2.allocUnsafeSlow
    ) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer2.prototype);
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function (arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function (size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function (size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function (size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  },
});

// node_modules/base-x/src/index.js
var require_src = __commonJS({
  "node_modules/base-x/src/index.js"(exports2, module2) {
    var _Buffer = require_safe_buffer().Buffer;
    function base(ALPHABET) {
      if (ALPHABET.length >= 255) {
        throw new TypeError("Alphabet too long");
      }
      var BASE_MAP = new Uint8Array(256);
      for (var j = 0; j < BASE_MAP.length; j++) {
        BASE_MAP[j] = 255;
      }
      for (var i = 0; i < ALPHABET.length; i++) {
        var x = ALPHABET.charAt(i);
        var xc = x.charCodeAt(0);
        if (BASE_MAP[xc] !== 255) {
          throw new TypeError(x + " is ambiguous");
        }
        BASE_MAP[xc] = i;
      }
      var BASE = ALPHABET.length;
      var LEADER = ALPHABET.charAt(0);
      var FACTOR = Math.log(BASE) / Math.log(256);
      var iFACTOR = Math.log(256) / Math.log(BASE);
      function encode2(source) {
        if (Array.isArray(source) || source instanceof Uint8Array) {
          source = _Buffer.from(source);
        }
        if (!_Buffer.isBuffer(source)) {
          throw new TypeError("Expected Buffer");
        }
        if (source.length === 0) {
          return "";
        }
        var zeroes = 0;
        var length = 0;
        var pbegin = 0;
        var pend = source.length;
        while (pbegin !== pend && source[pbegin] === 0) {
          pbegin++;
          zeroes++;
        }
        var size = ((pend - pbegin) * iFACTOR + 1) >>> 0;
        var b58 = new Uint8Array(size);
        while (pbegin !== pend) {
          var carry = source[pbegin];
          var i2 = 0;
          for (
            var it1 = size - 1;
            (carry !== 0 || i2 < length) && it1 !== -1;
            it1--, i2++
          ) {
            carry += (256 * b58[it1]) >>> 0;
            b58[it1] = carry % BASE >>> 0;
            carry = (carry / BASE) >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length = i2;
          pbegin++;
        }
        var it2 = size - length;
        while (it2 !== size && b58[it2] === 0) {
          it2++;
        }
        var str = LEADER.repeat(zeroes);
        for (; it2 < size; ++it2) {
          str += ALPHABET.charAt(b58[it2]);
        }
        return str;
      }
      function decodeUnsafe(source) {
        if (typeof source !== "string") {
          throw new TypeError("Expected String");
        }
        if (source.length === 0) {
          return _Buffer.alloc(0);
        }
        var psz = 0;
        var zeroes = 0;
        var length = 0;
        while (source[psz] === LEADER) {
          zeroes++;
          psz++;
        }
        var size = ((source.length - psz) * FACTOR + 1) >>> 0;
        var b256 = new Uint8Array(size);
        while (source[psz]) {
          var carry = BASE_MAP[source.charCodeAt(psz)];
          if (carry === 255) {
            return;
          }
          var i2 = 0;
          for (
            var it3 = size - 1;
            (carry !== 0 || i2 < length) && it3 !== -1;
            it3--, i2++
          ) {
            carry += (BASE * b256[it3]) >>> 0;
            b256[it3] = carry % 256 >>> 0;
            carry = (carry / 256) >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length = i2;
          psz++;
        }
        var it4 = size - length;
        while (it4 !== size && b256[it4] === 0) {
          it4++;
        }
        var vch = _Buffer.allocUnsafe(zeroes + (size - it4));
        vch.fill(0, 0, zeroes);
        var j2 = zeroes;
        while (it4 !== size) {
          vch[j2++] = b256[it4++];
        }
        return vch;
      }
      function decode2(string) {
        var buffer = decodeUnsafe(string);
        if (buffer) {
          return buffer;
        }
        throw new Error("Non-base" + BASE + " character");
      }
      return {
        encode: encode2,
        decodeUnsafe,
        decode: decode2,
      };
    }
    module2.exports = base;
  },
});

// node_modules/bs58/index.js
var require_bs58 = __commonJS({
  "node_modules/bs58/index.js"(exports2, module2) {
    var basex = require_src();
    var ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    module2.exports = basex(ALPHABET);
  },
});

// node_modules/text-encoding-utf-8/src/encoding.js
var encoding_exports = {};
__export(encoding_exports, {
  TextDecoder: () => TextDecoder2,
  TextEncoder: () => TextEncoder,
});
function inRange(a, min, max) {
  return min <= a && a <= max;
}
function ToDictionary(o) {
  if (o === void 0) return {};
  if (o === Object(o)) return o;
  throw TypeError("Could not convert argument to dictionary");
}
function stringToCodePoints(string) {
  var s = String(string);
  var n = s.length;
  var i = 0;
  var u = [];
  while (i < n) {
    var c = s.charCodeAt(i);
    if (c < 55296 || c > 57343) {
      u.push(c);
    } else if (56320 <= c && c <= 57343) {
      u.push(65533);
    } else if (55296 <= c && c <= 56319) {
      if (i === n - 1) {
        u.push(65533);
      } else {
        var d = string.charCodeAt(i + 1);
        if (56320 <= d && d <= 57343) {
          var a = c & 1023;
          var b = d & 1023;
          u.push(65536 + (a << 10) + b);
          i += 1;
        } else {
          u.push(65533);
        }
      }
    }
    i += 1;
  }
  return u;
}
function codePointsToString(code_points) {
  var s = "";
  for (var i = 0; i < code_points.length; ++i) {
    var cp = code_points[i];
    if (cp <= 65535) {
      s += String.fromCharCode(cp);
    } else {
      cp -= 65536;
      s += String.fromCharCode((cp >> 10) + 55296, (cp & 1023) + 56320);
    }
  }
  return s;
}
function Stream(tokens) {
  this.tokens = [].slice.call(tokens);
}
function decoderError(fatal, opt_code_point) {
  if (fatal) throw TypeError("Decoder error");
  return opt_code_point || 65533;
}
function TextDecoder2(encoding, options) {
  if (!(this instanceof TextDecoder2)) {
    return new TextDecoder2(encoding, options);
  }
  encoding =
    encoding !== void 0 ? String(encoding).toLowerCase() : DEFAULT_ENCODING;
  if (encoding !== DEFAULT_ENCODING) {
    throw new Error("Encoding not supported. Only utf-8 is supported");
  }
  options = ToDictionary(options);
  this._streaming = false;
  this._BOMseen = false;
  this._decoder = null;
  this._fatal = Boolean(options["fatal"]);
  this._ignoreBOM = Boolean(options["ignoreBOM"]);
  Object.defineProperty(this, "encoding", { value: "utf-8" });
  Object.defineProperty(this, "fatal", { value: this._fatal });
  Object.defineProperty(this, "ignoreBOM", { value: this._ignoreBOM });
}
function TextEncoder(encoding, options) {
  if (!(this instanceof TextEncoder)) return new TextEncoder(encoding, options);
  encoding =
    encoding !== void 0 ? String(encoding).toLowerCase() : DEFAULT_ENCODING;
  if (encoding !== DEFAULT_ENCODING) {
    throw new Error("Encoding not supported. Only utf-8 is supported");
  }
  options = ToDictionary(options);
  this._streaming = false;
  this._encoder = null;
  this._options = { fatal: Boolean(options["fatal"]) };
  Object.defineProperty(this, "encoding", { value: "utf-8" });
}
function UTF8Decoder(options) {
  var fatal = options.fatal;
  var utf8_code_point = 0,
    utf8_bytes_seen = 0,
    utf8_bytes_needed = 0,
    utf8_lower_boundary = 128,
    utf8_upper_boundary = 191;
  this.handler = function (stream, bite) {
    if (bite === end_of_stream && utf8_bytes_needed !== 0) {
      utf8_bytes_needed = 0;
      return decoderError(fatal);
    }
    if (bite === end_of_stream) return finished;
    if (utf8_bytes_needed === 0) {
      if (inRange(bite, 0, 127)) {
        return bite;
      }
      if (inRange(bite, 194, 223)) {
        utf8_bytes_needed = 1;
        utf8_code_point = bite - 192;
      } else if (inRange(bite, 224, 239)) {
        if (bite === 224) utf8_lower_boundary = 160;
        if (bite === 237) utf8_upper_boundary = 159;
        utf8_bytes_needed = 2;
        utf8_code_point = bite - 224;
      } else if (inRange(bite, 240, 244)) {
        if (bite === 240) utf8_lower_boundary = 144;
        if (bite === 244) utf8_upper_boundary = 143;
        utf8_bytes_needed = 3;
        utf8_code_point = bite - 240;
      } else {
        return decoderError(fatal);
      }
      utf8_code_point = utf8_code_point << (6 * utf8_bytes_needed);
      return null;
    }
    if (!inRange(bite, utf8_lower_boundary, utf8_upper_boundary)) {
      utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;
      utf8_lower_boundary = 128;
      utf8_upper_boundary = 191;
      stream.prepend(bite);
      return decoderError(fatal);
    }
    utf8_lower_boundary = 128;
    utf8_upper_boundary = 191;
    utf8_bytes_seen += 1;
    utf8_code_point +=
      (bite - 128) << (6 * (utf8_bytes_needed - utf8_bytes_seen));
    if (utf8_bytes_seen !== utf8_bytes_needed) return null;
    var code_point = utf8_code_point;
    utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;
    return code_point;
  };
}
function UTF8Encoder(options) {
  options.fatal;
  this.handler = function (stream, code_point) {
    if (code_point === end_of_stream) return finished;
    if (inRange(code_point, 0, 127)) return code_point;
    var count, offset;
    if (inRange(code_point, 128, 2047)) {
      count = 1;
      offset = 192;
    } else if (inRange(code_point, 2048, 65535)) {
      count = 2;
      offset = 224;
    } else if (inRange(code_point, 65536, 1114111)) {
      count = 3;
      offset = 240;
    }
    var bytes = [(code_point >> (6 * count)) + offset];
    while (count > 0) {
      var temp = code_point >> (6 * (count - 1));
      bytes.push(128 | (temp & 63));
      count -= 1;
    }
    return bytes;
  };
}
var end_of_stream, finished, DEFAULT_ENCODING;
var init_encoding = __esm({
  "node_modules/text-encoding-utf-8/src/encoding.js"() {
    end_of_stream = -1;
    Stream.prototype = {
      /**
       * @return {boolean} True if end-of-stream has been hit.
       */
      endOfStream: function () {
        return !this.tokens.length;
      },
      /**
       * When a token is read from a stream, the first token in the
       * stream must be returned and subsequently removed, and
       * end-of-stream must be returned otherwise.
       *
       * @return {number} Get the next token from the stream, or
       * end_of_stream.
       */
      read: function () {
        if (!this.tokens.length) return end_of_stream;
        return this.tokens.shift();
      },
      /**
       * When one or more tokens are prepended to a stream, those tokens
       * must be inserted, in given order, before the first token in the
       * stream.
       *
       * @param {(number|!Array.<number>)} token The token(s) to prepend to the stream.
       */
      prepend: function (token) {
        if (Array.isArray(token)) {
          var tokens =
            /**@type {!Array.<number>}*/
            token;
          while (tokens.length) this.tokens.unshift(tokens.pop());
        } else {
          this.tokens.unshift(token);
        }
      },
      /**
       * When one or more tokens are pushed to a stream, those tokens
       * must be inserted, in given order, after the last token in the
       * stream.
       *
       * @param {(number|!Array.<number>)} token The tokens(s) to prepend to the stream.
       */
      push: function (token) {
        if (Array.isArray(token)) {
          var tokens =
            /**@type {!Array.<number>}*/
            token;
          while (tokens.length) this.tokens.push(tokens.shift());
        } else {
          this.tokens.push(token);
        }
      },
    };
    finished = -1;
    DEFAULT_ENCODING = "utf-8";
    TextDecoder2.prototype = {
      /**
       * @param {ArrayBufferView=} input The buffer of bytes to decode.
       * @param {Object=} options
       * @return {string} The decoded string.
       */
      decode: function decode(input, options) {
        var bytes;
        if (typeof input === "object" && input instanceof ArrayBuffer) {
          bytes = new Uint8Array(input);
        } else if (
          typeof input === "object" &&
          "buffer" in input &&
          input.buffer instanceof ArrayBuffer
        ) {
          bytes = new Uint8Array(
            input.buffer,
            input.byteOffset,
            input.byteLength
          );
        } else {
          bytes = new Uint8Array(0);
        }
        options = ToDictionary(options);
        if (!this._streaming) {
          this._decoder = new UTF8Decoder({ fatal: this._fatal });
          this._BOMseen = false;
        }
        this._streaming = Boolean(options["stream"]);
        var input_stream = new Stream(bytes);
        var code_points = [];
        var result;
        while (!input_stream.endOfStream()) {
          result = this._decoder.handler(input_stream, input_stream.read());
          if (result === finished) break;
          if (result === null) continue;
          if (Array.isArray(result))
            code_points.push.apply(
              code_points,
              /**@type {!Array.<number>}*/
              result
            );
          else code_points.push(result);
        }
        if (!this._streaming) {
          do {
            result = this._decoder.handler(input_stream, input_stream.read());
            if (result === finished) break;
            if (result === null) continue;
            if (Array.isArray(result))
              code_points.push.apply(
                code_points,
                /**@type {!Array.<number>}*/
                result
              );
            else code_points.push(result);
          } while (!input_stream.endOfStream());
          this._decoder = null;
        }
        if (code_points.length) {
          if (
            ["utf-8"].indexOf(this.encoding) !== -1 &&
            !this._ignoreBOM &&
            !this._BOMseen
          ) {
            if (code_points[0] === 65279) {
              this._BOMseen = true;
              code_points.shift();
            } else {
              this._BOMseen = true;
            }
          }
        }
        return codePointsToString(code_points);
      },
    };
    TextEncoder.prototype = {
      /**
       * @param {string=} opt_string The string to encode.
       * @param {Object=} options
       * @return {Uint8Array} Encoded bytes, as a Uint8Array.
       */
      encode: function encode(opt_string, options) {
        opt_string = opt_string ? String(opt_string) : "";
        options = ToDictionary(options);
        if (!this._streaming) this._encoder = new UTF8Encoder(this._options);
        this._streaming = Boolean(options["stream"]);
        var bytes = [];
        var input_stream = new Stream(stringToCodePoints(opt_string));
        var result;
        while (!input_stream.endOfStream()) {
          result = this._encoder.handler(input_stream, input_stream.read());
          if (result === finished) break;
          if (Array.isArray(result))
            bytes.push.apply(
              bytes,
              /**@type {!Array.<number>}*/
              result
            );
          else bytes.push(result);
        }
        if (!this._streaming) {
          while (true) {
            result = this._encoder.handler(input_stream, input_stream.read());
            if (result === finished) break;
            if (Array.isArray(result))
              bytes.push.apply(
                bytes,
                /**@type {!Array.<number>}*/
                result
              );
            else bytes.push(result);
          }
          this._encoder = null;
        }
        return new Uint8Array(bytes);
      },
    };
  },
});

// node_modules/borsh/lib/index.js
var require_lib = __commonJS({
  "node_modules/borsh/lib/index.js"(exports2) {
    var __createBinding =
      (exports2 && exports2.__createBinding) ||
      (Object.create
        ? function (o, m, k, k2) {
            if (k2 === void 0) k2 = k;
            Object.defineProperty(o, k2, {
              enumerable: true,
              get: function () {
                return m[k];
              },
            });
          }
        : function (o, m, k, k2) {
            if (k2 === void 0) k2 = k;
            o[k2] = m[k];
          });
    var __setModuleDefault =
      (exports2 && exports2.__setModuleDefault) ||
      (Object.create
        ? function (o, v) {
            Object.defineProperty(o, "default", { enumerable: true, value: v });
          }
        : function (o, v) {
            o["default"] = v;
          });
    var __decorate =
      (exports2 && exports2.__decorate) ||
      function (decorators, target, key, desc) {
        var c = arguments.length,
          r =
            c < 3
              ? target
              : desc === null
              ? (desc = Object.getOwnPropertyDescriptor(target, key))
              : desc,
          d;
        if (
          typeof Reflect === "object" &&
          typeof Reflect.decorate === "function"
        )
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if ((d = decorators[i]))
              r =
                (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) ||
                r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
    var __importStar =
      (exports2 && exports2.__importStar) ||
      function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    var __importDefault =
      (exports2 && exports2.__importDefault) ||
      function (mod) {
        return mod && mod.__esModule ? mod : { default: mod };
      };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.deserializeUnchecked =
      exports2.deserialize =
      exports2.serialize =
      exports2.BinaryReader =
      exports2.BinaryWriter =
      exports2.BorshError =
      exports2.baseDecode =
      exports2.baseEncode =
        void 0;
    var bn_js_1 = __importDefault(require_bn());
    var bs58_1 = __importDefault(require_bs58());
    var encoding = __importStar(
      (init_encoding(), __toCommonJS(encoding_exports))
    );
    var ResolvedTextDecoder =
      typeof TextDecoder !== "function" ? encoding.TextDecoder : TextDecoder;
    var textDecoder = new ResolvedTextDecoder("utf-8", { fatal: true });
    function baseEncode(value) {
      if (typeof value === "string") {
        value = Buffer.from(value, "utf8");
      }
      return bs58_1.default.encode(Buffer.from(value));
    }
    exports2.baseEncode = baseEncode;
    function baseDecode(value) {
      return Buffer.from(bs58_1.default.decode(value));
    }
    exports2.baseDecode = baseDecode;
    var INITIAL_LENGTH = 1024;
    var BorshError = class extends Error {
      constructor(message) {
        super(message);
        this.fieldPath = [];
        this.originalMessage = message;
      }
      addToFieldPath(fieldName) {
        this.fieldPath.splice(0, 0, fieldName);
        this.message = this.originalMessage + ": " + this.fieldPath.join(".");
      }
    };
    exports2.BorshError = BorshError;
    var BinaryWriter = class {
      constructor() {
        this.buf = Buffer.alloc(INITIAL_LENGTH);
        this.length = 0;
      }
      maybeResize() {
        if (this.buf.length < 16 + this.length) {
          this.buf = Buffer.concat([this.buf, Buffer.alloc(INITIAL_LENGTH)]);
        }
      }
      writeU8(value) {
        this.maybeResize();
        this.buf.writeUInt8(value, this.length);
        this.length += 1;
      }
      writeU16(value) {
        this.maybeResize();
        this.buf.writeUInt16LE(value, this.length);
        this.length += 2;
      }
      writeU32(value) {
        this.maybeResize();
        this.buf.writeUInt32LE(value, this.length);
        this.length += 4;
      }
      writeU64(value) {
        this.maybeResize();
        this.writeBuffer(
          Buffer.from(new bn_js_1.default(value).toArray("le", 8))
        );
      }
      writeU128(value) {
        this.maybeResize();
        this.writeBuffer(
          Buffer.from(new bn_js_1.default(value).toArray("le", 16))
        );
      }
      writeU256(value) {
        this.maybeResize();
        this.writeBuffer(
          Buffer.from(new bn_js_1.default(value).toArray("le", 32))
        );
      }
      writeU512(value) {
        this.maybeResize();
        this.writeBuffer(
          Buffer.from(new bn_js_1.default(value).toArray("le", 64))
        );
      }
      writeBuffer(buffer) {
        this.buf = Buffer.concat([
          Buffer.from(this.buf.subarray(0, this.length)),
          buffer,
          Buffer.alloc(INITIAL_LENGTH),
        ]);
        this.length += buffer.length;
      }
      writeString(str) {
        this.maybeResize();
        const b = Buffer.from(str, "utf8");
        this.writeU32(b.length);
        this.writeBuffer(b);
      }
      writeFixedArray(array) {
        this.writeBuffer(Buffer.from(array));
      }
      writeArray(array, fn) {
        this.maybeResize();
        this.writeU32(array.length);
        for (const elem of array) {
          this.maybeResize();
          fn(elem);
        }
      }
      toArray() {
        return this.buf.subarray(0, this.length);
      }
    };
    exports2.BinaryWriter = BinaryWriter;
    function handlingRangeError(target, propertyKey, propertyDescriptor) {
      const originalMethod = propertyDescriptor.value;
      propertyDescriptor.value = function (...args) {
        try {
          return originalMethod.apply(this, args);
        } catch (e) {
          if (e instanceof RangeError) {
            const code = e.code;
            if (
              ["ERR_BUFFER_OUT_OF_BOUNDS", "ERR_OUT_OF_RANGE"].indexOf(code) >=
              0
            ) {
              throw new BorshError(
                "Reached the end of buffer when deserializing"
              );
            }
          }
          throw e;
        }
      };
    }
    var BinaryReader = class {
      constructor(buf) {
        this.buf = buf;
        this.offset = 0;
      }
      readU8() {
        const value = this.buf.readUInt8(this.offset);
        this.offset += 1;
        return value;
      }
      readU16() {
        const value = this.buf.readUInt16LE(this.offset);
        this.offset += 2;
        return value;
      }
      readU32() {
        const value = this.buf.readUInt32LE(this.offset);
        this.offset += 4;
        return value;
      }
      readU64() {
        const buf = this.readBuffer(8);
        return new bn_js_1.default(buf, "le");
      }
      readU128() {
        const buf = this.readBuffer(16);
        return new bn_js_1.default(buf, "le");
      }
      readU256() {
        const buf = this.readBuffer(32);
        return new bn_js_1.default(buf, "le");
      }
      readU512() {
        const buf = this.readBuffer(64);
        return new bn_js_1.default(buf, "le");
      }
      readBuffer(len) {
        if (this.offset + len > this.buf.length) {
          throw new BorshError(
            `Expected buffer length ${len} isn't within bounds`
          );
        }
        const result = this.buf.slice(this.offset, this.offset + len);
        this.offset += len;
        return result;
      }
      readString() {
        const len = this.readU32();
        const buf = this.readBuffer(len);
        try {
          return textDecoder.decode(buf);
        } catch (e) {
          throw new BorshError(`Error decoding UTF-8 string: ${e}`);
        }
      }
      readFixedArray(len) {
        return new Uint8Array(this.readBuffer(len));
      }
      readArray(fn) {
        const len = this.readU32();
        const result = Array();
        for (let i = 0; i < len; ++i) {
          result.push(fn());
        }
        return result;
      }
    };
    __decorate([handlingRangeError], BinaryReader.prototype, "readU8", null);
    __decorate([handlingRangeError], BinaryReader.prototype, "readU16", null);
    __decorate([handlingRangeError], BinaryReader.prototype, "readU32", null);
    __decorate([handlingRangeError], BinaryReader.prototype, "readU64", null);
    __decorate([handlingRangeError], BinaryReader.prototype, "readU128", null);
    __decorate([handlingRangeError], BinaryReader.prototype, "readU256", null);
    __decorate([handlingRangeError], BinaryReader.prototype, "readU512", null);
    __decorate(
      [handlingRangeError],
      BinaryReader.prototype,
      "readString",
      null
    );
    __decorate(
      [handlingRangeError],
      BinaryReader.prototype,
      "readFixedArray",
      null
    );
    __decorate([handlingRangeError], BinaryReader.prototype, "readArray", null);
    exports2.BinaryReader = BinaryReader;
    function capitalizeFirstLetter(string) {
      return string.charAt(0).toUpperCase() + string.slice(1);
    }
    function serializeField(schema, fieldName, value, fieldType, writer) {
      try {
        if (typeof fieldType === "string") {
          writer[`write${capitalizeFirstLetter(fieldType)}`](value);
        } else if (fieldType instanceof Array) {
          if (typeof fieldType[0] === "number") {
            if (value.length !== fieldType[0]) {
              throw new BorshError(
                `Expecting byte array of length ${fieldType[0]}, but got ${value.length} bytes`
              );
            }
            writer.writeFixedArray(value);
          } else if (
            fieldType.length === 2 &&
            typeof fieldType[1] === "number"
          ) {
            if (value.length !== fieldType[1]) {
              throw new BorshError(
                `Expecting byte array of length ${fieldType[1]}, but got ${value.length} bytes`
              );
            }
            for (let i = 0; i < fieldType[1]; i++) {
              serializeField(schema, null, value[i], fieldType[0], writer);
            }
          } else {
            writer.writeArray(value, (item) => {
              serializeField(schema, fieldName, item, fieldType[0], writer);
            });
          }
        } else if (fieldType.kind !== void 0) {
          switch (fieldType.kind) {
            case "option": {
              if (value === null || value === void 0) {
                writer.writeU8(0);
              } else {
                writer.writeU8(1);
                serializeField(
                  schema,
                  fieldName,
                  value,
                  fieldType.type,
                  writer
                );
              }
              break;
            }
            case "map": {
              writer.writeU32(value.size);
              value.forEach((val, key) => {
                serializeField(schema, fieldName, key, fieldType.key, writer);
                serializeField(schema, fieldName, val, fieldType.value, writer);
              });
              break;
            }
            default:
              throw new BorshError(`FieldType ${fieldType} unrecognized`);
          }
        } else {
          serializeStruct(schema, value, writer);
        }
      } catch (error) {
        if (error instanceof BorshError) {
          error.addToFieldPath(fieldName);
        }
        throw error;
      }
    }
    function serializeStruct(schema, obj, writer) {
      if (typeof obj.borshSerialize === "function") {
        obj.borshSerialize(writer);
        return;
      }
      const structSchema = schema.get(obj.constructor);
      if (!structSchema) {
        throw new BorshError(
          `Class ${obj.constructor.name} is missing in schema`
        );
      }
      if (structSchema.kind === "struct") {
        structSchema.fields.map(([fieldName, fieldType]) => {
          serializeField(schema, fieldName, obj[fieldName], fieldType, writer);
        });
      } else if (structSchema.kind === "enum") {
        const name = obj[structSchema.field];
        for (let idx = 0; idx < structSchema.values.length; ++idx) {
          const [fieldName, fieldType] = structSchema.values[idx];
          if (fieldName === name) {
            writer.writeU8(idx);
            serializeField(
              schema,
              fieldName,
              obj[fieldName],
              fieldType,
              writer
            );
            break;
          }
        }
      } else {
        throw new BorshError(
          `Unexpected schema kind: ${structSchema.kind} for ${obj.constructor.name}`
        );
      }
    }
    function serialize(schema, obj, Writer = BinaryWriter) {
      const writer = new Writer();
      serializeStruct(schema, obj, writer);
      return writer.toArray();
    }
    exports2.serialize = serialize;
    function deserializeField(schema, fieldName, fieldType, reader) {
      try {
        if (typeof fieldType === "string") {
          return reader[`read${capitalizeFirstLetter(fieldType)}`]();
        }
        if (fieldType instanceof Array) {
          if (typeof fieldType[0] === "number") {
            return reader.readFixedArray(fieldType[0]);
          } else if (typeof fieldType[1] === "number") {
            const arr = [];
            for (let i = 0; i < fieldType[1]; i++) {
              arr.push(deserializeField(schema, null, fieldType[0], reader));
            }
            return arr;
          } else {
            return reader.readArray(() =>
              deserializeField(schema, fieldName, fieldType[0], reader)
            );
          }
        }
        if (fieldType.kind === "option") {
          const option = reader.readU8();
          if (option) {
            return deserializeField(schema, fieldName, fieldType.type, reader);
          }
          return void 0;
        }
        if (fieldType.kind === "map") {
          let map = /* @__PURE__ */ new Map();
          const length = reader.readU32();
          for (let i = 0; i < length; i++) {
            const key = deserializeField(
              schema,
              fieldName,
              fieldType.key,
              reader
            );
            const val = deserializeField(
              schema,
              fieldName,
              fieldType.value,
              reader
            );
            map.set(key, val);
          }
          return map;
        }
        return deserializeStruct(schema, fieldType, reader);
      } catch (error) {
        if (error instanceof BorshError) {
          error.addToFieldPath(fieldName);
        }
        throw error;
      }
    }
    function deserializeStruct(schema, classType, reader) {
      if (typeof classType.borshDeserialize === "function") {
        return classType.borshDeserialize(reader);
      }
      const structSchema = schema.get(classType);
      if (!structSchema) {
        throw new BorshError(`Class ${classType.name} is missing in schema`);
      }
      if (structSchema.kind === "struct") {
        const result = {};
        for (const [fieldName, fieldType] of schema.get(classType).fields) {
          result[fieldName] = deserializeField(
            schema,
            fieldName,
            fieldType,
            reader
          );
        }
        return new classType(result);
      }
      if (structSchema.kind === "enum") {
        const idx = reader.readU8();
        if (idx >= structSchema.values.length) {
          throw new BorshError(`Enum index: ${idx} is out of range`);
        }
        const [fieldName, fieldType] = structSchema.values[idx];
        const fieldValue = deserializeField(
          schema,
          fieldName,
          fieldType,
          reader
        );
        return new classType({ [fieldName]: fieldValue });
      }
      throw new BorshError(
        `Unexpected schema kind: ${structSchema.kind} for ${classType.constructor.name}`
      );
    }
    function deserialize(schema, classType, buffer, Reader = BinaryReader) {
      const reader = new Reader(buffer);
      const result = deserializeStruct(schema, classType, reader);
      if (reader.offset < buffer.length) {
        throw new BorshError(
          `Unexpected ${
            buffer.length - reader.offset
          } bytes after deserialized data`
        );
      }
      return result;
    }
    exports2.deserialize = deserialize;
    function deserializeUnchecked(
      schema,
      classType,
      buffer,
      Reader = BinaryReader
    ) {
      const reader = new Reader(buffer);
      return deserializeStruct(schema, classType, reader);
    }
    exports2.deserializeUnchecked = deserializeUnchecked;
  },
});

// browser-external:crypto
var require_crypto = __commonJS({
  "browser-external:crypto"(exports2, module2) {
    module2.exports = {};
  },
});

// node_modules/tweetnacl/nacl-fast.js
var require_nacl_fast = __commonJS({
  "node_modules/tweetnacl/nacl-fast.js"(exports2, module2) {
    (function (nacl) {
      var gf = function (init) {
        var i,
          r = new Float64Array(16);
        if (init) for (i = 0; i < init.length; i++) r[i] = init[i];
        return r;
      };
      var randombytes = function () {
        throw new Error("no PRNG");
      };
      var _0 = new Uint8Array(16);
      var _9 = new Uint8Array(32);
      _9[0] = 9;
      var gf0 = gf(),
        gf1 = gf([1]),
        _121665 = gf([56129, 1]),
        D = gf([
          30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585,
          16505, 36039, 65139, 11119, 27886, 20995,
        ]),
        D2 = gf([
          61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171,
          33010, 6542, 64743, 22239, 55772, 9222,
        ]),
        X = gf([
          54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982,
          57905, 49316, 21502, 52590, 14035, 8553,
        ]),
        Y = gf([
          26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214,
          26214, 26214, 26214, 26214, 26214, 26214,
        ]),
        I = gf([
          41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867,
          153, 11085, 57099, 20417, 9344, 11139,
        ]);
      function ts64(x, i, h, l) {
        x[i] = (h >> 24) & 255;
        x[i + 1] = (h >> 16) & 255;
        x[i + 2] = (h >> 8) & 255;
        x[i + 3] = h & 255;
        x[i + 4] = (l >> 24) & 255;
        x[i + 5] = (l >> 16) & 255;
        x[i + 6] = (l >> 8) & 255;
        x[i + 7] = l & 255;
      }
      function vn(x, xi, y, yi, n) {
        var i,
          d = 0;
        for (i = 0; i < n; i++) d |= x[xi + i] ^ y[yi + i];
        return (1 & ((d - 1) >>> 8)) - 1;
      }
      function crypto_verify_16(x, xi, y, yi) {
        return vn(x, xi, y, yi, 16);
      }
      function crypto_verify_32(x, xi, y, yi) {
        return vn(x, xi, y, yi, 32);
      }
      function core_salsa20(o, p, k, c) {
        var j0 =
            (c[0] & 255) |
            ((c[1] & 255) << 8) |
            ((c[2] & 255) << 16) |
            ((c[3] & 255) << 24),
          j1 =
            (k[0] & 255) |
            ((k[1] & 255) << 8) |
            ((k[2] & 255) << 16) |
            ((k[3] & 255) << 24),
          j2 =
            (k[4] & 255) |
            ((k[5] & 255) << 8) |
            ((k[6] & 255) << 16) |
            ((k[7] & 255) << 24),
          j3 =
            (k[8] & 255) |
            ((k[9] & 255) << 8) |
            ((k[10] & 255) << 16) |
            ((k[11] & 255) << 24),
          j4 =
            (k[12] & 255) |
            ((k[13] & 255) << 8) |
            ((k[14] & 255) << 16) |
            ((k[15] & 255) << 24),
          j5 =
            (c[4] & 255) |
            ((c[5] & 255) << 8) |
            ((c[6] & 255) << 16) |
            ((c[7] & 255) << 24),
          j6 =
            (p[0] & 255) |
            ((p[1] & 255) << 8) |
            ((p[2] & 255) << 16) |
            ((p[3] & 255) << 24),
          j7 =
            (p[4] & 255) |
            ((p[5] & 255) << 8) |
            ((p[6] & 255) << 16) |
            ((p[7] & 255) << 24),
          j8 =
            (p[8] & 255) |
            ((p[9] & 255) << 8) |
            ((p[10] & 255) << 16) |
            ((p[11] & 255) << 24),
          j9 =
            (p[12] & 255) |
            ((p[13] & 255) << 8) |
            ((p[14] & 255) << 16) |
            ((p[15] & 255) << 24),
          j10 =
            (c[8] & 255) |
            ((c[9] & 255) << 8) |
            ((c[10] & 255) << 16) |
            ((c[11] & 255) << 24),
          j11 =
            (k[16] & 255) |
            ((k[17] & 255) << 8) |
            ((k[18] & 255) << 16) |
            ((k[19] & 255) << 24),
          j12 =
            (k[20] & 255) |
            ((k[21] & 255) << 8) |
            ((k[22] & 255) << 16) |
            ((k[23] & 255) << 24),
          j13 =
            (k[24] & 255) |
            ((k[25] & 255) << 8) |
            ((k[26] & 255) << 16) |
            ((k[27] & 255) << 24),
          j14 =
            (k[28] & 255) |
            ((k[29] & 255) << 8) |
            ((k[30] & 255) << 16) |
            ((k[31] & 255) << 24),
          j15 =
            (c[12] & 255) |
            ((c[13] & 255) << 8) |
            ((c[14] & 255) << 16) |
            ((c[15] & 255) << 24);
        var x0 = j0,
          x1 = j1,
          x2 = j2,
          x3 = j3,
          x4 = j4,
          x5 = j5,
          x6 = j6,
          x7 = j7,
          x8 = j8,
          x9 = j9,
          x10 = j10,
          x11 = j11,
          x12 = j12,
          x13 = j13,
          x14 = j14,
          x15 = j15,
          u;
        for (var i = 0; i < 20; i += 2) {
          u = (x0 + x12) | 0;
          x4 ^= (u << 7) | (u >>> (32 - 7));
          u = (x4 + x0) | 0;
          x8 ^= (u << 9) | (u >>> (32 - 9));
          u = (x8 + x4) | 0;
          x12 ^= (u << 13) | (u >>> (32 - 13));
          u = (x12 + x8) | 0;
          x0 ^= (u << 18) | (u >>> (32 - 18));
          u = (x5 + x1) | 0;
          x9 ^= (u << 7) | (u >>> (32 - 7));
          u = (x9 + x5) | 0;
          x13 ^= (u << 9) | (u >>> (32 - 9));
          u = (x13 + x9) | 0;
          x1 ^= (u << 13) | (u >>> (32 - 13));
          u = (x1 + x13) | 0;
          x5 ^= (u << 18) | (u >>> (32 - 18));
          u = (x10 + x6) | 0;
          x14 ^= (u << 7) | (u >>> (32 - 7));
          u = (x14 + x10) | 0;
          x2 ^= (u << 9) | (u >>> (32 - 9));
          u = (x2 + x14) | 0;
          x6 ^= (u << 13) | (u >>> (32 - 13));
          u = (x6 + x2) | 0;
          x10 ^= (u << 18) | (u >>> (32 - 18));
          u = (x15 + x11) | 0;
          x3 ^= (u << 7) | (u >>> (32 - 7));
          u = (x3 + x15) | 0;
          x7 ^= (u << 9) | (u >>> (32 - 9));
          u = (x7 + x3) | 0;
          x11 ^= (u << 13) | (u >>> (32 - 13));
          u = (x11 + x7) | 0;
          x15 ^= (u << 18) | (u >>> (32 - 18));
          u = (x0 + x3) | 0;
          x1 ^= (u << 7) | (u >>> (32 - 7));
          u = (x1 + x0) | 0;
          x2 ^= (u << 9) | (u >>> (32 - 9));
          u = (x2 + x1) | 0;
          x3 ^= (u << 13) | (u >>> (32 - 13));
          u = (x3 + x2) | 0;
          x0 ^= (u << 18) | (u >>> (32 - 18));
          u = (x5 + x4) | 0;
          x6 ^= (u << 7) | (u >>> (32 - 7));
          u = (x6 + x5) | 0;
          x7 ^= (u << 9) | (u >>> (32 - 9));
          u = (x7 + x6) | 0;
          x4 ^= (u << 13) | (u >>> (32 - 13));
          u = (x4 + x7) | 0;
          x5 ^= (u << 18) | (u >>> (32 - 18));
          u = (x10 + x9) | 0;
          x11 ^= (u << 7) | (u >>> (32 - 7));
          u = (x11 + x10) | 0;
          x8 ^= (u << 9) | (u >>> (32 - 9));
          u = (x8 + x11) | 0;
          x9 ^= (u << 13) | (u >>> (32 - 13));
          u = (x9 + x8) | 0;
          x10 ^= (u << 18) | (u >>> (32 - 18));
          u = (x15 + x14) | 0;
          x12 ^= (u << 7) | (u >>> (32 - 7));
          u = (x12 + x15) | 0;
          x13 ^= (u << 9) | (u >>> (32 - 9));
          u = (x13 + x12) | 0;
          x14 ^= (u << 13) | (u >>> (32 - 13));
          u = (x14 + x13) | 0;
          x15 ^= (u << 18) | (u >>> (32 - 18));
        }
        x0 = (x0 + j0) | 0;
        x1 = (x1 + j1) | 0;
        x2 = (x2 + j2) | 0;
        x3 = (x3 + j3) | 0;
        x4 = (x4 + j4) | 0;
        x5 = (x5 + j5) | 0;
        x6 = (x6 + j6) | 0;
        x7 = (x7 + j7) | 0;
        x8 = (x8 + j8) | 0;
        x9 = (x9 + j9) | 0;
        x10 = (x10 + j10) | 0;
        x11 = (x11 + j11) | 0;
        x12 = (x12 + j12) | 0;
        x13 = (x13 + j13) | 0;
        x14 = (x14 + j14) | 0;
        x15 = (x15 + j15) | 0;
        o[0] = (x0 >>> 0) & 255;
        o[1] = (x0 >>> 8) & 255;
        o[2] = (x0 >>> 16) & 255;
        o[3] = (x0 >>> 24) & 255;
        o[4] = (x1 >>> 0) & 255;
        o[5] = (x1 >>> 8) & 255;
        o[6] = (x1 >>> 16) & 255;
        o[7] = (x1 >>> 24) & 255;
        o[8] = (x2 >>> 0) & 255;
        o[9] = (x2 >>> 8) & 255;
        o[10] = (x2 >>> 16) & 255;
        o[11] = (x2 >>> 24) & 255;
        o[12] = (x3 >>> 0) & 255;
        o[13] = (x3 >>> 8) & 255;
        o[14] = (x3 >>> 16) & 255;
        o[15] = (x3 >>> 24) & 255;
        o[16] = (x4 >>> 0) & 255;
        o[17] = (x4 >>> 8) & 255;
        o[18] = (x4 >>> 16) & 255;
        o[19] = (x4 >>> 24) & 255;
        o[20] = (x5 >>> 0) & 255;
        o[21] = (x5 >>> 8) & 255;
        o[22] = (x5 >>> 16) & 255;
        o[23] = (x5 >>> 24) & 255;
        o[24] = (x6 >>> 0) & 255;
        o[25] = (x6 >>> 8) & 255;
        o[26] = (x6 >>> 16) & 255;
        o[27] = (x6 >>> 24) & 255;
        o[28] = (x7 >>> 0) & 255;
        o[29] = (x7 >>> 8) & 255;
        o[30] = (x7 >>> 16) & 255;
        o[31] = (x7 >>> 24) & 255;
        o[32] = (x8 >>> 0) & 255;
        o[33] = (x8 >>> 8) & 255;
        o[34] = (x8 >>> 16) & 255;
        o[35] = (x8 >>> 24) & 255;
        o[36] = (x9 >>> 0) & 255;
        o[37] = (x9 >>> 8) & 255;
        o[38] = (x9 >>> 16) & 255;
        o[39] = (x9 >>> 24) & 255;
        o[40] = (x10 >>> 0) & 255;
        o[41] = (x10 >>> 8) & 255;
        o[42] = (x10 >>> 16) & 255;
        o[43] = (x10 >>> 24) & 255;
        o[44] = (x11 >>> 0) & 255;
        o[45] = (x11 >>> 8) & 255;
        o[46] = (x11 >>> 16) & 255;
        o[47] = (x11 >>> 24) & 255;
        o[48] = (x12 >>> 0) & 255;
        o[49] = (x12 >>> 8) & 255;
        o[50] = (x12 >>> 16) & 255;
        o[51] = (x12 >>> 24) & 255;
        o[52] = (x13 >>> 0) & 255;
        o[53] = (x13 >>> 8) & 255;
        o[54] = (x13 >>> 16) & 255;
        o[55] = (x13 >>> 24) & 255;
        o[56] = (x14 >>> 0) & 255;
        o[57] = (x14 >>> 8) & 255;
        o[58] = (x14 >>> 16) & 255;
        o[59] = (x14 >>> 24) & 255;
        o[60] = (x15 >>> 0) & 255;
        o[61] = (x15 >>> 8) & 255;
        o[62] = (x15 >>> 16) & 255;
        o[63] = (x15 >>> 24) & 255;
      }
      function core_hsalsa20(o, p, k, c) {
        var j0 =
            (c[0] & 255) |
            ((c[1] & 255) << 8) |
            ((c[2] & 255) << 16) |
            ((c[3] & 255) << 24),
          j1 =
            (k[0] & 255) |
            ((k[1] & 255) << 8) |
            ((k[2] & 255) << 16) |
            ((k[3] & 255) << 24),
          j2 =
            (k[4] & 255) |
            ((k[5] & 255) << 8) |
            ((k[6] & 255) << 16) |
            ((k[7] & 255) << 24),
          j3 =
            (k[8] & 255) |
            ((k[9] & 255) << 8) |
            ((k[10] & 255) << 16) |
            ((k[11] & 255) << 24),
          j4 =
            (k[12] & 255) |
            ((k[13] & 255) << 8) |
            ((k[14] & 255) << 16) |
            ((k[15] & 255) << 24),
          j5 =
            (c[4] & 255) |
            ((c[5] & 255) << 8) |
            ((c[6] & 255) << 16) |
            ((c[7] & 255) << 24),
          j6 =
            (p[0] & 255) |
            ((p[1] & 255) << 8) |
            ((p[2] & 255) << 16) |
            ((p[3] & 255) << 24),
          j7 =
            (p[4] & 255) |
            ((p[5] & 255) << 8) |
            ((p[6] & 255) << 16) |
            ((p[7] & 255) << 24),
          j8 =
            (p[8] & 255) |
            ((p[9] & 255) << 8) |
            ((p[10] & 255) << 16) |
            ((p[11] & 255) << 24),
          j9 =
            (p[12] & 255) |
            ((p[13] & 255) << 8) |
            ((p[14] & 255) << 16) |
            ((p[15] & 255) << 24),
          j10 =
            (c[8] & 255) |
            ((c[9] & 255) << 8) |
            ((c[10] & 255) << 16) |
            ((c[11] & 255) << 24),
          j11 =
            (k[16] & 255) |
            ((k[17] & 255) << 8) |
            ((k[18] & 255) << 16) |
            ((k[19] & 255) << 24),
          j12 =
            (k[20] & 255) |
            ((k[21] & 255) << 8) |
            ((k[22] & 255) << 16) |
            ((k[23] & 255) << 24),
          j13 =
            (k[24] & 255) |
            ((k[25] & 255) << 8) |
            ((k[26] & 255) << 16) |
            ((k[27] & 255) << 24),
          j14 =
            (k[28] & 255) |
            ((k[29] & 255) << 8) |
            ((k[30] & 255) << 16) |
            ((k[31] & 255) << 24),
          j15 =
            (c[12] & 255) |
            ((c[13] & 255) << 8) |
            ((c[14] & 255) << 16) |
            ((c[15] & 255) << 24);
        var x0 = j0,
          x1 = j1,
          x2 = j2,
          x3 = j3,
          x4 = j4,
          x5 = j5,
          x6 = j6,
          x7 = j7,
          x8 = j8,
          x9 = j9,
          x10 = j10,
          x11 = j11,
          x12 = j12,
          x13 = j13,
          x14 = j14,
          x15 = j15,
          u;
        for (var i = 0; i < 20; i += 2) {
          u = (x0 + x12) | 0;
          x4 ^= (u << 7) | (u >>> (32 - 7));
          u = (x4 + x0) | 0;
          x8 ^= (u << 9) | (u >>> (32 - 9));
          u = (x8 + x4) | 0;
          x12 ^= (u << 13) | (u >>> (32 - 13));
          u = (x12 + x8) | 0;
          x0 ^= (u << 18) | (u >>> (32 - 18));
          u = (x5 + x1) | 0;
          x9 ^= (u << 7) | (u >>> (32 - 7));
          u = (x9 + x5) | 0;
          x13 ^= (u << 9) | (u >>> (32 - 9));
          u = (x13 + x9) | 0;
          x1 ^= (u << 13) | (u >>> (32 - 13));
          u = (x1 + x13) | 0;
          x5 ^= (u << 18) | (u >>> (32 - 18));
          u = (x10 + x6) | 0;
          x14 ^= (u << 7) | (u >>> (32 - 7));
          u = (x14 + x10) | 0;
          x2 ^= (u << 9) | (u >>> (32 - 9));
          u = (x2 + x14) | 0;
          x6 ^= (u << 13) | (u >>> (32 - 13));
          u = (x6 + x2) | 0;
          x10 ^= (u << 18) | (u >>> (32 - 18));
          u = (x15 + x11) | 0;
          x3 ^= (u << 7) | (u >>> (32 - 7));
          u = (x3 + x15) | 0;
          x7 ^= (u << 9) | (u >>> (32 - 9));
          u = (x7 + x3) | 0;
          x11 ^= (u << 13) | (u >>> (32 - 13));
          u = (x11 + x7) | 0;
          x15 ^= (u << 18) | (u >>> (32 - 18));
          u = (x0 + x3) | 0;
          x1 ^= (u << 7) | (u >>> (32 - 7));
          u = (x1 + x0) | 0;
          x2 ^= (u << 9) | (u >>> (32 - 9));
          u = (x2 + x1) | 0;
          x3 ^= (u << 13) | (u >>> (32 - 13));
          u = (x3 + x2) | 0;
          x0 ^= (u << 18) | (u >>> (32 - 18));
          u = (x5 + x4) | 0;
          x6 ^= (u << 7) | (u >>> (32 - 7));
          u = (x6 + x5) | 0;
          x7 ^= (u << 9) | (u >>> (32 - 9));
          u = (x7 + x6) | 0;
          x4 ^= (u << 13) | (u >>> (32 - 13));
          u = (x4 + x7) | 0;
          x5 ^= (u << 18) | (u >>> (32 - 18));
          u = (x10 + x9) | 0;
          x11 ^= (u << 7) | (u >>> (32 - 7));
          u = (x11 + x10) | 0;
          x8 ^= (u << 9) | (u >>> (32 - 9));
          u = (x8 + x11) | 0;
          x9 ^= (u << 13) | (u >>> (32 - 13));
          u = (x9 + x8) | 0;
          x10 ^= (u << 18) | (u >>> (32 - 18));
          u = (x15 + x14) | 0;
          x12 ^= (u << 7) | (u >>> (32 - 7));
          u = (x12 + x15) | 0;
          x13 ^= (u << 9) | (u >>> (32 - 9));
          u = (x13 + x12) | 0;
          x14 ^= (u << 13) | (u >>> (32 - 13));
          u = (x14 + x13) | 0;
          x15 ^= (u << 18) | (u >>> (32 - 18));
        }
        o[0] = (x0 >>> 0) & 255;
        o[1] = (x0 >>> 8) & 255;
        o[2] = (x0 >>> 16) & 255;
        o[3] = (x0 >>> 24) & 255;
        o[4] = (x5 >>> 0) & 255;
        o[5] = (x5 >>> 8) & 255;
        o[6] = (x5 >>> 16) & 255;
        o[7] = (x5 >>> 24) & 255;
        o[8] = (x10 >>> 0) & 255;
        o[9] = (x10 >>> 8) & 255;
        o[10] = (x10 >>> 16) & 255;
        o[11] = (x10 >>> 24) & 255;
        o[12] = (x15 >>> 0) & 255;
        o[13] = (x15 >>> 8) & 255;
        o[14] = (x15 >>> 16) & 255;
        o[15] = (x15 >>> 24) & 255;
        o[16] = (x6 >>> 0) & 255;
        o[17] = (x6 >>> 8) & 255;
        o[18] = (x6 >>> 16) & 255;
        o[19] = (x6 >>> 24) & 255;
        o[20] = (x7 >>> 0) & 255;
        o[21] = (x7 >>> 8) & 255;
        o[22] = (x7 >>> 16) & 255;
        o[23] = (x7 >>> 24) & 255;
        o[24] = (x8 >>> 0) & 255;
        o[25] = (x8 >>> 8) & 255;
        o[26] = (x8 >>> 16) & 255;
        o[27] = (x8 >>> 24) & 255;
        o[28] = (x9 >>> 0) & 255;
        o[29] = (x9 >>> 8) & 255;
        o[30] = (x9 >>> 16) & 255;
        o[31] = (x9 >>> 24) & 255;
      }
      function crypto_core_salsa20(out, inp, k, c) {
        core_salsa20(out, inp, k, c);
      }
      function crypto_core_hsalsa20(out, inp, k, c) {
        core_hsalsa20(out, inp, k, c);
      }
      var sigma = new Uint8Array([
        101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107,
      ]);
      function crypto_stream_salsa20_xor(c, cpos, m, mpos, b, n, k) {
        var z = new Uint8Array(16),
          x = new Uint8Array(64);
        var u, i;
        for (i = 0; i < 16; i++) z[i] = 0;
        for (i = 0; i < 8; i++) z[i] = n[i];
        while (b >= 64) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i = 0; i < 64; i++) c[cpos + i] = m[mpos + i] ^ x[i];
          u = 1;
          for (i = 8; i < 16; i++) {
            u = (u + (z[i] & 255)) | 0;
            z[i] = u & 255;
            u >>>= 8;
          }
          b -= 64;
          cpos += 64;
          mpos += 64;
        }
        if (b > 0) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i = 0; i < b; i++) c[cpos + i] = m[mpos + i] ^ x[i];
        }
        return 0;
      }
      function crypto_stream_salsa20(c, cpos, b, n, k) {
        var z = new Uint8Array(16),
          x = new Uint8Array(64);
        var u, i;
        for (i = 0; i < 16; i++) z[i] = 0;
        for (i = 0; i < 8; i++) z[i] = n[i];
        while (b >= 64) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i = 0; i < 64; i++) c[cpos + i] = x[i];
          u = 1;
          for (i = 8; i < 16; i++) {
            u = (u + (z[i] & 255)) | 0;
            z[i] = u & 255;
            u >>>= 8;
          }
          b -= 64;
          cpos += 64;
        }
        if (b > 0) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i = 0; i < b; i++) c[cpos + i] = x[i];
        }
        return 0;
      }
      function crypto_stream(c, cpos, d, n, k) {
        var s = new Uint8Array(32);
        crypto_core_hsalsa20(s, n, k, sigma);
        var sn = new Uint8Array(8);
        for (var i = 0; i < 8; i++) sn[i] = n[i + 16];
        return crypto_stream_salsa20(c, cpos, d, sn, s);
      }
      function crypto_stream_xor(c, cpos, m, mpos, d, n, k) {
        var s = new Uint8Array(32);
        crypto_core_hsalsa20(s, n, k, sigma);
        var sn = new Uint8Array(8);
        for (var i = 0; i < 8; i++) sn[i] = n[i + 16];
        return crypto_stream_salsa20_xor(c, cpos, m, mpos, d, sn, s);
      }
      var poly1305 = function (key) {
        this.buffer = new Uint8Array(16);
        this.r = new Uint16Array(10);
        this.h = new Uint16Array(10);
        this.pad = new Uint16Array(8);
        this.leftover = 0;
        this.fin = 0;
        var t0, t1, t2, t3, t4, t5, t6, t7;
        t0 = (key[0] & 255) | ((key[1] & 255) << 8);
        this.r[0] = t0 & 8191;
        t1 = (key[2] & 255) | ((key[3] & 255) << 8);
        this.r[1] = ((t0 >>> 13) | (t1 << 3)) & 8191;
        t2 = (key[4] & 255) | ((key[5] & 255) << 8);
        this.r[2] = ((t1 >>> 10) | (t2 << 6)) & 7939;
        t3 = (key[6] & 255) | ((key[7] & 255) << 8);
        this.r[3] = ((t2 >>> 7) | (t3 << 9)) & 8191;
        t4 = (key[8] & 255) | ((key[9] & 255) << 8);
        this.r[4] = ((t3 >>> 4) | (t4 << 12)) & 255;
        this.r[5] = (t4 >>> 1) & 8190;
        t5 = (key[10] & 255) | ((key[11] & 255) << 8);
        this.r[6] = ((t4 >>> 14) | (t5 << 2)) & 8191;
        t6 = (key[12] & 255) | ((key[13] & 255) << 8);
        this.r[7] = ((t5 >>> 11) | (t6 << 5)) & 8065;
        t7 = (key[14] & 255) | ((key[15] & 255) << 8);
        this.r[8] = ((t6 >>> 8) | (t7 << 8)) & 8191;
        this.r[9] = (t7 >>> 5) & 127;
        this.pad[0] = (key[16] & 255) | ((key[17] & 255) << 8);
        this.pad[1] = (key[18] & 255) | ((key[19] & 255) << 8);
        this.pad[2] = (key[20] & 255) | ((key[21] & 255) << 8);
        this.pad[3] = (key[22] & 255) | ((key[23] & 255) << 8);
        this.pad[4] = (key[24] & 255) | ((key[25] & 255) << 8);
        this.pad[5] = (key[26] & 255) | ((key[27] & 255) << 8);
        this.pad[6] = (key[28] & 255) | ((key[29] & 255) << 8);
        this.pad[7] = (key[30] & 255) | ((key[31] & 255) << 8);
      };
      poly1305.prototype.blocks = function (m, mpos, bytes) {
        var hibit = this.fin ? 0 : 1 << 11;
        var t0, t1, t2, t3, t4, t5, t6, t7, c;
        var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;
        var h0 = this.h[0],
          h1 = this.h[1],
          h2 = this.h[2],
          h3 = this.h[3],
          h4 = this.h[4],
          h5 = this.h[5],
          h6 = this.h[6],
          h7 = this.h[7],
          h8 = this.h[8],
          h9 = this.h[9];
        var r0 = this.r[0],
          r1 = this.r[1],
          r2 = this.r[2],
          r3 = this.r[3],
          r4 = this.r[4],
          r5 = this.r[5],
          r6 = this.r[6],
          r7 = this.r[7],
          r8 = this.r[8],
          r9 = this.r[9];
        while (bytes >= 16) {
          t0 = (m[mpos + 0] & 255) | ((m[mpos + 1] & 255) << 8);
          h0 += t0 & 8191;
          t1 = (m[mpos + 2] & 255) | ((m[mpos + 3] & 255) << 8);
          h1 += ((t0 >>> 13) | (t1 << 3)) & 8191;
          t2 = (m[mpos + 4] & 255) | ((m[mpos + 5] & 255) << 8);
          h2 += ((t1 >>> 10) | (t2 << 6)) & 8191;
          t3 = (m[mpos + 6] & 255) | ((m[mpos + 7] & 255) << 8);
          h3 += ((t2 >>> 7) | (t3 << 9)) & 8191;
          t4 = (m[mpos + 8] & 255) | ((m[mpos + 9] & 255) << 8);
          h4 += ((t3 >>> 4) | (t4 << 12)) & 8191;
          h5 += (t4 >>> 1) & 8191;
          t5 = (m[mpos + 10] & 255) | ((m[mpos + 11] & 255) << 8);
          h6 += ((t4 >>> 14) | (t5 << 2)) & 8191;
          t6 = (m[mpos + 12] & 255) | ((m[mpos + 13] & 255) << 8);
          h7 += ((t5 >>> 11) | (t6 << 5)) & 8191;
          t7 = (m[mpos + 14] & 255) | ((m[mpos + 15] & 255) << 8);
          h8 += ((t6 >>> 8) | (t7 << 8)) & 8191;
          h9 += (t7 >>> 5) | hibit;
          c = 0;
          d0 = c;
          d0 += h0 * r0;
          d0 += h1 * (5 * r9);
          d0 += h2 * (5 * r8);
          d0 += h3 * (5 * r7);
          d0 += h4 * (5 * r6);
          c = d0 >>> 13;
          d0 &= 8191;
          d0 += h5 * (5 * r5);
          d0 += h6 * (5 * r4);
          d0 += h7 * (5 * r3);
          d0 += h8 * (5 * r2);
          d0 += h9 * (5 * r1);
          c += d0 >>> 13;
          d0 &= 8191;
          d1 = c;
          d1 += h0 * r1;
          d1 += h1 * r0;
          d1 += h2 * (5 * r9);
          d1 += h3 * (5 * r8);
          d1 += h4 * (5 * r7);
          c = d1 >>> 13;
          d1 &= 8191;
          d1 += h5 * (5 * r6);
          d1 += h6 * (5 * r5);
          d1 += h7 * (5 * r4);
          d1 += h8 * (5 * r3);
          d1 += h9 * (5 * r2);
          c += d1 >>> 13;
          d1 &= 8191;
          d2 = c;
          d2 += h0 * r2;
          d2 += h1 * r1;
          d2 += h2 * r0;
          d2 += h3 * (5 * r9);
          d2 += h4 * (5 * r8);
          c = d2 >>> 13;
          d2 &= 8191;
          d2 += h5 * (5 * r7);
          d2 += h6 * (5 * r6);
          d2 += h7 * (5 * r5);
          d2 += h8 * (5 * r4);
          d2 += h9 * (5 * r3);
          c += d2 >>> 13;
          d2 &= 8191;
          d3 = c;
          d3 += h0 * r3;
          d3 += h1 * r2;
          d3 += h2 * r1;
          d3 += h3 * r0;
          d3 += h4 * (5 * r9);
          c = d3 >>> 13;
          d3 &= 8191;
          d3 += h5 * (5 * r8);
          d3 += h6 * (5 * r7);
          d3 += h7 * (5 * r6);
          d3 += h8 * (5 * r5);
          d3 += h9 * (5 * r4);
          c += d3 >>> 13;
          d3 &= 8191;
          d4 = c;
          d4 += h0 * r4;
          d4 += h1 * r3;
          d4 += h2 * r2;
          d4 += h3 * r1;
          d4 += h4 * r0;
          c = d4 >>> 13;
          d4 &= 8191;
          d4 += h5 * (5 * r9);
          d4 += h6 * (5 * r8);
          d4 += h7 * (5 * r7);
          d4 += h8 * (5 * r6);
          d4 += h9 * (5 * r5);
          c += d4 >>> 13;
          d4 &= 8191;
          d5 = c;
          d5 += h0 * r5;
          d5 += h1 * r4;
          d5 += h2 * r3;
          d5 += h3 * r2;
          d5 += h4 * r1;
          c = d5 >>> 13;
          d5 &= 8191;
          d5 += h5 * r0;
          d5 += h6 * (5 * r9);
          d5 += h7 * (5 * r8);
          d5 += h8 * (5 * r7);
          d5 += h9 * (5 * r6);
          c += d5 >>> 13;
          d5 &= 8191;
          d6 = c;
          d6 += h0 * r6;
          d6 += h1 * r5;
          d6 += h2 * r4;
          d6 += h3 * r3;
          d6 += h4 * r2;
          c = d6 >>> 13;
          d6 &= 8191;
          d6 += h5 * r1;
          d6 += h6 * r0;
          d6 += h7 * (5 * r9);
          d6 += h8 * (5 * r8);
          d6 += h9 * (5 * r7);
          c += d6 >>> 13;
          d6 &= 8191;
          d7 = c;
          d7 += h0 * r7;
          d7 += h1 * r6;
          d7 += h2 * r5;
          d7 += h3 * r4;
          d7 += h4 * r3;
          c = d7 >>> 13;
          d7 &= 8191;
          d7 += h5 * r2;
          d7 += h6 * r1;
          d7 += h7 * r0;
          d7 += h8 * (5 * r9);
          d7 += h9 * (5 * r8);
          c += d7 >>> 13;
          d7 &= 8191;
          d8 = c;
          d8 += h0 * r8;
          d8 += h1 * r7;
          d8 += h2 * r6;
          d8 += h3 * r5;
          d8 += h4 * r4;
          c = d8 >>> 13;
          d8 &= 8191;
          d8 += h5 * r3;
          d8 += h6 * r2;
          d8 += h7 * r1;
          d8 += h8 * r0;
          d8 += h9 * (5 * r9);
          c += d8 >>> 13;
          d8 &= 8191;
          d9 = c;
          d9 += h0 * r9;
          d9 += h1 * r8;
          d9 += h2 * r7;
          d9 += h3 * r6;
          d9 += h4 * r5;
          c = d9 >>> 13;
          d9 &= 8191;
          d9 += h5 * r4;
          d9 += h6 * r3;
          d9 += h7 * r2;
          d9 += h8 * r1;
          d9 += h9 * r0;
          c += d9 >>> 13;
          d9 &= 8191;
          c = ((c << 2) + c) | 0;
          c = (c + d0) | 0;
          d0 = c & 8191;
          c = c >>> 13;
          d1 += c;
          h0 = d0;
          h1 = d1;
          h2 = d2;
          h3 = d3;
          h4 = d4;
          h5 = d5;
          h6 = d6;
          h7 = d7;
          h8 = d8;
          h9 = d9;
          mpos += 16;
          bytes -= 16;
        }
        this.h[0] = h0;
        this.h[1] = h1;
        this.h[2] = h2;
        this.h[3] = h3;
        this.h[4] = h4;
        this.h[5] = h5;
        this.h[6] = h6;
        this.h[7] = h7;
        this.h[8] = h8;
        this.h[9] = h9;
      };
      poly1305.prototype.finish = function (mac, macpos) {
        var g = new Uint16Array(10);
        var c, mask, f, i;
        if (this.leftover) {
          i = this.leftover;
          this.buffer[i++] = 1;
          for (; i < 16; i++) this.buffer[i] = 0;
          this.fin = 1;
          this.blocks(this.buffer, 0, 16);
        }
        c = this.h[1] >>> 13;
        this.h[1] &= 8191;
        for (i = 2; i < 10; i++) {
          this.h[i] += c;
          c = this.h[i] >>> 13;
          this.h[i] &= 8191;
        }
        this.h[0] += c * 5;
        c = this.h[0] >>> 13;
        this.h[0] &= 8191;
        this.h[1] += c;
        c = this.h[1] >>> 13;
        this.h[1] &= 8191;
        this.h[2] += c;
        g[0] = this.h[0] + 5;
        c = g[0] >>> 13;
        g[0] &= 8191;
        for (i = 1; i < 10; i++) {
          g[i] = this.h[i] + c;
          c = g[i] >>> 13;
          g[i] &= 8191;
        }
        g[9] -= 1 << 13;
        mask = (c ^ 1) - 1;
        for (i = 0; i < 10; i++) g[i] &= mask;
        mask = ~mask;
        for (i = 0; i < 10; i++) this.h[i] = (this.h[i] & mask) | g[i];
        this.h[0] = (this.h[0] | (this.h[1] << 13)) & 65535;
        this.h[1] = ((this.h[1] >>> 3) | (this.h[2] << 10)) & 65535;
        this.h[2] = ((this.h[2] >>> 6) | (this.h[3] << 7)) & 65535;
        this.h[3] = ((this.h[3] >>> 9) | (this.h[4] << 4)) & 65535;
        this.h[4] =
          ((this.h[4] >>> 12) | (this.h[5] << 1) | (this.h[6] << 14)) & 65535;
        this.h[5] = ((this.h[6] >>> 2) | (this.h[7] << 11)) & 65535;
        this.h[6] = ((this.h[7] >>> 5) | (this.h[8] << 8)) & 65535;
        this.h[7] = ((this.h[8] >>> 8) | (this.h[9] << 5)) & 65535;
        f = this.h[0] + this.pad[0];
        this.h[0] = f & 65535;
        for (i = 1; i < 8; i++) {
          f = (((this.h[i] + this.pad[i]) | 0) + (f >>> 16)) | 0;
          this.h[i] = f & 65535;
        }
        mac[macpos + 0] = (this.h[0] >>> 0) & 255;
        mac[macpos + 1] = (this.h[0] >>> 8) & 255;
        mac[macpos + 2] = (this.h[1] >>> 0) & 255;
        mac[macpos + 3] = (this.h[1] >>> 8) & 255;
        mac[macpos + 4] = (this.h[2] >>> 0) & 255;
        mac[macpos + 5] = (this.h[2] >>> 8) & 255;
        mac[macpos + 6] = (this.h[3] >>> 0) & 255;
        mac[macpos + 7] = (this.h[3] >>> 8) & 255;
        mac[macpos + 8] = (this.h[4] >>> 0) & 255;
        mac[macpos + 9] = (this.h[4] >>> 8) & 255;
        mac[macpos + 10] = (this.h[5] >>> 0) & 255;
        mac[macpos + 11] = (this.h[5] >>> 8) & 255;
        mac[macpos + 12] = (this.h[6] >>> 0) & 255;
        mac[macpos + 13] = (this.h[6] >>> 8) & 255;
        mac[macpos + 14] = (this.h[7] >>> 0) & 255;
        mac[macpos + 15] = (this.h[7] >>> 8) & 255;
      };
      poly1305.prototype.update = function (m, mpos, bytes) {
        var i, want;
        if (this.leftover) {
          want = 16 - this.leftover;
          if (want > bytes) want = bytes;
          for (i = 0; i < want; i++)
            this.buffer[this.leftover + i] = m[mpos + i];
          bytes -= want;
          mpos += want;
          this.leftover += want;
          if (this.leftover < 16) return;
          this.blocks(this.buffer, 0, 16);
          this.leftover = 0;
        }
        if (bytes >= 16) {
          want = bytes - (bytes % 16);
          this.blocks(m, mpos, want);
          mpos += want;
          bytes -= want;
        }
        if (bytes) {
          for (i = 0; i < bytes; i++)
            this.buffer[this.leftover + i] = m[mpos + i];
          this.leftover += bytes;
        }
      };
      function crypto_onetimeauth(out, outpos, m, mpos, n, k) {
        var s = new poly1305(k);
        s.update(m, mpos, n);
        s.finish(out, outpos);
        return 0;
      }
      function crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {
        var x = new Uint8Array(16);
        crypto_onetimeauth(x, 0, m, mpos, n, k);
        return crypto_verify_16(h, hpos, x, 0);
      }
      function crypto_secretbox(c, m, d, n, k) {
        var i;
        if (d < 32) return -1;
        crypto_stream_xor(c, 0, m, 0, d, n, k);
        crypto_onetimeauth(c, 16, c, 32, d - 32, c);
        for (i = 0; i < 16; i++) c[i] = 0;
        return 0;
      }
      function crypto_secretbox_open(m, c, d, n, k) {
        var i;
        var x = new Uint8Array(32);
        if (d < 32) return -1;
        crypto_stream(x, 0, 32, n, k);
        if (crypto_onetimeauth_verify(c, 16, c, 32, d - 32, x) !== 0) return -1;
        crypto_stream_xor(m, 0, c, 0, d, n, k);
        for (i = 0; i < 32; i++) m[i] = 0;
        return 0;
      }
      function set25519(r, a) {
        var i;
        for (i = 0; i < 16; i++) r[i] = a[i] | 0;
      }
      function car25519(o) {
        var i,
          v,
          c = 1;
        for (i = 0; i < 16; i++) {
          v = o[i] + c + 65535;
          c = Math.floor(v / 65536);
          o[i] = v - c * 65536;
        }
        o[0] += c - 1 + 37 * (c - 1);
      }
      function sel25519(p, q, b) {
        var t,
          c = ~(b - 1);
        for (var i = 0; i < 16; i++) {
          t = c & (p[i] ^ q[i]);
          p[i] ^= t;
          q[i] ^= t;
        }
      }
      function pack25519(o, n) {
        var i, j, b;
        var m = gf(),
          t = gf();
        for (i = 0; i < 16; i++) t[i] = n[i];
        car25519(t);
        car25519(t);
        car25519(t);
        for (j = 0; j < 2; j++) {
          m[0] = t[0] - 65517;
          for (i = 1; i < 15; i++) {
            m[i] = t[i] - 65535 - ((m[i - 1] >> 16) & 1);
            m[i - 1] &= 65535;
          }
          m[15] = t[15] - 32767 - ((m[14] >> 16) & 1);
          b = (m[15] >> 16) & 1;
          m[14] &= 65535;
          sel25519(t, m, 1 - b);
        }
        for (i = 0; i < 16; i++) {
          o[2 * i] = t[i] & 255;
          o[2 * i + 1] = t[i] >> 8;
        }
      }
      function neq25519(a, b) {
        var c = new Uint8Array(32),
          d = new Uint8Array(32);
        pack25519(c, a);
        pack25519(d, b);
        return crypto_verify_32(c, 0, d, 0);
      }
      function par25519(a) {
        var d = new Uint8Array(32);
        pack25519(d, a);
        return d[0] & 1;
      }
      function unpack25519(o, n) {
        var i;
        for (i = 0; i < 16; i++) o[i] = n[2 * i] + (n[2 * i + 1] << 8);
        o[15] &= 32767;
      }
      function A(o, a, b) {
        for (var i = 0; i < 16; i++) o[i] = a[i] + b[i];
      }
      function Z(o, a, b) {
        for (var i = 0; i < 16; i++) o[i] = a[i] - b[i];
      }
      function M(o, a, b) {
        var v,
          c,
          t0 = 0,
          t1 = 0,
          t2 = 0,
          t3 = 0,
          t4 = 0,
          t5 = 0,
          t6 = 0,
          t7 = 0,
          t8 = 0,
          t9 = 0,
          t10 = 0,
          t11 = 0,
          t12 = 0,
          t13 = 0,
          t14 = 0,
          t15 = 0,
          t16 = 0,
          t17 = 0,
          t18 = 0,
          t19 = 0,
          t20 = 0,
          t21 = 0,
          t22 = 0,
          t23 = 0,
          t24 = 0,
          t25 = 0,
          t26 = 0,
          t27 = 0,
          t28 = 0,
          t29 = 0,
          t30 = 0,
          b0 = b[0],
          b1 = b[1],
          b2 = b[2],
          b3 = b[3],
          b4 = b[4],
          b5 = b[5],
          b6 = b[6],
          b7 = b[7],
          b8 = b[8],
          b9 = b[9],
          b10 = b[10],
          b11 = b[11],
          b12 = b[12],
          b13 = b[13],
          b14 = b[14],
          b15 = b[15];
        v = a[0];
        t0 += v * b0;
        t1 += v * b1;
        t2 += v * b2;
        t3 += v * b3;
        t4 += v * b4;
        t5 += v * b5;
        t6 += v * b6;
        t7 += v * b7;
        t8 += v * b8;
        t9 += v * b9;
        t10 += v * b10;
        t11 += v * b11;
        t12 += v * b12;
        t13 += v * b13;
        t14 += v * b14;
        t15 += v * b15;
        v = a[1];
        t1 += v * b0;
        t2 += v * b1;
        t3 += v * b2;
        t4 += v * b3;
        t5 += v * b4;
        t6 += v * b5;
        t7 += v * b6;
        t8 += v * b7;
        t9 += v * b8;
        t10 += v * b9;
        t11 += v * b10;
        t12 += v * b11;
        t13 += v * b12;
        t14 += v * b13;
        t15 += v * b14;
        t16 += v * b15;
        v = a[2];
        t2 += v * b0;
        t3 += v * b1;
        t4 += v * b2;
        t5 += v * b3;
        t6 += v * b4;
        t7 += v * b5;
        t8 += v * b6;
        t9 += v * b7;
        t10 += v * b8;
        t11 += v * b9;
        t12 += v * b10;
        t13 += v * b11;
        t14 += v * b12;
        t15 += v * b13;
        t16 += v * b14;
        t17 += v * b15;
        v = a[3];
        t3 += v * b0;
        t4 += v * b1;
        t5 += v * b2;
        t6 += v * b3;
        t7 += v * b4;
        t8 += v * b5;
        t9 += v * b6;
        t10 += v * b7;
        t11 += v * b8;
        t12 += v * b9;
        t13 += v * b10;
        t14 += v * b11;
        t15 += v * b12;
        t16 += v * b13;
        t17 += v * b14;
        t18 += v * b15;
        v = a[4];
        t4 += v * b0;
        t5 += v * b1;
        t6 += v * b2;
        t7 += v * b3;
        t8 += v * b4;
        t9 += v * b5;
        t10 += v * b6;
        t11 += v * b7;
        t12 += v * b8;
        t13 += v * b9;
        t14 += v * b10;
        t15 += v * b11;
        t16 += v * b12;
        t17 += v * b13;
        t18 += v * b14;
        t19 += v * b15;
        v = a[5];
        t5 += v * b0;
        t6 += v * b1;
        t7 += v * b2;
        t8 += v * b3;
        t9 += v * b4;
        t10 += v * b5;
        t11 += v * b6;
        t12 += v * b7;
        t13 += v * b8;
        t14 += v * b9;
        t15 += v * b10;
        t16 += v * b11;
        t17 += v * b12;
        t18 += v * b13;
        t19 += v * b14;
        t20 += v * b15;
        v = a[6];
        t6 += v * b0;
        t7 += v * b1;
        t8 += v * b2;
        t9 += v * b3;
        t10 += v * b4;
        t11 += v * b5;
        t12 += v * b6;
        t13 += v * b7;
        t14 += v * b8;
        t15 += v * b9;
        t16 += v * b10;
        t17 += v * b11;
        t18 += v * b12;
        t19 += v * b13;
        t20 += v * b14;
        t21 += v * b15;
        v = a[7];
        t7 += v * b0;
        t8 += v * b1;
        t9 += v * b2;
        t10 += v * b3;
        t11 += v * b4;
        t12 += v * b5;
        t13 += v * b6;
        t14 += v * b7;
        t15 += v * b8;
        t16 += v * b9;
        t17 += v * b10;
        t18 += v * b11;
        t19 += v * b12;
        t20 += v * b13;
        t21 += v * b14;
        t22 += v * b15;
        v = a[8];
        t8 += v * b0;
        t9 += v * b1;
        t10 += v * b2;
        t11 += v * b3;
        t12 += v * b4;
        t13 += v * b5;
        t14 += v * b6;
        t15 += v * b7;
        t16 += v * b8;
        t17 += v * b9;
        t18 += v * b10;
        t19 += v * b11;
        t20 += v * b12;
        t21 += v * b13;
        t22 += v * b14;
        t23 += v * b15;
        v = a[9];
        t9 += v * b0;
        t10 += v * b1;
        t11 += v * b2;
        t12 += v * b3;
        t13 += v * b4;
        t14 += v * b5;
        t15 += v * b6;
        t16 += v * b7;
        t17 += v * b8;
        t18 += v * b9;
        t19 += v * b10;
        t20 += v * b11;
        t21 += v * b12;
        t22 += v * b13;
        t23 += v * b14;
        t24 += v * b15;
        v = a[10];
        t10 += v * b0;
        t11 += v * b1;
        t12 += v * b2;
        t13 += v * b3;
        t14 += v * b4;
        t15 += v * b5;
        t16 += v * b6;
        t17 += v * b7;
        t18 += v * b8;
        t19 += v * b9;
        t20 += v * b10;
        t21 += v * b11;
        t22 += v * b12;
        t23 += v * b13;
        t24 += v * b14;
        t25 += v * b15;
        v = a[11];
        t11 += v * b0;
        t12 += v * b1;
        t13 += v * b2;
        t14 += v * b3;
        t15 += v * b4;
        t16 += v * b5;
        t17 += v * b6;
        t18 += v * b7;
        t19 += v * b8;
        t20 += v * b9;
        t21 += v * b10;
        t22 += v * b11;
        t23 += v * b12;
        t24 += v * b13;
        t25 += v * b14;
        t26 += v * b15;
        v = a[12];
        t12 += v * b0;
        t13 += v * b1;
        t14 += v * b2;
        t15 += v * b3;
        t16 += v * b4;
        t17 += v * b5;
        t18 += v * b6;
        t19 += v * b7;
        t20 += v * b8;
        t21 += v * b9;
        t22 += v * b10;
        t23 += v * b11;
        t24 += v * b12;
        t25 += v * b13;
        t26 += v * b14;
        t27 += v * b15;
        v = a[13];
        t13 += v * b0;
        t14 += v * b1;
        t15 += v * b2;
        t16 += v * b3;
        t17 += v * b4;
        t18 += v * b5;
        t19 += v * b6;
        t20 += v * b7;
        t21 += v * b8;
        t22 += v * b9;
        t23 += v * b10;
        t24 += v * b11;
        t25 += v * b12;
        t26 += v * b13;
        t27 += v * b14;
        t28 += v * b15;
        v = a[14];
        t14 += v * b0;
        t15 += v * b1;
        t16 += v * b2;
        t17 += v * b3;
        t18 += v * b4;
        t19 += v * b5;
        t20 += v * b6;
        t21 += v * b7;
        t22 += v * b8;
        t23 += v * b9;
        t24 += v * b10;
        t25 += v * b11;
        t26 += v * b12;
        t27 += v * b13;
        t28 += v * b14;
        t29 += v * b15;
        v = a[15];
        t15 += v * b0;
        t16 += v * b1;
        t17 += v * b2;
        t18 += v * b3;
        t19 += v * b4;
        t20 += v * b5;
        t21 += v * b6;
        t22 += v * b7;
        t23 += v * b8;
        t24 += v * b9;
        t25 += v * b10;
        t26 += v * b11;
        t27 += v * b12;
        t28 += v * b13;
        t29 += v * b14;
        t30 += v * b15;
        t0 += 38 * t16;
        t1 += 38 * t17;
        t2 += 38 * t18;
        t3 += 38 * t19;
        t4 += 38 * t20;
        t5 += 38 * t21;
        t6 += 38 * t22;
        t7 += 38 * t23;
        t8 += 38 * t24;
        t9 += 38 * t25;
        t10 += 38 * t26;
        t11 += 38 * t27;
        t12 += 38 * t28;
        t13 += 38 * t29;
        t14 += 38 * t30;
        c = 1;
        v = t0 + c + 65535;
        c = Math.floor(v / 65536);
        t0 = v - c * 65536;
        v = t1 + c + 65535;
        c = Math.floor(v / 65536);
        t1 = v - c * 65536;
        v = t2 + c + 65535;
        c = Math.floor(v / 65536);
        t2 = v - c * 65536;
        v = t3 + c + 65535;
        c = Math.floor(v / 65536);
        t3 = v - c * 65536;
        v = t4 + c + 65535;
        c = Math.floor(v / 65536);
        t4 = v - c * 65536;
        v = t5 + c + 65535;
        c = Math.floor(v / 65536);
        t5 = v - c * 65536;
        v = t6 + c + 65535;
        c = Math.floor(v / 65536);
        t6 = v - c * 65536;
        v = t7 + c + 65535;
        c = Math.floor(v / 65536);
        t7 = v - c * 65536;
        v = t8 + c + 65535;
        c = Math.floor(v / 65536);
        t8 = v - c * 65536;
        v = t9 + c + 65535;
        c = Math.floor(v / 65536);
        t9 = v - c * 65536;
        v = t10 + c + 65535;
        c = Math.floor(v / 65536);
        t10 = v - c * 65536;
        v = t11 + c + 65535;
        c = Math.floor(v / 65536);
        t11 = v - c * 65536;
        v = t12 + c + 65535;
        c = Math.floor(v / 65536);
        t12 = v - c * 65536;
        v = t13 + c + 65535;
        c = Math.floor(v / 65536);
        t13 = v - c * 65536;
        v = t14 + c + 65535;
        c = Math.floor(v / 65536);
        t14 = v - c * 65536;
        v = t15 + c + 65535;
        c = Math.floor(v / 65536);
        t15 = v - c * 65536;
        t0 += c - 1 + 37 * (c - 1);
        c = 1;
        v = t0 + c + 65535;
        c = Math.floor(v / 65536);
        t0 = v - c * 65536;
        v = t1 + c + 65535;
        c = Math.floor(v / 65536);
        t1 = v - c * 65536;
        v = t2 + c + 65535;
        c = Math.floor(v / 65536);
        t2 = v - c * 65536;
        v = t3 + c + 65535;
        c = Math.floor(v / 65536);
        t3 = v - c * 65536;
        v = t4 + c + 65535;
        c = Math.floor(v / 65536);
        t4 = v - c * 65536;
        v = t5 + c + 65535;
        c = Math.floor(v / 65536);
        t5 = v - c * 65536;
        v = t6 + c + 65535;
        c = Math.floor(v / 65536);
        t6 = v - c * 65536;
        v = t7 + c + 65535;
        c = Math.floor(v / 65536);
        t7 = v - c * 65536;
        v = t8 + c + 65535;
        c = Math.floor(v / 65536);
        t8 = v - c * 65536;
        v = t9 + c + 65535;
        c = Math.floor(v / 65536);
        t9 = v - c * 65536;
        v = t10 + c + 65535;
        c = Math.floor(v / 65536);
        t10 = v - c * 65536;
        v = t11 + c + 65535;
        c = Math.floor(v / 65536);
        t11 = v - c * 65536;
        v = t12 + c + 65535;
        c = Math.floor(v / 65536);
        t12 = v - c * 65536;
        v = t13 + c + 65535;
        c = Math.floor(v / 65536);
        t13 = v - c * 65536;
        v = t14 + c + 65535;
        c = Math.floor(v / 65536);
        t14 = v - c * 65536;
        v = t15 + c + 65535;
        c = Math.floor(v / 65536);
        t15 = v - c * 65536;
        t0 += c - 1 + 37 * (c - 1);
        o[0] = t0;
        o[1] = t1;
        o[2] = t2;
        o[3] = t3;
        o[4] = t4;
        o[5] = t5;
        o[6] = t6;
        o[7] = t7;
        o[8] = t8;
        o[9] = t9;
        o[10] = t10;
        o[11] = t11;
        o[12] = t12;
        o[13] = t13;
        o[14] = t14;
        o[15] = t15;
      }
      function S(o, a) {
        M(o, a, a);
      }
      function inv25519(o, i) {
        var c = gf();
        var a;
        for (a = 0; a < 16; a++) c[a] = i[a];
        for (a = 253; a >= 0; a--) {
          S(c, c);
          if (a !== 2 && a !== 4) M(c, c, i);
        }
        for (a = 0; a < 16; a++) o[a] = c[a];
      }
      function pow2523(o, i) {
        var c = gf();
        var a;
        for (a = 0; a < 16; a++) c[a] = i[a];
        for (a = 250; a >= 0; a--) {
          S(c, c);
          if (a !== 1) M(c, c, i);
        }
        for (a = 0; a < 16; a++) o[a] = c[a];
      }
      function crypto_scalarmult(q, n, p) {
        var z = new Uint8Array(32);
        var x = new Float64Array(80),
          r,
          i;
        var a = gf(),
          b = gf(),
          c = gf(),
          d = gf(),
          e = gf(),
          f = gf();
        for (i = 0; i < 31; i++) z[i] = n[i];
        z[31] = (n[31] & 127) | 64;
        z[0] &= 248;
        unpack25519(x, p);
        for (i = 0; i < 16; i++) {
          b[i] = x[i];
          d[i] = a[i] = c[i] = 0;
        }
        a[0] = d[0] = 1;
        for (i = 254; i >= 0; --i) {
          r = (z[i >>> 3] >>> (i & 7)) & 1;
          sel25519(a, b, r);
          sel25519(c, d, r);
          A(e, a, c);
          Z(a, a, c);
          A(c, b, d);
          Z(b, b, d);
          S(d, e);
          S(f, a);
          M(a, c, a);
          M(c, b, e);
          A(e, a, c);
          Z(a, a, c);
          S(b, a);
          Z(c, d, f);
          M(a, c, _121665);
          A(a, a, d);
          M(c, c, a);
          M(a, d, f);
          M(d, b, x);
          S(b, e);
          sel25519(a, b, r);
          sel25519(c, d, r);
        }
        for (i = 0; i < 16; i++) {
          x[i + 16] = a[i];
          x[i + 32] = c[i];
          x[i + 48] = b[i];
          x[i + 64] = d[i];
        }
        var x32 = x.subarray(32);
        var x16 = x.subarray(16);
        inv25519(x32, x32);
        M(x16, x16, x32);
        pack25519(q, x16);
        return 0;
      }
      function crypto_scalarmult_base(q, n) {
        return crypto_scalarmult(q, n, _9);
      }
      function crypto_box_keypair(y, x) {
        randombytes(x, 32);
        return crypto_scalarmult_base(y, x);
      }
      function crypto_box_beforenm(k, y, x) {
        var s = new Uint8Array(32);
        crypto_scalarmult(s, x, y);
        return crypto_core_hsalsa20(k, _0, s, sigma);
      }
      var crypto_box_afternm = crypto_secretbox;
      var crypto_box_open_afternm = crypto_secretbox_open;
      function crypto_box(c, m, d, n, y, x) {
        var k = new Uint8Array(32);
        crypto_box_beforenm(k, y, x);
        return crypto_box_afternm(c, m, d, n, k);
      }
      function crypto_box_open(m, c, d, n, y, x) {
        var k = new Uint8Array(32);
        crypto_box_beforenm(k, y, x);
        return crypto_box_open_afternm(m, c, d, n, k);
      }
      var K2 = [
        1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399,
        3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265,
        2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394,
        310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994,
        1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317,
        3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139,
        264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901,
        1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837,
        2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879,
        3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901,
        113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964,
        773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823,
        1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142,
        2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273,
        3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344,
        3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720,
        430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593,
        883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403,
        1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012,
        2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044,
        2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573,
        3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711,
        3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554,
        174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315,
        685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100,
        1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866,
        1607167915, 987167468, 1816402316, 1246189591,
      ];
      function crypto_hashblocks_hl(hh, hl, m, n) {
        var wh = new Int32Array(16),
          wl = new Int32Array(16),
          bh0,
          bh1,
          bh2,
          bh3,
          bh4,
          bh5,
          bh6,
          bh7,
          bl0,
          bl1,
          bl2,
          bl3,
          bl4,
          bl5,
          bl6,
          bl7,
          th,
          tl,
          i,
          j,
          h,
          l,
          a,
          b,
          c,
          d;
        var ah0 = hh[0],
          ah1 = hh[1],
          ah2 = hh[2],
          ah3 = hh[3],
          ah4 = hh[4],
          ah5 = hh[5],
          ah6 = hh[6],
          ah7 = hh[7],
          al0 = hl[0],
          al1 = hl[1],
          al2 = hl[2],
          al3 = hl[3],
          al4 = hl[4],
          al5 = hl[5],
          al6 = hl[6],
          al7 = hl[7];
        var pos = 0;
        while (n >= 128) {
          for (i = 0; i < 16; i++) {
            j = 8 * i + pos;
            wh[i] =
              (m[j + 0] << 24) | (m[j + 1] << 16) | (m[j + 2] << 8) | m[j + 3];
            wl[i] =
              (m[j + 4] << 24) | (m[j + 5] << 16) | (m[j + 6] << 8) | m[j + 7];
          }
          for (i = 0; i < 80; i++) {
            bh0 = ah0;
            bh1 = ah1;
            bh2 = ah2;
            bh3 = ah3;
            bh4 = ah4;
            bh5 = ah5;
            bh6 = ah6;
            bh7 = ah7;
            bl0 = al0;
            bl1 = al1;
            bl2 = al2;
            bl3 = al3;
            bl4 = al4;
            bl5 = al5;
            bl6 = al6;
            bl7 = al7;
            h = ah7;
            l = al7;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h =
              ((ah4 >>> 14) | (al4 << (32 - 14))) ^
              ((ah4 >>> 18) | (al4 << (32 - 18))) ^
              ((al4 >>> (41 - 32)) | (ah4 << (32 - (41 - 32))));
            l =
              ((al4 >>> 14) | (ah4 << (32 - 14))) ^
              ((al4 >>> 18) | (ah4 << (32 - 18))) ^
              ((ah4 >>> (41 - 32)) | (al4 << (32 - (41 - 32))));
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = (ah4 & ah5) ^ (~ah4 & ah6);
            l = (al4 & al5) ^ (~al4 & al6);
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = K2[i * 2];
            l = K2[i * 2 + 1];
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = wh[i % 16];
            l = wl[i % 16];
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            th = (c & 65535) | (d << 16);
            tl = (a & 65535) | (b << 16);
            h = th;
            l = tl;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h =
              ((ah0 >>> 28) | (al0 << (32 - 28))) ^
              ((al0 >>> (34 - 32)) | (ah0 << (32 - (34 - 32)))) ^
              ((al0 >>> (39 - 32)) | (ah0 << (32 - (39 - 32))));
            l =
              ((al0 >>> 28) | (ah0 << (32 - 28))) ^
              ((ah0 >>> (34 - 32)) | (al0 << (32 - (34 - 32)))) ^
              ((ah0 >>> (39 - 32)) | (al0 << (32 - (39 - 32))));
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = (ah0 & ah1) ^ (ah0 & ah2) ^ (ah1 & ah2);
            l = (al0 & al1) ^ (al0 & al2) ^ (al1 & al2);
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            bh7 = (c & 65535) | (d << 16);
            bl7 = (a & 65535) | (b << 16);
            h = bh3;
            l = bl3;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = th;
            l = tl;
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            bh3 = (c & 65535) | (d << 16);
            bl3 = (a & 65535) | (b << 16);
            ah1 = bh0;
            ah2 = bh1;
            ah3 = bh2;
            ah4 = bh3;
            ah5 = bh4;
            ah6 = bh5;
            ah7 = bh6;
            ah0 = bh7;
            al1 = bl0;
            al2 = bl1;
            al3 = bl2;
            al4 = bl3;
            al5 = bl4;
            al6 = bl5;
            al7 = bl6;
            al0 = bl7;
            if (i % 16 === 15) {
              for (j = 0; j < 16; j++) {
                h = wh[j];
                l = wl[j];
                a = l & 65535;
                b = l >>> 16;
                c = h & 65535;
                d = h >>> 16;
                h = wh[(j + 9) % 16];
                l = wl[(j + 9) % 16];
                a += l & 65535;
                b += l >>> 16;
                c += h & 65535;
                d += h >>> 16;
                th = wh[(j + 1) % 16];
                tl = wl[(j + 1) % 16];
                h =
                  ((th >>> 1) | (tl << (32 - 1))) ^
                  ((th >>> 8) | (tl << (32 - 8))) ^
                  (th >>> 7);
                l =
                  ((tl >>> 1) | (th << (32 - 1))) ^
                  ((tl >>> 8) | (th << (32 - 8))) ^
                  ((tl >>> 7) | (th << (32 - 7)));
                a += l & 65535;
                b += l >>> 16;
                c += h & 65535;
                d += h >>> 16;
                th = wh[(j + 14) % 16];
                tl = wl[(j + 14) % 16];
                h =
                  ((th >>> 19) | (tl << (32 - 19))) ^
                  ((tl >>> (61 - 32)) | (th << (32 - (61 - 32)))) ^
                  (th >>> 6);
                l =
                  ((tl >>> 19) | (th << (32 - 19))) ^
                  ((th >>> (61 - 32)) | (tl << (32 - (61 - 32)))) ^
                  ((tl >>> 6) | (th << (32 - 6)));
                a += l & 65535;
                b += l >>> 16;
                c += h & 65535;
                d += h >>> 16;
                b += a >>> 16;
                c += b >>> 16;
                d += c >>> 16;
                wh[j] = (c & 65535) | (d << 16);
                wl[j] = (a & 65535) | (b << 16);
              }
            }
          }
          h = ah0;
          l = al0;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[0];
          l = hl[0];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[0] = ah0 = (c & 65535) | (d << 16);
          hl[0] = al0 = (a & 65535) | (b << 16);
          h = ah1;
          l = al1;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[1];
          l = hl[1];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[1] = ah1 = (c & 65535) | (d << 16);
          hl[1] = al1 = (a & 65535) | (b << 16);
          h = ah2;
          l = al2;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[2];
          l = hl[2];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[2] = ah2 = (c & 65535) | (d << 16);
          hl[2] = al2 = (a & 65535) | (b << 16);
          h = ah3;
          l = al3;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[3];
          l = hl[3];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[3] = ah3 = (c & 65535) | (d << 16);
          hl[3] = al3 = (a & 65535) | (b << 16);
          h = ah4;
          l = al4;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[4];
          l = hl[4];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[4] = ah4 = (c & 65535) | (d << 16);
          hl[4] = al4 = (a & 65535) | (b << 16);
          h = ah5;
          l = al5;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[5];
          l = hl[5];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[5] = ah5 = (c & 65535) | (d << 16);
          hl[5] = al5 = (a & 65535) | (b << 16);
          h = ah6;
          l = al6;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[6];
          l = hl[6];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[6] = ah6 = (c & 65535) | (d << 16);
          hl[6] = al6 = (a & 65535) | (b << 16);
          h = ah7;
          l = al7;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[7];
          l = hl[7];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[7] = ah7 = (c & 65535) | (d << 16);
          hl[7] = al7 = (a & 65535) | (b << 16);
          pos += 128;
          n -= 128;
        }
        return n;
      }
      function crypto_hash(out, m, n) {
        var hh = new Int32Array(8),
          hl = new Int32Array(8),
          x = new Uint8Array(256),
          i,
          b = n;
        hh[0] = 1779033703;
        hh[1] = 3144134277;
        hh[2] = 1013904242;
        hh[3] = 2773480762;
        hh[4] = 1359893119;
        hh[5] = 2600822924;
        hh[6] = 528734635;
        hh[7] = 1541459225;
        hl[0] = 4089235720;
        hl[1] = 2227873595;
        hl[2] = 4271175723;
        hl[3] = 1595750129;
        hl[4] = 2917565137;
        hl[5] = 725511199;
        hl[6] = 4215389547;
        hl[7] = 327033209;
        crypto_hashblocks_hl(hh, hl, m, n);
        n %= 128;
        for (i = 0; i < n; i++) x[i] = m[b - n + i];
        x[n] = 128;
        n = 256 - 128 * (n < 112 ? 1 : 0);
        x[n - 9] = 0;
        ts64(x, n - 8, (b / 536870912) | 0, b << 3);
        crypto_hashblocks_hl(hh, hl, x, n);
        for (i = 0; i < 8; i++) ts64(out, 8 * i, hh[i], hl[i]);
        return 0;
      }
      function add(p, q) {
        var a = gf(),
          b = gf(),
          c = gf(),
          d = gf(),
          e = gf(),
          f = gf(),
          g = gf(),
          h = gf(),
          t = gf();
        Z(a, p[1], p[0]);
        Z(t, q[1], q[0]);
        M(a, a, t);
        A(b, p[0], p[1]);
        A(t, q[0], q[1]);
        M(b, b, t);
        M(c, p[3], q[3]);
        M(c, c, D2);
        M(d, p[2], q[2]);
        A(d, d, d);
        Z(e, b, a);
        Z(f, d, c);
        A(g, d, c);
        A(h, b, a);
        M(p[0], e, f);
        M(p[1], h, g);
        M(p[2], g, f);
        M(p[3], e, h);
      }
      function cswap(p, q, b) {
        var i;
        for (i = 0; i < 4; i++) {
          sel25519(p[i], q[i], b);
        }
      }
      function pack(r, p) {
        var tx = gf(),
          ty = gf(),
          zi = gf();
        inv25519(zi, p[2]);
        M(tx, p[0], zi);
        M(ty, p[1], zi);
        pack25519(r, ty);
        r[31] ^= par25519(tx) << 7;
      }
      function scalarmult(p, q, s) {
        var b, i;
        set25519(p[0], gf0);
        set25519(p[1], gf1);
        set25519(p[2], gf1);
        set25519(p[3], gf0);
        for (i = 255; i >= 0; --i) {
          b = (s[(i / 8) | 0] >> (i & 7)) & 1;
          cswap(p, q, b);
          add(q, p);
          add(p, p);
          cswap(p, q, b);
        }
      }
      function scalarbase(p, s) {
        var q = [gf(), gf(), gf(), gf()];
        set25519(q[0], X);
        set25519(q[1], Y);
        set25519(q[2], gf1);
        M(q[3], X, Y);
        scalarmult(p, q, s);
      }
      function crypto_sign_keypair(pk, sk, seeded) {
        var d = new Uint8Array(64);
        var p = [gf(), gf(), gf(), gf()];
        var i;
        if (!seeded) randombytes(sk, 32);
        crypto_hash(d, sk, 32);
        d[0] &= 248;
        d[31] &= 127;
        d[31] |= 64;
        scalarbase(p, d);
        pack(pk, p);
        for (i = 0; i < 32; i++) sk[i + 32] = pk[i];
        return 0;
      }
      var L = new Float64Array([
        237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222,
        20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16,
      ]);
      function modL(r, x) {
        var carry, i, j, k;
        for (i = 63; i >= 32; --i) {
          carry = 0;
          for (j = i - 32, k = i - 12; j < k; ++j) {
            x[j] += carry - 16 * x[i] * L[j - (i - 32)];
            carry = Math.floor((x[j] + 128) / 256);
            x[j] -= carry * 256;
          }
          x[j] += carry;
          x[i] = 0;
        }
        carry = 0;
        for (j = 0; j < 32; j++) {
          x[j] += carry - (x[31] >> 4) * L[j];
          carry = x[j] >> 8;
          x[j] &= 255;
        }
        for (j = 0; j < 32; j++) x[j] -= carry * L[j];
        for (i = 0; i < 32; i++) {
          x[i + 1] += x[i] >> 8;
          r[i] = x[i] & 255;
        }
      }
      function reduce(r) {
        var x = new Float64Array(64),
          i;
        for (i = 0; i < 64; i++) x[i] = r[i];
        for (i = 0; i < 64; i++) r[i] = 0;
        modL(r, x);
      }
      function crypto_sign(sm, m, n, sk) {
        var d = new Uint8Array(64),
          h = new Uint8Array(64),
          r = new Uint8Array(64);
        var i,
          j,
          x = new Float64Array(64);
        var p = [gf(), gf(), gf(), gf()];
        crypto_hash(d, sk, 32);
        d[0] &= 248;
        d[31] &= 127;
        d[31] |= 64;
        var smlen = n + 64;
        for (i = 0; i < n; i++) sm[64 + i] = m[i];
        for (i = 0; i < 32; i++) sm[32 + i] = d[32 + i];
        crypto_hash(r, sm.subarray(32), n + 32);
        reduce(r);
        scalarbase(p, r);
        pack(sm, p);
        for (i = 32; i < 64; i++) sm[i] = sk[i];
        crypto_hash(h, sm, n + 64);
        reduce(h);
        for (i = 0; i < 64; i++) x[i] = 0;
        for (i = 0; i < 32; i++) x[i] = r[i];
        for (i = 0; i < 32; i++) {
          for (j = 0; j < 32; j++) {
            x[i + j] += h[i] * d[j];
          }
        }
        modL(sm.subarray(32), x);
        return smlen;
      }
      function unpackneg(r, p) {
        var t = gf(),
          chk = gf(),
          num = gf(),
          den = gf(),
          den2 = gf(),
          den4 = gf(),
          den6 = gf();
        set25519(r[2], gf1);
        unpack25519(r[1], p);
        S(num, r[1]);
        M(den, num, D);
        Z(num, num, r[2]);
        A(den, r[2], den);
        S(den2, den);
        S(den4, den2);
        M(den6, den4, den2);
        M(t, den6, num);
        M(t, t, den);
        pow2523(t, t);
        M(t, t, num);
        M(t, t, den);
        M(t, t, den);
        M(r[0], t, den);
        S(chk, r[0]);
        M(chk, chk, den);
        if (neq25519(chk, num)) M(r[0], r[0], I);
        S(chk, r[0]);
        M(chk, chk, den);
        if (neq25519(chk, num)) return -1;
        if (par25519(r[0]) === p[31] >> 7) Z(r[0], gf0, r[0]);
        M(r[3], r[0], r[1]);
        return 0;
      }
      function crypto_sign_open(m, sm, n, pk) {
        var i;
        var t = new Uint8Array(32),
          h = new Uint8Array(64);
        var p = [gf(), gf(), gf(), gf()],
          q = [gf(), gf(), gf(), gf()];
        if (n < 64) return -1;
        if (unpackneg(q, pk)) return -1;
        for (i = 0; i < n; i++) m[i] = sm[i];
        for (i = 0; i < 32; i++) m[i + 32] = pk[i];
        crypto_hash(h, m, n);
        reduce(h);
        scalarmult(p, q, h);
        scalarbase(q, sm.subarray(32));
        add(p, q);
        pack(t, p);
        n -= 64;
        if (crypto_verify_32(sm, 0, t, 0)) {
          for (i = 0; i < n; i++) m[i] = 0;
          return -1;
        }
        for (i = 0; i < n; i++) m[i] = sm[i + 64];
        return n;
      }
      var crypto_secretbox_KEYBYTES = 32,
        crypto_secretbox_NONCEBYTES = 24,
        crypto_secretbox_ZEROBYTES = 32,
        crypto_secretbox_BOXZEROBYTES = 16,
        crypto_scalarmult_BYTES = 32,
        crypto_scalarmult_SCALARBYTES = 32,
        crypto_box_PUBLICKEYBYTES = 32,
        crypto_box_SECRETKEYBYTES = 32,
        crypto_box_BEFORENMBYTES = 32,
        crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES,
        crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES,
        crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES,
        crypto_sign_BYTES = 64,
        crypto_sign_PUBLICKEYBYTES = 32,
        crypto_sign_SECRETKEYBYTES = 64,
        crypto_sign_SEEDBYTES = 32,
        crypto_hash_BYTES = 64;
      nacl.lowlevel = {
        crypto_core_hsalsa20,
        crypto_stream_xor,
        crypto_stream,
        crypto_stream_salsa20_xor,
        crypto_stream_salsa20,
        crypto_onetimeauth,
        crypto_onetimeauth_verify,
        crypto_verify_16,
        crypto_verify_32,
        crypto_secretbox,
        crypto_secretbox_open,
        crypto_scalarmult,
        crypto_scalarmult_base,
        crypto_box_beforenm,
        crypto_box_afternm,
        crypto_box,
        crypto_box_open,
        crypto_box_keypair,
        crypto_hash,
        crypto_sign,
        crypto_sign_keypair,
        crypto_sign_open,
        crypto_secretbox_KEYBYTES,
        crypto_secretbox_NONCEBYTES,
        crypto_secretbox_ZEROBYTES,
        crypto_secretbox_BOXZEROBYTES,
        crypto_scalarmult_BYTES,
        crypto_scalarmult_SCALARBYTES,
        crypto_box_PUBLICKEYBYTES,
        crypto_box_SECRETKEYBYTES,
        crypto_box_BEFORENMBYTES,
        crypto_box_NONCEBYTES,
        crypto_box_ZEROBYTES,
        crypto_box_BOXZEROBYTES,
        crypto_sign_BYTES,
        crypto_sign_PUBLICKEYBYTES,
        crypto_sign_SECRETKEYBYTES,
        crypto_sign_SEEDBYTES,
        crypto_hash_BYTES,
        gf,
        D,
        L,
        pack25519,
        unpack25519,
        M,
        A,
        S,
        Z,
        pow2523,
        add,
        set25519,
        modL,
        scalarmult,
        scalarbase,
      };
      function checkLengths(k, n) {
        if (k.length !== crypto_secretbox_KEYBYTES)
          throw new Error("bad key size");
        if (n.length !== crypto_secretbox_NONCEBYTES)
          throw new Error("bad nonce size");
      }
      function checkBoxLengths(pk, sk) {
        if (pk.length !== crypto_box_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        if (sk.length !== crypto_box_SECRETKEYBYTES)
          throw new Error("bad secret key size");
      }
      function checkArrayTypes() {
        for (var i = 0; i < arguments.length; i++) {
          if (!(arguments[i] instanceof Uint8Array))
            throw new TypeError("unexpected type, use Uint8Array");
        }
      }
      function cleanup(arr) {
        for (var i = 0; i < arr.length; i++) arr[i] = 0;
      }
      nacl.randomBytes = function (n) {
        var b = new Uint8Array(n);
        randombytes(b, n);
        return b;
      };
      nacl.secretbox = function (msg, nonce, key) {
        checkArrayTypes(msg, nonce, key);
        checkLengths(key, nonce);
        var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
        var c = new Uint8Array(m.length);
        for (var i = 0; i < msg.length; i++)
          m[i + crypto_secretbox_ZEROBYTES] = msg[i];
        crypto_secretbox(c, m, m.length, nonce, key);
        return c.subarray(crypto_secretbox_BOXZEROBYTES);
      };
      nacl.secretbox.open = function (box, nonce, key) {
        checkArrayTypes(box, nonce, key);
        checkLengths(key, nonce);
        var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
        var m = new Uint8Array(c.length);
        for (var i = 0; i < box.length; i++)
          c[i + crypto_secretbox_BOXZEROBYTES] = box[i];
        if (c.length < 32) return null;
        if (crypto_secretbox_open(m, c, c.length, nonce, key) !== 0)
          return null;
        return m.subarray(crypto_secretbox_ZEROBYTES);
      };
      nacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;
      nacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
      nacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;
      nacl.scalarMult = function (n, p) {
        checkArrayTypes(n, p);
        if (n.length !== crypto_scalarmult_SCALARBYTES)
          throw new Error("bad n size");
        if (p.length !== crypto_scalarmult_BYTES) throw new Error("bad p size");
        var q = new Uint8Array(crypto_scalarmult_BYTES);
        crypto_scalarmult(q, n, p);
        return q;
      };
      nacl.scalarMult.base = function (n) {
        checkArrayTypes(n);
        if (n.length !== crypto_scalarmult_SCALARBYTES)
          throw new Error("bad n size");
        var q = new Uint8Array(crypto_scalarmult_BYTES);
        crypto_scalarmult_base(q, n);
        return q;
      };
      nacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
      nacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;
      nacl.box = function (msg, nonce, publicKey, secretKey) {
        var k = nacl.box.before(publicKey, secretKey);
        return nacl.secretbox(msg, nonce, k);
      };
      nacl.box.before = function (publicKey, secretKey) {
        checkArrayTypes(publicKey, secretKey);
        checkBoxLengths(publicKey, secretKey);
        var k = new Uint8Array(crypto_box_BEFORENMBYTES);
        crypto_box_beforenm(k, publicKey, secretKey);
        return k;
      };
      nacl.box.after = nacl.secretbox;
      nacl.box.open = function (msg, nonce, publicKey, secretKey) {
        var k = nacl.box.before(publicKey, secretKey);
        return nacl.secretbox.open(msg, nonce, k);
      };
      nacl.box.open.after = nacl.secretbox.open;
      nacl.box.keyPair = function () {
        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
        crypto_box_keypair(pk, sk);
        return { publicKey: pk, secretKey: sk };
      };
      nacl.box.keyPair.fromSecretKey = function (secretKey) {
        checkArrayTypes(secretKey);
        if (secretKey.length !== crypto_box_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
        crypto_scalarmult_base(pk, secretKey);
        return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
      };
      nacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
      nacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
      nacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
      nacl.box.nonceLength = crypto_box_NONCEBYTES;
      nacl.box.overheadLength = nacl.secretbox.overheadLength;
      nacl.sign = function (msg, secretKey) {
        checkArrayTypes(msg, secretKey);
        if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var signedMsg = new Uint8Array(crypto_sign_BYTES + msg.length);
        crypto_sign(signedMsg, msg, msg.length, secretKey);
        return signedMsg;
      };
      nacl.sign.open = function (signedMsg, publicKey) {
        checkArrayTypes(signedMsg, publicKey);
        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        var tmp = new Uint8Array(signedMsg.length);
        var mlen = crypto_sign_open(
          tmp,
          signedMsg,
          signedMsg.length,
          publicKey
        );
        if (mlen < 0) return null;
        var m = new Uint8Array(mlen);
        for (var i = 0; i < m.length; i++) m[i] = tmp[i];
        return m;
      };
      nacl.sign.detached = function (msg, secretKey) {
        var signedMsg = nacl.sign(msg, secretKey);
        var sig = new Uint8Array(crypto_sign_BYTES);
        for (var i = 0; i < sig.length; i++) sig[i] = signedMsg[i];
        return sig;
      };
      nacl.sign.detached.verify = function (msg, sig, publicKey) {
        checkArrayTypes(msg, sig, publicKey);
        if (sig.length !== crypto_sign_BYTES)
          throw new Error("bad signature size");
        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
        var m = new Uint8Array(crypto_sign_BYTES + msg.length);
        var i;
        for (i = 0; i < crypto_sign_BYTES; i++) sm[i] = sig[i];
        for (i = 0; i < msg.length; i++) sm[i + crypto_sign_BYTES] = msg[i];
        return crypto_sign_open(m, sm, sm.length, publicKey) >= 0;
      };
      nacl.sign.keyPair = function () {
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
        crypto_sign_keypair(pk, sk);
        return { publicKey: pk, secretKey: sk };
      };
      nacl.sign.keyPair.fromSecretKey = function (secretKey) {
        checkArrayTypes(secretKey);
        if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        for (var i = 0; i < pk.length; i++) pk[i] = secretKey[32 + i];
        return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
      };
      nacl.sign.keyPair.fromSeed = function (seed) {
        checkArrayTypes(seed);
        if (seed.length !== crypto_sign_SEEDBYTES)
          throw new Error("bad seed size");
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
        for (var i = 0; i < 32; i++) sk[i] = seed[i];
        crypto_sign_keypair(pk, sk, true);
        return { publicKey: pk, secretKey: sk };
      };
      nacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
      nacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
      nacl.sign.seedLength = crypto_sign_SEEDBYTES;
      nacl.sign.signatureLength = crypto_sign_BYTES;
      nacl.hash = function (msg) {
        checkArrayTypes(msg);
        var h = new Uint8Array(crypto_hash_BYTES);
        crypto_hash(h, msg, msg.length);
        return h;
      };
      nacl.hash.hashLength = crypto_hash_BYTES;
      nacl.verify = function (x, y) {
        checkArrayTypes(x, y);
        if (x.length === 0 || y.length === 0) return false;
        if (x.length !== y.length) return false;
        return vn(x, 0, y, 0, x.length) === 0 ? true : false;
      };
      nacl.setPRNG = function (fn) {
        randombytes = fn;
      };
      (function () {
        var crypto2 =
          typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
        if (crypto2 && crypto2.getRandomValues) {
          var QUOTA = 65536;
          nacl.setPRNG(function (x, n) {
            var i,
              v = new Uint8Array(n);
            for (i = 0; i < n; i += QUOTA) {
              crypto2.getRandomValues(
                v.subarray(i, i + Math.min(n - i, QUOTA))
              );
            }
            for (i = 0; i < n; i++) x[i] = v[i];
            cleanup(v);
          });
        } else if (typeof __require !== "undefined") {
          crypto2 = require_crypto();
          if (crypto2 && crypto2.randomBytes) {
            nacl.setPRNG(function (x, n) {
              var i,
                v = crypto2.randomBytes(n);
              for (i = 0; i < n; i++) x[i] = v[i];
              cleanup(v);
            });
          }
        }
      })();
    })(
      typeof module2 !== "undefined" && module2.exports
        ? module2.exports
        : (self.nacl = self.nacl || {})
    );
  },
});

// node_modules/@near-js/types/lib/assignable.js
var require_assignable = __commonJS({
  "node_modules/@near-js/types/lib/assignable.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Assignable = void 0;
    var Assignable = class {
      constructor(properties) {
        Object.keys(properties).map((key) => {
          this[key] = properties[key];
        });
      }
    };
    exports2.Assignable = Assignable;
  },
});

// node_modules/@near-js/types/lib/errors.js
var require_errors = __commonJS({
  "node_modules/@near-js/types/lib/errors.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ErrorContext =
      exports2.TypedError =
      exports2.ArgumentTypeError =
      exports2.PositionalArgsError =
        void 0;
    var PositionalArgsError = class extends Error {
      constructor() {
        super(
          "Contract method calls expect named arguments wrapped in object, e.g. { argName1: argValue1, argName2: argValue2 }"
        );
      }
    };
    exports2.PositionalArgsError = PositionalArgsError;
    var ArgumentTypeError = class extends Error {
      constructor(argName, argType, argValue) {
        super(
          `Expected ${argType} for '${argName}' argument, but got '${JSON.stringify(
            argValue
          )}'`
        );
      }
    };
    exports2.ArgumentTypeError = ArgumentTypeError;
    var TypedError = class extends Error {
      constructor(message, type, context) {
        super(message);
        this.type = type || "UntypedError";
        this.context = context;
      }
    };
    exports2.TypedError = TypedError;
    var ErrorContext = class {
      constructor(transactionHash) {
        this.transactionHash = transactionHash;
      }
    };
    exports2.ErrorContext = ErrorContext;
  },
});

// node_modules/@near-js/types/lib/provider/light_client.js
var require_light_client = __commonJS({
  "node_modules/@near-js/types/lib/provider/light_client.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IdType = void 0;
    (function (IdType2) {
      IdType2["Transaction"] = "transaction";
      IdType2["Receipt"] = "receipt";
    })(exports2.IdType || (exports2.IdType = {}));
  },
});

// node_modules/@near-js/types/lib/provider/response.js
var require_response = __commonJS({
  "node_modules/@near-js/types/lib/provider/response.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FinalExecutionStatusBasic = exports2.ExecutionStatusBasic = void 0;
    (function (ExecutionStatusBasic2) {
      ExecutionStatusBasic2["Unknown"] = "Unknown";
      ExecutionStatusBasic2["Pending"] = "Pending";
      ExecutionStatusBasic2["Failure"] = "Failure";
    })(exports2.ExecutionStatusBasic || (exports2.ExecutionStatusBasic = {}));
    (function (FinalExecutionStatusBasic2) {
      FinalExecutionStatusBasic2["NotStarted"] = "NotStarted";
      FinalExecutionStatusBasic2["Started"] = "Started";
      FinalExecutionStatusBasic2["Failure"] = "Failure";
    })(
      exports2.FinalExecutionStatusBasic ||
        (exports2.FinalExecutionStatusBasic = {})
    );
  },
});

// node_modules/@near-js/types/lib/provider/index.js
var require_provider = __commonJS({
  "node_modules/@near-js/types/lib/provider/index.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FinalExecutionStatusBasic =
      exports2.ExecutionStatusBasic =
      exports2.IdType =
        void 0;
    var light_client_1 = require_light_client();
    Object.defineProperty(exports2, "IdType", {
      enumerable: true,
      get: function () {
        return light_client_1.IdType;
      },
    });
    var response_1 = require_response();
    Object.defineProperty(exports2, "ExecutionStatusBasic", {
      enumerable: true,
      get: function () {
        return response_1.ExecutionStatusBasic;
      },
    });
    Object.defineProperty(exports2, "FinalExecutionStatusBasic", {
      enumerable: true,
      get: function () {
        return response_1.FinalExecutionStatusBasic;
      },
    });
  },
});

// node_modules/@near-js/types/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/@near-js/types/lib/index.js"(exports2) {
    var __createBinding =
      (exports2 && exports2.__createBinding) ||
      (Object.create
        ? function (o, m, k, k2) {
            if (k2 === void 0) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);
            if (
              !desc ||
              ("get" in desc
                ? !m.__esModule
                : desc.writable || desc.configurable)
            ) {
              desc = {
                enumerable: true,
                get: function () {
                  return m[k];
                },
              };
            }
            Object.defineProperty(o, k2, desc);
          }
        : function (o, m, k, k2) {
            if (k2 === void 0) k2 = k;
            o[k2] = m[k];
          });
    var __exportStar =
      (exports2 && exports2.__exportStar) ||
      function (m, exports3) {
        for (var p in m)
          if (
            p !== "default" &&
            !Object.prototype.hasOwnProperty.call(exports3, p)
          )
            __createBinding(exports3, m, p);
      };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_assignable(), exports2);
    __exportStar(require_errors(), exports2);
    __exportStar(require_provider(), exports2);
  },
});

// node_modules/@near-js/crypto/lib/public_key.js
var require_public_key = __commonJS({
  "node_modules/@near-js/crypto/lib/public_key.js"(exports2) {
    var __importDefault =
      (exports2 && exports2.__importDefault) ||
      function (mod) {
        return mod && mod.__esModule ? mod : { default: mod };
      };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PublicKey = void 0;
    var types_1 = require_lib2();
    var borsh_1 = require_lib();
    var tweetnacl_1 = __importDefault(require_nacl_fast());
    var constants_1 = require_constants();
    function key_type_to_str(keyType) {
      switch (keyType) {
        case constants_1.KeyType.ED25519:
          return "ed25519";
        default:
          throw new Error(`Unknown key type ${keyType}`);
      }
    }
    function str_to_key_type(keyType) {
      switch (keyType.toLowerCase()) {
        case "ed25519":
          return constants_1.KeyType.ED25519;
        default:
          throw new Error(`Unknown key type ${keyType}`);
      }
    }
    var PublicKey = class _PublicKey extends types_1.Assignable {
      static from(value) {
        if (typeof value === "string") {
          return _PublicKey.fromString(value);
        }
        return value;
      }
      static fromString(encodedKey) {
        const parts = encodedKey.split(":");
        let publicKey;
        let keyType = constants_1.KeyType.ED25519;
        if (parts.length === 1) {
          publicKey = parts[0];
        } else if (parts.length === 2) {
          publicKey = parts[1];
          keyType = str_to_key_type(parts[0]);
        } else {
          throw new Error(
            "Invalid encoded key format, must be <curve>:<encoded key>"
          );
        }
        const decodedPublicKey = (0, borsh_1.baseDecode)(publicKey);
        if (
          decodedPublicKey.length !== tweetnacl_1.default.box.publicKeyLength
        ) {
          throw new Error(
            `Invalid public key size (${decodedPublicKey.length}), must be ${tweetnacl_1.default.box.publicKeyLength}`
          );
        }
        return new _PublicKey({ keyType, data: decodedPublicKey });
      }
      toString() {
        return `${key_type_to_str(this.keyType)}:${(0, borsh_1.baseEncode)(
          this.data
        )}`;
      }
      verify(message, signature) {
        switch (this.keyType) {
          case constants_1.KeyType.ED25519:
            return tweetnacl_1.default.sign.detached.verify(
              message,
              signature,
              this.data
            );
          default:
            throw new Error(`Unknown key type ${this.keyType}`);
        }
      }
    };
    exports2.PublicKey = PublicKey;
  },
});

// node_modules/@near-js/crypto/lib/key_pair_ed25519.js
var require_key_pair_ed25519 = __commonJS({
  "node_modules/@near-js/crypto/lib/key_pair_ed25519.js"(exports2) {
    var __importDefault =
      (exports2 && exports2.__importDefault) ||
      function (mod) {
        return mod && mod.__esModule ? mod : { default: mod };
      };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.KeyPairEd25519 = void 0;
    var borsh_1 = require_lib();
    var tweetnacl_1 = __importDefault(require_nacl_fast());
    var constants_1 = require_constants();
    var key_pair_base_1 = require_key_pair_base();
    var public_key_1 = require_public_key();
    var KeyPairEd25519 = class _KeyPairEd25519 extends key_pair_base_1.KeyPairBase {
      /**
       * Construct an instance of key pair given a secret key.
       * It's generally assumed that these are encoded in base58.
       * @param {string} secretKey
       */
      constructor(secretKey) {
        super();
        const keyPair = tweetnacl_1.default.sign.keyPair.fromSecretKey(
          (0, borsh_1.baseDecode)(secretKey)
        );
        this.publicKey = new public_key_1.PublicKey({
          keyType: constants_1.KeyType.ED25519,
          data: keyPair.publicKey,
        });
        this.secretKey = secretKey;
      }
      /**
       * Generate a new random keypair.
       * @example
       * const keyRandom = KeyPair.fromRandom();
       * keyRandom.publicKey
       * // returns [PUBLIC_KEY]
       *
       * keyRandom.secretKey
       * // returns [SECRET_KEY]
       */
      static fromRandom() {
        const newKeyPair = tweetnacl_1.default.sign.keyPair();
        return new _KeyPairEd25519(
          (0, borsh_1.baseEncode)(newKeyPair.secretKey)
        );
      }
      sign(message) {
        const signature = tweetnacl_1.default.sign.detached(
          message,
          (0, borsh_1.baseDecode)(this.secretKey)
        );
        return { signature, publicKey: this.publicKey };
      }
      verify(message, signature) {
        return this.publicKey.verify(message, signature);
      }
      toString() {
        return `ed25519:${this.secretKey}`;
      }
      getPublicKey() {
        return this.publicKey;
      }
    };
    exports2.KeyPairEd25519 = KeyPairEd25519;
  },
});

// node_modules/@near-js/crypto/lib/key_pair.js
var require_key_pair = __commonJS({
  "node_modules/@near-js/crypto/lib/key_pair.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.KeyPair = void 0;
    var key_pair_base_1 = require_key_pair_base();
    var key_pair_ed25519_1 = require_key_pair_ed25519();
    var KeyPair = class extends key_pair_base_1.KeyPairBase {
      /**
       * @param curve Name of elliptical curve, case-insensitive
       * @returns Random KeyPair based on the curve
       */
      static fromRandom(curve) {
        switch (curve.toUpperCase()) {
          case "ED25519":
            return key_pair_ed25519_1.KeyPairEd25519.fromRandom();
          default:
            throw new Error(`Unknown curve ${curve}`);
        }
      }
      static fromString(encodedKey) {
        const parts = encodedKey.split(":");
        if (parts.length === 1) {
          return new key_pair_ed25519_1.KeyPairEd25519(parts[0]);
        } else if (parts.length === 2) {
          switch (parts[0].toUpperCase()) {
            case "ED25519":
              return new key_pair_ed25519_1.KeyPairEd25519(parts[1]);
            default:
              throw new Error(`Unknown curve: ${parts[0]}`);
          }
        } else {
          throw new Error(
            "Invalid encoded key format, must be <curve>:<encoded key>"
          );
        }
      }
    };
    exports2.KeyPair = KeyPair;
  },
});

// node_modules/@near-js/crypto/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/@near-js/crypto/lib/index.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PublicKey =
      exports2.KeyPairEd25519 =
      exports2.KeyPair =
      exports2.KeyType =
        void 0;
    var constants_1 = require_constants();
    Object.defineProperty(exports2, "KeyType", {
      enumerable: true,
      get: function () {
        return constants_1.KeyType;
      },
    });
    var key_pair_1 = require_key_pair();
    Object.defineProperty(exports2, "KeyPair", {
      enumerable: true,
      get: function () {
        return key_pair_1.KeyPair;
      },
    });
    var key_pair_ed25519_1 = require_key_pair_ed25519();
    Object.defineProperty(exports2, "KeyPairEd25519", {
      enumerable: true,
      get: function () {
        return key_pair_ed25519_1.KeyPairEd25519;
      },
    });
    var public_key_1 = require_public_key();
    Object.defineProperty(exports2, "PublicKey", {
      enumerable: true,
      get: function () {
        return public_key_1.PublicKey;
      },
    });
  },
});

// node_modules/@near-js/keystores/lib/keystore.js
var require_keystore = __commonJS({
  "node_modules/@near-js/keystores/lib/keystore.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.KeyStore = void 0;
    var KeyStore = class {};
    exports2.KeyStore = KeyStore;
  },
});

// node_modules/@near-js/keystores/lib/in_memory_key_store.js
var require_in_memory_key_store = __commonJS({
  "node_modules/@near-js/keystores/lib/in_memory_key_store.js"(exports2) {
    var __awaiter =
      (exports2 && exports2.__awaiter) ||
      function (thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P
            ? value
            : new P(function (resolve) {
                resolve(value);
              });
        }
        return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done
              ? resolve(result.value)
              : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InMemoryKeyStore = void 0;
    var crypto_1 = require_lib3();
    var keystore_1 = require_keystore();
    var InMemoryKeyStore = class extends keystore_1.KeyStore {
      constructor() {
        super();
        this.keys = {};
      }
      /**
       * Stores a {@link utils/key_pair!KeyPair} in in-memory storage item
       * @param networkId The targeted network. (ex. default, betanet, etc)
       * @param accountId The NEAR account tied to the key pair
       * @param keyPair The key pair to store in local storage
       */
      setKey(networkId, accountId, keyPair) {
        return __awaiter(this, void 0, void 0, function* () {
          this.keys[`${accountId}:${networkId}`] = keyPair.toString();
        });
      }
      /**
       * Gets a {@link utils/key_pair!KeyPair} from in-memory storage
       * @param networkId The targeted network. (ex. default, betanet, etc)
       * @param accountId The NEAR account tied to the key pair
       * @returns {Promise<KeyPair>}
       */
      getKey(networkId, accountId) {
        return __awaiter(this, void 0, void 0, function* () {
          const value = this.keys[`${accountId}:${networkId}`];
          if (!value) {
            return null;
          }
          return crypto_1.KeyPair.fromString(value);
        });
      }
      /**
       * Removes a {@link utils/key_pair!KeyPair} from in-memory storage
       * @param networkId The targeted network. (ex. default, betanet, etc)
       * @param accountId The NEAR account tied to the key pair
       */
      removeKey(networkId, accountId) {
        return __awaiter(this, void 0, void 0, function* () {
          delete this.keys[`${accountId}:${networkId}`];
        });
      }
      /**
       * Removes all {@link utils/key_pair!KeyPair} from in-memory storage
       */
      clear() {
        return __awaiter(this, void 0, void 0, function* () {
          this.keys = {};
        });
      }
      /**
       * Get the network(s) from in-memory storage
       * @returns {Promise<string[]>}
       */
      getNetworks() {
        return __awaiter(this, void 0, void 0, function* () {
          const result = /* @__PURE__ */ new Set();
          Object.keys(this.keys).forEach((key) => {
            const parts = key.split(":");
            result.add(parts[1]);
          });
          return Array.from(result.values());
        });
      }
      /**
       * Gets the account(s) from in-memory storage
       * @param networkId The targeted network. (ex. default, betanet, etc)
       */
      getAccounts(networkId) {
        return __awaiter(this, void 0, void 0, function* () {
          const result = new Array();
          Object.keys(this.keys).forEach((key) => {
            const parts = key.split(":");
            if (parts[parts.length - 1] === networkId) {
              result.push(parts.slice(0, parts.length - 1).join(":"));
            }
          });
          return result;
        });
      }
      /** @hidden */
      toString() {
        return "InMemoryKeyStore";
      }
    };
    exports2.InMemoryKeyStore = InMemoryKeyStore;
  },
});

// node_modules/@near-js/keystores/lib/merge_key_store.js
var require_merge_key_store = __commonJS({
  "node_modules/@near-js/keystores/lib/merge_key_store.js"(exports2) {
    var __awaiter =
      (exports2 && exports2.__awaiter) ||
      function (thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P
            ? value
            : new P(function (resolve) {
                resolve(value);
              });
        }
        return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done
              ? resolve(result.value)
              : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MergeKeyStore = void 0;
    var keystore_1 = require_keystore();
    var MergeKeyStore = class extends keystore_1.KeyStore {
      /**
       * @param keyStores read calls are attempted from start to end of array
       * @param options.writeKeyStoreIndex the keystore index that will receive all write calls
       */
      constructor(keyStores, options = { writeKeyStoreIndex: 0 }) {
        super();
        this.options = options;
        this.keyStores = keyStores;
      }
      /**
       * Store a {@link utils/key_pair!KeyPair} to the first index of a key store array
       * @param networkId The targeted network. (ex. default, betanet, etc)
       * @param accountId The NEAR account tied to the key pair
       * @param keyPair The key pair to store in local storage
       */
      setKey(networkId, accountId, keyPair) {
        return __awaiter(this, void 0, void 0, function* () {
          yield this.keyStores[this.options.writeKeyStoreIndex].setKey(
            networkId,
            accountId,
            keyPair
          );
        });
      }
      /**
       * Gets a {@link utils/key_pair!KeyPair} from the array of key stores
       * @param networkId The targeted network. (ex. default, betanet, etc)
       * @param accountId The NEAR account tied to the key pair
       * @returns {Promise<KeyPair>}
       */
      getKey(networkId, accountId) {
        return __awaiter(this, void 0, void 0, function* () {
          for (const keyStore of this.keyStores) {
            const keyPair = yield keyStore.getKey(networkId, accountId);
            if (keyPair) {
              return keyPair;
            }
          }
          return null;
        });
      }
      /**
       * Removes a {@link utils/key_pair!KeyPair} from the array of key stores
       * @param networkId The targeted network. (ex. default, betanet, etc)
       * @param accountId The NEAR account tied to the key pair
       */
      removeKey(networkId, accountId) {
        return __awaiter(this, void 0, void 0, function* () {
          for (const keyStore of this.keyStores) {
            yield keyStore.removeKey(networkId, accountId);
          }
        });
      }
      /**
       * Removes all items from each key store
       */
      clear() {
        return __awaiter(this, void 0, void 0, function* () {
          for (const keyStore of this.keyStores) {
            yield keyStore.clear();
          }
        });
      }
      /**
       * Get the network(s) from the array of key stores
       * @returns {Promise<string[]>}
       */
      getNetworks() {
        return __awaiter(this, void 0, void 0, function* () {
          const result = /* @__PURE__ */ new Set();
          for (const keyStore of this.keyStores) {
            for (const network of yield keyStore.getNetworks()) {
              result.add(network);
            }
          }
          return Array.from(result);
        });
      }
      /**
       * Gets the account(s) from the array of key stores
       * @param networkId The targeted network. (ex. default, betanet, etc)
       */
      getAccounts(networkId) {
        return __awaiter(this, void 0, void 0, function* () {
          const result = /* @__PURE__ */ new Set();
          for (const keyStore of this.keyStores) {
            for (const account of yield keyStore.getAccounts(networkId)) {
              result.add(account);
            }
          }
          return Array.from(result);
        });
      }
      /** @hidden */
      toString() {
        return `MergeKeyStore(${this.keyStores.join(", ")})`;
      }
    };
    exports2.MergeKeyStore = MergeKeyStore;
  },
});

// node_modules/@near-js/keystores/lib/index.js
var require_lib4 = __commonJS({
  "node_modules/@near-js/keystores/lib/index.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MergeKeyStore =
      exports2.KeyStore =
      exports2.InMemoryKeyStore =
        void 0;
    var in_memory_key_store_1 = require_in_memory_key_store();
    Object.defineProperty(exports2, "InMemoryKeyStore", {
      enumerable: true,
      get: function () {
        return in_memory_key_store_1.InMemoryKeyStore;
      },
    });
    var keystore_1 = require_keystore();
    Object.defineProperty(exports2, "KeyStore", {
      enumerable: true,
      get: function () {
        return keystore_1.KeyStore;
      },
    });
    var merge_key_store_1 = require_merge_key_store();
    Object.defineProperty(exports2, "MergeKeyStore", {
      enumerable: true,
      get: function () {
        return merge_key_store_1.MergeKeyStore;
      },
    });
  },
});

// node_modules/near-api-js/lib/key_stores/keystore.js
var require_keystore2 = __commonJS({
  "node_modules/near-api-js/lib/key_stores/keystore.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.KeyStore = void 0;
    var keystores_1 = require_lib4();
    Object.defineProperty(exports2, "KeyStore", {
      enumerable: true,
      get: function () {
        return keystores_1.KeyStore;
      },
    });
  },
});

// node_modules/near-api-js/lib/key_stores/in_memory_key_store.js
var require_in_memory_key_store2 = __commonJS({
  "node_modules/near-api-js/lib/key_stores/in_memory_key_store.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InMemoryKeyStore = void 0;
    var keystores_1 = require_lib4();
    Object.defineProperty(exports2, "InMemoryKeyStore", {
      enumerable: true,
      get: function () {
        return keystores_1.InMemoryKeyStore;
      },
    });
  },
});

// node_modules/@near-js/keystores-browser/lib/browser_local_storage_key_store.js
var require_browser_local_storage_key_store = __commonJS({
  "node_modules/@near-js/keystores-browser/lib/browser_local_storage_key_store.js"(
    exports2
  ) {
    var __awaiter =
      (exports2 && exports2.__awaiter) ||
      function (thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P
            ? value
            : new P(function (resolve) {
                resolve(value);
              });
        }
        return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done
              ? resolve(result.value)
              : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BrowserLocalStorageKeyStore = void 0;
    var crypto_1 = require_lib3();
    var keystores_1 = require_lib4();
    var LOCAL_STORAGE_KEY_PREFIX = "near-api-js:keystore:";
    var BrowserLocalStorageKeyStore = class extends keystores_1.KeyStore {
      /**
       * @param localStorage defaults to window.localStorage
       * @param prefix defaults to `near-api-js:keystore:`
       */
      constructor(
        localStorage = window.localStorage,
        prefix = LOCAL_STORAGE_KEY_PREFIX
      ) {
        super();
        this.localStorage = localStorage;
        this.prefix = prefix;
      }
      /**
       * Stores a {@link utils/key_pair!KeyPair} in local storage.
       * @param networkId The targeted network. (ex. default, betanet, etc)
       * @param accountId The NEAR account tied to the key pair
       * @param keyPair The key pair to store in local storage
       */
      setKey(networkId, accountId, keyPair) {
        return __awaiter(this, void 0, void 0, function* () {
          this.localStorage.setItem(
            this.storageKeyForSecretKey(networkId, accountId),
            keyPair.toString()
          );
        });
      }
      /**
       * Gets a {@link utils/key_pair!KeyPair} from local storage
       * @param networkId The targeted network. (ex. default, betanet, etc)
       * @param accountId The NEAR account tied to the key pair
       * @returns {Promise<KeyPair>}
       */
      getKey(networkId, accountId) {
        return __awaiter(this, void 0, void 0, function* () {
          const value = this.localStorage.getItem(
            this.storageKeyForSecretKey(networkId, accountId)
          );
          if (!value) {
            return null;
          }
          return crypto_1.KeyPair.fromString(value);
        });
      }
      /**
       * Removes a {@link utils/key_pair!KeyPair} from local storage
       * @param networkId The targeted network. (ex. default, betanet, etc)
       * @param accountId The NEAR account tied to the key pair
       */
      removeKey(networkId, accountId) {
        return __awaiter(this, void 0, void 0, function* () {
          this.localStorage.removeItem(
            this.storageKeyForSecretKey(networkId, accountId)
          );
        });
      }
      /**
       * Removes all items that start with `prefix` from local storage
       */
      clear() {
        return __awaiter(this, void 0, void 0, function* () {
          for (const key of this.storageKeys()) {
            if (key.startsWith(this.prefix)) {
              this.localStorage.removeItem(key);
            }
          }
        });
      }
      /**
       * Get the network(s) from local storage
       * @returns {Promise<string[]>}
       */
      getNetworks() {
        return __awaiter(this, void 0, void 0, function* () {
          const result = /* @__PURE__ */ new Set();
          for (const key of this.storageKeys()) {
            if (key.startsWith(this.prefix)) {
              const parts = key.substring(this.prefix.length).split(":");
              result.add(parts[1]);
            }
          }
          return Array.from(result.values());
        });
      }
      /**
       * Gets the account(s) from local storage
       * @param networkId The targeted network. (ex. default, betanet, etc)
       */
      getAccounts(networkId) {
        return __awaiter(this, void 0, void 0, function* () {
          const result = new Array();
          for (const key of this.storageKeys()) {
            if (key.startsWith(this.prefix)) {
              const parts = key.substring(this.prefix.length).split(":");
              if (parts[1] === networkId) {
                result.push(parts[0]);
              }
            }
          }
          return result;
        });
      }
      /**
       * @hidden
       * Helper function to retrieve a local storage key
       * @param networkId The targeted network. (ex. default, betanet, etc)
       * @param accountId The NEAR account tied to the storage keythat's sought
       * @returns {string} An example might be: `near-api-js:keystore:near-friend:default`
       */
      storageKeyForSecretKey(networkId, accountId) {
        return `${this.prefix}${accountId}:${networkId}`;
      }
      /** @hidden */
      *storageKeys() {
        for (let i = 0; i < this.localStorage.length; i++) {
          yield this.localStorage.key(i);
        }
      }
    };
    exports2.BrowserLocalStorageKeyStore = BrowserLocalStorageKeyStore;
  },
});

// node_modules/@near-js/keystores-browser/lib/index.js
var require_lib5 = __commonJS({
  "node_modules/@near-js/keystores-browser/lib/index.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BrowserLocalStorageKeyStore = void 0;
    var browser_local_storage_key_store_1 =
      require_browser_local_storage_key_store();
    Object.defineProperty(exports2, "BrowserLocalStorageKeyStore", {
      enumerable: true,
      get: function () {
        return browser_local_storage_key_store_1.BrowserLocalStorageKeyStore;
      },
    });
  },
});

// node_modules/near-api-js/lib/key_stores/browser_local_storage_key_store.js
var require_browser_local_storage_key_store2 = __commonJS({
  "node_modules/near-api-js/lib/key_stores/browser_local_storage_key_store.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BrowserLocalStorageKeyStore = void 0;
    var keystores_browser_1 = require_lib5();
    Object.defineProperty(exports2, "BrowserLocalStorageKeyStore", {
      enumerable: true,
      get: function () {
        return keystores_browser_1.BrowserLocalStorageKeyStore;
      },
    });
  },
});

// node_modules/near-api-js/lib/key_stores/merge_key_store.js
var require_merge_key_store2 = __commonJS({
  "node_modules/near-api-js/lib/key_stores/merge_key_store.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MergeKeyStore = void 0;
    var keystores_1 = require_lib4();
    Object.defineProperty(exports2, "MergeKeyStore", {
      enumerable: true,
      get: function () {
        return keystores_1.MergeKeyStore;
      },
    });
  },
});

// node_modules/near-api-js/lib/key_stores/browser-index.js
var require_browser_index = __commonJS({
  "node_modules/near-api-js/lib/key_stores/browser-index.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MergeKeyStore =
      exports2.BrowserLocalStorageKeyStore =
      exports2.InMemoryKeyStore =
      exports2.KeyStore =
        void 0;
    var keystore_1 = require_keystore2();
    Object.defineProperty(exports2, "KeyStore", {
      enumerable: true,
      get: function () {
        return keystore_1.KeyStore;
      },
    });
    var in_memory_key_store_1 = require_in_memory_key_store2();
    Object.defineProperty(exports2, "InMemoryKeyStore", {
      enumerable: true,
      get: function () {
        return in_memory_key_store_1.InMemoryKeyStore;
      },
    });
    var browser_local_storage_key_store_1 =
      require_browser_local_storage_key_store2();
    Object.defineProperty(exports2, "BrowserLocalStorageKeyStore", {
      enumerable: true,
      get: function () {
        return browser_local_storage_key_store_1.BrowserLocalStorageKeyStore;
      },
    });
    var merge_key_store_1 = require_merge_key_store2();
    Object.defineProperty(exports2, "MergeKeyStore", {
      enumerable: true,
      get: function () {
        return merge_key_store_1.MergeKeyStore;
      },
    });
  },
});

// node_modules/@near-js/utils/lib/constants.js
var require_constants2 = __commonJS({
  "node_modules/@near-js/utils/lib/constants.js"(exports2) {
    var __importDefault =
      (exports2 && exports2.__importDefault) ||
      function (mod) {
        return mod && mod.__esModule ? mod : { default: mod };
      };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DEFAULT_FUNCTION_CALL_GAS = void 0;
    var bn_js_1 = __importDefault(require_bn());
    exports2.DEFAULT_FUNCTION_CALL_GAS = new bn_js_1.default("30000000000000");
  },
});

// node_modules/@near-js/utils/lib/errors/errors.js
var require_errors2 = __commonJS({
  "node_modules/@near-js/utils/lib/errors/errors.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.logWarning = void 0;
    function logWarning(...args) {
      if (!{}["NEAR_NO_LOGS"]) {
        console.warn(...args);
      }
    }
    exports2.logWarning = logWarning;
  },
});

// node_modules/mustache/mustache.js
var require_mustache = __commonJS({
  "node_modules/mustache/mustache.js"(exports2, module2) {
    (function (global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined"
        ? (module2.exports = factory())
        : typeof define === "function" && define.amd
        ? define(factory)
        : ((global2 = global2 || self), (global2.Mustache = factory()));
    })(exports2, function () {
      var objectToString = Object.prototype.toString;
      var isArray =
        Array.isArray ||
        function isArrayPolyfill(object) {
          return objectToString.call(object) === "[object Array]";
        };
      function isFunction(object) {
        return typeof object === "function";
      }
      function typeStr(obj) {
        return isArray(obj) ? "array" : typeof obj;
      }
      function escapeRegExp(string) {
        return string.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
      }
      function hasProperty(obj, propName) {
        return obj != null && typeof obj === "object" && propName in obj;
      }
      function primitiveHasOwnProperty(primitive, propName) {
        return (
          primitive != null &&
          typeof primitive !== "object" &&
          primitive.hasOwnProperty &&
          primitive.hasOwnProperty(propName)
        );
      }
      var regExpTest = RegExp.prototype.test;
      function testRegExp(re, string) {
        return regExpTest.call(re, string);
      }
      var nonSpaceRe = /\S/;
      function isWhitespace(string) {
        return !testRegExp(nonSpaceRe, string);
      }
      var entityMap = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;",
        "/": "&#x2F;",
        "`": "&#x60;",
        "=": "&#x3D;",
      };
      function escapeHtml(string) {
        return String(string).replace(
          /[&<>"'`=\/]/g,
          function fromEntityMap(s) {
            return entityMap[s];
          }
        );
      }
      var whiteRe = /\s*/;
      var spaceRe = /\s+/;
      var equalsRe = /\s*=/;
      var curlyRe = /\s*\}/;
      var tagRe = /#|\^|\/|>|\{|&|=|!/;
      function parseTemplate(template, tags) {
        if (!template) return [];
        var lineHasNonSpace = false;
        var sections = [];
        var tokens = [];
        var spaces = [];
        var hasTag = false;
        var nonSpace = false;
        var indentation = "";
        var tagIndex = 0;
        function stripSpace() {
          if (hasTag && !nonSpace) {
            while (spaces.length) delete tokens[spaces.pop()];
          } else {
            spaces = [];
          }
          hasTag = false;
          nonSpace = false;
        }
        var openingTagRe, closingTagRe, closingCurlyRe;
        function compileTags(tagsToCompile) {
          if (typeof tagsToCompile === "string")
            tagsToCompile = tagsToCompile.split(spaceRe, 2);
          if (!isArray(tagsToCompile) || tagsToCompile.length !== 2)
            throw new Error("Invalid tags: " + tagsToCompile);
          openingTagRe = new RegExp(escapeRegExp(tagsToCompile[0]) + "\\s*");
          closingTagRe = new RegExp("\\s*" + escapeRegExp(tagsToCompile[1]));
          closingCurlyRe = new RegExp(
            "\\s*" + escapeRegExp("}" + tagsToCompile[1])
          );
        }
        compileTags(tags || mustache.tags);
        var scanner = new Scanner(template);
        var start, type, value, chr, token, openSection;
        while (!scanner.eos()) {
          start = scanner.pos;
          value = scanner.scanUntil(openingTagRe);
          if (value) {
            for (var i = 0, valueLength = value.length; i < valueLength; ++i) {
              chr = value.charAt(i);
              if (isWhitespace(chr)) {
                spaces.push(tokens.length);
                indentation += chr;
              } else {
                nonSpace = true;
                lineHasNonSpace = true;
                indentation += " ";
              }
              tokens.push(["text", chr, start, start + 1]);
              start += 1;
              if (chr === "\n") {
                stripSpace();
                indentation = "";
                tagIndex = 0;
                lineHasNonSpace = false;
              }
            }
          }
          if (!scanner.scan(openingTagRe)) break;
          hasTag = true;
          type = scanner.scan(tagRe) || "name";
          scanner.scan(whiteRe);
          if (type === "=") {
            value = scanner.scanUntil(equalsRe);
            scanner.scan(equalsRe);
            scanner.scanUntil(closingTagRe);
          } else if (type === "{") {
            value = scanner.scanUntil(closingCurlyRe);
            scanner.scan(curlyRe);
            scanner.scanUntil(closingTagRe);
            type = "&";
          } else {
            value = scanner.scanUntil(closingTagRe);
          }
          if (!scanner.scan(closingTagRe))
            throw new Error("Unclosed tag at " + scanner.pos);
          if (type == ">") {
            token = [
              type,
              value,
              start,
              scanner.pos,
              indentation,
              tagIndex,
              lineHasNonSpace,
            ];
          } else {
            token = [type, value, start, scanner.pos];
          }
          tagIndex++;
          tokens.push(token);
          if (type === "#" || type === "^") {
            sections.push(token);
          } else if (type === "/") {
            openSection = sections.pop();
            if (!openSection)
              throw new Error('Unopened section "' + value + '" at ' + start);
            if (openSection[1] !== value)
              throw new Error(
                'Unclosed section "' + openSection[1] + '" at ' + start
              );
          } else if (type === "name" || type === "{" || type === "&") {
            nonSpace = true;
          } else if (type === "=") {
            compileTags(value);
          }
        }
        stripSpace();
        openSection = sections.pop();
        if (openSection)
          throw new Error(
            'Unclosed section "' + openSection[1] + '" at ' + scanner.pos
          );
        return nestTokens(squashTokens(tokens));
      }
      function squashTokens(tokens) {
        var squashedTokens = [];
        var token, lastToken;
        for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
          token = tokens[i];
          if (token) {
            if (token[0] === "text" && lastToken && lastToken[0] === "text") {
              lastToken[1] += token[1];
              lastToken[3] = token[3];
            } else {
              squashedTokens.push(token);
              lastToken = token;
            }
          }
        }
        return squashedTokens;
      }
      function nestTokens(tokens) {
        var nestedTokens = [];
        var collector = nestedTokens;
        var sections = [];
        var token, section;
        for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
          token = tokens[i];
          switch (token[0]) {
            case "#":
            case "^":
              collector.push(token);
              sections.push(token);
              collector = token[4] = [];
              break;
            case "/":
              section = sections.pop();
              section[5] = token[2];
              collector =
                sections.length > 0
                  ? sections[sections.length - 1][4]
                  : nestedTokens;
              break;
            default:
              collector.push(token);
          }
        }
        return nestedTokens;
      }
      function Scanner(string) {
        this.string = string;
        this.tail = string;
        this.pos = 0;
      }
      Scanner.prototype.eos = function eos() {
        return this.tail === "";
      };
      Scanner.prototype.scan = function scan(re) {
        var match = this.tail.match(re);
        if (!match || match.index !== 0) return "";
        var string = match[0];
        this.tail = this.tail.substring(string.length);
        this.pos += string.length;
        return string;
      };
      Scanner.prototype.scanUntil = function scanUntil(re) {
        var index = this.tail.search(re),
          match;
        switch (index) {
          case -1:
            match = this.tail;
            this.tail = "";
            break;
          case 0:
            match = "";
            break;
          default:
            match = this.tail.substring(0, index);
            this.tail = this.tail.substring(index);
        }
        this.pos += match.length;
        return match;
      };
      function Context(view, parentContext) {
        this.view = view;
        this.cache = { ".": this.view };
        this.parent = parentContext;
      }
      Context.prototype.push = function push(view) {
        return new Context(view, this);
      };
      Context.prototype.lookup = function lookup(name) {
        var cache = this.cache;
        var value;
        if (cache.hasOwnProperty(name)) {
          value = cache[name];
        } else {
          var context = this,
            intermediateValue,
            names,
            index,
            lookupHit = false;
          while (context) {
            if (name.indexOf(".") > 0) {
              intermediateValue = context.view;
              names = name.split(".");
              index = 0;
              while (intermediateValue != null && index < names.length) {
                if (index === names.length - 1)
                  lookupHit =
                    hasProperty(intermediateValue, names[index]) ||
                    primitiveHasOwnProperty(intermediateValue, names[index]);
                intermediateValue = intermediateValue[names[index++]];
              }
            } else {
              intermediateValue = context.view[name];
              lookupHit = hasProperty(context.view, name);
            }
            if (lookupHit) {
              value = intermediateValue;
              break;
            }
            context = context.parent;
          }
          cache[name] = value;
        }
        if (isFunction(value)) value = value.call(this.view);
        return value;
      };
      function Writer() {
        this.templateCache = {
          _cache: {},
          set: function set(key, value) {
            this._cache[key] = value;
          },
          get: function get(key) {
            return this._cache[key];
          },
          clear: function clear() {
            this._cache = {};
          },
        };
      }
      Writer.prototype.clearCache = function clearCache() {
        if (typeof this.templateCache !== "undefined") {
          this.templateCache.clear();
        }
      };
      Writer.prototype.parse = function parse(template, tags) {
        var cache = this.templateCache;
        var cacheKey = template + ":" + (tags || mustache.tags).join(":");
        var isCacheEnabled = typeof cache !== "undefined";
        var tokens = isCacheEnabled ? cache.get(cacheKey) : void 0;
        if (tokens == void 0) {
          tokens = parseTemplate(template, tags);
          isCacheEnabled && cache.set(cacheKey, tokens);
        }
        return tokens;
      };
      Writer.prototype.render = function render(
        template,
        view,
        partials,
        config
      ) {
        var tags = this.getConfigTags(config);
        var tokens = this.parse(template, tags);
        var context =
          view instanceof Context ? view : new Context(view, void 0);
        return this.renderTokens(tokens, context, partials, template, config);
      };
      Writer.prototype.renderTokens = function renderTokens(
        tokens,
        context,
        partials,
        originalTemplate,
        config
      ) {
        var buffer = "";
        var token, symbol, value;
        for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
          value = void 0;
          token = tokens[i];
          symbol = token[0];
          if (symbol === "#")
            value = this.renderSection(
              token,
              context,
              partials,
              originalTemplate,
              config
            );
          else if (symbol === "^")
            value = this.renderInverted(
              token,
              context,
              partials,
              originalTemplate,
              config
            );
          else if (symbol === ">")
            value = this.renderPartial(token, context, partials, config);
          else if (symbol === "&") value = this.unescapedValue(token, context);
          else if (symbol === "name")
            value = this.escapedValue(token, context, config);
          else if (symbol === "text") value = this.rawValue(token);
          if (value !== void 0) buffer += value;
        }
        return buffer;
      };
      Writer.prototype.renderSection = function renderSection(
        token,
        context,
        partials,
        originalTemplate,
        config
      ) {
        var self2 = this;
        var buffer = "";
        var value = context.lookup(token[1]);
        function subRender(template) {
          return self2.render(template, context, partials, config);
        }
        if (!value) return;
        if (isArray(value)) {
          for (var j = 0, valueLength = value.length; j < valueLength; ++j) {
            buffer += this.renderTokens(
              token[4],
              context.push(value[j]),
              partials,
              originalTemplate,
              config
            );
          }
        } else if (
          typeof value === "object" ||
          typeof value === "string" ||
          typeof value === "number"
        ) {
          buffer += this.renderTokens(
            token[4],
            context.push(value),
            partials,
            originalTemplate,
            config
          );
        } else if (isFunction(value)) {
          if (typeof originalTemplate !== "string")
            throw new Error(
              "Cannot use higher-order sections without the original template"
            );
          value = value.call(
            context.view,
            originalTemplate.slice(token[3], token[5]),
            subRender
          );
          if (value != null) buffer += value;
        } else {
          buffer += this.renderTokens(
            token[4],
            context,
            partials,
            originalTemplate,
            config
          );
        }
        return buffer;
      };
      Writer.prototype.renderInverted = function renderInverted(
        token,
        context,
        partials,
        originalTemplate,
        config
      ) {
        var value = context.lookup(token[1]);
        if (!value || (isArray(value) && value.length === 0))
          return this.renderTokens(
            token[4],
            context,
            partials,
            originalTemplate,
            config
          );
      };
      Writer.prototype.indentPartial = function indentPartial(
        partial,
        indentation,
        lineHasNonSpace
      ) {
        var filteredIndentation = indentation.replace(/[^ \t]/g, "");
        var partialByNl = partial.split("\n");
        for (var i = 0; i < partialByNl.length; i++) {
          if (partialByNl[i].length && (i > 0 || !lineHasNonSpace)) {
            partialByNl[i] = filteredIndentation + partialByNl[i];
          }
        }
        return partialByNl.join("\n");
      };
      Writer.prototype.renderPartial = function renderPartial(
        token,
        context,
        partials,
        config
      ) {
        if (!partials) return;
        var tags = this.getConfigTags(config);
        var value = isFunction(partials)
          ? partials(token[1])
          : partials[token[1]];
        if (value != null) {
          var lineHasNonSpace = token[6];
          var tagIndex = token[5];
          var indentation = token[4];
          var indentedValue = value;
          if (tagIndex == 0 && indentation) {
            indentedValue = this.indentPartial(
              value,
              indentation,
              lineHasNonSpace
            );
          }
          var tokens = this.parse(indentedValue, tags);
          return this.renderTokens(
            tokens,
            context,
            partials,
            indentedValue,
            config
          );
        }
      };
      Writer.prototype.unescapedValue = function unescapedValue(
        token,
        context
      ) {
        var value = context.lookup(token[1]);
        if (value != null) return value;
      };
      Writer.prototype.escapedValue = function escapedValue(
        token,
        context,
        config
      ) {
        var escape = this.getConfigEscape(config) || mustache.escape;
        var value = context.lookup(token[1]);
        if (value != null)
          return typeof value === "number" && escape === mustache.escape
            ? String(value)
            : escape(value);
      };
      Writer.prototype.rawValue = function rawValue(token) {
        return token[1];
      };
      Writer.prototype.getConfigTags = function getConfigTags(config) {
        if (isArray(config)) {
          return config;
        } else if (config && typeof config === "object") {
          return config.tags;
        } else {
          return void 0;
        }
      };
      Writer.prototype.getConfigEscape = function getConfigEscape(config) {
        if (config && typeof config === "object" && !isArray(config)) {
          return config.escape;
        } else {
          return void 0;
        }
      };
      var mustache = {
        name: "mustache.js",
        version: "4.2.0",
        tags: ["{{", "}}"],
        clearCache: void 0,
        escape: void 0,
        parse: void 0,
        render: void 0,
        Scanner: void 0,
        Context: void 0,
        Writer: void 0,
        /**
         * Allows a user to override the default caching strategy, by providing an
         * object with set, get and clear methods. This can also be used to disable
         * the cache by setting it to the literal `undefined`.
         */
        set templateCache(cache) {
          defaultWriter.templateCache = cache;
        },
        /**
         * Gets the default or overridden caching object from the default writer.
         */
        get templateCache() {
          return defaultWriter.templateCache;
        },
      };
      var defaultWriter = new Writer();
      mustache.clearCache = function clearCache() {
        return defaultWriter.clearCache();
      };
      mustache.parse = function parse(template, tags) {
        return defaultWriter.parse(template, tags);
      };
      mustache.render = function render(template, view, partials, config) {
        if (typeof template !== "string") {
          throw new TypeError(
            'Invalid template! Template should be a "string" but "' +
              typeStr(template) +
              '" was given as the first argument for mustache#render(template, view, partials)'
          );
        }
        return defaultWriter.render(template, view, partials, config);
      };
      mustache.escape = escapeHtml;
      mustache.Scanner = Scanner;
      mustache.Context = Context;
      mustache.Writer = Writer;
      return mustache;
    });
  },
});

// node_modules/@near-js/utils/lib/format.js
var require_format = __commonJS({
  "node_modules/@near-js/utils/lib/format.js"(exports2) {
    var __importDefault =
      (exports2 && exports2.__importDefault) ||
      function (mod) {
        return mod && mod.__esModule ? mod : { default: mod };
      };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseNearAmount =
      exports2.formatNearAmount =
      exports2.NEAR_NOMINATION =
      exports2.NEAR_NOMINATION_EXP =
        void 0;
    var bn_js_1 = __importDefault(require_bn());
    exports2.NEAR_NOMINATION_EXP = 24;
    exports2.NEAR_NOMINATION = new bn_js_1.default("10", 10).pow(
      new bn_js_1.default(exports2.NEAR_NOMINATION_EXP, 10)
    );
    var ROUNDING_OFFSETS = [];
    var BN10 = new bn_js_1.default(10);
    for (
      let i = 0, offset = new bn_js_1.default(5);
      i < exports2.NEAR_NOMINATION_EXP;
      i++, offset = offset.mul(BN10)
    ) {
      ROUNDING_OFFSETS[i] = offset;
    }
    function formatNearAmount(
      balance,
      fracDigits = exports2.NEAR_NOMINATION_EXP
    ) {
      const balanceBN = new bn_js_1.default(balance, 10);
      if (fracDigits !== exports2.NEAR_NOMINATION_EXP) {
        const roundingExp = exports2.NEAR_NOMINATION_EXP - fracDigits - 1;
        if (roundingExp > 0) {
          balanceBN.iadd(ROUNDING_OFFSETS[roundingExp]);
        }
      }
      balance = balanceBN.toString();
      const wholeStr =
        balance.substring(0, balance.length - exports2.NEAR_NOMINATION_EXP) ||
        "0";
      const fractionStr = balance
        .substring(balance.length - exports2.NEAR_NOMINATION_EXP)
        .padStart(exports2.NEAR_NOMINATION_EXP, "0")
        .substring(0, fracDigits);
      return trimTrailingZeroes(`${formatWithCommas(wholeStr)}.${fractionStr}`);
    }
    exports2.formatNearAmount = formatNearAmount;
    function parseNearAmount(amt) {
      if (!amt) {
        return null;
      }
      amt = cleanupAmount(amt);
      const split = amt.split(".");
      const wholePart = split[0];
      const fracPart = split[1] || "";
      if (split.length > 2 || fracPart.length > exports2.NEAR_NOMINATION_EXP) {
        throw new Error(`Cannot parse '${amt}' as NEAR amount`);
      }
      return trimLeadingZeroes(
        wholePart + fracPart.padEnd(exports2.NEAR_NOMINATION_EXP, "0")
      );
    }
    exports2.parseNearAmount = parseNearAmount;
    function cleanupAmount(amount) {
      return amount.replace(/,/g, "").trim();
    }
    function trimTrailingZeroes(value) {
      return value.replace(/\.?0*$/, "");
    }
    function trimLeadingZeroes(value) {
      value = value.replace(/^0+/, "");
      if (value === "") {
        return "0";
      }
      return value;
    }
    function formatWithCommas(value) {
      const pattern = /(-?\d+)(\d{3})/;
      while (pattern.test(value)) {
        value = value.replace(pattern, "$1,$2");
      }
      return value;
    }
  },
});

// node_modules/@near-js/utils/lib/errors/error_messages.json
var require_error_messages = __commonJS({
  "node_modules/@near-js/utils/lib/errors/error_messages.json"(
    exports2,
    module2
  ) {
    module2.exports = {
      GasLimitExceeded:
        "Exceeded the maximum amount of gas allowed to burn per contract",
      MethodEmptyName: "Method name is empty",
      WasmerCompileError: "Wasmer compilation error: {{msg}}",
      GuestPanic: "Smart contract panicked: {{panic_msg}}",
      Memory: "Error creating Wasm memory",
      GasExceeded: "Exceeded the prepaid gas",
      MethodUTF8Error: "Method name is not valid UTF8 string",
      BadUTF16: "String encoding is bad UTF-16 sequence",
      WasmTrap: "WebAssembly trap: {{msg}}",
      GasInstrumentation:
        "Gas instrumentation failed or contract has denied instructions.",
      InvalidPromiseIndex:
        "{{promise_idx}} does not correspond to existing promises",
      InvalidPromiseResultIndex:
        "Accessed invalid promise result index: {{result_idx}}",
      Deserialization: "Error happened while deserializing the module",
      MethodNotFound: "Contract method is not found",
      InvalidRegisterId: "Accessed invalid register id: {{register_id}}",
      InvalidReceiptIndex:
        "VM Logic returned an invalid receipt index: {{receipt_index}}",
      EmptyMethodName: "Method name is empty in contract call",
      CannotReturnJointPromise:
        "Returning joint promise is currently prohibited",
      StackHeightInstrumentation: "Stack instrumentation failed",
      CodeDoesNotExist: "Cannot find contract code for account {{account_id}}",
      MethodInvalidSignature: "Invalid method signature",
      IntegerOverflow: "Integer overflow happened during contract execution",
      MemoryAccessViolation: "MemoryAccessViolation",
      InvalidIteratorIndex: "Iterator index {{iterator_index}} does not exist",
      IteratorWasInvalidated:
        "Iterator {{iterator_index}} was invalidated after its creation by performing a mutable operation on trie",
      InvalidAccountId: "VM Logic returned an invalid account id",
      Serialization: "Error happened while serializing the module",
      CannotAppendActionToJointPromise:
        "Actions can only be appended to non-joint promise.",
      InternalMemoryDeclared:
        "Internal memory declaration has been found in the module",
      Instantiate: "Error happened during instantiation",
      ProhibitedInView: "{{method_name}} is not allowed in view calls",
      InvalidMethodName: "VM Logic returned an invalid method name",
      BadUTF8: "String encoding is bad UTF-8 sequence",
      BalanceExceeded: "Exceeded the account balance",
      LinkError: "Wasm contract link error: {{msg}}",
      InvalidPublicKey: "VM Logic provided an invalid public key",
      ActorNoPermission:
        "Actor {{actor_id}} doesn't have permission to account {{account_id}} to complete the action",
      LackBalanceForState:
        "The account {{account_id}} wouldn't have enough balance to cover storage, required to have {{amount}} yoctoNEAR more",
      ReceiverMismatch:
        "Wrong AccessKey used for transaction: transaction is sent to receiver_id={{tx_receiver}}, but is signed with function call access key that restricted to only use with receiver_id={{ak_receiver}}. Either change receiver_id in your transaction or switch to use a FullAccessKey.",
      CostOverflow: "Transaction gas or balance cost is too high",
      InvalidSignature: "Transaction is not signed with the given public key",
      AccessKeyNotFound: `Signer "{{account_id}}" doesn't have access key with the given public_key {{public_key}}`,
      NotEnoughBalance:
        "Sender {{signer_id}} does not have enough balance {{#formatNear}}{{balance}}{{/formatNear}} for operation costing {{#formatNear}}{{cost}}{{/formatNear}}",
      NotEnoughAllowance:
        "Access Key {account_id}:{public_key} does not have enough balance {{#formatNear}}{{allowance}}{{/formatNear}} for transaction costing {{#formatNear}}{{cost}}{{/formatNear}}",
      Expired: "Transaction has expired",
      DeleteAccountStaking:
        "Account {{account_id}} is staking and can not be deleted",
      SignerDoesNotExist: "Signer {{signer_id}} does not exist",
      TriesToStake:
        "Account {{account_id}} tried to stake {{#formatNear}}{{stake}}{{/formatNear}}, but has staked {{#formatNear}}{{locked}}{{/formatNear}} and only has {{#formatNear}}{{balance}}{{/formatNear}}",
      AddKeyAlreadyExists:
        "The public key {{public_key}} is already used for an existing access key",
      InvalidSigner:
        "Invalid signer account ID {{signer_id}} according to requirements",
      CreateAccountNotAllowed:
        "The new account_id {{account_id}} can't be created by {{predecessor_id}}",
      RequiresFullAccess:
        "The transaction contains more then one action, but it was signed with an access key which allows transaction to apply only one specific action. To apply more then one actions TX must be signed with a full access key",
      TriesToUnstake:
        "Account {{account_id}} is not yet staked, but tried to unstake",
      InvalidNonce:
        "Transaction nonce {{tx_nonce}} must be larger than nonce of the used access key {{ak_nonce}}",
      AccountAlreadyExists:
        "Can't create a new account {{account_id}}, because it already exists",
      InvalidChain:
        "Transaction parent block hash doesn't belong to the current chain",
      AccountDoesNotExist:
        "Can't complete the action because account {{account_id}} doesn't exist",
      MethodNameMismatch:
        "Transaction method name {{method_name}} isn't allowed by the access key",
      DeleteAccountHasRent:
        "Account {{account_id}} can't be deleted. It has {{#formatNear}}{{balance}}{{/formatNear}}, which is enough to cover the rent",
      DeleteAccountHasEnoughBalance:
        "Account {{account_id}} can't be deleted. It has {{#formatNear}}{{balance}}{{/formatNear}}, which is enough to cover it's storage",
      InvalidReceiver:
        "Invalid receiver account ID {{receiver_id}} according to requirements",
      DeleteKeyDoesNotExist:
        "Account {{account_id}} tries to remove an access key that doesn't exist",
      Timeout: "Timeout exceeded",
      Closed: "Connection closed",
    };
  },
});

// node_modules/@near-js/utils/lib/errors/rpc_error_schema.json
var require_rpc_error_schema = __commonJS({
  "node_modules/@near-js/utils/lib/errors/rpc_error_schema.json"(
    exports2,
    module2
  ) {
    module2.exports = {
      schema: {
        BadUTF16: {
          name: "BadUTF16",
          subtypes: [],
          props: {},
        },
        BadUTF8: {
          name: "BadUTF8",
          subtypes: [],
          props: {},
        },
        BalanceExceeded: {
          name: "BalanceExceeded",
          subtypes: [],
          props: {},
        },
        BreakpointTrap: {
          name: "BreakpointTrap",
          subtypes: [],
          props: {},
        },
        CacheError: {
          name: "CacheError",
          subtypes: [
            "ReadError",
            "WriteError",
            "DeserializationError",
            "SerializationError",
          ],
          props: {},
        },
        CallIndirectOOB: {
          name: "CallIndirectOOB",
          subtypes: [],
          props: {},
        },
        CannotAppendActionToJointPromise: {
          name: "CannotAppendActionToJointPromise",
          subtypes: [],
          props: {},
        },
        CannotReturnJointPromise: {
          name: "CannotReturnJointPromise",
          subtypes: [],
          props: {},
        },
        CodeDoesNotExist: {
          name: "CodeDoesNotExist",
          subtypes: [],
          props: {
            account_id: "",
          },
        },
        CompilationError: {
          name: "CompilationError",
          subtypes: ["CodeDoesNotExist", "PrepareError", "WasmerCompileError"],
          props: {},
        },
        ContractSizeExceeded: {
          name: "ContractSizeExceeded",
          subtypes: [],
          props: {
            limit: "",
            size: "",
          },
        },
        Deprecated: {
          name: "Deprecated",
          subtypes: [],
          props: {
            method_name: "",
          },
        },
        Deserialization: {
          name: "Deserialization",
          subtypes: [],
          props: {},
        },
        DeserializationError: {
          name: "DeserializationError",
          subtypes: [],
          props: {},
        },
        EmptyMethodName: {
          name: "EmptyMethodName",
          subtypes: [],
          props: {},
        },
        FunctionCallError: {
          name: "FunctionCallError",
          subtypes: [
            "CompilationError",
            "LinkError",
            "MethodResolveError",
            "WasmTrap",
            "WasmUnknownError",
            "HostError",
            "EvmError",
          ],
          props: {},
        },
        GasExceeded: {
          name: "GasExceeded",
          subtypes: [],
          props: {},
        },
        GasInstrumentation: {
          name: "GasInstrumentation",
          subtypes: [],
          props: {},
        },
        GasLimitExceeded: {
          name: "GasLimitExceeded",
          subtypes: [],
          props: {},
        },
        GenericTrap: {
          name: "GenericTrap",
          subtypes: [],
          props: {},
        },
        GuestPanic: {
          name: "GuestPanic",
          subtypes: [],
          props: {
            panic_msg: "",
          },
        },
        HostError: {
          name: "HostError",
          subtypes: [
            "BadUTF16",
            "BadUTF8",
            "GasExceeded",
            "GasLimitExceeded",
            "BalanceExceeded",
            "EmptyMethodName",
            "GuestPanic",
            "IntegerOverflow",
            "InvalidPromiseIndex",
            "CannotAppendActionToJointPromise",
            "CannotReturnJointPromise",
            "InvalidPromiseResultIndex",
            "InvalidRegisterId",
            "IteratorWasInvalidated",
            "MemoryAccessViolation",
            "InvalidReceiptIndex",
            "InvalidIteratorIndex",
            "InvalidAccountId",
            "InvalidMethodName",
            "InvalidPublicKey",
            "ProhibitedInView",
            "NumberOfLogsExceeded",
            "KeyLengthExceeded",
            "ValueLengthExceeded",
            "TotalLogLengthExceeded",
            "NumberPromisesExceeded",
            "NumberInputDataDependenciesExceeded",
            "ReturnedValueLengthExceeded",
            "ContractSizeExceeded",
            "Deprecated",
          ],
          props: {},
        },
        IllegalArithmetic: {
          name: "IllegalArithmetic",
          subtypes: [],
          props: {},
        },
        IncorrectCallIndirectSignature: {
          name: "IncorrectCallIndirectSignature",
          subtypes: [],
          props: {},
        },
        Instantiate: {
          name: "Instantiate",
          subtypes: [],
          props: {},
        },
        IntegerOverflow: {
          name: "IntegerOverflow",
          subtypes: [],
          props: {},
        },
        InternalMemoryDeclared: {
          name: "InternalMemoryDeclared",
          subtypes: [],
          props: {},
        },
        InvalidAccountId: {
          name: "InvalidAccountId",
          subtypes: [],
          props: {
            account_id: "",
          },
        },
        InvalidIteratorIndex: {
          name: "InvalidIteratorIndex",
          subtypes: [],
          props: {
            iterator_index: "",
          },
        },
        InvalidMethodName: {
          name: "InvalidMethodName",
          subtypes: [],
          props: {},
        },
        InvalidPromiseIndex: {
          name: "InvalidPromiseIndex",
          subtypes: [],
          props: {
            promise_idx: "",
          },
        },
        InvalidPromiseResultIndex: {
          name: "InvalidPromiseResultIndex",
          subtypes: [],
          props: {
            result_idx: "",
          },
        },
        InvalidPublicKey: {
          name: "InvalidPublicKey",
          subtypes: [],
          props: {},
        },
        InvalidReceiptIndex: {
          name: "InvalidReceiptIndex",
          subtypes: [],
          props: {
            receipt_index: "",
          },
        },
        InvalidRegisterId: {
          name: "InvalidRegisterId",
          subtypes: [],
          props: {
            register_id: "",
          },
        },
        IteratorWasInvalidated: {
          name: "IteratorWasInvalidated",
          subtypes: [],
          props: {
            iterator_index: "",
          },
        },
        KeyLengthExceeded: {
          name: "KeyLengthExceeded",
          subtypes: [],
          props: {
            length: "",
            limit: "",
          },
        },
        LinkError: {
          name: "LinkError",
          subtypes: [],
          props: {
            msg: "",
          },
        },
        Memory: {
          name: "Memory",
          subtypes: [],
          props: {},
        },
        MemoryAccessViolation: {
          name: "MemoryAccessViolation",
          subtypes: [],
          props: {},
        },
        MemoryOutOfBounds: {
          name: "MemoryOutOfBounds",
          subtypes: [],
          props: {},
        },
        MethodEmptyName: {
          name: "MethodEmptyName",
          subtypes: [],
          props: {},
        },
        MethodInvalidSignature: {
          name: "MethodInvalidSignature",
          subtypes: [],
          props: {},
        },
        MethodNotFound: {
          name: "MethodNotFound",
          subtypes: [],
          props: {},
        },
        MethodResolveError: {
          name: "MethodResolveError",
          subtypes: [
            "MethodEmptyName",
            "MethodUTF8Error",
            "MethodNotFound",
            "MethodInvalidSignature",
          ],
          props: {},
        },
        MethodUTF8Error: {
          name: "MethodUTF8Error",
          subtypes: [],
          props: {},
        },
        MisalignedAtomicAccess: {
          name: "MisalignedAtomicAccess",
          subtypes: [],
          props: {},
        },
        NumberInputDataDependenciesExceeded: {
          name: "NumberInputDataDependenciesExceeded",
          subtypes: [],
          props: {
            limit: "",
            number_of_input_data_dependencies: "",
          },
        },
        NumberOfLogsExceeded: {
          name: "NumberOfLogsExceeded",
          subtypes: [],
          props: {
            limit: "",
          },
        },
        NumberPromisesExceeded: {
          name: "NumberPromisesExceeded",
          subtypes: [],
          props: {
            limit: "",
            number_of_promises: "",
          },
        },
        PrepareError: {
          name: "PrepareError",
          subtypes: [
            "Serialization",
            "Deserialization",
            "InternalMemoryDeclared",
            "GasInstrumentation",
            "StackHeightInstrumentation",
            "Instantiate",
            "Memory",
          ],
          props: {},
        },
        ProhibitedInView: {
          name: "ProhibitedInView",
          subtypes: [],
          props: {
            method_name: "",
          },
        },
        ReadError: {
          name: "ReadError",
          subtypes: [],
          props: {},
        },
        ReturnedValueLengthExceeded: {
          name: "ReturnedValueLengthExceeded",
          subtypes: [],
          props: {
            length: "",
            limit: "",
          },
        },
        Serialization: {
          name: "Serialization",
          subtypes: [],
          props: {},
        },
        SerializationError: {
          name: "SerializationError",
          subtypes: [],
          props: {
            hash: "",
          },
        },
        StackHeightInstrumentation: {
          name: "StackHeightInstrumentation",
          subtypes: [],
          props: {},
        },
        StackOverflow: {
          name: "StackOverflow",
          subtypes: [],
          props: {},
        },
        TotalLogLengthExceeded: {
          name: "TotalLogLengthExceeded",
          subtypes: [],
          props: {
            length: "",
            limit: "",
          },
        },
        Unreachable: {
          name: "Unreachable",
          subtypes: [],
          props: {},
        },
        ValueLengthExceeded: {
          name: "ValueLengthExceeded",
          subtypes: [],
          props: {
            length: "",
            limit: "",
          },
        },
        WasmTrap: {
          name: "WasmTrap",
          subtypes: [
            "Unreachable",
            "IncorrectCallIndirectSignature",
            "MemoryOutOfBounds",
            "CallIndirectOOB",
            "IllegalArithmetic",
            "MisalignedAtomicAccess",
            "BreakpointTrap",
            "StackOverflow",
            "GenericTrap",
          ],
          props: {},
        },
        WasmUnknownError: {
          name: "WasmUnknownError",
          subtypes: [],
          props: {},
        },
        WasmerCompileError: {
          name: "WasmerCompileError",
          subtypes: [],
          props: {
            msg: "",
          },
        },
        WriteError: {
          name: "WriteError",
          subtypes: [],
          props: {},
        },
        AccessKeyNotFound: {
          name: "AccessKeyNotFound",
          subtypes: [],
          props: {
            account_id: "",
            public_key: "",
          },
        },
        AccountAlreadyExists: {
          name: "AccountAlreadyExists",
          subtypes: [],
          props: {
            account_id: "",
          },
        },
        AccountDoesNotExist: {
          name: "AccountDoesNotExist",
          subtypes: [],
          props: {
            account_id: "",
          },
        },
        ActionError: {
          name: "ActionError",
          subtypes: [
            "AccountAlreadyExists",
            "AccountDoesNotExist",
            "CreateAccountOnlyByRegistrar",
            "CreateAccountNotAllowed",
            "ActorNoPermission",
            "DeleteKeyDoesNotExist",
            "AddKeyAlreadyExists",
            "DeleteAccountStaking",
            "LackBalanceForState",
            "TriesToUnstake",
            "TriesToStake",
            "InsufficientStake",
            "FunctionCallError",
            "NewReceiptValidationError",
            "OnlyImplicitAccountCreationAllowed",
          ],
          props: {
            index: "",
          },
        },
        ActionsValidationError: {
          name: "ActionsValidationError",
          subtypes: [
            "DeleteActionMustBeFinal",
            "TotalPrepaidGasExceeded",
            "TotalNumberOfActionsExceeded",
            "AddKeyMethodNamesNumberOfBytesExceeded",
            "AddKeyMethodNameLengthExceeded",
            "IntegerOverflow",
            "InvalidAccountId",
            "ContractSizeExceeded",
            "FunctionCallMethodNameLengthExceeded",
            "FunctionCallArgumentsLengthExceeded",
            "UnsuitableStakingKey",
            "FunctionCallZeroAttachedGas",
          ],
          props: {},
        },
        ActorNoPermission: {
          name: "ActorNoPermission",
          subtypes: [],
          props: {
            account_id: "",
            actor_id: "",
          },
        },
        AddKeyAlreadyExists: {
          name: "AddKeyAlreadyExists",
          subtypes: [],
          props: {
            account_id: "",
            public_key: "",
          },
        },
        AddKeyMethodNameLengthExceeded: {
          name: "AddKeyMethodNameLengthExceeded",
          subtypes: [],
          props: {
            length: "",
            limit: "",
          },
        },
        AddKeyMethodNamesNumberOfBytesExceeded: {
          name: "AddKeyMethodNamesNumberOfBytesExceeded",
          subtypes: [],
          props: {
            limit: "",
            total_number_of_bytes: "",
          },
        },
        BalanceMismatchError: {
          name: "BalanceMismatchError",
          subtypes: [],
          props: {
            final_accounts_balance: "",
            final_postponed_receipts_balance: "",
            incoming_receipts_balance: "",
            incoming_validator_rewards: "",
            initial_accounts_balance: "",
            initial_postponed_receipts_balance: "",
            new_delayed_receipts_balance: "",
            other_burnt_amount: "",
            outgoing_receipts_balance: "",
            processed_delayed_receipts_balance: "",
            slashed_burnt_amount: "",
            tx_burnt_amount: "",
          },
        },
        CostOverflow: {
          name: "CostOverflow",
          subtypes: [],
          props: {},
        },
        CreateAccountNotAllowed: {
          name: "CreateAccountNotAllowed",
          subtypes: [],
          props: {
            account_id: "",
            predecessor_id: "",
          },
        },
        CreateAccountOnlyByRegistrar: {
          name: "CreateAccountOnlyByRegistrar",
          subtypes: [],
          props: {
            account_id: "",
            predecessor_id: "",
            registrar_account_id: "",
          },
        },
        DeleteAccountStaking: {
          name: "DeleteAccountStaking",
          subtypes: [],
          props: {
            account_id: "",
          },
        },
        DeleteActionMustBeFinal: {
          name: "DeleteActionMustBeFinal",
          subtypes: [],
          props: {},
        },
        DeleteKeyDoesNotExist: {
          name: "DeleteKeyDoesNotExist",
          subtypes: [],
          props: {
            account_id: "",
            public_key: "",
          },
        },
        DepositWithFunctionCall: {
          name: "DepositWithFunctionCall",
          subtypes: [],
          props: {},
        },
        Expired: {
          name: "Expired",
          subtypes: [],
          props: {},
        },
        FunctionCallArgumentsLengthExceeded: {
          name: "FunctionCallArgumentsLengthExceeded",
          subtypes: [],
          props: {
            length: "",
            limit: "",
          },
        },
        FunctionCallMethodNameLengthExceeded: {
          name: "FunctionCallMethodNameLengthExceeded",
          subtypes: [],
          props: {
            length: "",
            limit: "",
          },
        },
        FunctionCallZeroAttachedGas: {
          name: "FunctionCallZeroAttachedGas",
          subtypes: [],
          props: {},
        },
        InsufficientStake: {
          name: "InsufficientStake",
          subtypes: [],
          props: {
            account_id: "",
            minimum_stake: "",
            stake: "",
          },
        },
        InvalidAccessKeyError: {
          name: "InvalidAccessKeyError",
          subtypes: [
            "AccessKeyNotFound",
            "ReceiverMismatch",
            "MethodNameMismatch",
            "RequiresFullAccess",
            "NotEnoughAllowance",
            "DepositWithFunctionCall",
          ],
          props: {},
        },
        InvalidChain: {
          name: "InvalidChain",
          subtypes: [],
          props: {},
        },
        InvalidDataReceiverId: {
          name: "InvalidDataReceiverId",
          subtypes: [],
          props: {
            account_id: "",
          },
        },
        InvalidNonce: {
          name: "InvalidNonce",
          subtypes: [],
          props: {
            ak_nonce: "",
            tx_nonce: "",
          },
        },
        InvalidPredecessorId: {
          name: "InvalidPredecessorId",
          subtypes: [],
          props: {
            account_id: "",
          },
        },
        InvalidReceiverId: {
          name: "InvalidReceiverId",
          subtypes: [],
          props: {
            account_id: "",
          },
        },
        InvalidSignature: {
          name: "InvalidSignature",
          subtypes: [],
          props: {},
        },
        InvalidSignerId: {
          name: "InvalidSignerId",
          subtypes: [],
          props: {
            account_id: "",
          },
        },
        InvalidTxError: {
          name: "InvalidTxError",
          subtypes: [
            "InvalidAccessKeyError",
            "InvalidSignerId",
            "SignerDoesNotExist",
            "InvalidNonce",
            "InvalidReceiverId",
            "InvalidSignature",
            "NotEnoughBalance",
            "LackBalanceForState",
            "CostOverflow",
            "InvalidChain",
            "Expired",
            "ActionsValidation",
          ],
          props: {},
        },
        LackBalanceForState: {
          name: "LackBalanceForState",
          subtypes: [],
          props: {
            account_id: "",
            amount: "",
          },
        },
        MethodNameMismatch: {
          name: "MethodNameMismatch",
          subtypes: [],
          props: {
            method_name: "",
          },
        },
        NotEnoughAllowance: {
          name: "NotEnoughAllowance",
          subtypes: [],
          props: {
            account_id: "",
            allowance: "",
            cost: "",
            public_key: "",
          },
        },
        NotEnoughBalance: {
          name: "NotEnoughBalance",
          subtypes: [],
          props: {
            balance: "",
            cost: "",
            signer_id: "",
          },
        },
        OnlyImplicitAccountCreationAllowed: {
          name: "OnlyImplicitAccountCreationAllowed",
          subtypes: [],
          props: {
            account_id: "",
          },
        },
        ReceiptValidationError: {
          name: "ReceiptValidationError",
          subtypes: [
            "InvalidPredecessorId",
            "InvalidReceiverId",
            "InvalidSignerId",
            "InvalidDataReceiverId",
            "ReturnedValueLengthExceeded",
            "NumberInputDataDependenciesExceeded",
            "ActionsValidation",
          ],
          props: {},
        },
        ReceiverMismatch: {
          name: "ReceiverMismatch",
          subtypes: [],
          props: {
            ak_receiver: "",
            tx_receiver: "",
          },
        },
        RequiresFullAccess: {
          name: "RequiresFullAccess",
          subtypes: [],
          props: {},
        },
        SignerDoesNotExist: {
          name: "SignerDoesNotExist",
          subtypes: [],
          props: {
            signer_id: "",
          },
        },
        TotalNumberOfActionsExceeded: {
          name: "TotalNumberOfActionsExceeded",
          subtypes: [],
          props: {
            limit: "",
            total_number_of_actions: "",
          },
        },
        TotalPrepaidGasExceeded: {
          name: "TotalPrepaidGasExceeded",
          subtypes: [],
          props: {
            limit: "",
            total_prepaid_gas: "",
          },
        },
        TriesToStake: {
          name: "TriesToStake",
          subtypes: [],
          props: {
            account_id: "",
            balance: "",
            locked: "",
            stake: "",
          },
        },
        TriesToUnstake: {
          name: "TriesToUnstake",
          subtypes: [],
          props: {
            account_id: "",
          },
        },
        TxExecutionError: {
          name: "TxExecutionError",
          subtypes: ["ActionError", "InvalidTxError"],
          props: {},
        },
        UnsuitableStakingKey: {
          name: "UnsuitableStakingKey",
          subtypes: [],
          props: {
            public_key: "",
          },
        },
        Closed: {
          name: "Closed",
          subtypes: [],
          props: {},
        },
        InternalError: {
          name: "InternalError",
          subtypes: [],
          props: {},
        },
        ServerError: {
          name: "ServerError",
          subtypes: ["TxExecutionError", "Timeout", "Closed", "InternalError"],
          props: {},
        },
        Timeout: {
          name: "Timeout",
          subtypes: [],
          props: {},
        },
      },
    };
  },
});

// node_modules/@near-js/utils/lib/errors/rpc_errors.js
var require_rpc_errors = __commonJS({
  "node_modules/@near-js/utils/lib/errors/rpc_errors.js"(exports2) {
    var __importDefault =
      (exports2 && exports2.__importDefault) ||
      function (mod) {
        return mod && mod.__esModule ? mod : { default: mod };
      };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getErrorTypeFromErrorMessage =
      exports2.formatError =
      exports2.parseResultError =
      exports2.parseRpcError =
      exports2.ServerError =
        void 0;
    var types_1 = require_lib2();
    var mustache_1 = __importDefault(require_mustache());
    var format_1 = require_format();
    var error_messages_json_1 = __importDefault(require_error_messages());
    var rpc_error_schema_json_1 = __importDefault(require_rpc_error_schema());
    var mustacheHelpers = {
      formatNear: () => (n, render) =>
        (0, format_1.formatNearAmount)(render(n)),
    };
    var ServerError = class extends types_1.TypedError {};
    exports2.ServerError = ServerError;
    var ServerTransactionError = class extends ServerError {};
    function parseRpcError(errorObj) {
      const result = {};
      const errorClassName = walkSubtype(
        errorObj,
        rpc_error_schema_json_1.default.schema,
        result,
        ""
      );
      const error = new ServerError(
        formatError(errorClassName, result),
        errorClassName
      );
      Object.assign(error, result);
      return error;
    }
    exports2.parseRpcError = parseRpcError;
    function parseResultError(result) {
      const server_error = parseRpcError(result.status.Failure);
      const server_tx_error = new ServerTransactionError();
      Object.assign(server_tx_error, server_error);
      server_tx_error.type = server_error.type;
      server_tx_error.message = server_error.message;
      server_tx_error.transaction_outcome = result.transaction_outcome;
      return server_tx_error;
    }
    exports2.parseResultError = parseResultError;
    function formatError(errorClassName, errorData) {
      if (typeof error_messages_json_1.default[errorClassName] === "string") {
        return mustache_1.default.render(
          error_messages_json_1.default[errorClassName],
          Object.assign(Object.assign({}, errorData), mustacheHelpers)
        );
      }
      return JSON.stringify(errorData);
    }
    exports2.formatError = formatError;
    function walkSubtype(errorObj, schema, result, typeName) {
      let error;
      let type;
      let errorTypeName;
      for (const errorName in schema) {
        if (isString(errorObj[errorName])) {
          return errorObj[errorName];
        }
        if (isObject(errorObj[errorName])) {
          error = errorObj[errorName];
          type = schema[errorName];
          errorTypeName = errorName;
        } else if (
          isObject(errorObj.kind) &&
          isObject(errorObj.kind[errorName])
        ) {
          error = errorObj.kind[errorName];
          type = schema[errorName];
          errorTypeName = errorName;
        } else {
          continue;
        }
      }
      if (error && type) {
        for (const prop of Object.keys(type.props)) {
          result[prop] = error[prop];
        }
        return walkSubtype(error, schema, result, errorTypeName);
      } else {
        result.kind = errorObj;
        return typeName;
      }
    }
    function getErrorTypeFromErrorMessage(errorMessage, errorType) {
      switch (true) {
        case /^account .*? does not exist while viewing$/.test(errorMessage):
          return "AccountDoesNotExist";
        case /^Account .*? doesn't exist$/.test(errorMessage):
          return "AccountDoesNotExist";
        case /^access key .*? does not exist while viewing$/.test(errorMessage):
          return "AccessKeyDoesNotExist";
        case /wasm execution failed with error: FunctionCallError\(CompilationError\(CodeDoesNotExist/.test(
          errorMessage
        ):
          return "CodeDoesNotExist";
        case /Transaction nonce \d+ must be larger than nonce of the used access key \d+/.test(
          errorMessage
        ):
          return "InvalidNonce";
        default:
          return errorType;
      }
    }
    exports2.getErrorTypeFromErrorMessage = getErrorTypeFromErrorMessage;
    function isObject(n) {
      return Object.prototype.toString.call(n) === "[object Object]";
    }
    function isString(n) {
      return Object.prototype.toString.call(n) === "[object String]";
    }
  },
});

// node_modules/@near-js/utils/lib/errors/index.js
var require_errors3 = __commonJS({
  "node_modules/@near-js/utils/lib/errors/index.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseRpcError =
      exports2.parseResultError =
      exports2.getErrorTypeFromErrorMessage =
      exports2.formatError =
      exports2.ServerError =
      exports2.logWarning =
        void 0;
    var errors_1 = require_errors2();
    Object.defineProperty(exports2, "logWarning", {
      enumerable: true,
      get: function () {
        return errors_1.logWarning;
      },
    });
    var rpc_errors_1 = require_rpc_errors();
    Object.defineProperty(exports2, "ServerError", {
      enumerable: true,
      get: function () {
        return rpc_errors_1.ServerError;
      },
    });
    Object.defineProperty(exports2, "formatError", {
      enumerable: true,
      get: function () {
        return rpc_errors_1.formatError;
      },
    });
    Object.defineProperty(exports2, "getErrorTypeFromErrorMessage", {
      enumerable: true,
      get: function () {
        return rpc_errors_1.getErrorTypeFromErrorMessage;
      },
    });
    Object.defineProperty(exports2, "parseResultError", {
      enumerable: true,
      get: function () {
        return rpc_errors_1.parseResultError;
      },
    });
    Object.defineProperty(exports2, "parseRpcError", {
      enumerable: true,
      get: function () {
        return rpc_errors_1.parseRpcError;
      },
    });
  },
});

// node_modules/@near-js/utils/lib/logging.js
var require_logging = __commonJS({
  "node_modules/@near-js/utils/lib/logging.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.printTxOutcomeLogs = exports2.printTxOutcomeLogsAndFailures =
      void 0;
    var errors_1 = require_errors3();
    var SUPPRESS_LOGGING = !!{}.NEAR_NO_LOGS;
    function printTxOutcomeLogsAndFailures({ contractId, outcome }) {
      if (SUPPRESS_LOGGING) {
        return;
      }
      const flatLogs = [
        outcome.transaction_outcome,
        ...outcome.receipts_outcome,
      ].reduce((acc, it) => {
        const isFailure =
          typeof it.outcome.status === "object" &&
          typeof it.outcome.status.Failure === "object";
        if (it.outcome.logs.length || isFailure) {
          return acc.concat({
            receiptIds: it.outcome.receipt_ids,
            logs: it.outcome.logs,
            failure:
              typeof it.outcome.status === "object" &&
              it.outcome.status.Failure !== void 0
                ? (0, errors_1.parseRpcError)(it.outcome.status.Failure)
                : null,
          });
        } else {
          return acc;
        }
      }, []);
      for (const result of flatLogs) {
        console.log(
          `Receipt${
            result.receiptIds.length > 1 ? "s" : ""
          }: ${result.receiptIds.join(", ")}`
        );
        printTxOutcomeLogs({
          contractId,
          logs: result.logs,
          prefix: "	",
        });
        if (result.failure) {
          console.warn(`	Failure [${contractId}]: ${result.failure}`);
        }
      }
    }
    exports2.printTxOutcomeLogsAndFailures = printTxOutcomeLogsAndFailures;
    function printTxOutcomeLogs({ contractId, logs, prefix = "" }) {
      if (SUPPRESS_LOGGING) {
        return;
      }
      for (const log of logs) {
        console.log(`${prefix}Log [${contractId}]: ${log}`);
      }
    }
    exports2.printTxOutcomeLogs = printTxOutcomeLogs;
  },
});

// node_modules/@near-js/utils/lib/provider.js
var require_provider2 = __commonJS({
  "node_modules/@near-js/utils/lib/provider.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getTransactionLastResult = void 0;
    function getTransactionLastResult(txResult) {
      if (
        typeof txResult.status === "object" &&
        typeof txResult.status.SuccessValue === "string"
      ) {
        const value = Buffer.from(
          txResult.status.SuccessValue,
          "base64"
        ).toString();
        try {
          return JSON.parse(value);
        } catch (e) {
          return value;
        }
      }
      return null;
    }
    exports2.getTransactionLastResult = getTransactionLastResult;
  },
});

// node_modules/depd/lib/browser/index.js
var require_browser$1 = __commonJS({
  "node_modules/depd/lib/browser/index.js"(exports2, module2) {
    module2.exports = depd;
    function depd(namespace) {
      if (!namespace) {
        throw new TypeError("argument namespace is required");
      }
      function deprecate(message) {}
      deprecate._file = void 0;
      deprecate._ignored = true;
      deprecate._namespace = namespace;
      deprecate._traced = false;
      deprecate._warned = /* @__PURE__ */ Object.create(null);
      deprecate.function = wrapfunction;
      deprecate.property = wrapproperty;
      return deprecate;
    }
    function wrapfunction(fn, message) {
      if (typeof fn !== "function") {
        throw new TypeError("argument fn must be a function");
      }
      return fn;
    }
    function wrapproperty(obj, prop, message) {
      if (!obj || (typeof obj !== "object" && typeof obj !== "function")) {
        throw new TypeError("argument obj must be object");
      }
      var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
      if (!descriptor) {
        throw new TypeError("must call property on owner object");
      }
      if (!descriptor.configurable) {
        throw new TypeError("property must be configurable");
      }
    }
  },
});

// node_modules/@near-js/utils/lib/validators.js
var require_validators = __commonJS({
  "node_modules/@near-js/utils/lib/validators.js"(exports2) {
    var __importDefault =
      (exports2 && exports2.__importDefault) ||
      function (mod) {
        return mod && mod.__esModule ? mod : { default: mod };
      };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.diffEpochValidators = exports2.findSeatPrice = void 0;
    var bn_js_1 = __importDefault(require_bn());
    var depd_1 = __importDefault(require_browser$1());
    function findSeatPrice(
      validators,
      maxNumberOfSeats,
      minimumStakeRatio,
      protocolVersion
    ) {
      if (protocolVersion && protocolVersion < 49) {
        return findSeatPriceForProtocolBefore49(validators, maxNumberOfSeats);
      }
      if (!minimumStakeRatio) {
        const deprecate = (0, depd_1.default)(
          "findSeatPrice(validators, maxNumberOfSeats)"
        );
        deprecate(
          "`use `findSeatPrice(validators, maxNumberOfSeats, minimumStakeRatio)` instead"
        );
        minimumStakeRatio = [1, 6250];
      }
      return findSeatPriceForProtocolAfter49(
        validators,
        maxNumberOfSeats,
        minimumStakeRatio
      );
    }
    exports2.findSeatPrice = findSeatPrice;
    function findSeatPriceForProtocolBefore49(validators, numSeats) {
      const stakes = validators
        .map((v) => new bn_js_1.default(v.stake, 10))
        .sort((a, b) => a.cmp(b));
      const num = new bn_js_1.default(numSeats);
      const stakesSum = stakes.reduce((a, b) => a.add(b));
      if (stakesSum.lt(num)) {
        throw new Error("Stakes are below seats");
      }
      let left = new bn_js_1.default(1),
        right = stakesSum.add(new bn_js_1.default(1));
      while (!left.eq(right.sub(new bn_js_1.default(1)))) {
        const mid = left.add(right).div(new bn_js_1.default(2));
        let found = false;
        let currentSum = new bn_js_1.default(0);
        for (let i = 0; i < stakes.length; ++i) {
          currentSum = currentSum.add(stakes[i].div(mid));
          if (currentSum.gte(num)) {
            left = mid;
            found = true;
            break;
          }
        }
        if (!found) {
          right = mid;
        }
      }
      return left;
    }
    function findSeatPriceForProtocolAfter49(
      validators,
      maxNumberOfSeats,
      minimumStakeRatio
    ) {
      if (minimumStakeRatio.length != 2) {
        throw Error("minimumStakeRatio should have 2 elements");
      }
      const stakes = validators
        .map((v) => new bn_js_1.default(v.stake, 10))
        .sort((a, b) => a.cmp(b));
      const stakesSum = stakes.reduce((a, b) => a.add(b));
      if (validators.length < maxNumberOfSeats) {
        return stakesSum
          .mul(new bn_js_1.default(minimumStakeRatio[0]))
          .div(new bn_js_1.default(minimumStakeRatio[1]));
      } else {
        return stakes[0].add(new bn_js_1.default(1));
      }
    }
    function diffEpochValidators(currentValidators, nextValidators) {
      const validatorsMap = /* @__PURE__ */ new Map();
      currentValidators.forEach((v) => validatorsMap.set(v.account_id, v));
      const nextValidatorsSet = new Set(
        nextValidators.map((v) => v.account_id)
      );
      return {
        newValidators: nextValidators.filter(
          (v) => !validatorsMap.has(v.account_id)
        ),
        removedValidators: currentValidators.filter(
          (v) => !nextValidatorsSet.has(v.account_id)
        ),
        changedValidators: nextValidators
          .filter(
            (v) =>
              validatorsMap.has(v.account_id) &&
              validatorsMap.get(v.account_id).stake != v.stake
          )
          .map((v) => ({ current: validatorsMap.get(v.account_id), next: v })),
      };
    }
    exports2.diffEpochValidators = diffEpochValidators;
  },
});

// node_modules/@near-js/utils/lib/index.js
var require_lib6 = __commonJS({
  "node_modules/@near-js/utils/lib/index.js"(exports2) {
    var __createBinding =
      (exports2 && exports2.__createBinding) ||
      (Object.create
        ? function (o, m, k, k2) {
            if (k2 === void 0) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);
            if (
              !desc ||
              ("get" in desc
                ? !m.__esModule
                : desc.writable || desc.configurable)
            ) {
              desc = {
                enumerable: true,
                get: function () {
                  return m[k];
                },
              };
            }
            Object.defineProperty(o, k2, desc);
          }
        : function (o, m, k, k2) {
            if (k2 === void 0) k2 = k;
            o[k2] = m[k];
          });
    var __exportStar =
      (exports2 && exports2.__exportStar) ||
      function (m, exports3) {
        for (var p in m)
          if (
            p !== "default" &&
            !Object.prototype.hasOwnProperty.call(exports3, p)
          )
            __createBinding(exports3, m, p);
      };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_constants2(), exports2);
    __exportStar(require_errors3(), exports2);
    __exportStar(require_format(), exports2);
    __exportStar(require_logging(), exports2);
    __exportStar(require_provider2(), exports2);
    __exportStar(require_validators(), exports2);
  },
});

// node_modules/@near-js/providers/lib/exponential-backoff.js
var require_exponential_backoff = __commonJS({
  "node_modules/@near-js/providers/lib/exponential-backoff.js"(exports2) {
    var __awaiter =
      (exports2 && exports2.__awaiter) ||
      function (thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P
            ? value
            : new P(function (resolve) {
                resolve(value);
              });
        }
        return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done
              ? resolve(result.value)
              : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.exponentialBackoff = void 0;
    function exponentialBackoff(
      startWaitTime,
      retryNumber,
      waitBackoff,
      getResult
    ) {
      return __awaiter(this, void 0, void 0, function* () {
        let waitTime = startWaitTime;
        for (let i = 0; i < retryNumber; i++) {
          const result = yield getResult();
          if (result) {
            return result;
          }
          yield sleep(waitTime);
          waitTime *= waitBackoff;
        }
        return null;
      });
    }
    exports2.exponentialBackoff = exponentialBackoff;
    function sleep(millis) {
      return new Promise((resolve) => setTimeout(resolve, millis));
    }
  },
});

// node_modules/@near-js/transactions/lib/actions.js
var require_actions = __commonJS({
  "node_modules/@near-js/transactions/lib/actions.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Action =
      exports2.SignedDelegate =
      exports2.DeleteAccount =
      exports2.DeleteKey =
      exports2.AddKey =
      exports2.Stake =
      exports2.Transfer =
      exports2.FunctionCall =
      exports2.DeployContract =
      exports2.CreateAccount =
      exports2.IAction =
      exports2.AccessKey =
      exports2.AccessKeyPermission =
      exports2.FullAccessPermission =
      exports2.FunctionCallPermission =
        void 0;
    var types_1 = require_lib2();
    var Enum = class {
      constructor(properties) {
        if (Object.keys(properties).length !== 1) {
          throw new Error("Enum can only take single value");
        }
        Object.keys(properties).map((key) => {
          this[key] = properties[key];
          this.enum = key;
        });
      }
    };
    var FunctionCallPermission = class extends types_1.Assignable {};
    exports2.FunctionCallPermission = FunctionCallPermission;
    var FullAccessPermission = class extends types_1.Assignable {};
    exports2.FullAccessPermission = FullAccessPermission;
    var AccessKeyPermission = class extends Enum {};
    exports2.AccessKeyPermission = AccessKeyPermission;
    var AccessKey = class extends types_1.Assignable {};
    exports2.AccessKey = AccessKey;
    var IAction = class extends types_1.Assignable {};
    exports2.IAction = IAction;
    var CreateAccount = class extends IAction {};
    exports2.CreateAccount = CreateAccount;
    var DeployContract = class extends IAction {};
    exports2.DeployContract = DeployContract;
    var FunctionCall = class extends IAction {};
    exports2.FunctionCall = FunctionCall;
    var Transfer = class extends IAction {};
    exports2.Transfer = Transfer;
    var Stake = class extends IAction {};
    exports2.Stake = Stake;
    var AddKey = class extends IAction {};
    exports2.AddKey = AddKey;
    var DeleteKey = class extends IAction {};
    exports2.DeleteKey = DeleteKey;
    var DeleteAccount = class extends IAction {};
    exports2.DeleteAccount = DeleteAccount;
    var SignedDelegate = class extends IAction {};
    exports2.SignedDelegate = SignedDelegate;
    var Action = class extends Enum {};
    exports2.Action = Action;
  },
});

// node_modules/@near-js/transactions/lib/action_creators.js
var require_action_creators = __commonJS({
  "node_modules/@near-js/transactions/lib/action_creators.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.actionCreators = exports2.stringifyJsonOrBytes = void 0;
    var actions_1 = require_actions();
    function fullAccessKey() {
      return new actions_1.AccessKey({
        permission: new actions_1.AccessKeyPermission({
          fullAccess: new actions_1.FullAccessPermission({}),
        }),
      });
    }
    function functionCallAccessKey(receiverId, methodNames, allowance) {
      return new actions_1.AccessKey({
        permission: new actions_1.AccessKeyPermission({
          functionCall: new actions_1.FunctionCallPermission({
            receiverId,
            allowance,
            methodNames,
          }),
        }),
      });
    }
    function createAccount() {
      return new actions_1.Action({
        createAccount: new actions_1.CreateAccount({}),
      });
    }
    function deployContract(code) {
      return new actions_1.Action({
        deployContract: new actions_1.DeployContract({ code }),
      });
    }
    function stringifyJsonOrBytes(args) {
      const isUint8Array =
        args.byteLength !== void 0 && args.byteLength === args.length;
      return isUint8Array ? args : Buffer.from(JSON.stringify(args));
    }
    exports2.stringifyJsonOrBytes = stringifyJsonOrBytes;
    function functionCall(
      methodName,
      args,
      gas,
      deposit,
      stringify = stringifyJsonOrBytes,
      jsContract = false
    ) {
      if (jsContract) {
        return new actions_1.Action({
          functionCall: new actions_1.FunctionCall({
            methodName,
            args,
            gas,
            deposit,
          }),
        });
      }
      return new actions_1.Action({
        functionCall: new actions_1.FunctionCall({
          methodName,
          args: stringify(args),
          gas,
          deposit,
        }),
      });
    }
    function transfer(deposit) {
      return new actions_1.Action({
        transfer: new actions_1.Transfer({ deposit }),
      });
    }
    function stake(stake2, publicKey) {
      return new actions_1.Action({
        stake: new actions_1.Stake({ stake: stake2, publicKey }),
      });
    }
    function addKey(publicKey, accessKey) {
      return new actions_1.Action({
        addKey: new actions_1.AddKey({ publicKey, accessKey }),
      });
    }
    function deleteKey(publicKey) {
      return new actions_1.Action({
        deleteKey: new actions_1.DeleteKey({ publicKey }),
      });
    }
    function deleteAccount(beneficiaryId) {
      return new actions_1.Action({
        deleteAccount: new actions_1.DeleteAccount({ beneficiaryId }),
      });
    }
    function signedDelegate({ delegateAction, signature }) {
      return new actions_1.Action({
        signedDelegate: new actions_1.SignedDelegate({
          delegateAction,
          signature,
        }),
      });
    }
    exports2.actionCreators = {
      addKey,
      createAccount,
      deleteAccount,
      deleteKey,
      deployContract,
      fullAccessKey,
      functionCall,
      functionCallAccessKey,
      signedDelegate,
      stake,
      transfer,
    };
  },
});

// node_modules/@near-js/transactions/lib/delegate.js
var require_delegate = __commonJS({
  "node_modules/@near-js/transactions/lib/delegate.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.buildDelegateAction = exports2.DelegateAction = void 0;
    var types_1 = require_lib2();
    var action_creators_1 = require_action_creators();
    var {
      addKey,
      createAccount,
      deleteAccount,
      deleteKey,
      deployContract,
      functionCall,
      stake,
      transfer,
    } = action_creators_1.actionCreators;
    var DelegateAction = class extends types_1.Assignable {};
    exports2.DelegateAction = DelegateAction;
    function buildDelegateAction({
      actions,
      maxBlockHeight,
      nonce,
      publicKey,
      receiverId,
      senderId,
    }) {
      return new DelegateAction({
        senderId,
        receiverId,
        actions: actions.map((a) => {
          if (!a.type && !a.params) {
            return a;
          }
          switch (a.type) {
            case "AddKey": {
              const { publicKey: publicKey2, accessKey } = a.params;
              return addKey(publicKey2, accessKey);
            }
            case "CreateAccount": {
              return createAccount(a.params.createAccount);
            }
            case "DeleteAccount": {
              return deleteAccount(a.params.deleteAccount);
            }
            case "DeleteKey": {
              return deleteKey(a.params.publicKey);
            }
            case "DeployContract": {
              return deployContract(a.params.code);
            }
            case "FunctionCall": {
              const { methodName, args, gas, deposit } = a.params;
              return functionCall(methodName, args, gas, deposit);
            }
            case "Stake": {
              return stake(a.params.stake, a.params.publicKey);
            }
            case "Transfer": {
              const { deposit } = a.params;
              return transfer(deposit);
            }
          }
          throw new Error("Unrecognized action");
        }),
        nonce,
        maxBlockHeight,
        publicKey,
      });
    }
    exports2.buildDelegateAction = buildDelegateAction;
  },
});

// node_modules/@near-js/transactions/lib/prefix.js
var require_prefix = __commonJS({
  "node_modules/@near-js/transactions/lib/prefix.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DelegateActionPrefix = void 0;
    var types_1 = require_lib2();
    var ACTIONABLE_MESSAGE_BASE = Math.pow(2, 30);
    var NEP = {
      MetaTransactions: 366,
    };
    var NEPPrefix = class extends types_1.Assignable {};
    var ActionableMessagePrefix = class extends NEPPrefix {
      /** Given the NEP number, set the prefix using 2^30 as the offset **/
      constructor(prefix) {
        super({ prefix: ACTIONABLE_MESSAGE_BASE + prefix });
      }
    };
    var DelegateActionPrefix = class extends ActionableMessagePrefix {
      constructor() {
        super(NEP.MetaTransactions);
      }
    };
    exports2.DelegateActionPrefix = DelegateActionPrefix;
  },
});

// node_modules/@near-js/transactions/lib/signature.js
var require_signature = __commonJS({
  "node_modules/@near-js/transactions/lib/signature.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Signature = void 0;
    var types_1 = require_lib2();
    var Signature = class extends types_1.Assignable {};
    exports2.Signature = Signature;
  },
});

// node_modules/@near-js/transactions/lib/schema.js
var require_schema = __commonJS({
  "node_modules/@near-js/transactions/lib/schema.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SCHEMA =
      exports2.SignedTransaction =
      exports2.Transaction =
      exports2.decodeSignedTransaction =
      exports2.decodeTransaction =
      exports2.encodeTransaction =
      exports2.encodeSignedDelegate =
      exports2.encodeDelegateAction =
        void 0;
    var crypto_1 = require_lib3();
    var types_1 = require_lib2();
    var borsh_1 = require_lib();
    var actions_1 = require_actions();
    var delegate_1 = require_delegate();
    var prefix_1 = require_prefix();
    var signature_1 = require_signature();
    function encodeDelegateAction(delegateAction) {
      return new Uint8Array([
        ...(0, borsh_1.serialize)(
          exports2.SCHEMA,
          new prefix_1.DelegateActionPrefix()
        ),
        ...(0, borsh_1.serialize)(exports2.SCHEMA, delegateAction),
      ]);
    }
    exports2.encodeDelegateAction = encodeDelegateAction;
    function encodeSignedDelegate(signedDelegate) {
      return (0, borsh_1.serialize)(exports2.SCHEMA, signedDelegate);
    }
    exports2.encodeSignedDelegate = encodeSignedDelegate;
    function encodeTransaction(transaction) {
      return (0, borsh_1.serialize)(exports2.SCHEMA, transaction);
    }
    exports2.encodeTransaction = encodeTransaction;
    function decodeTransaction(bytes) {
      return (0, borsh_1.deserialize)(exports2.SCHEMA, Transaction, bytes);
    }
    exports2.decodeTransaction = decodeTransaction;
    function decodeSignedTransaction(bytes) {
      return (0, borsh_1.deserialize)(
        exports2.SCHEMA,
        SignedTransaction,
        bytes
      );
    }
    exports2.decodeSignedTransaction = decodeSignedTransaction;
    var Transaction = class extends types_1.Assignable {
      encode() {
        return encodeTransaction(this);
      }
      static decode(bytes) {
        return decodeTransaction(bytes);
      }
    };
    exports2.Transaction = Transaction;
    var SignedTransaction = class extends types_1.Assignable {
      encode() {
        return encodeTransaction(this);
      }
      static decode(bytes) {
        return decodeSignedTransaction(bytes);
      }
    };
    exports2.SignedTransaction = SignedTransaction;
    exports2.SCHEMA = /* @__PURE__ */ new Map([
      [
        signature_1.Signature,
        {
          kind: "struct",
          fields: [
            ["keyType", "u8"],
            ["data", [64]],
          ],
        },
      ],
      [
        SignedTransaction,
        {
          kind: "struct",
          fields: [
            ["transaction", Transaction],
            ["signature", signature_1.Signature],
          ],
        },
      ],
      [
        Transaction,
        {
          kind: "struct",
          fields: [
            ["signerId", "string"],
            ["publicKey", crypto_1.PublicKey],
            ["nonce", "u64"],
            ["receiverId", "string"],
            ["blockHash", [32]],
            ["actions", [actions_1.Action]],
          ],
        },
      ],
      [
        crypto_1.PublicKey,
        {
          kind: "struct",
          fields: [
            ["keyType", "u8"],
            ["data", [32]],
          ],
        },
      ],
      [
        actions_1.AccessKey,
        {
          kind: "struct",
          fields: [
            ["nonce", "u64"],
            ["permission", actions_1.AccessKeyPermission],
          ],
        },
      ],
      [
        actions_1.AccessKeyPermission,
        {
          kind: "enum",
          field: "enum",
          values: [
            ["functionCall", actions_1.FunctionCallPermission],
            ["fullAccess", actions_1.FullAccessPermission],
          ],
        },
      ],
      [
        actions_1.FunctionCallPermission,
        {
          kind: "struct",
          fields: [
            ["allowance", { kind: "option", type: "u128" }],
            ["receiverId", "string"],
            ["methodNames", ["string"]],
          ],
        },
      ],
      [actions_1.FullAccessPermission, { kind: "struct", fields: [] }],
      [
        actions_1.Action,
        {
          kind: "enum",
          field: "enum",
          values: [
            ["createAccount", actions_1.CreateAccount],
            ["deployContract", actions_1.DeployContract],
            ["functionCall", actions_1.FunctionCall],
            ["transfer", actions_1.Transfer],
            ["stake", actions_1.Stake],
            ["addKey", actions_1.AddKey],
            ["deleteKey", actions_1.DeleteKey],
            ["deleteAccount", actions_1.DeleteAccount],
            ["signedDelegate", actions_1.SignedDelegate],
          ],
        },
      ],
      [actions_1.CreateAccount, { kind: "struct", fields: [] }],
      [
        actions_1.DeployContract,
        { kind: "struct", fields: [["code", ["u8"]]] },
      ],
      [
        actions_1.FunctionCall,
        {
          kind: "struct",
          fields: [
            ["methodName", "string"],
            ["args", ["u8"]],
            ["gas", "u64"],
            ["deposit", "u128"],
          ],
        },
      ],
      [actions_1.Transfer, { kind: "struct", fields: [["deposit", "u128"]] }],
      [
        actions_1.Stake,
        {
          kind: "struct",
          fields: [
            ["stake", "u128"],
            ["publicKey", crypto_1.PublicKey],
          ],
        },
      ],
      [
        actions_1.AddKey,
        {
          kind: "struct",
          fields: [
            ["publicKey", crypto_1.PublicKey],
            ["accessKey", actions_1.AccessKey],
          ],
        },
      ],
      [
        actions_1.DeleteKey,
        { kind: "struct", fields: [["publicKey", crypto_1.PublicKey]] },
      ],
      [
        actions_1.DeleteAccount,
        { kind: "struct", fields: [["beneficiaryId", "string"]] },
      ],
      [
        delegate_1.DelegateAction,
        {
          kind: "struct",
          fields: [
            ["senderId", "string"],
            ["receiverId", "string"],
            ["actions", [actions_1.Action]],
            ["nonce", "u64"],
            ["maxBlockHeight", "u64"],
            ["publicKey", crypto_1.PublicKey],
          ],
        },
      ],
      [
        prefix_1.DelegateActionPrefix,
        { kind: "struct", fields: [["prefix", "u32"]] },
      ],
      [
        actions_1.SignedDelegate,
        {
          kind: "struct",
          fields: [
            ["delegateAction", delegate_1.DelegateAction],
            ["signature", signature_1.Signature],
          ],
        },
      ],
    ]);
  },
});

// node_modules/@near-js/transactions/lib/create_transaction.js
var require_create_transaction = __commonJS({
  "node_modules/@near-js/transactions/lib/create_transaction.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createTransaction = void 0;
    var schema_1 = require_schema();
    function createTransaction(
      signerId,
      publicKey,
      receiverId,
      nonce,
      actions,
      blockHash
    ) {
      return new schema_1.Transaction({
        signerId,
        publicKey,
        nonce,
        receiverId,
        actions,
        blockHash,
      });
    }
    exports2.createTransaction = createTransaction;
  },
});

// node_modules/js-sha256/src/sha256.js
var require_sha256 = __commonJS({
  "node_modules/js-sha256/src/sha256.js"(exports, module) {
    (function () {
      var ERROR = "input is invalid type";
      var WINDOW = typeof window === "object";
      var root = WINDOW ? window : {};
      if (root.JS_SHA256_NO_WINDOW) {
        WINDOW = false;
      }
      var WEB_WORKER = !WINDOW && typeof self === "object";
      var NODE_JS =
        !root.JS_SHA256_NO_NODE_JS &&
        typeof process === "object" &&
        process.versions &&
        process.versions.node;
      if (NODE_JS) {
        root = global;
      } else if (WEB_WORKER) {
        root = self;
      }
      var COMMON_JS =
        !root.JS_SHA256_NO_COMMON_JS &&
        typeof module === "object" &&
        module.exports;
      var AMD = typeof define === "function" && define.amd;
      var ARRAY_BUFFER =
        !root.JS_SHA256_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
      var HEX_CHARS = "0123456789abcdef".split("");
      var EXTRA = [-2147483648, 8388608, 32768, 128];
      var SHIFT = [24, 16, 8, 0];
      var K = [
        1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993,
        2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987,
        1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774,
        264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986,
        2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711,
        113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291,
        1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411,
        3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344,
        430227734, 506948616, 659060556, 883997877, 958139571, 1322822218,
        1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424,
        2428436474, 2756734187, 3204031479, 3329325298,
      ];
      var OUTPUT_TYPES = ["hex", "array", "digest", "arrayBuffer"];
      var blocks = [];
      if (root.JS_SHA256_NO_NODE_JS || !Array.isArray) {
        Array.isArray = function (obj) {
          return Object.prototype.toString.call(obj) === "[object Array]";
        };
      }
      if (
        ARRAY_BUFFER &&
        (root.JS_SHA256_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)
      ) {
        ArrayBuffer.isView = function (obj) {
          return (
            typeof obj === "object" &&
            obj.buffer &&
            obj.buffer.constructor === ArrayBuffer
          );
        };
      }
      var createOutputMethod = function (outputType, is2242) {
        return function (message) {
          return new Sha256(is2242, true).update(message)[outputType]();
        };
      };
      var createMethod = function (is2242) {
        var method2 = createOutputMethod("hex", is2242);
        if (NODE_JS) {
          method2 = nodeWrap(method2, is2242);
        }
        method2.create = function () {
          return new Sha256(is2242);
        };
        method2.update = function (message) {
          return method2.create().update(message);
        };
        for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
          var type = OUTPUT_TYPES[i];
          method2[type] = createOutputMethod(type, is2242);
        }
        return method2;
      };
      var nodeWrap = function (method, is224) {
        var crypto = eval("require('crypto')");
        var Buffer = eval("require('buffer').Buffer");
        var algorithm = is224 ? "sha224" : "sha256";
        var nodeMethod = function (message) {
          if (typeof message === "string") {
            return crypto
              .createHash(algorithm)
              .update(message, "utf8")
              .digest("hex");
          } else {
            if (message === null || message === void 0) {
              throw new Error(ERROR);
            } else if (message.constructor === ArrayBuffer) {
              message = new Uint8Array(message);
            }
          }
          if (
            Array.isArray(message) ||
            ArrayBuffer.isView(message) ||
            message.constructor === Buffer
          ) {
            return crypto
              .createHash(algorithm)
              .update(new Buffer(message))
              .digest("hex");
          } else {
            return method(message);
          }
        };
        return nodeMethod;
      };
      var createHmacOutputMethod = function (outputType, is2242) {
        return function (key, message) {
          return new HmacSha256(key, is2242, true)
            .update(message)
            [outputType]();
        };
      };
      var createHmacMethod = function (is2242) {
        var method2 = createHmacOutputMethod("hex", is2242);
        method2.create = function (key) {
          return new HmacSha256(key, is2242);
        };
        method2.update = function (key, message) {
          return method2.create(key).update(message);
        };
        for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
          var type = OUTPUT_TYPES[i];
          method2[type] = createHmacOutputMethod(type, is2242);
        }
        return method2;
      };
      function Sha256(is2242, sharedMemory) {
        if (sharedMemory) {
          blocks[0] =
            blocks[16] =
            blocks[1] =
            blocks[2] =
            blocks[3] =
            blocks[4] =
            blocks[5] =
            blocks[6] =
            blocks[7] =
            blocks[8] =
            blocks[9] =
            blocks[10] =
            blocks[11] =
            blocks[12] =
            blocks[13] =
            blocks[14] =
            blocks[15] =
              0;
          this.blocks = blocks;
        } else {
          this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        }
        if (is2242) {
          this.h0 = 3238371032;
          this.h1 = 914150663;
          this.h2 = 812702999;
          this.h3 = 4144912697;
          this.h4 = 4290775857;
          this.h5 = 1750603025;
          this.h6 = 1694076839;
          this.h7 = 3204075428;
        } else {
          this.h0 = 1779033703;
          this.h1 = 3144134277;
          this.h2 = 1013904242;
          this.h3 = 2773480762;
          this.h4 = 1359893119;
          this.h5 = 2600822924;
          this.h6 = 528734635;
          this.h7 = 1541459225;
        }
        this.block = this.start = this.bytes = this.hBytes = 0;
        this.finalized = this.hashed = false;
        this.first = true;
        this.is224 = is2242;
      }
      Sha256.prototype.update = function (message) {
        if (this.finalized) {
          return;
        }
        var notString,
          type = typeof message;
        if (type !== "string") {
          if (type === "object") {
            if (message === null) {
              throw new Error(ERROR);
            } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
              message = new Uint8Array(message);
            } else if (!Array.isArray(message)) {
              if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
                throw new Error(ERROR);
              }
            }
          } else {
            throw new Error(ERROR);
          }
          notString = true;
        }
        var code,
          index = 0,
          i,
          length = message.length,
          blocks2 = this.blocks;
        while (index < length) {
          if (this.hashed) {
            this.hashed = false;
            blocks2[0] = this.block;
            blocks2[16] =
              blocks2[1] =
              blocks2[2] =
              blocks2[3] =
              blocks2[4] =
              blocks2[5] =
              blocks2[6] =
              blocks2[7] =
              blocks2[8] =
              blocks2[9] =
              blocks2[10] =
              blocks2[11] =
              blocks2[12] =
              blocks2[13] =
              blocks2[14] =
              blocks2[15] =
                0;
          }
          if (notString) {
            for (i = this.start; index < length && i < 64; ++index) {
              blocks2[i >> 2] |= message[index] << SHIFT[i++ & 3];
            }
          } else {
            for (i = this.start; index < length && i < 64; ++index) {
              code = message.charCodeAt(index);
              if (code < 128) {
                blocks2[i >> 2] |= code << SHIFT[i++ & 3];
              } else if (code < 2048) {
                blocks2[i >> 2] |= (192 | (code >> 6)) << SHIFT[i++ & 3];
                blocks2[i >> 2] |= (128 | (code & 63)) << SHIFT[i++ & 3];
              } else if (code < 55296 || code >= 57344) {
                blocks2[i >> 2] |= (224 | (code >> 12)) << SHIFT[i++ & 3];
                blocks2[i >> 2] |= (128 | ((code >> 6) & 63)) << SHIFT[i++ & 3];
                blocks2[i >> 2] |= (128 | (code & 63)) << SHIFT[i++ & 3];
              } else {
                code =
                  65536 +
                  (((code & 1023) << 10) |
                    (message.charCodeAt(++index) & 1023));
                blocks2[i >> 2] |= (240 | (code >> 18)) << SHIFT[i++ & 3];
                blocks2[i >> 2] |=
                  (128 | ((code >> 12) & 63)) << SHIFT[i++ & 3];
                blocks2[i >> 2] |= (128 | ((code >> 6) & 63)) << SHIFT[i++ & 3];
                blocks2[i >> 2] |= (128 | (code & 63)) << SHIFT[i++ & 3];
              }
            }
          }
          this.lastByteIndex = i;
          this.bytes += i - this.start;
          if (i >= 64) {
            this.block = blocks2[16];
            this.start = i - 64;
            this.hash();
            this.hashed = true;
          } else {
            this.start = i;
          }
        }
        if (this.bytes > 4294967295) {
          this.hBytes += (this.bytes / 4294967296) << 0;
          this.bytes = this.bytes % 4294967296;
        }
        return this;
      };
      Sha256.prototype.finalize = function () {
        if (this.finalized) {
          return;
        }
        this.finalized = true;
        var blocks2 = this.blocks,
          i = this.lastByteIndex;
        blocks2[16] = this.block;
        blocks2[i >> 2] |= EXTRA[i & 3];
        this.block = blocks2[16];
        if (i >= 56) {
          if (!this.hashed) {
            this.hash();
          }
          blocks2[0] = this.block;
          blocks2[16] =
            blocks2[1] =
            blocks2[2] =
            blocks2[3] =
            blocks2[4] =
            blocks2[5] =
            blocks2[6] =
            blocks2[7] =
            blocks2[8] =
            blocks2[9] =
            blocks2[10] =
            blocks2[11] =
            blocks2[12] =
            blocks2[13] =
            blocks2[14] =
            blocks2[15] =
              0;
        }
        blocks2[14] = (this.hBytes << 3) | (this.bytes >>> 29);
        blocks2[15] = this.bytes << 3;
        this.hash();
      };
      Sha256.prototype.hash = function () {
        var a = this.h0,
          b = this.h1,
          c = this.h2,
          d = this.h3,
          e = this.h4,
          f = this.h5,
          g = this.h6,
          h = this.h7,
          blocks2 = this.blocks,
          j,
          s0,
          s1,
          maj,
          t1,
          t2,
          ch,
          ab,
          da,
          cd,
          bc;
        for (j = 16; j < 64; ++j) {
          t1 = blocks2[j - 15];
          s0 =
            ((t1 >>> 7) | (t1 << 25)) ^ ((t1 >>> 18) | (t1 << 14)) ^ (t1 >>> 3);
          t1 = blocks2[j - 2];
          s1 =
            ((t1 >>> 17) | (t1 << 15)) ^
            ((t1 >>> 19) | (t1 << 13)) ^
            (t1 >>> 10);
          blocks2[j] = (blocks2[j - 16] + s0 + blocks2[j - 7] + s1) << 0;
        }
        bc = b & c;
        for (j = 0; j < 64; j += 4) {
          if (this.first) {
            if (this.is224) {
              ab = 300032;
              t1 = blocks2[0] - 1413257819;
              h = (t1 - 150054599) << 0;
              d = (t1 + 24177077) << 0;
            } else {
              ab = 704751109;
              t1 = blocks2[0] - 210244248;
              h = (t1 - 1521486534) << 0;
              d = (t1 + 143694565) << 0;
            }
            this.first = false;
          } else {
            s0 =
              ((a >>> 2) | (a << 30)) ^
              ((a >>> 13) | (a << 19)) ^
              ((a >>> 22) | (a << 10));
            s1 =
              ((e >>> 6) | (e << 26)) ^
              ((e >>> 11) | (e << 21)) ^
              ((e >>> 25) | (e << 7));
            ab = a & b;
            maj = ab ^ (a & c) ^ bc;
            ch = (e & f) ^ (~e & g);
            t1 = h + s1 + ch + K[j] + blocks2[j];
            t2 = s0 + maj;
            h = (d + t1) << 0;
            d = (t1 + t2) << 0;
          }
          s0 =
            ((d >>> 2) | (d << 30)) ^
            ((d >>> 13) | (d << 19)) ^
            ((d >>> 22) | (d << 10));
          s1 =
            ((h >>> 6) | (h << 26)) ^
            ((h >>> 11) | (h << 21)) ^
            ((h >>> 25) | (h << 7));
          da = d & a;
          maj = da ^ (d & b) ^ ab;
          ch = (h & e) ^ (~h & f);
          t1 = g + s1 + ch + K[j + 1] + blocks2[j + 1];
          t2 = s0 + maj;
          g = (c + t1) << 0;
          c = (t1 + t2) << 0;
          s0 =
            ((c >>> 2) | (c << 30)) ^
            ((c >>> 13) | (c << 19)) ^
            ((c >>> 22) | (c << 10));
          s1 =
            ((g >>> 6) | (g << 26)) ^
            ((g >>> 11) | (g << 21)) ^
            ((g >>> 25) | (g << 7));
          cd = c & d;
          maj = cd ^ (c & a) ^ da;
          ch = (g & h) ^ (~g & e);
          t1 = f + s1 + ch + K[j + 2] + blocks2[j + 2];
          t2 = s0 + maj;
          f = (b + t1) << 0;
          b = (t1 + t2) << 0;
          s0 =
            ((b >>> 2) | (b << 30)) ^
            ((b >>> 13) | (b << 19)) ^
            ((b >>> 22) | (b << 10));
          s1 =
            ((f >>> 6) | (f << 26)) ^
            ((f >>> 11) | (f << 21)) ^
            ((f >>> 25) | (f << 7));
          bc = b & c;
          maj = bc ^ (b & d) ^ cd;
          ch = (f & g) ^ (~f & h);
          t1 = e + s1 + ch + K[j + 3] + blocks2[j + 3];
          t2 = s0 + maj;
          e = (a + t1) << 0;
          a = (t1 + t2) << 0;
        }
        this.h0 = (this.h0 + a) << 0;
        this.h1 = (this.h1 + b) << 0;
        this.h2 = (this.h2 + c) << 0;
        this.h3 = (this.h3 + d) << 0;
        this.h4 = (this.h4 + e) << 0;
        this.h5 = (this.h5 + f) << 0;
        this.h6 = (this.h6 + g) << 0;
        this.h7 = (this.h7 + h) << 0;
      };
      Sha256.prototype.hex = function () {
        this.finalize();
        var h0 = this.h0,
          h1 = this.h1,
          h2 = this.h2,
          h3 = this.h3,
          h4 = this.h4,
          h5 = this.h5,
          h6 = this.h6,
          h7 = this.h7;
        var hex =
          HEX_CHARS[(h0 >> 28) & 15] +
          HEX_CHARS[(h0 >> 24) & 15] +
          HEX_CHARS[(h0 >> 20) & 15] +
          HEX_CHARS[(h0 >> 16) & 15] +
          HEX_CHARS[(h0 >> 12) & 15] +
          HEX_CHARS[(h0 >> 8) & 15] +
          HEX_CHARS[(h0 >> 4) & 15] +
          HEX_CHARS[h0 & 15] +
          HEX_CHARS[(h1 >> 28) & 15] +
          HEX_CHARS[(h1 >> 24) & 15] +
          HEX_CHARS[(h1 >> 20) & 15] +
          HEX_CHARS[(h1 >> 16) & 15] +
          HEX_CHARS[(h1 >> 12) & 15] +
          HEX_CHARS[(h1 >> 8) & 15] +
          HEX_CHARS[(h1 >> 4) & 15] +
          HEX_CHARS[h1 & 15] +
          HEX_CHARS[(h2 >> 28) & 15] +
          HEX_CHARS[(h2 >> 24) & 15] +
          HEX_CHARS[(h2 >> 20) & 15] +
          HEX_CHARS[(h2 >> 16) & 15] +
          HEX_CHARS[(h2 >> 12) & 15] +
          HEX_CHARS[(h2 >> 8) & 15] +
          HEX_CHARS[(h2 >> 4) & 15] +
          HEX_CHARS[h2 & 15] +
          HEX_CHARS[(h3 >> 28) & 15] +
          HEX_CHARS[(h3 >> 24) & 15] +
          HEX_CHARS[(h3 >> 20) & 15] +
          HEX_CHARS[(h3 >> 16) & 15] +
          HEX_CHARS[(h3 >> 12) & 15] +
          HEX_CHARS[(h3 >> 8) & 15] +
          HEX_CHARS[(h3 >> 4) & 15] +
          HEX_CHARS[h3 & 15] +
          HEX_CHARS[(h4 >> 28) & 15] +
          HEX_CHARS[(h4 >> 24) & 15] +
          HEX_CHARS[(h4 >> 20) & 15] +
          HEX_CHARS[(h4 >> 16) & 15] +
          HEX_CHARS[(h4 >> 12) & 15] +
          HEX_CHARS[(h4 >> 8) & 15] +
          HEX_CHARS[(h4 >> 4) & 15] +
          HEX_CHARS[h4 & 15] +
          HEX_CHARS[(h5 >> 28) & 15] +
          HEX_CHARS[(h5 >> 24) & 15] +
          HEX_CHARS[(h5 >> 20) & 15] +
          HEX_CHARS[(h5 >> 16) & 15] +
          HEX_CHARS[(h5 >> 12) & 15] +
          HEX_CHARS[(h5 >> 8) & 15] +
          HEX_CHARS[(h5 >> 4) & 15] +
          HEX_CHARS[h5 & 15] +
          HEX_CHARS[(h6 >> 28) & 15] +
          HEX_CHARS[(h6 >> 24) & 15] +
          HEX_CHARS[(h6 >> 20) & 15] +
          HEX_CHARS[(h6 >> 16) & 15] +
          HEX_CHARS[(h6 >> 12) & 15] +
          HEX_CHARS[(h6 >> 8) & 15] +
          HEX_CHARS[(h6 >> 4) & 15] +
          HEX_CHARS[h6 & 15];
        if (!this.is224) {
          hex +=
            HEX_CHARS[(h7 >> 28) & 15] +
            HEX_CHARS[(h7 >> 24) & 15] +
            HEX_CHARS[(h7 >> 20) & 15] +
            HEX_CHARS[(h7 >> 16) & 15] +
            HEX_CHARS[(h7 >> 12) & 15] +
            HEX_CHARS[(h7 >> 8) & 15] +
            HEX_CHARS[(h7 >> 4) & 15] +
            HEX_CHARS[h7 & 15];
        }
        return hex;
      };
      Sha256.prototype.toString = Sha256.prototype.hex;
      Sha256.prototype.digest = function () {
        this.finalize();
        var h0 = this.h0,
          h1 = this.h1,
          h2 = this.h2,
          h3 = this.h3,
          h4 = this.h4,
          h5 = this.h5,
          h6 = this.h6,
          h7 = this.h7;
        var arr = [
          (h0 >> 24) & 255,
          (h0 >> 16) & 255,
          (h0 >> 8) & 255,
          h0 & 255,
          (h1 >> 24) & 255,
          (h1 >> 16) & 255,
          (h1 >> 8) & 255,
          h1 & 255,
          (h2 >> 24) & 255,
          (h2 >> 16) & 255,
          (h2 >> 8) & 255,
          h2 & 255,
          (h3 >> 24) & 255,
          (h3 >> 16) & 255,
          (h3 >> 8) & 255,
          h3 & 255,
          (h4 >> 24) & 255,
          (h4 >> 16) & 255,
          (h4 >> 8) & 255,
          h4 & 255,
          (h5 >> 24) & 255,
          (h5 >> 16) & 255,
          (h5 >> 8) & 255,
          h5 & 255,
          (h6 >> 24) & 255,
          (h6 >> 16) & 255,
          (h6 >> 8) & 255,
          h6 & 255,
        ];
        if (!this.is224) {
          arr.push(
            (h7 >> 24) & 255,
            (h7 >> 16) & 255,
            (h7 >> 8) & 255,
            h7 & 255
          );
        }
        return arr;
      };
      Sha256.prototype.array = Sha256.prototype.digest;
      Sha256.prototype.arrayBuffer = function () {
        this.finalize();
        var buffer = new ArrayBuffer(this.is224 ? 28 : 32);
        var dataView = new DataView(buffer);
        dataView.setUint32(0, this.h0);
        dataView.setUint32(4, this.h1);
        dataView.setUint32(8, this.h2);
        dataView.setUint32(12, this.h3);
        dataView.setUint32(16, this.h4);
        dataView.setUint32(20, this.h5);
        dataView.setUint32(24, this.h6);
        if (!this.is224) {
          dataView.setUint32(28, this.h7);
        }
        return buffer;
      };
      function HmacSha256(key, is2242, sharedMemory) {
        var i,
          type = typeof key;
        if (type === "string") {
          var bytes = [],
            length = key.length,
            index = 0,
            code;
          for (i = 0; i < length; ++i) {
            code = key.charCodeAt(i);
            if (code < 128) {
              bytes[index++] = code;
            } else if (code < 2048) {
              bytes[index++] = 192 | (code >> 6);
              bytes[index++] = 128 | (code & 63);
            } else if (code < 55296 || code >= 57344) {
              bytes[index++] = 224 | (code >> 12);
              bytes[index++] = 128 | ((code >> 6) & 63);
              bytes[index++] = 128 | (code & 63);
            } else {
              code =
                65536 + (((code & 1023) << 10) | (key.charCodeAt(++i) & 1023));
              bytes[index++] = 240 | (code >> 18);
              bytes[index++] = 128 | ((code >> 12) & 63);
              bytes[index++] = 128 | ((code >> 6) & 63);
              bytes[index++] = 128 | (code & 63);
            }
          }
          key = bytes;
        } else {
          if (type === "object") {
            if (key === null) {
              throw new Error(ERROR);
            } else if (ARRAY_BUFFER && key.constructor === ArrayBuffer) {
              key = new Uint8Array(key);
            } else if (!Array.isArray(key)) {
              if (!ARRAY_BUFFER || !ArrayBuffer.isView(key)) {
                throw new Error(ERROR);
              }
            }
          } else {
            throw new Error(ERROR);
          }
        }
        if (key.length > 64) {
          key = new Sha256(is2242, true).update(key).array();
        }
        var oKeyPad = [],
          iKeyPad = [];
        for (i = 0; i < 64; ++i) {
          var b = key[i] || 0;
          oKeyPad[i] = 92 ^ b;
          iKeyPad[i] = 54 ^ b;
        }
        Sha256.call(this, is2242, sharedMemory);
        this.update(iKeyPad);
        this.oKeyPad = oKeyPad;
        this.inner = true;
        this.sharedMemory = sharedMemory;
      }
      HmacSha256.prototype = new Sha256();
      HmacSha256.prototype.finalize = function () {
        Sha256.prototype.finalize.call(this);
        if (this.inner) {
          this.inner = false;
          var innerHash = this.array();
          Sha256.call(this, this.is224, this.sharedMemory);
          this.update(this.oKeyPad);
          this.update(innerHash);
          Sha256.prototype.finalize.call(this);
        }
      };
      var exports = createMethod();
      exports.sha256 = exports;
      exports.sha224 = createMethod(true);
      exports.sha256.hmac = createHmacMethod();
      exports.sha224.hmac = createHmacMethod(true);
      if (COMMON_JS) {
        module.exports = exports;
      } else {
        root.sha256 = exports.sha256;
        root.sha224 = exports.sha224;
        if (AMD) {
          define(function () {
            return exports;
          });
        }
      }
    })();
  },
});

// node_modules/@near-js/transactions/lib/sign.js
var require_sign = __commonJS({
  "node_modules/@near-js/transactions/lib/sign.js"(exports2) {
    var __awaiter =
      (exports2 && exports2.__awaiter) ||
      function (thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P
            ? value
            : new P(function (resolve) {
                resolve(value);
              });
        }
        return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done
              ? resolve(result.value)
              : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
    var __importDefault =
      (exports2 && exports2.__importDefault) ||
      function (mod) {
        return mod && mod.__esModule ? mod : { default: mod };
      };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.signDelegateAction = exports2.signTransaction = void 0;
    var js_sha256_1 = __importDefault(require_sha256());
    var actions_1 = require_actions();
    var create_transaction_1 = require_create_transaction();
    var schema_1 = require_schema();
    var signature_1 = require_signature();
    function signTransactionObject(transaction, signer, accountId, networkId) {
      return __awaiter(this, void 0, void 0, function* () {
        const message = (0, schema_1.encodeTransaction)(transaction);
        const hash = new Uint8Array(js_sha256_1.default.sha256.array(message));
        const signature = yield signer.signMessage(
          message,
          accountId,
          networkId
        );
        const signedTx = new schema_1.SignedTransaction({
          transaction,
          signature: new signature_1.Signature({
            keyType: transaction.publicKey.keyType,
            data: signature.signature,
          }),
        });
        return [hash, signedTx];
      });
    }
    function signTransaction(...args) {
      return __awaiter(this, void 0, void 0, function* () {
        if (args[0].constructor === schema_1.Transaction) {
          const [transaction, signer, accountId, networkId] = args;
          return signTransactionObject(
            transaction,
            signer,
            accountId,
            networkId
          );
        } else {
          const [
            receiverId,
            nonce,
            actions,
            blockHash,
            signer,
            accountId,
            networkId,
          ] = args;
          const publicKey = yield signer.getPublicKey(accountId, networkId);
          const transaction = (0, create_transaction_1.createTransaction)(
            accountId,
            publicKey,
            receiverId,
            nonce,
            actions,
            blockHash
          );
          return signTransactionObject(
            transaction,
            signer,
            accountId,
            networkId
          );
        }
      });
    }
    exports2.signTransaction = signTransaction;
    function signDelegateAction({ delegateAction, signer }) {
      return __awaiter(this, void 0, void 0, function* () {
        const message = (0, schema_1.encodeDelegateAction)(delegateAction);
        const signature = yield signer.sign(message);
        const signedDelegateAction = new actions_1.SignedDelegate({
          delegateAction,
          signature: new signature_1.Signature({
            keyType: delegateAction.publicKey.keyType,
            data: signature,
          }),
        });
        return {
          hash: new Uint8Array(js_sha256_1.default.sha256.array(message)),
          signedDelegateAction,
        };
      });
    }
    exports2.signDelegateAction = signDelegateAction;
  },
});

// node_modules/@near-js/transactions/lib/index.js
var require_lib7 = __commonJS({
  "node_modules/@near-js/transactions/lib/index.js"(exports2) {
    var __createBinding =
      (exports2 && exports2.__createBinding) ||
      (Object.create
        ? function (o, m, k, k2) {
            if (k2 === void 0) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);
            if (
              !desc ||
              ("get" in desc
                ? !m.__esModule
                : desc.writable || desc.configurable)
            ) {
              desc = {
                enumerable: true,
                get: function () {
                  return m[k];
                },
              };
            }
            Object.defineProperty(o, k2, desc);
          }
        : function (o, m, k, k2) {
            if (k2 === void 0) k2 = k;
            o[k2] = m[k];
          });
    var __exportStar =
      (exports2 && exports2.__exportStar) ||
      function (m, exports3) {
        for (var p in m)
          if (
            p !== "default" &&
            !Object.prototype.hasOwnProperty.call(exports3, p)
          )
            __createBinding(exports3, m, p);
      };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_action_creators(), exports2);
    __exportStar(require_actions(), exports2);
    __exportStar(require_create_transaction(), exports2);
    __exportStar(require_delegate(), exports2);
    __exportStar(require_schema(), exports2);
    __exportStar(require_sign(), exports2);
    __exportStar(require_signature(), exports2);
  },
});

// node_modules/@near-js/providers/lib/provider.js
var require_provider3 = __commonJS({
  "node_modules/@near-js/providers/lib/provider.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Provider = void 0;
    var Provider = class {};
    exports2.Provider = Provider;
  },
});

// node_modules/http-errors/node_modules/depd/lib/browser/index.js
var require_browser2 = __commonJS({
  "node_modules/http-errors/node_modules/depd/lib/browser/index.js"(
    exports2,
    module2
  ) {
    module2.exports = depd;
    function depd(namespace) {
      if (!namespace) {
        throw new TypeError("argument namespace is required");
      }
      function deprecate(message) {}
      deprecate._file = void 0;
      deprecate._ignored = true;
      deprecate._namespace = namespace;
      deprecate._traced = false;
      deprecate._warned = /* @__PURE__ */ Object.create(null);
      deprecate.function = wrapfunction;
      deprecate.property = wrapproperty;
      return deprecate;
    }
    function wrapfunction(fn, message) {
      if (typeof fn !== "function") {
        throw new TypeError("argument fn must be a function");
      }
      return fn;
    }
    function wrapproperty(obj, prop, message) {
      if (!obj || (typeof obj !== "object" && typeof obj !== "function")) {
        throw new TypeError("argument obj must be object");
      }
      var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
      if (!descriptor) {
        throw new TypeError("must call property on owner object");
      }
      if (!descriptor.configurable) {
        throw new TypeError("property must be configurable");
      }
    }
  },
});

// node_modules/setprototypeof/index.js
var require_setprototypeof = __commonJS({
  "node_modules/setprototypeof/index.js"(exports2, module2) {
    module2.exports =
      Object.setPrototypeOf ||
      ({ __proto__: [] } instanceof Array ? setProtoOf : mixinProperties);
    function setProtoOf(obj, proto) {
      obj.__proto__ = proto;
      return obj;
    }
    function mixinProperties(obj, proto) {
      for (var prop in proto) {
        if (!Object.prototype.hasOwnProperty.call(obj, prop)) {
          obj[prop] = proto[prop];
        }
      }
      return obj;
    }
  },
});

// node_modules/statuses/codes.json
var require_codes = __commonJS({
  "node_modules/statuses/codes.json"(exports2, module2) {
    module2.exports = {
      100: "Continue",
      101: "Switching Protocols",
      102: "Processing",
      103: "Early Hints",
      200: "OK",
      201: "Created",
      202: "Accepted",
      203: "Non-Authoritative Information",
      204: "No Content",
      205: "Reset Content",
      206: "Partial Content",
      207: "Multi-Status",
      208: "Already Reported",
      226: "IM Used",
      300: "Multiple Choices",
      301: "Moved Permanently",
      302: "Found",
      303: "See Other",
      304: "Not Modified",
      305: "Use Proxy",
      306: "(Unused)",
      307: "Temporary Redirect",
      308: "Permanent Redirect",
      400: "Bad Request",
      401: "Unauthorized",
      402: "Payment Required",
      403: "Forbidden",
      404: "Not Found",
      405: "Method Not Allowed",
      406: "Not Acceptable",
      407: "Proxy Authentication Required",
      408: "Request Timeout",
      409: "Conflict",
      410: "Gone",
      411: "Length Required",
      412: "Precondition Failed",
      413: "Payload Too Large",
      414: "URI Too Long",
      415: "Unsupported Media Type",
      416: "Range Not Satisfiable",
      417: "Expectation Failed",
      418: "I'm a teapot",
      421: "Misdirected Request",
      422: "Unprocessable Entity",
      423: "Locked",
      424: "Failed Dependency",
      425: "Unordered Collection",
      426: "Upgrade Required",
      428: "Precondition Required",
      429: "Too Many Requests",
      431: "Request Header Fields Too Large",
      451: "Unavailable For Legal Reasons",
      500: "Internal Server Error",
      501: "Not Implemented",
      502: "Bad Gateway",
      503: "Service Unavailable",
      504: "Gateway Timeout",
      505: "HTTP Version Not Supported",
      506: "Variant Also Negotiates",
      507: "Insufficient Storage",
      508: "Loop Detected",
      509: "Bandwidth Limit Exceeded",
      510: "Not Extended",
      511: "Network Authentication Required",
    };
  },
});

// node_modules/statuses/index.js
var require_statuses = __commonJS({
  "node_modules/statuses/index.js"(exports2, module2) {
    var codes = require_codes();
    module2.exports = status;
    status.STATUS_CODES = codes;
    status.codes = populateStatusesMap(status, codes);
    status.redirect = {
      300: true,
      301: true,
      302: true,
      303: true,
      305: true,
      307: true,
      308: true,
    };
    status.empty = {
      204: true,
      205: true,
      304: true,
    };
    status.retry = {
      502: true,
      503: true,
      504: true,
    };
    function populateStatusesMap(statuses, codes2) {
      var arr = [];
      Object.keys(codes2).forEach(function forEachCode(code) {
        var message = codes2[code];
        var status2 = Number(code);
        statuses[status2] = message;
        statuses[message] = status2;
        statuses[message.toLowerCase()] = status2;
        arr.push(status2);
      });
      return arr;
    }
    function status(code) {
      if (typeof code === "number") {
        if (!status[code]) throw new Error("invalid status code: " + code);
        return code;
      }
      if (typeof code !== "string") {
        throw new TypeError("code must be a number or string");
      }
      var n = parseInt(code, 10);
      if (!isNaN(n)) {
        if (!status[n]) throw new Error("invalid status code: " + n);
        return n;
      }
      n = status[code.toLowerCase()];
      if (!n) throw new Error('invalid status message: "' + code + '"');
      return n;
    }
  },
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/inherits/inherits_browser.js"(exports2, module2) {
    if (typeof Object.create === "function") {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true,
            },
          });
        }
      };
    } else {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function () {};
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  },
});

// node_modules/toidentifier/index.js
var require_toidentifier = __commonJS({
  "node_modules/toidentifier/index.js"(exports2, module2) {
    module2.exports = toIdentifier;
    function toIdentifier(str) {
      return str
        .split(" ")
        .map(function (token) {
          return token.slice(0, 1).toUpperCase() + token.slice(1);
        })
        .join("")
        .replace(/[^ _0-9a-z]/gi, "");
    }
  },
});

// node_modules/http-errors/index.js
var require_http_errors = __commonJS({
  "node_modules/http-errors/index.js"(exports2, module2) {
    var deprecate = require_browser2()("http-errors");
    var setPrototypeOf = require_setprototypeof();
    var statuses = require_statuses();
    var inherits = require_inherits_browser();
    var toIdentifier = require_toidentifier();
    module2.exports = createError;
    module2.exports.HttpError = createHttpErrorConstructor();
    module2.exports.isHttpError = createIsHttpErrorFunction(
      module2.exports.HttpError
    );
    populateConstructorExports(
      module2.exports,
      statuses.codes,
      module2.exports.HttpError
    );
    function codeClass(status) {
      return Number(String(status).charAt(0) + "00");
    }
    function createError() {
      var err;
      var msg;
      var status = 500;
      var props = {};
      for (var i = 0; i < arguments.length; i++) {
        var arg = arguments[i];
        if (arg instanceof Error) {
          err = arg;
          status = err.status || err.statusCode || status;
          continue;
        }
        switch (typeof arg) {
          case "string":
            msg = arg;
            break;
          case "number":
            status = arg;
            if (i !== 0) {
              deprecate(
                "non-first-argument status code; replace with createError(" +
                  arg +
                  ", ...)"
              );
            }
            break;
          case "object":
            props = arg;
            break;
        }
      }
      if (typeof status === "number" && (status < 400 || status >= 600)) {
        deprecate("non-error status code; use only 4xx or 5xx status codes");
      }
      if (
        typeof status !== "number" ||
        (!statuses[status] && (status < 400 || status >= 600))
      ) {
        status = 500;
      }
      var HttpError = createError[status] || createError[codeClass(status)];
      if (!err) {
        err = HttpError
          ? new HttpError(msg)
          : new Error(msg || statuses[status]);
        Error.captureStackTrace(err, createError);
      }
      if (!HttpError || !(err instanceof HttpError) || err.status !== status) {
        err.expose = status < 500;
        err.status = err.statusCode = status;
      }
      for (var key in props) {
        if (key !== "status" && key !== "statusCode") {
          err[key] = props[key];
        }
      }
      return err;
    }
    function createHttpErrorConstructor() {
      function HttpError() {
        throw new TypeError("cannot construct abstract class");
      }
      inherits(HttpError, Error);
      return HttpError;
    }
    function createClientErrorConstructor(HttpError, name, code) {
      var className = toClassName(name);
      function ClientError(message) {
        var msg = message != null ? message : statuses[code];
        var err = new Error(msg);
        Error.captureStackTrace(err, ClientError);
        setPrototypeOf(err, ClientError.prototype);
        Object.defineProperty(err, "message", {
          enumerable: true,
          configurable: true,
          value: msg,
          writable: true,
        });
        Object.defineProperty(err, "name", {
          enumerable: false,
          configurable: true,
          value: className,
          writable: true,
        });
        return err;
      }
      inherits(ClientError, HttpError);
      nameFunc(ClientError, className);
      ClientError.prototype.status = code;
      ClientError.prototype.statusCode = code;
      ClientError.prototype.expose = true;
      return ClientError;
    }
    function createIsHttpErrorFunction(HttpError) {
      return function isHttpError(val) {
        if (!val || typeof val !== "object") {
          return false;
        }
        if (val instanceof HttpError) {
          return true;
        }
        return (
          val instanceof Error &&
          typeof val.expose === "boolean" &&
          typeof val.statusCode === "number" &&
          val.status === val.statusCode
        );
      };
    }
    function createServerErrorConstructor(HttpError, name, code) {
      var className = toClassName(name);
      function ServerError(message) {
        var msg = message != null ? message : statuses[code];
        var err = new Error(msg);
        Error.captureStackTrace(err, ServerError);
        setPrototypeOf(err, ServerError.prototype);
        Object.defineProperty(err, "message", {
          enumerable: true,
          configurable: true,
          value: msg,
          writable: true,
        });
        Object.defineProperty(err, "name", {
          enumerable: false,
          configurable: true,
          value: className,
          writable: true,
        });
        return err;
      }
      inherits(ServerError, HttpError);
      nameFunc(ServerError, className);
      ServerError.prototype.status = code;
      ServerError.prototype.statusCode = code;
      ServerError.prototype.expose = false;
      return ServerError;
    }
    function nameFunc(func, name) {
      var desc = Object.getOwnPropertyDescriptor(func, "name");
      if (desc && desc.configurable) {
        desc.value = name;
        Object.defineProperty(func, "name", desc);
      }
    }
    function populateConstructorExports(exports3, codes, HttpError) {
      codes.forEach(function forEachCode(code) {
        var CodeError;
        var name = toIdentifier(statuses[code]);
        switch (codeClass(code)) {
          case 400:
            CodeError = createClientErrorConstructor(HttpError, name, code);
            break;
          case 500:
            CodeError = createServerErrorConstructor(HttpError, name, code);
            break;
        }
        if (CodeError) {
          exports3[code] = CodeError;
          exports3[name] = CodeError;
        }
      });
      exports3["I'mateapot"] = deprecate.function(
        exports3.ImATeapot,
        `"I'mateapot"; use "ImATeapot" instead`
      );
    }
    function toClassName(name) {
      return name.substr(-5) !== "Error" ? name + "Error" : name;
    }
  },
});

// node_modules/node-fetch/browser.js
var require_browser3 = __commonJS({
  "node_modules/node-fetch/browser.js"(exports2, module2) {
    var getGlobal = function () {
      if (typeof self !== "undefined") {
        return self;
      }
      if (typeof window !== "undefined") {
        return window;
      }
      if (typeof global !== "undefined") {
        return global;
      }
      throw new Error("unable to locate global object");
    };
    var globalObject = getGlobal();
    module2.exports = exports2 = globalObject.fetch;
    if (globalObject.fetch) {
      exports2.default = globalObject.fetch.bind(globalObject);
    }
    exports2.Headers = globalObject.Headers;
    exports2.Request = globalObject.Request;
    exports2.Response = globalObject.Response;
  },
});

// browser-external:http
var require_http = __commonJS({
  "browser-external:http"(exports2, module2) {
    module2.exports = {};
  },
});

// browser-external:https
var require_https = __commonJS({
  "browser-external:https"(exports2, module2) {
    module2.exports = {};
  },
});

// node_modules/@near-js/providers/lib/fetch.js
var require_fetch = __commonJS({
  "node_modules/@near-js/providers/lib/fetch.js"(exports2) {
    var __importDefault =
      (exports2 && exports2.__importDefault) ||
      function (mod) {
        return mod && mod.__esModule ? mod : { default: mod };
      };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var node_fetch_1 = __importDefault(require_browser3());
    var http_1 = __importDefault(require_http());
    var https_1 = __importDefault(require_https());
    var httpAgent = new http_1.default.Agent({ keepAlive: true });
    var httpsAgent = new https_1.default.Agent({ keepAlive: true });
    function agent(_parsedURL) {
      if (_parsedURL.protocol === "http:") {
        return httpAgent;
      } else {
        return httpsAgent;
      }
    }
    function default_1(resource, init) {
      return (0, node_fetch_1.default)(
        resource,
        Object.assign({ agent: agent(new URL(resource.toString())) }, init)
      );
    }
    exports2.default = default_1;
  },
});

// node_modules/@near-js/providers/lib/fetch_json.js
var require_fetch_json = __commonJS({
  "node_modules/@near-js/providers/lib/fetch_json.js"(exports2) {
    var __createBinding =
      (exports2 && exports2.__createBinding) ||
      (Object.create
        ? function (o, m, k, k2) {
            if (k2 === void 0) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);
            if (
              !desc ||
              ("get" in desc
                ? !m.__esModule
                : desc.writable || desc.configurable)
            ) {
              desc = {
                enumerable: true,
                get: function () {
                  return m[k];
                },
              };
            }
            Object.defineProperty(o, k2, desc);
          }
        : function (o, m, k, k2) {
            if (k2 === void 0) k2 = k;
            o[k2] = m[k];
          });
    var __setModuleDefault =
      (exports2 && exports2.__setModuleDefault) ||
      (Object.create
        ? function (o, v) {
            Object.defineProperty(o, "default", { enumerable: true, value: v });
          }
        : function (o, v) {
            o["default"] = v;
          });
    var __importStar =
      (exports2 && exports2.__importStar) ||
      function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    var __awaiter =
      (exports2 && exports2.__awaiter) ||
      function (thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P
            ? value
            : new P(function (resolve) {
                resolve(value);
              });
        }
        return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done
              ? resolve(result.value)
              : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
    var __importDefault =
      (exports2 && exports2.__importDefault) ||
      function (mod) {
        return mod && mod.__esModule ? mod : { default: mod };
      };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.fetchJson = void 0;
    var types_1 = require_lib2();
    var http_errors_1 = __importDefault(require_http_errors());
    var exponential_backoff_1 = require_exponential_backoff();
    var START_WAIT_TIME_MS = 1e3;
    var BACKOFF_MULTIPLIER = 1.5;
    var RETRY_NUMBER = 10;
    var logWarning = (...args) => !{}["NEAR_NO_LOGS"] && console.warn(...args);
    function fetchJson(connectionInfoOrUrl, json) {
      return __awaiter(this, void 0, void 0, function* () {
        let connectionInfo = { url: null };
        if (typeof connectionInfoOrUrl === "string") {
          connectionInfo.url = connectionInfoOrUrl;
        } else {
          connectionInfo = connectionInfoOrUrl;
        }
        const response = yield (0, exponential_backoff_1.exponentialBackoff)(
          START_WAIT_TIME_MS,
          RETRY_NUMBER,
          BACKOFF_MULTIPLIER,
          () =>
            __awaiter(this, void 0, void 0, function* () {
              try {
                if (!global.fetch) {
                  global.fetch = (yield Promise.resolve().then(() =>
                    __importStar(require_fetch())
                  )).default;
                }
                const response2 = yield global.fetch(connectionInfo.url, {
                  method: json ? "POST" : "GET",
                  body: json ? json : void 0,
                  headers: Object.assign(
                    Object.assign({}, connectionInfo.headers),
                    { "Content-Type": "application/json" }
                  ),
                });
                if (!response2.ok) {
                  if (response2.status === 503) {
                    logWarning(
                      `Retrying HTTP request for ${connectionInfo.url} as it's not available now`
                    );
                    return null;
                  }
                  throw (0, http_errors_1.default)(
                    response2.status,
                    yield response2.text()
                  );
                }
                return response2;
              } catch (error) {
                if (
                  error.toString().includes("FetchError") ||
                  error.toString().includes("Failed to fetch")
                ) {
                  logWarning(
                    `Retrying HTTP request for ${connectionInfo.url} because of error: ${error}`
                  );
                  return null;
                }
                throw error;
              }
            })
        );
        if (!response) {
          throw new types_1.TypedError(
            `Exceeded ${RETRY_NUMBER} attempts for ${connectionInfo.url}.`,
            "RetriesExceeded"
          );
        }
        return yield response.json();
      });
    }
    exports2.fetchJson = fetchJson;
  },
});

// node_modules/@near-js/providers/lib/json-rpc-provider.js
var require_json_rpc_provider = __commonJS({
  "node_modules/@near-js/providers/lib/json-rpc-provider.js"(exports2) {
    var __awaiter =
      (exports2 && exports2.__awaiter) ||
      function (thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P
            ? value
            : new P(function (resolve) {
                resolve(value);
              });
        }
        return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done
              ? resolve(result.value)
              : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
    var __rest =
      (exports2 && exports2.__rest) ||
      function (s, e) {
        var t = {};
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
          for (
            var i = 0, p = Object.getOwnPropertySymbols(s);
            i < p.length;
            i++
          ) {
            if (
              e.indexOf(p[i]) < 0 &&
              Object.prototype.propertyIsEnumerable.call(s, p[i])
            )
              t[p[i]] = s[p[i]];
          }
        return t;
      };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.JsonRpcProvider = void 0;
    var utils_1 = require_lib6();
    var types_1 = require_lib2();
    var transactions_1 = require_lib7();
    var borsh_1 = require_lib();
    var exponential_backoff_1 = require_exponential_backoff();
    var provider_1 = require_provider3();
    var fetch_json_1 = require_fetch_json();
    var REQUEST_RETRY_NUMBER = 12;
    var REQUEST_RETRY_WAIT = 500;
    var REQUEST_RETRY_WAIT_BACKOFF = 1.5;
    var _nextId = 123;
    var JsonRpcProvider = class extends provider_1.Provider {
      /**
       * @param connectionInfo Connection info
       */
      constructor(connectionInfo) {
        super();
        this.connection = connectionInfo || { url: "" };
      }
      /**
       * Gets the RPC's status
       * @see [https://docs.near.org/docs/develop/front-end/rpc#general-validator-status](https://docs.near.org/docs/develop/front-end/rpc#general-validator-status)
       */
      status() {
        return __awaiter(this, void 0, void 0, function* () {
          return this.sendJsonRpc("status", []);
        });
      }
      /**
       * Sends a signed transaction to the RPC and waits until transaction is fully complete
       * @see [https://docs.near.org/docs/develop/front-end/rpc#send-transaction-await](https://docs.near.org/docs/develop/front-end/rpc#general-validator-status)
       *
       * @param signedTransaction The signed transaction being sent
       */
      sendTransaction(signedTransaction) {
        return __awaiter(this, void 0, void 0, function* () {
          const bytes = (0, transactions_1.encodeTransaction)(
            signedTransaction
          );
          return this.sendJsonRpc("broadcast_tx_commit", [
            Buffer.from(bytes).toString("base64"),
          ]);
        });
      }
      /**
       * Sends a signed transaction to the RPC and immediately returns transaction hash
       * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#send-transaction-async)
       * @param signedTransaction The signed transaction being sent
       * @returns {Promise<FinalExecutionOutcome>}
       */
      sendTransactionAsync(signedTransaction) {
        return __awaiter(this, void 0, void 0, function* () {
          const bytes = (0, transactions_1.encodeTransaction)(
            signedTransaction
          );
          return this.sendJsonRpc("broadcast_tx_async", [
            Buffer.from(bytes).toString("base64"),
          ]);
        });
      }
      /**
       * Gets a transaction's status from the RPC
       * @see [https://docs.near.org/docs/develop/front-end/rpc#transaction-status](https://docs.near.org/docs/develop/front-end/rpc#general-validator-status)
       *
       * @param txHash A transaction hash as either a Uint8Array or a base58 encoded string
       * @param accountId The NEAR account that signed the transaction
       */
      txStatus(txHash, accountId) {
        return __awaiter(this, void 0, void 0, function* () {
          if (typeof txHash === "string") {
            return this.txStatusString(txHash, accountId);
          } else {
            return this.txStatusUint8Array(txHash, accountId);
          }
        });
      }
      txStatusUint8Array(txHash, accountId) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.sendJsonRpc("tx", [
            (0, borsh_1.baseEncode)(txHash),
            accountId,
          ]);
        });
      }
      txStatusString(txHash, accountId) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.sendJsonRpc("tx", [txHash, accountId]);
        });
      }
      /**
       * Gets a transaction's status from the RPC with receipts
       * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#transaction-status-with-receipts)
       * @param txHash The hash of the transaction
       * @param accountId The NEAR account that signed the transaction
       * @returns {Promise<FinalExecutionOutcome>}
       */
      txStatusReceipts(txHash, accountId) {
        return __awaiter(this, void 0, void 0, function* () {
          if (typeof txHash === "string") {
            return this.sendJsonRpc("EXPERIMENTAL_tx_status", [
              txHash,
              accountId,
            ]);
          } else {
            return this.sendJsonRpc("EXPERIMENTAL_tx_status", [
              (0, borsh_1.baseEncode)(txHash),
              accountId,
            ]);
          }
        });
      }
      /**
       * Query the RPC by passing an {@link providers/provider!RpcQueryRequest}
       * @see [https://docs.near.org/api/rpc/contracts](https://docs.near.org/api/rpc/contracts)
       *
       * @typeParam T the shape of the returned query response
       */
      query(...args) {
        return __awaiter(this, void 0, void 0, function* () {
          let result;
          if (args.length === 1) {
            const _a = args[0],
              { block_id, blockId } = _a,
              otherParams = __rest(_a, ["block_id", "blockId"]);
            result = yield this.sendJsonRpc(
              "query",
              Object.assign(Object.assign({}, otherParams), {
                block_id: block_id || blockId,
              })
            );
          } else {
            const [path, data] = args;
            result = yield this.sendJsonRpc("query", [path, data]);
          }
          if (result && result.error) {
            throw new types_1.TypedError(
              `Querying failed: ${result.error}.
${JSON.stringify(result, null, 2)}`,
              (0, utils_1.getErrorTypeFromErrorMessage)(
                result.error,
                result.error.name
              )
            );
          }
          return result;
        });
      }
      /**
       * Query for block info from the RPC
       * pass block_id OR finality as blockQuery, not both
       * @see [https://docs.near.org/api/rpc/block-chunk](https://docs.near.org/api/rpc/block-chunk)
       *
       * @param blockQuery {@link providers/provider!BlockReference} (passing a {@link providers/provider!BlockId} is deprecated)
       */
      block(blockQuery) {
        return __awaiter(this, void 0, void 0, function* () {
          const { finality } = blockQuery;
          const { blockId } = blockQuery;
          return this.sendJsonRpc("block", { block_id: blockId, finality });
        });
      }
      /**
       * Query changes in block from the RPC
       * pass block_id OR finality as blockQuery, not both
       * @see [https://docs.near.org/api/rpc/block-chunk](https://docs.near.org/api/rpc/block-chunk)
       */
      blockChanges(blockQuery) {
        return __awaiter(this, void 0, void 0, function* () {
          const { finality } = blockQuery;
          const { blockId } = blockQuery;
          return this.sendJsonRpc("EXPERIMENTAL_changes_in_block", {
            block_id: blockId,
            finality,
          });
        });
      }
      /**
       * Queries for details about a specific chunk appending details of receipts and transactions to the same chunk data provided by a block
       * @see [https://docs.near.org/api/rpc/block-chunk](https://docs.near.org/api/rpc/block-chunk)
       *
       * @param chunkId Hash of a chunk ID or shard ID
       */
      chunk(chunkId) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.sendJsonRpc("chunk", [chunkId]);
        });
      }
      /**
       * Query validators of the epoch defined by the given block id.
       * @see [https://docs.near.org/api/rpc/network#validation-status](https://docs.near.org/api/rpc/network#validation-status)
       *
       * @param blockId Block hash or height, or null for latest.
       */
      validators(blockId) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.sendJsonRpc("validators", [blockId]);
        });
      }
      /**
       * Gets the protocol config at a block from RPC
       *
       * @param blockReference specifies the block to get the protocol config for
       */
      experimental_protocolConfig(blockReference) {
        return __awaiter(this, void 0, void 0, function* () {
          const _a = blockReference,
            { blockId } = _a,
            otherParams = __rest(_a, ["blockId"]);
          return yield this.sendJsonRpc(
            "EXPERIMENTAL_protocol_config",
            Object.assign(Object.assign({}, otherParams), { block_id: blockId })
          );
        });
      }
      /**
       * Gets a light client execution proof for verifying execution outcomes
       * @see [https://github.com/nearprotocol/NEPs/blob/master/specs/ChainSpec/LightClient.md#light-client-proof](https://github.com/nearprotocol/NEPs/blob/master/specs/ChainSpec/LightClient.md#light-client-proof)
       */
      lightClientProof(request) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.sendJsonRpc(
            "EXPERIMENTAL_light_client_proof",
            request
          );
        });
      }
      /**
       * Returns the next light client block as far in the future as possible from the last known hash
       * to still be able to validate from that hash. This will either return the last block of the
       * next epoch, or the last final known block.
       *
       * @see [https://github.com/near/NEPs/blob/master/specs/ChainSpec/LightClient.md#light-client-block](https://github.com/near/NEPs/blob/master/specs/ChainSpec/LightClient.md#light-client-block)
       */
      nextLightClientBlock(request) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.sendJsonRpc("next_light_client_block", request);
        });
      }
      /**
       * Gets access key changes for a given array of accountIds
       * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-access-key-changes-all)
       * @returns {Promise<ChangeResult>}
       */
      accessKeyChanges(accountIdArray, blockQuery) {
        return __awaiter(this, void 0, void 0, function* () {
          const { finality } = blockQuery;
          const { blockId } = blockQuery;
          return this.sendJsonRpc("EXPERIMENTAL_changes", {
            changes_type: "all_access_key_changes",
            account_ids: accountIdArray,
            block_id: blockId,
            finality,
          });
        });
      }
      /**
       * Gets single access key changes for a given array of access keys
       * pass block_id OR finality as blockQuery, not both
       * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-access-key-changes-single)
       * @returns {Promise<ChangeResult>}
       */
      singleAccessKeyChanges(accessKeyArray, blockQuery) {
        return __awaiter(this, void 0, void 0, function* () {
          const { finality } = blockQuery;
          const { blockId } = blockQuery;
          return this.sendJsonRpc("EXPERIMENTAL_changes", {
            changes_type: "single_access_key_changes",
            keys: accessKeyArray,
            block_id: blockId,
            finality,
          });
        });
      }
      /**
       * Gets account changes for a given array of accountIds
       * pass block_id OR finality as blockQuery, not both
       * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-account-changes)
       * @returns {Promise<ChangeResult>}
       */
      accountChanges(accountIdArray, blockQuery) {
        return __awaiter(this, void 0, void 0, function* () {
          const { finality } = blockQuery;
          const { blockId } = blockQuery;
          return this.sendJsonRpc("EXPERIMENTAL_changes", {
            changes_type: "account_changes",
            account_ids: accountIdArray,
            block_id: blockId,
            finality,
          });
        });
      }
      /**
       * Gets contract state changes for a given array of accountIds
       * pass block_id OR finality as blockQuery, not both
       * Note: If you pass a keyPrefix it must be base64 encoded
       * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-contract-state-changes)
       * @returns {Promise<ChangeResult>}
       */
      contractStateChanges(accountIdArray, blockQuery, keyPrefix = "") {
        return __awaiter(this, void 0, void 0, function* () {
          const { finality } = blockQuery;
          const { blockId } = blockQuery;
          return this.sendJsonRpc("EXPERIMENTAL_changes", {
            changes_type: "data_changes",
            account_ids: accountIdArray,
            key_prefix_base64: keyPrefix,
            block_id: blockId,
            finality,
          });
        });
      }
      /**
       * Gets contract code changes for a given array of accountIds
       * pass block_id OR finality as blockQuery, not both
       * Note: Change is returned in a base64 encoded WASM file
       * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-contract-code-changes)
       * @returns {Promise<ChangeResult>}
       */
      contractCodeChanges(accountIdArray, blockQuery) {
        return __awaiter(this, void 0, void 0, function* () {
          const { finality } = blockQuery;
          const { blockId } = blockQuery;
          return this.sendJsonRpc("EXPERIMENTAL_changes", {
            changes_type: "contract_code_changes",
            account_ids: accountIdArray,
            block_id: blockId,
            finality,
          });
        });
      }
      /**
       * Returns gas price for a specific block_height or block_hash.
       * @see [https://docs.near.org/api/rpc/gas](https://docs.near.org/api/rpc/gas)
       *
       * @param blockId Block hash or height, or null for latest.
       */
      gasPrice(blockId) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.sendJsonRpc("gas_price", [blockId]);
        });
      }
      /**
       * Directly call the RPC specifying the method and params
       *
       * @param method RPC method
       * @param params Parameters to the method
       */
      sendJsonRpc(method2, params) {
        return __awaiter(this, void 0, void 0, function* () {
          const response = yield (0, exponential_backoff_1.exponentialBackoff)(
            REQUEST_RETRY_WAIT,
            REQUEST_RETRY_NUMBER,
            REQUEST_RETRY_WAIT_BACKOFF,
            () =>
              __awaiter(this, void 0, void 0, function* () {
                try {
                  const request = {
                    method: method2,
                    params,
                    id: _nextId++,
                    jsonrpc: "2.0",
                  };
                  const response2 = yield (0, fetch_json_1.fetchJson)(
                    this.connection,
                    JSON.stringify(request)
                  );
                  if (response2.error) {
                    if (typeof response2.error.data === "object") {
                      if (
                        typeof response2.error.data.error_message ===
                          "string" &&
                        typeof response2.error.data.error_type === "string"
                      ) {
                        throw new types_1.TypedError(
                          response2.error.data.error_message,
                          response2.error.data.error_type
                        );
                      }
                      throw (0, utils_1.parseRpcError)(response2.error.data);
                    } else {
                      const errorMessage = `[${response2.error.code}] ${response2.error.message}: ${response2.error.data}`;
                      if (
                        response2.error.data === "Timeout" ||
                        errorMessage.includes("Timeout error") ||
                        errorMessage.includes("query has timed out")
                      ) {
                        throw new types_1.TypedError(
                          errorMessage,
                          "TimeoutError"
                        );
                      }
                      throw new types_1.TypedError(
                        errorMessage,
                        (0, utils_1.getErrorTypeFromErrorMessage)(
                          response2.error.data,
                          response2.error.name
                        )
                      );
                    }
                  }
                  return response2;
                } catch (error) {
                  if (error.type === "TimeoutError") {
                    if (!{}["NEAR_NO_LOGS"]) {
                      console.warn(
                        `Retrying request to ${method2} as it has timed out`,
                        params
                      );
                    }
                    return null;
                  }
                  throw error;
                }
              })
          );
          const { result } = response;
          if (typeof result === "undefined") {
            throw new types_1.TypedError(
              `Exceeded ${REQUEST_RETRY_NUMBER} attempts for request to ${method2}.`,
              "RetriesExceeded"
            );
          }
          return result;
        });
      }
    };
    exports2.JsonRpcProvider = JsonRpcProvider;
  },
});

// node_modules/@near-js/providers/lib/index.js
var require_lib8 = __commonJS({
  "node_modules/@near-js/providers/lib/index.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.fetchJson =
      exports2.Provider =
      exports2.JsonRpcProvider =
      exports2.exponentialBackoff =
        void 0;
    var exponential_backoff_1 = require_exponential_backoff();
    Object.defineProperty(exports2, "exponentialBackoff", {
      enumerable: true,
      get: function () {
        return exponential_backoff_1.exponentialBackoff;
      },
    });
    var json_rpc_provider_1 = require_json_rpc_provider();
    Object.defineProperty(exports2, "JsonRpcProvider", {
      enumerable: true,
      get: function () {
        return json_rpc_provider_1.JsonRpcProvider;
      },
    });
    var provider_1 = require_provider3();
    Object.defineProperty(exports2, "Provider", {
      enumerable: true,
      get: function () {
        return provider_1.Provider;
      },
    });
    var fetch_json_1 = require_fetch_json();
    Object.defineProperty(exports2, "fetchJson", {
      enumerable: true,
      get: function () {
        return fetch_json_1.fetchJson;
      },
    });
  },
});

// node_modules/near-api-js/lib/providers/provider.js
var require_provider4 = __commonJS({
  "node_modules/near-api-js/lib/providers/provider.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FinalExecutionStatusBasic =
      exports2.ExecutionStatusBasic =
      exports2.IdType =
      exports2.Provider =
      exports2.getTransactionLastResult =
        void 0;
    var utils_1 = require_lib6();
    Object.defineProperty(exports2, "getTransactionLastResult", {
      enumerable: true,
      get: function () {
        return utils_1.getTransactionLastResult;
      },
    });
    var providers_1 = require_lib8();
    Object.defineProperty(exports2, "Provider", {
      enumerable: true,
      get: function () {
        return providers_1.Provider;
      },
    });
    var types_1 = require_lib2();
    Object.defineProperty(exports2, "IdType", {
      enumerable: true,
      get: function () {
        return types_1.IdType;
      },
    });
    Object.defineProperty(exports2, "ExecutionStatusBasic", {
      enumerable: true,
      get: function () {
        return types_1.ExecutionStatusBasic;
      },
    });
    Object.defineProperty(exports2, "FinalExecutionStatusBasic", {
      enumerable: true,
      get: function () {
        return types_1.FinalExecutionStatusBasic;
      },
    });
  },
});

// node_modules/near-api-js/lib/providers/json-rpc-provider.js
var require_json_rpc_provider2 = __commonJS({
  "node_modules/near-api-js/lib/providers/json-rpc-provider.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.JsonRpcProvider =
      exports2.TypedError =
      exports2.ErrorContext =
        void 0;
    var types_1 = require_lib2();
    Object.defineProperty(exports2, "ErrorContext", {
      enumerable: true,
      get: function () {
        return types_1.ErrorContext;
      },
    });
    Object.defineProperty(exports2, "TypedError", {
      enumerable: true,
      get: function () {
        return types_1.TypedError;
      },
    });
    var providers_1 = require_lib8();
    Object.defineProperty(exports2, "JsonRpcProvider", {
      enumerable: true,
      get: function () {
        return providers_1.JsonRpcProvider;
      },
    });
  },
});

// node_modules/near-api-js/lib/providers/index.js
var require_providers = __commonJS({
  "node_modules/near-api-js/lib/providers/index.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ErrorContext =
      exports2.TypedError =
      exports2.getTransactionLastResult =
      exports2.FinalExecutionStatusBasic =
      exports2.JsonRpcProvider =
      exports2.Provider =
        void 0;
    var provider_1 = require_provider4();
    Object.defineProperty(exports2, "Provider", {
      enumerable: true,
      get: function () {
        return provider_1.Provider;
      },
    });
    Object.defineProperty(exports2, "getTransactionLastResult", {
      enumerable: true,
      get: function () {
        return provider_1.getTransactionLastResult;
      },
    });
    Object.defineProperty(exports2, "FinalExecutionStatusBasic", {
      enumerable: true,
      get: function () {
        return provider_1.FinalExecutionStatusBasic;
      },
    });
    var json_rpc_provider_1 = require_json_rpc_provider2();
    Object.defineProperty(exports2, "JsonRpcProvider", {
      enumerable: true,
      get: function () {
        return json_rpc_provider_1.JsonRpcProvider;
      },
    });
    Object.defineProperty(exports2, "TypedError", {
      enumerable: true,
      get: function () {
        return json_rpc_provider_1.TypedError;
      },
    });
    Object.defineProperty(exports2, "ErrorContext", {
      enumerable: true,
      get: function () {
        return json_rpc_provider_1.ErrorContext;
      },
    });
  },
});

// node_modules/near-api-js/lib/utils/key_pair.js
var require_key_pair2 = __commonJS({
  "node_modules/near-api-js/lib/utils/key_pair.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PublicKey =
      exports2.KeyType =
      exports2.KeyPairEd25519 =
      exports2.KeyPair =
        void 0;
    var crypto_1 = require_lib3();
    Object.defineProperty(exports2, "KeyPair", {
      enumerable: true,
      get: function () {
        return crypto_1.KeyPair;
      },
    });
    Object.defineProperty(exports2, "KeyPairEd25519", {
      enumerable: true,
      get: function () {
        return crypto_1.KeyPairEd25519;
      },
    });
    Object.defineProperty(exports2, "KeyType", {
      enumerable: true,
      get: function () {
        return crypto_1.KeyType;
      },
    });
    Object.defineProperty(exports2, "PublicKey", {
      enumerable: true,
      get: function () {
        return crypto_1.PublicKey;
      },
    });
  },
});

// node_modules/near-api-js/lib/utils/serialize.js
var require_serialize = __commonJS({
  "node_modules/near-api-js/lib/utils/serialize.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BinaryReader =
      exports2.BinaryWriter =
      exports2.BorshError =
      exports2.deserialize =
      exports2.serialize =
      exports2.base_decode =
      exports2.base_encode =
        void 0;
    var borsh_1 = require_lib();
    Object.defineProperty(exports2, "base_encode", {
      enumerable: true,
      get: function () {
        return borsh_1.baseEncode;
      },
    });
    Object.defineProperty(exports2, "base_decode", {
      enumerable: true,
      get: function () {
        return borsh_1.baseDecode;
      },
    });
    Object.defineProperty(exports2, "serialize", {
      enumerable: true,
      get: function () {
        return borsh_1.serialize;
      },
    });
    Object.defineProperty(exports2, "deserialize", {
      enumerable: true,
      get: function () {
        return borsh_1.deserialize;
      },
    });
    Object.defineProperty(exports2, "BorshError", {
      enumerable: true,
      get: function () {
        return borsh_1.BorshError;
      },
    });
    Object.defineProperty(exports2, "BinaryWriter", {
      enumerable: true,
      get: function () {
        return borsh_1.BinaryWriter;
      },
    });
    Object.defineProperty(exports2, "BinaryReader", {
      enumerable: true,
      get: function () {
        return borsh_1.BinaryReader;
      },
    });
  },
});

// node_modules/near-api-js/lib/utils/web.js
var require_web = __commonJS({
  "node_modules/near-api-js/lib/utils/web.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.fetchJson = void 0;
    var providers_1 = require_lib8();
    Object.defineProperty(exports2, "fetchJson", {
      enumerable: true,
      get: function () {
        return providers_1.fetchJson;
      },
    });
  },
});

// node_modules/near-api-js/lib/utils/enums.js
var require_enums = __commonJS({
  "node_modules/near-api-js/lib/utils/enums.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Enum = exports2.Assignable = void 0;
    var types_1 = require_lib2();
    Object.defineProperty(exports2, "Assignable", {
      enumerable: true,
      get: function () {
        return types_1.Assignable;
      },
    });
    var Enum = class {
      constructor(properties) {
        if (Object.keys(properties).length !== 1) {
          throw new Error("Enum can only take single value");
        }
        Object.keys(properties).map((key) => {
          this[key] = properties[key];
          this.enum = key;
        });
      }
    };
    exports2.Enum = Enum;
  },
});

// node_modules/near-api-js/lib/utils/format.js
var require_format2 = __commonJS({
  "node_modules/near-api-js/lib/utils/format.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseNearAmount =
      exports2.formatNearAmount =
      exports2.NEAR_NOMINATION_EXP =
      exports2.NEAR_NOMINATION =
        void 0;
    var utils_1 = require_lib6();
    Object.defineProperty(exports2, "NEAR_NOMINATION", {
      enumerable: true,
      get: function () {
        return utils_1.NEAR_NOMINATION;
      },
    });
    Object.defineProperty(exports2, "NEAR_NOMINATION_EXP", {
      enumerable: true,
      get: function () {
        return utils_1.NEAR_NOMINATION_EXP;
      },
    });
    Object.defineProperty(exports2, "formatNearAmount", {
      enumerable: true,
      get: function () {
        return utils_1.formatNearAmount;
      },
    });
    Object.defineProperty(exports2, "parseNearAmount", {
      enumerable: true,
      get: function () {
        return utils_1.parseNearAmount;
      },
    });
  },
});

// node_modules/near-api-js/lib/utils/rpc_errors.js
var require_rpc_errors2 = __commonJS({
  "node_modules/near-api-js/lib/utils/rpc_errors.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ServerError =
      exports2.getErrorTypeFromErrorMessage =
      exports2.formatError =
      exports2.parseResultError =
      exports2.parseRpcError =
        void 0;
    var utils_1 = require_lib6();
    Object.defineProperty(exports2, "parseRpcError", {
      enumerable: true,
      get: function () {
        return utils_1.parseRpcError;
      },
    });
    Object.defineProperty(exports2, "parseResultError", {
      enumerable: true,
      get: function () {
        return utils_1.parseResultError;
      },
    });
    Object.defineProperty(exports2, "formatError", {
      enumerable: true,
      get: function () {
        return utils_1.formatError;
      },
    });
    Object.defineProperty(exports2, "getErrorTypeFromErrorMessage", {
      enumerable: true,
      get: function () {
        return utils_1.getErrorTypeFromErrorMessage;
      },
    });
    Object.defineProperty(exports2, "ServerError", {
      enumerable: true,
      get: function () {
        return utils_1.ServerError;
      },
    });
  },
});

// node_modules/@near-js/accounts/lib/account.js
var require_account = __commonJS({
  "node_modules/@near-js/accounts/lib/account.js"(exports2) {
    var __awaiter =
      (exports2 && exports2.__awaiter) ||
      function (thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P
            ? value
            : new P(function (resolve) {
                resolve(value);
              });
        }
        return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done
              ? resolve(result.value)
              : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
    var __importDefault =
      (exports2 && exports2.__importDefault) ||
      function (mod) {
        return mod && mod.__esModule ? mod : { default: mod };
      };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Account = void 0;
    var crypto_1 = require_lib3();
    var providers_1 = require_lib8();
    var transactions_1 = require_lib7();
    var types_1 = require_lib2();
    var utils_1 = require_lib6();
    var bn_js_1 = __importDefault(require_bn());
    var borsh_1 = require_lib();
    var {
      addKey,
      createAccount,
      deleteAccount,
      deleteKey,
      deployContract,
      fullAccessKey,
      functionCall,
      functionCallAccessKey,
      stake,
      transfer,
    } = transactions_1.actionCreators;
    var TX_NONCE_RETRY_NUMBER = 12;
    var TX_NONCE_RETRY_WAIT = 500;
    var TX_NONCE_RETRY_WAIT_BACKOFF = 1.5;
    function parseJsonFromRawResponse(response) {
      return JSON.parse(Buffer.from(response).toString());
    }
    function bytesJsonStringify(input) {
      return Buffer.from(JSON.stringify(input));
    }
    var Account = class _Account {
      constructor(connection, accountId) {
        this.accessKeyByPublicKeyCache = {};
        this.connection = connection;
        this.accountId = accountId;
      }
      /**
       * Returns basic NEAR account information via the `view_account` RPC query method
       * @see [https://docs.near.org/api/rpc/contracts#view-account](https://docs.near.org/api/rpc/contracts#view-account)
       */
      state() {
        return __awaiter(this, void 0, void 0, function* () {
          return this.connection.provider.query({
            request_type: "view_account",
            account_id: this.accountId,
            finality: "optimistic",
          });
        });
      }
      /**
       * Create a signed transaction which can be broadcast to the network
       * @param receiverId NEAR account receiving the transaction
       * @param actions list of actions to perform as part of the transaction
       * @see {@link providers/json-rpc-provider!JsonRpcProvider#sendTransaction | JsonRpcProvider.sendTransaction}
       */
      signTransaction(receiverId, actions) {
        return __awaiter(this, void 0, void 0, function* () {
          const accessKeyInfo = yield this.findAccessKey(receiverId, actions);
          if (!accessKeyInfo) {
            throw new types_1.TypedError(
              `Can not sign transactions for account ${this.accountId} on network ${this.connection.networkId}, no matching key pair exists for this account`,
              "KeyNotFound"
            );
          }
          const { accessKey } = accessKeyInfo;
          const block = yield this.connection.provider.block({
            finality: "final",
          });
          const blockHash = block.header.hash;
          const nonce = accessKey.nonce.add(new bn_js_1.default(1));
          return yield (0,
          transactions_1.signTransaction)(receiverId, nonce, actions, (0, borsh_1.baseDecode)(blockHash), this.connection.signer, this.accountId, this.connection.networkId);
        });
      }
      /**
       * Sign a transaction to preform a list of actions and broadcast it using the RPC API.
       * @see {@link providers/json-rpc-provider!JsonRpcProvider#sendTransaction | JsonRpcProvider.sendTransaction}
       */
      signAndSendTransaction({ receiverId, actions, returnError }) {
        return __awaiter(this, void 0, void 0, function* () {
          let txHash, signedTx;
          const result = yield (0, providers_1.exponentialBackoff)(
            TX_NONCE_RETRY_WAIT,
            TX_NONCE_RETRY_NUMBER,
            TX_NONCE_RETRY_WAIT_BACKOFF,
            () =>
              __awaiter(this, void 0, void 0, function* () {
                [txHash, signedTx] = yield this.signTransaction(
                  receiverId,
                  actions
                );
                const publicKey = signedTx.transaction.publicKey;
                try {
                  return yield this.connection.provider.sendTransaction(
                    signedTx
                  );
                } catch (error) {
                  if (error.type === "InvalidNonce") {
                    (0, utils_1.logWarning)(
                      `Retrying transaction ${receiverId}:${(0,
                      borsh_1.baseEncode)(txHash)} with new nonce.`
                    );
                    delete this.accessKeyByPublicKeyCache[publicKey.toString()];
                    return null;
                  }
                  if (error.type === "Expired") {
                    (0, utils_1.logWarning)(
                      `Retrying transaction ${receiverId}:${(0,
                      borsh_1.baseEncode)(txHash)} due to expired block hash`
                    );
                    return null;
                  }
                  error.context = new types_1.ErrorContext(
                    (0, borsh_1.baseEncode)(txHash)
                  );
                  throw error;
                }
              })
          );
          if (!result) {
            throw new types_1.TypedError(
              "nonce retries exceeded for transaction. This usually means there are too many parallel requests with the same access key.",
              "RetriesExceeded"
            );
          }
          (0,
          utils_1.printTxOutcomeLogsAndFailures)({ contractId: signedTx.transaction.receiverId, outcome: result });
          if (
            !returnError &&
            typeof result.status === "object" &&
            typeof result.status.Failure === "object" &&
            result.status.Failure !== null
          ) {
            if (
              result.status.Failure.error_message &&
              result.status.Failure.error_type
            ) {
              throw new types_1.TypedError(
                `Transaction ${result.transaction_outcome.id} failed. ${result.status.Failure.error_message}`,
                result.status.Failure.error_type
              );
            } else {
              throw (0, utils_1.parseResultError)(result);
            }
          }
          return result;
        });
      }
      /**
       * Finds the {@link providers/provider!AccessKeyView} associated with the accounts {@link utils/key_pair!PublicKey} stored in the {@link key_stores/keystore!KeyStore}.
       *
       * @todo Find matching access key based on transaction (i.e. receiverId and actions)
       *
       * @param receiverId currently unused (see todo)
       * @param actions currently unused (see todo)
       * @returns `{ publicKey PublicKey; accessKey: AccessKeyView }`
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      findAccessKey(receiverId, actions) {
        return __awaiter(this, void 0, void 0, function* () {
          const publicKey = yield this.connection.signer.getPublicKey(
            this.accountId,
            this.connection.networkId
          );
          if (!publicKey) {
            throw new types_1.TypedError(
              `no matching key pair found in ${this.connection.signer}`,
              "PublicKeyNotFound"
            );
          }
          const cachedAccessKey =
            this.accessKeyByPublicKeyCache[publicKey.toString()];
          if (cachedAccessKey !== void 0) {
            return { publicKey, accessKey: cachedAccessKey };
          }
          try {
            const rawAccessKey = yield this.connection.provider.query({
              request_type: "view_access_key",
              account_id: this.accountId,
              public_key: publicKey.toString(),
              finality: "optimistic",
            });
            const accessKey = Object.assign(Object.assign({}, rawAccessKey), {
              nonce: new bn_js_1.default(rawAccessKey.nonce),
            });
            if (this.accessKeyByPublicKeyCache[publicKey.toString()]) {
              return {
                publicKey,
                accessKey: this.accessKeyByPublicKeyCache[publicKey.toString()],
              };
            }
            this.accessKeyByPublicKeyCache[publicKey.toString()] = accessKey;
            return { publicKey, accessKey };
          } catch (e) {
            if (e.type == "AccessKeyDoesNotExist") {
              return null;
            }
            throw e;
          }
        });
      }
      /**
       * Create a new account and deploy a contract to it
       *
       * @param contractId NEAR account where the contract is deployed
       * @param publicKey The public key to add to the created contract account
       * @param data The compiled contract code
       * @param amount of NEAR to transfer to the created contract account. Transfer enough to pay for storage https://docs.near.org/docs/concepts/storage-staking
       */
      createAndDeployContract(contractId, publicKey, data, amount) {
        return __awaiter(this, void 0, void 0, function* () {
          const accessKey = fullAccessKey();
          yield this.signAndSendTransaction({
            receiverId: contractId,
            actions: [
              createAccount(),
              transfer(amount),
              addKey(crypto_1.PublicKey.from(publicKey), accessKey),
              deployContract(data),
            ],
          });
          const contractAccount = new _Account(this.connection, contractId);
          return contractAccount;
        });
      }
      /**
       * @param receiverId NEAR account receiving 
       * @param amount Amount to send in yocto
       */
      sendMoney(receiverId, amount) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.signAndSendTransaction({
            receiverId,
            actions: [transfer(amount)],
          });
        });
      }
      /**
       * @param newAccountId NEAR account name to be created
       * @param publicKey A public key created from the masterAccount
       */
      createAccount(newAccountId, publicKey, amount) {
        return __awaiter(this, void 0, void 0, function* () {
          const accessKey = fullAccessKey();
          return this.signAndSendTransaction({
            receiverId: newAccountId,
            actions: [
              createAccount(),
              transfer(amount),
              addKey(crypto_1.PublicKey.from(publicKey), accessKey),
            ],
          });
        });
      }
      /**
       * @param beneficiaryId The NEAR account that will receive the remaining  balance from the account being deleted
       */
      deleteAccount(beneficiaryId) {
        return __awaiter(this, void 0, void 0, function* () {
          if (!{}["NEAR_NO_LOGS"]) {
            console.log(
              "Deleting an account does not automatically transfer NFTs and FTs to the beneficiary address. Ensure to transfer assets before deleting."
            );
          }
          return this.signAndSendTransaction({
            receiverId: this.accountId,
            actions: [deleteAccount(beneficiaryId)],
          });
        });
      }
      /**
       * @param data The compiled contract code
       */
      deployContract(data) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.signAndSendTransaction({
            receiverId: this.accountId,
            actions: [deployContract(data)],
          });
        });
      }
      /** @hidden */
      encodeJSContractArgs(contractId, method2, args) {
        return Buffer.concat([
          Buffer.from(contractId),
          Buffer.from([0]),
          Buffer.from(method2),
          Buffer.from([0]),
          Buffer.from(args),
        ]);
      }
      /**
       * Execute function call
       * @returns {Promise<FinalExecutionOutcome>}
       */
      functionCall({
        contractId,
        methodName,
        args = {},
        gas = utils_1.DEFAULT_FUNCTION_CALL_GAS,
        attachedDeposit,
        walletMeta,
        walletCallbackUrl,
        stringify,
        jsContract,
      }) {
        return __awaiter(this, void 0, void 0, function* () {
          this.validateArgs(args);
          let functionCallArgs;
          if (jsContract) {
            const encodedArgs = this.encodeJSContractArgs(
              contractId,
              methodName,
              JSON.stringify(args)
            );
            functionCallArgs = [
              "call_js_contract",
              encodedArgs,
              gas,
              attachedDeposit,
              null,
              true,
            ];
          } else {
            const stringifyArg =
              stringify === void 0
                ? transactions_1.stringifyJsonOrBytes
                : stringify;
            functionCallArgs = [
              methodName,
              args,
              gas,
              attachedDeposit,
              stringifyArg,
              false,
            ];
          }
          return this.signAndSendTransaction({
            receiverId: jsContract ? this.connection.jsvmAccountId : contractId,
            // eslint-disable-next-line prefer-spread
            actions: [functionCall.apply(void 0, functionCallArgs)],
            walletMeta,
            walletCallbackUrl,
          });
        });
      }
      /**
       * @see [https://docs.near.org/concepts/basics/accounts/access-keys](https://docs.near.org/concepts/basics/accounts/access-keys)
       * @todo expand this API to support more options.
       * @param publicKey A public key to be associated with the contract
       * @param contractId NEAR account where the contract is deployed
       * @param methodNames The method names on the contract that should be allowed to be called. Pass null for no method names and '' or [] for any method names.
       * @param amount Payment in yocto that is sent to the contract during this function call
       */
      addKey(publicKey, contractId, methodNames, amount) {
        return __awaiter(this, void 0, void 0, function* () {
          if (!methodNames) {
            methodNames = [];
          }
          if (!Array.isArray(methodNames)) {
            methodNames = [methodNames];
          }
          let accessKey;
          if (!contractId) {
            accessKey = fullAccessKey();
          } else {
            accessKey = functionCallAccessKey(contractId, methodNames, amount);
          }
          return this.signAndSendTransaction({
            receiverId: this.accountId,
            actions: [addKey(crypto_1.PublicKey.from(publicKey), accessKey)],
          });
        });
      }
      /**
       * @param publicKey The public key to be deleted
       * @returns {Promise<FinalExecutionOutcome>}
       */
      deleteKey(publicKey) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.signAndSendTransaction({
            receiverId: this.accountId,
            actions: [deleteKey(crypto_1.PublicKey.from(publicKey))],
          });
        });
      }
      /**
       * @see [https://near-nodes.io/validator/staking-and-delegation](https://near-nodes.io/validator/staking-and-delegation)
       *
       * @param publicKey The public key for the account that's staking
       * @param amount The account to stake in yocto
       */
      stake(publicKey, amount) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.signAndSendTransaction({
            receiverId: this.accountId,
            actions: [stake(amount, crypto_1.PublicKey.from(publicKey))],
          });
        });
      }
      /**
       * Compose and sign a SignedDelegate action to be executed in a transaction on behalf of this Account instance
       *
       * @param actions Actions to be included in the meta transaction
       * @param blockHeightTtl Number of blocks past the current block height for which the SignedDelegate action may be included in a meta transaction
       * @param receiverId Receiver account of the meta transaction
       */
      signedDelegate({ actions, blockHeightTtl, receiverId }) {
        return __awaiter(this, void 0, void 0, function* () {
          const { provider, signer } = this.connection;
          const { header } = yield provider.block({ finality: "final" });
          const { accessKey, publicKey } = yield this.findAccessKey(null, null);
          const delegateAction = (0, transactions_1.buildDelegateAction)({
            actions,
            maxBlockHeight: new bn_js_1.default(header.height).add(
              new bn_js_1.default(blockHeightTtl)
            ),
            nonce: new bn_js_1.default(accessKey.nonce).add(
              new bn_js_1.default(1)
            ),
            publicKey,
            receiverId,
            senderId: this.accountId,
          });
          const { signedDelegateAction } = yield (0,
          transactions_1.signDelegateAction)({
            delegateAction,
            signer: {
              sign: (message) =>
                __awaiter(this, void 0, void 0, function* () {
                  const { signature } = yield signer.signMessage(
                    message,
                    delegateAction.senderId,
                    this.connection.networkId
                  );
                  return signature;
                }),
            },
          });
          return signedDelegateAction;
        });
      }
      /** @hidden */
      validateArgs(args) {
        const isUint8Array =
          args.byteLength !== void 0 && args.byteLength === args.length;
        if (isUint8Array) {
          return;
        }
        if (Array.isArray(args) || typeof args !== "object") {
          throw new types_1.PositionalArgsError();
        }
      }
      /**
       * Invoke a contract view function using the RPC API.
       * @see [https://docs.near.org/api/rpc/contracts#call-a-contract-function](https://docs.near.org/api/rpc/contracts#call-a-contract-function)
       *
       * @param viewFunctionCallOptions.contractId NEAR account where the contract is deployed
       * @param viewFunctionCallOptions.methodName The view-only method (no state mutations) name on the contract as it is written in the contract code
       * @param viewFunctionCallOptions.args Any arguments to the view contract method, wrapped in JSON
       * @param viewFunctionCallOptions.parse Parse the result of the call. Receives a Buffer (bytes array) and converts it to any object. By default result will be treated as json.
       * @param viewFunctionCallOptions.stringify Convert input arguments into a bytes array. By default the input is treated as a JSON.
       * @param viewFunctionCallOptions.jsContract Is contract from JS SDK, automatically encodes args from JS SDK to binary.
       * @param viewFunctionCallOptions.blockQuery specifies which block to query state at. By default returns last "optimistic" block (i.e. not necessarily finalized).
       * @returns {Promise<any>}
       */
      viewFunction({
        contractId,
        methodName,
        args = {},
        parse = parseJsonFromRawResponse,
        stringify = bytesJsonStringify,
        jsContract = false,
        blockQuery = { finality: "optimistic" },
      }) {
        return __awaiter(this, void 0, void 0, function* () {
          let encodedArgs;
          this.validateArgs(args);
          if (jsContract) {
            encodedArgs = this.encodeJSContractArgs(
              contractId,
              methodName,
              Object.keys(args).length > 0 ? JSON.stringify(args) : ""
            );
          } else {
            encodedArgs = stringify(args);
          }
          const result = yield this.connection.provider.query(
            Object.assign(
              Object.assign({ request_type: "call_function" }, blockQuery),
              {
                account_id: jsContract
                  ? this.connection.jsvmAccountId
                  : contractId,
                method_name: jsContract ? "view_js_contract" : methodName,
                args_base64: encodedArgs.toString("base64"),
              }
            )
          );
          if (result.logs) {
            (0, utils_1.printTxOutcomeLogs)({ contractId, logs: result.logs });
          }
          return (
            result.result &&
            result.result.length > 0 &&
            parse(Buffer.from(result.result))
          );
        });
      }
      /**
       * Returns the state (key value pairs) of this account's contract based on the key prefix.
       * Pass an empty string for prefix if you would like to return the entire state.
       * @see [https://docs.near.org/api/rpc/contracts#view-contract-state](https://docs.near.org/api/rpc/contracts#view-contract-state)
       *
       * @param prefix allows to filter which keys should be returned. Empty prefix means all keys. String prefix is utf-8 encoded.
       * @param blockQuery specifies which block to query state at. By default returns last "optimistic" block (i.e. not necessarily finalized).
       */
      viewState(prefix, blockQuery = { finality: "optimistic" }) {
        return __awaiter(this, void 0, void 0, function* () {
          const { values } = yield this.connection.provider.query(
            Object.assign(
              Object.assign({ request_type: "view_state" }, blockQuery),
              {
                account_id: this.accountId,
                prefix_base64: Buffer.from(prefix).toString("base64"),
              }
            )
          );
          return values.map(({ key, value }) => ({
            key: Buffer.from(key, "base64"),
            value: Buffer.from(value, "base64"),
          }));
        });
      }
      /**
       * Get all access keys for the account
       * @see [https://docs.near.org/api/rpc/access-keys#view-access-key-list](https://docs.near.org/api/rpc/access-keys#view-access-key-list)
       */
      getAccessKeys() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
          const response = yield this.connection.provider.query({
            request_type: "view_access_key_list",
            account_id: this.accountId,
            finality: "optimistic",
          });
          return (_a =
            response === null || response === void 0
              ? void 0
              : response.keys) === null || _a === void 0
            ? void 0
            : _a.map((key) =>
                Object.assign(Object.assign({}, key), {
                  access_key: Object.assign(Object.assign({}, key.access_key), {
                    nonce: new bn_js_1.default(key.access_key.nonce),
                  }),
                })
              );
        });
      }
      /**
       * Returns a list of authorized apps
       * @todo update the response value to return all the different keys, not just app keys.
       */
      getAccountDetails() {
        return __awaiter(this, void 0, void 0, function* () {
          const accessKeys = yield this.getAccessKeys();
          const authorizedApps = accessKeys
            .filter((item) => item.access_key.permission !== "FullAccess")
            .map((item) => {
              const perm = item.access_key.permission;
              return {
                contractId: perm.FunctionCall.receiver_id,
                amount: perm.FunctionCall.allowance,
                publicKey: item.public_key,
              };
            });
          return { authorizedApps };
        });
      }
      /**
       * Returns calculated account balance
       */
      getAccountBalance() {
        return __awaiter(this, void 0, void 0, function* () {
          const protocolConfig =
            yield this.connection.provider.experimental_protocolConfig({
              finality: "final",
            });
          const state = yield this.state();
          const costPerByte = new bn_js_1.default(
            protocolConfig.runtime_config.storage_amount_per_byte
          );
          const stateStaked = new bn_js_1.default(state.storage_usage).mul(
            costPerByte
          );
          const staked = new bn_js_1.default(state.locked);
          const totalBalance = new bn_js_1.default(state.amount).add(staked);
          const availableBalance = totalBalance.sub(
            bn_js_1.default.max(staked, stateStaked)
          );
          return {
            total: totalBalance.toString(),
            stateStaked: stateStaked.toString(),
            staked: staked.toString(),
            available: availableBalance.toString(),
          };
        });
      }
      /**
       * Returns the NEAR tokens balance and validators of a given account that is delegated to the staking pools that are part of the validators set in the current epoch.
       *
       * NOTE: If the tokens are delegated to a staking pool that is currently on pause or does not have enough tokens to participate in validation, they won't be accounted for.
       * @returns {Promise<ActiveDelegatedStakeBalance>}
       */
      getActiveDelegatedStakeBalance() {
        return __awaiter(this, void 0, void 0, function* () {
          const block = yield this.connection.provider.block({
            finality: "final",
          });
          const blockHash = block.header.hash;
          const epochId = block.header.epoch_id;
          const { current_validators, next_validators, current_proposals } =
            yield this.connection.provider.validators(epochId);
          const pools = /* @__PURE__ */ new Set();
          [
            ...current_validators,
            ...next_validators,
            ...current_proposals,
          ].forEach((validator) => pools.add(validator.account_id));
          const uniquePools = [...pools];
          const promises = uniquePools.map((validator) =>
            this.viewFunction({
              contractId: validator,
              methodName: "get_account_total_balance",
              args: { account_id: this.accountId },
              blockQuery: { blockId: blockHash },
            })
          );
          const results = yield Promise.allSettled(promises);
          const hasTimeoutError = results.some((result) => {
            if (
              result.status === "rejected" &&
              result.reason.type === "TimeoutError"
            ) {
              return true;
            }
            return false;
          });
          if (hasTimeoutError) {
            throw new Error("Failed to get delegated stake balance");
          }
          const summary = results.reduce(
            (result, state, index) => {
              const validatorId = uniquePools[index];
              if (state.status === "fulfilled") {
                const currentBN = new bn_js_1.default(state.value);
                if (!currentBN.isZero()) {
                  return Object.assign(Object.assign({}, result), {
                    stakedValidators: [
                      ...result.stakedValidators,
                      { validatorId, amount: currentBN.toString() },
                    ],
                    total: result.total.add(currentBN),
                  });
                }
              }
              if (state.status === "rejected") {
                return Object.assign(Object.assign({}, result), {
                  failedValidators: [
                    ...result.failedValidators,
                    { validatorId, error: state.reason },
                  ],
                });
              }
              return result;
            },
            {
              stakedValidators: [],
              failedValidators: [],
              total: new bn_js_1.default(0),
            }
          );
          return Object.assign(Object.assign({}, summary), {
            total: summary.total.toString(),
          });
        });
      }
    };
    exports2.Account = Account;
  },
});

// node_modules/@near-js/accounts/lib/constants.js
var require_constants3 = __commonJS({
  "node_modules/@near-js/accounts/lib/constants.js"(exports2) {
    var __importDefault =
      (exports2 && exports2.__importDefault) ||
      function (mod) {
        return mod && mod.__esModule ? mod : { default: mod };
      };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MULTISIG_CONFIRM_METHODS =
      exports2.MULTISIG_CHANGE_METHODS =
      exports2.MULTISIG_DEPOSIT =
      exports2.MULTISIG_GAS =
      exports2.MULTISIG_ALLOWANCE =
      exports2.MULTISIG_STORAGE_KEY =
        void 0;
    var utils_1 = require_lib6();
    var bn_js_1 = __importDefault(require_bn());
    exports2.MULTISIG_STORAGE_KEY = "__multisigRequest";
    exports2.MULTISIG_ALLOWANCE = new bn_js_1.default(
      (0, utils_1.parseNearAmount)("1")
    );
    exports2.MULTISIG_GAS = new bn_js_1.default("100000000000000");
    exports2.MULTISIG_DEPOSIT = new bn_js_1.default("0");
    exports2.MULTISIG_CHANGE_METHODS = [
      "add_request",
      "add_request_and_confirm",
      "delete_request",
      "confirm",
    ];
    exports2.MULTISIG_CONFIRM_METHODS = ["confirm"];
  },
});

// node_modules/@near-js/accounts/lib/types.js
var require_types = __commonJS({
  "node_modules/@near-js/accounts/lib/types.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MultisigStateStatus =
      exports2.MultisigDeleteRequestRejectionError = void 0;
    (function (MultisigDeleteRequestRejectionError2) {
      MultisigDeleteRequestRejectionError2["CANNOT_DESERIALIZE_STATE"] =
        "Cannot deserialize the contract state";
      MultisigDeleteRequestRejectionError2["MULTISIG_NOT_INITIALIZED"] =
        "Smart contract panicked: Multisig contract should be initialized before usage";
      MultisigDeleteRequestRejectionError2["NO_SUCH_REQUEST"] =
        "Smart contract panicked: panicked at 'No such request: either wrong number or already confirmed'";
      MultisigDeleteRequestRejectionError2["REQUEST_COOLDOWN_ERROR"] =
        "Request cannot be deleted immediately after creation.";
      MultisigDeleteRequestRejectionError2["METHOD_NOT_FOUND"] =
        "Contract method is not found";
    })(
      exports2.MultisigDeleteRequestRejectionError ||
        (exports2.MultisigDeleteRequestRejectionError = {})
    );
    (function (MultisigStateStatus2) {
      MultisigStateStatus2[(MultisigStateStatus2["INVALID_STATE"] = 0)] =
        "INVALID_STATE";
      MultisigStateStatus2[
        (MultisigStateStatus2["STATE_NOT_INITIALIZED"] = 1)
      ] = "STATE_NOT_INITIALIZED";
      MultisigStateStatus2[(MultisigStateStatus2["VALID_STATE"] = 2)] =
        "VALID_STATE";
      MultisigStateStatus2[(MultisigStateStatus2["UNKNOWN_STATE"] = 3)] =
        "UNKNOWN_STATE";
    })(exports2.MultisigStateStatus || (exports2.MultisigStateStatus = {}));
  },
});

// node_modules/@near-js/accounts/lib/account_multisig.js
var require_account_multisig = __commonJS({
  "node_modules/@near-js/accounts/lib/account_multisig.js"(exports2) {
    var __awaiter =
      (exports2 && exports2.__awaiter) ||
      function (thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P
            ? value
            : new P(function (resolve) {
                resolve(value);
              });
        }
        return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done
              ? resolve(result.value)
              : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AccountMultisig = void 0;
    var transactions_1 = require_lib7();
    var account_1 = require_account();
    var constants_1 = require_constants3();
    var types_1 = require_types();
    var { deployContract, functionCall } = transactions_1.actionCreators;
    var MultisigCodeStatus;
    (function (MultisigCodeStatus2) {
      MultisigCodeStatus2[(MultisigCodeStatus2["INVALID_CODE"] = 0)] =
        "INVALID_CODE";
      MultisigCodeStatus2[(MultisigCodeStatus2["VALID_CODE"] = 1)] =
        "VALID_CODE";
      MultisigCodeStatus2[(MultisigCodeStatus2["UNKNOWN_CODE"] = 2)] =
        "UNKNOWN_CODE";
    })(MultisigCodeStatus || (MultisigCodeStatus = {}));
    var storageFallback = {
      [constants_1.MULTISIG_STORAGE_KEY]: null,
    };
    var AccountMultisig = class extends account_1.Account {
      constructor(connection, accountId, options) {
        super(connection, accountId);
        this.storage = options.storage;
        this.onAddRequestResult = options.onAddRequestResult;
      }
      signAndSendTransactionWithAccount(receiverId, actions) {
        const _super = Object.create(null, {
          signAndSendTransaction: { get: () => super.signAndSendTransaction },
        });
        return __awaiter(this, void 0, void 0, function* () {
          return _super.signAndSendTransaction.call(this, {
            receiverId,
            actions,
          });
        });
      }
      signAndSendTransaction({ receiverId, actions }) {
        const _super = Object.create(null, {
          signAndSendTransaction: { get: () => super.signAndSendTransaction },
        });
        return __awaiter(this, void 0, void 0, function* () {
          const { accountId } = this;
          const args = Buffer.from(
            JSON.stringify({
              request: {
                receiver_id: receiverId,
                actions: convertActions(actions, accountId, receiverId),
              },
            })
          );
          let result;
          try {
            result = yield _super.signAndSendTransaction.call(this, {
              receiverId: accountId,
              actions: [
                functionCall(
                  "add_request_and_confirm",
                  args,
                  constants_1.MULTISIG_GAS,
                  constants_1.MULTISIG_DEPOSIT
                ),
              ],
            });
          } catch (e) {
            if (
              e
                .toString()
                .includes(
                  "Account has too many active requests. Confirm or delete some"
                )
            ) {
              yield this.deleteUnconfirmedRequests();
              return yield this.signAndSendTransaction({ receiverId, actions });
            }
            throw e;
          }
          if (!result.status) {
            throw new Error("Request failed");
          }
          const status = Object.assign({}, result.status);
          if (!status.SuccessValue || typeof status.SuccessValue !== "string") {
            throw new Error("Request failed");
          }
          this.setRequest({
            accountId,
            actions,
            requestId: parseInt(
              Buffer.from(status.SuccessValue, "base64").toString("ascii"),
              10
            ),
          });
          if (this.onAddRequestResult) {
            yield this.onAddRequestResult(result);
          }
          this.deleteUnconfirmedRequests();
          return result;
        });
      }
      /*
       * This method submits a canary transaction that is expected to always fail in order to determine whether the contract currently has valid multisig state
       * and whether it is initialized. The canary transaction attempts to delete a request at index u32_max and will go through if a request exists at that index.
       * a u32_max + 1 and -1 value cannot be used for the canary due to expected u32 error thrown before deserialization attempt.
       */
      checkMultisigCodeAndStateStatus(contractBytes) {
        const _super = Object.create(null, {
          signAndSendTransaction: { get: () => super.signAndSendTransaction },
        });
        return __awaiter(this, void 0, void 0, function* () {
          const u32_max = 4294967295;
          const validCodeStatusIfNoDeploy = contractBytes
            ? MultisigCodeStatus.UNKNOWN_CODE
            : MultisigCodeStatus.VALID_CODE;
          try {
            if (contractBytes) {
              yield _super.signAndSendTransaction.call(this, {
                receiverId: this.accountId,
                actions: [
                  deployContract(contractBytes),
                  functionCall(
                    "delete_request",
                    { request_id: u32_max },
                    constants_1.MULTISIG_GAS,
                    constants_1.MULTISIG_DEPOSIT
                  ),
                ],
              });
            } else {
              yield this.deleteRequest(u32_max);
            }
            return {
              codeStatus: MultisigCodeStatus.VALID_CODE,
              stateStatus: types_1.MultisigStateStatus.VALID_STATE,
            };
          } catch (e) {
            if (
              new RegExp(
                types_1.MultisigDeleteRequestRejectionError.CANNOT_DESERIALIZE_STATE
              ).test(e && e.kind && e.kind.ExecutionError)
            ) {
              return {
                codeStatus: validCodeStatusIfNoDeploy,
                stateStatus: types_1.MultisigStateStatus.INVALID_STATE,
              };
            } else if (
              new RegExp(
                types_1.MultisigDeleteRequestRejectionError.MULTISIG_NOT_INITIALIZED
              ).test(e && e.kind && e.kind.ExecutionError)
            ) {
              return {
                codeStatus: validCodeStatusIfNoDeploy,
                stateStatus: types_1.MultisigStateStatus.STATE_NOT_INITIALIZED,
              };
            } else if (
              new RegExp(
                types_1.MultisigDeleteRequestRejectionError.NO_SUCH_REQUEST
              ).test(e && e.kind && e.kind.ExecutionError)
            ) {
              return {
                codeStatus: validCodeStatusIfNoDeploy,
                stateStatus: types_1.MultisigStateStatus.VALID_STATE,
              };
            } else if (
              new RegExp(
                types_1.MultisigDeleteRequestRejectionError.METHOD_NOT_FOUND
              ).test(e && e.message)
            ) {
              return {
                codeStatus: MultisigCodeStatus.INVALID_CODE,
                stateStatus: types_1.MultisigStateStatus.UNKNOWN_STATE,
              };
            }
            throw e;
          }
        });
      }
      deleteRequest(request_id) {
        return super.signAndSendTransaction({
          receiverId: this.accountId,
          actions: [
            functionCall(
              "delete_request",
              { request_id },
              constants_1.MULTISIG_GAS,
              constants_1.MULTISIG_DEPOSIT
            ),
          ],
        });
      }
      deleteAllRequests() {
        return __awaiter(this, void 0, void 0, function* () {
          const request_ids = yield this.getRequestIds();
          if (request_ids.length) {
            yield Promise.all(request_ids.map((id) => this.deleteRequest(id)));
          }
        });
      }
      deleteUnconfirmedRequests() {
        const _super = Object.create(null, {
          signAndSendTransaction: { get: () => super.signAndSendTransaction },
        });
        return __awaiter(this, void 0, void 0, function* () {
          const request_ids = yield this.getRequestIds();
          const { requestId } = this.getRequest();
          for (const requestIdToDelete of request_ids) {
            if (requestIdToDelete == requestId) {
              continue;
            }
            try {
              yield _super.signAndSendTransaction.call(this, {
                receiverId: this.accountId,
                actions: [
                  functionCall(
                    "delete_request",
                    { request_id: requestIdToDelete },
                    constants_1.MULTISIG_GAS,
                    constants_1.MULTISIG_DEPOSIT
                  ),
                ],
              });
            } catch (e) {
              console.warn(
                "Attempt to delete an earlier request before 15 minutes failed. Will try again."
              );
            }
          }
        });
      }
      // helpers
      getRequestIds() {
        return __awaiter(this, void 0, void 0, function* () {
          return this.viewFunction({
            contractId: this.accountId,
            methodName: "list_request_ids",
          });
        });
      }
      getRequest() {
        if (this.storage) {
          return JSON.parse(
            this.storage.getItem(constants_1.MULTISIG_STORAGE_KEY) || "{}"
          );
        }
        return storageFallback[constants_1.MULTISIG_STORAGE_KEY];
      }
      setRequest(data) {
        if (this.storage) {
          return this.storage.setItem(
            constants_1.MULTISIG_STORAGE_KEY,
            JSON.stringify(data)
          );
        }
        storageFallback[constants_1.MULTISIG_STORAGE_KEY] = data;
      }
    };
    exports2.AccountMultisig = AccountMultisig;
    var convertPKForContract = (pk) => pk.toString().replace("ed25519:", "");
    var convertActions = (actions, accountId, receiverId) =>
      actions.map((a) => {
        const type = a.enum;
        const { gas, publicKey, methodName, args, deposit, accessKey, code } =
          a[type];
        const action = {
          type: type[0].toUpperCase() + type.substr(1),
          gas: (gas && gas.toString()) || void 0,
          public_key: (publicKey && convertPKForContract(publicKey)) || void 0,
          method_name: methodName,
          args: (args && Buffer.from(args).toString("base64")) || void 0,
          code: (code && Buffer.from(code).toString("base64")) || void 0,
          amount: (deposit && deposit.toString()) || void 0,
          deposit: (deposit && deposit.toString()) || "0",
          permission: void 0,
        };
        if (accessKey) {
          if (
            receiverId === accountId &&
            accessKey.permission.enum !== "fullAccess"
          ) {
            action.permission = {
              receiver_id: accountId,
              allowance: constants_1.MULTISIG_ALLOWANCE.toString(),
              method_names: constants_1.MULTISIG_CHANGE_METHODS,
            };
          }
          if (accessKey.permission.enum === "functionCall") {
            const {
              receiverId: receiver_id,
              methodNames: method_names,
              allowance,
            } = accessKey.permission.functionCall;
            action.permission = {
              receiver_id,
              allowance: (allowance && allowance.toString()) || void 0,
              method_names,
            };
          }
        }
        return action;
      });
  },
});

// node_modules/@near-js/accounts/lib/account_2fa.js
var require_account_2fa = __commonJS({
  "node_modules/@near-js/accounts/lib/account_2fa.js"(exports2) {
    var __awaiter =
      (exports2 && exports2.__awaiter) ||
      function (thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P
            ? value
            : new P(function (resolve) {
                resolve(value);
              });
        }
        return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done
              ? resolve(result.value)
              : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
    var __importDefault =
      (exports2 && exports2.__importDefault) ||
      function (mod) {
        return mod && mod.__esModule ? mod : { default: mod };
      };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Account2FA = void 0;
    var crypto_1 = require_lib3();
    var types_1 = require_lib2();
    var providers_1 = require_lib8();
    var transactions_1 = require_lib7();
    var bn_js_1 = __importDefault(require_bn());
    var account_multisig_1 = require_account_multisig();
    var constants_1 = require_constants3();
    var types_2 = require_types();
    var {
      addKey,
      deleteKey,
      deployContract,
      fullAccessKey,
      functionCall,
      functionCallAccessKey,
    } = transactions_1.actionCreators;
    var Account2FA = class extends account_multisig_1.AccountMultisig {
      constructor(connection, accountId, options) {
        super(connection, accountId, options);
        this.helperUrl = "https://helper.testnet.near.org";
        this.helperUrl = options.helperUrl || this.helperUrl;
        this.storage = options.storage;
        this.sendCode = options.sendCode || this.sendCodeDefault;
        this.getCode = options.getCode || this.getCodeDefault;
        this.verifyCode = options.verifyCode || this.verifyCodeDefault;
        this.onConfirmResult = options.onConfirmResult;
      }
      /**
       * Sign a transaction to preform a list of actions and broadcast it using the RPC API.
       * @see {@link providers/json-rpc-provider!JsonRpcProvider#sendTransaction | JsonRpcProvider.sendTransaction}
       */
      signAndSendTransaction({ receiverId, actions }) {
        const _super = Object.create(null, {
          signAndSendTransaction: { get: () => super.signAndSendTransaction },
        });
        return __awaiter(this, void 0, void 0, function* () {
          yield _super.signAndSendTransaction.call(this, {
            receiverId,
            actions,
          });
          yield this.sendCode();
          const result = yield this.promptAndVerify();
          if (this.onConfirmResult) {
            yield this.onConfirmResult(result);
          }
          return result;
        });
      }
      // default helpers for CH deployments of multisig
      deployMultisig(contractBytes) {
        const _super = Object.create(null, {
          signAndSendTransactionWithAccount: {
            get: () => super.signAndSendTransactionWithAccount,
          },
        });
        return __awaiter(this, void 0, void 0, function* () {
          const { accountId } = this;
          const seedOrLedgerKey = (yield this.getRecoveryMethods()).data
            .filter(
              ({ kind, publicKey }) =>
                (kind === "phrase" || kind === "ledger") && publicKey !== null
            )
            .map((rm) => rm.publicKey);
          const fak2lak = (yield this.getAccessKeys())
            .filter(
              ({ public_key, access_key: { permission } }) =>
                permission === "FullAccess" &&
                !seedOrLedgerKey.includes(public_key)
            )
            .map((ak) => ak.public_key)
            .map(toPK);
          const confirmOnlyKey = toPK(
            (yield this.postSignedJson("/2fa/getAccessKey", { accountId }))
              .publicKey
          );
          const newArgs = Buffer.from(JSON.stringify({ num_confirmations: 2 }));
          const actions = [
            ...fak2lak.map((pk) => deleteKey(pk)),
            ...fak2lak.map((pk) =>
              addKey(
                pk,
                functionCallAccessKey(
                  accountId,
                  constants_1.MULTISIG_CHANGE_METHODS,
                  null
                )
              )
            ),
            addKey(
              confirmOnlyKey,
              functionCallAccessKey(
                accountId,
                constants_1.MULTISIG_CONFIRM_METHODS,
                null
              )
            ),
            deployContract(contractBytes),
          ];
          const newFunctionCallActionBatch = actions.concat(
            functionCall(
              "new",
              newArgs,
              constants_1.MULTISIG_GAS,
              constants_1.MULTISIG_DEPOSIT
            )
          );
          console.log("deploying multisig contract for", accountId);
          const { stateStatus: multisigStateStatus } =
            yield this.checkMultisigCodeAndStateStatus(contractBytes);
          switch (multisigStateStatus) {
            case types_2.MultisigStateStatus.STATE_NOT_INITIALIZED:
              return yield _super.signAndSendTransactionWithAccount.call(
                this,
                accountId,
                newFunctionCallActionBatch
              );
            case types_2.MultisigStateStatus.VALID_STATE:
              return yield _super.signAndSendTransactionWithAccount.call(
                this,
                accountId,
                actions
              );
            case types_2.MultisigStateStatus.INVALID_STATE:
              throw new types_1.TypedError(
                `Can not deploy a contract to account ${this.accountId} on network ${this.connection.networkId}, the account has existing state.`,
                "ContractHasExistingState"
              );
            default:
              throw new types_1.TypedError(
                `Can not deploy a contract to account ${this.accountId} on network ${this.connection.networkId}, the account state could not be verified.`,
                "ContractStateUnknown"
              );
          }
        });
      }
      disableWithFAK({ contractBytes, cleanupContractBytes }) {
        return __awaiter(this, void 0, void 0, function* () {
          let cleanupActions = [];
          if (cleanupContractBytes) {
            yield this.deleteAllRequests().catch((e) => e);
            cleanupActions = yield this.get2faDisableCleanupActions(
              cleanupContractBytes
            );
          }
          const keyConversionActions =
            yield this.get2faDisableKeyConversionActions();
          const actions = [
            ...cleanupActions,
            ...keyConversionActions,
            deployContract(contractBytes),
          ];
          const accessKeyInfo = yield this.findAccessKey(
            this.accountId,
            actions
          );
          if (
            accessKeyInfo &&
            accessKeyInfo.accessKey &&
            accessKeyInfo.accessKey.permission !== "FullAccess"
          ) {
            throw new types_1.TypedError(
              "No full access key found in keystore. Unable to bypass multisig",
              "NoFAKFound"
            );
          }
          return this.signAndSendTransactionWithAccount(
            this.accountId,
            actions
          );
        });
      }
      get2faDisableCleanupActions(cleanupContractBytes) {
        return __awaiter(this, void 0, void 0, function* () {
          const currentAccountState = yield this.viewState("").catch(
            (error) => {
              const cause = error.cause && error.cause.name;
              if (cause == "NO_CONTRACT_CODE") {
                return [];
              }
              throw cause == "TOO_LARGE_CONTRACT_STATE"
                ? new types_1.TypedError(
                    `Can not deploy a contract to account ${this.accountId} on network ${this.connection.networkId}, the account has existing state.`,
                    "ContractHasExistingState"
                  )
                : error;
            }
          );
          const currentAccountStateKeys = currentAccountState.map(({ key }) =>
            key.toString("base64")
          );
          return currentAccountState.length
            ? [
                deployContract(cleanupContractBytes),
                functionCall(
                  "clean",
                  { keys: currentAccountStateKeys },
                  constants_1.MULTISIG_GAS,
                  new bn_js_1.default("0")
                ),
              ]
            : [];
        });
      }
      get2faDisableKeyConversionActions() {
        return __awaiter(this, void 0, void 0, function* () {
          const { accountId } = this;
          const accessKeys = yield this.getAccessKeys();
          const lak2fak = accessKeys
            .filter(({ access_key }) => access_key.permission !== "FullAccess")
            .filter(({ access_key }) => {
              const perm = access_key.permission.FunctionCall;
              return (
                perm.receiver_id === accountId &&
                perm.method_names.length === 4 &&
                perm.method_names.includes("add_request_and_confirm")
              );
            });
          const confirmOnlyKey = crypto_1.PublicKey.from(
            (yield this.postSignedJson("/2fa/getAccessKey", { accountId }))
              .publicKey
          );
          return [
            deleteKey(confirmOnlyKey),
            ...lak2fak.map(({ public_key }) =>
              deleteKey(crypto_1.PublicKey.from(public_key))
            ),
            ...lak2fak.map(({ public_key }) =>
              addKey(crypto_1.PublicKey.from(public_key), fullAccessKey())
            ),
          ];
        });
      }
      /**
       * This method converts LAKs back to FAKs, clears state and deploys an 'empty' contract (contractBytes param)
       * @param [contractBytes]{@link https://github.com/near/near-wallet/blob/master/packages/frontend/src/wasm/main.wasm?raw=true}
       * @param [cleanupContractBytes]{@link https://github.com/near/core-contracts/blob/master/state-cleanup/res/state_cleanup.wasm?raw=true}
       */
      disable(contractBytes, cleanupContractBytes) {
        return __awaiter(this, void 0, void 0, function* () {
          const { stateStatus } = yield this.checkMultisigCodeAndStateStatus();
          if (
            stateStatus !== types_2.MultisigStateStatus.VALID_STATE &&
            stateStatus !== types_2.MultisigStateStatus.STATE_NOT_INITIALIZED
          ) {
            throw new types_1.TypedError(
              `Can not deploy a contract to account ${this.accountId} on network ${this.connection.networkId}, the account state could not be verified.`,
              "ContractStateUnknown"
            );
          }
          let deleteAllRequestsError;
          yield this.deleteAllRequests().catch(
            (e) => (deleteAllRequestsError = e)
          );
          const cleanupActions = yield this.get2faDisableCleanupActions(
            cleanupContractBytes
          ).catch((e) => {
            if (e.type === "ContractHasExistingState") {
              throw deleteAllRequestsError || e;
            }
            throw e;
          });
          const actions = [
            ...cleanupActions,
            ...(yield this.get2faDisableKeyConversionActions()),
            deployContract(contractBytes),
          ];
          console.log("disabling 2fa for", this.accountId);
          return yield this.signAndSendTransaction({
            receiverId: this.accountId,
            actions,
          });
        });
      }
      sendCodeDefault() {
        return __awaiter(this, void 0, void 0, function* () {
          const { accountId } = this;
          const { requestId } = this.getRequest();
          const method2 = yield this.get2faMethod();
          yield this.postSignedJson("/2fa/send", {
            accountId,
            method: method2,
            requestId,
          });
          return requestId;
        });
      }
      getCodeDefault() {
        return __awaiter(this, void 0, void 0, function* () {
          throw new Error(
            'There is no getCode callback provided. Please provide your own in AccountMultisig constructor options. It has a parameter method where method.kind is "email" or "phone".'
          );
        });
      }
      promptAndVerify() {
        return __awaiter(this, void 0, void 0, function* () {
          const method2 = yield this.get2faMethod();
          const securityCode = yield this.getCode(method2);
          try {
            const result = yield this.verifyCode(securityCode);
            return result;
          } catch (e) {
            console.warn("Error validating security code:", e);
            if (
              e.toString().includes("invalid 2fa code provided") ||
              e.toString().includes("2fa code not valid")
            ) {
              return yield this.promptAndVerify();
            }
            throw e;
          }
        });
      }
      verifyCodeDefault(securityCode) {
        return __awaiter(this, void 0, void 0, function* () {
          const { accountId } = this;
          const request = this.getRequest();
          if (!request) {
            throw new Error("no request pending");
          }
          const { requestId } = request;
          return yield this.postSignedJson("/2fa/verify", {
            accountId,
            securityCode,
            requestId,
          });
        });
      }
      getRecoveryMethods() {
        return __awaiter(this, void 0, void 0, function* () {
          const { accountId } = this;
          return {
            accountId,
            data: yield this.postSignedJson("/account/recoveryMethods", {
              accountId,
            }),
          };
        });
      }
      get2faMethod() {
        return __awaiter(this, void 0, void 0, function* () {
          let { data } = yield this.getRecoveryMethods();
          if (data && data.length) {
            data = data.find((m) => m.kind.indexOf("2fa-") === 0);
          }
          if (!data) return null;
          const { kind, detail } = data;
          return { kind, detail };
        });
      }
      signatureFor() {
        return __awaiter(this, void 0, void 0, function* () {
          const { accountId } = this;
          const block = yield this.connection.provider.block({
            finality: "final",
          });
          const blockNumber = block.header.height.toString();
          const signed = yield this.connection.signer.signMessage(
            Buffer.from(blockNumber),
            accountId,
            this.connection.networkId
          );
          const blockNumberSignature = Buffer.from(signed.signature).toString(
            "base64"
          );
          return { blockNumber, blockNumberSignature };
        });
      }
      postSignedJson(path, body) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield (0,
          providers_1.fetchJson)(this.helperUrl + path, JSON.stringify(Object.assign(Object.assign({}, body), yield this.signatureFor())));
        });
      }
    };
    exports2.Account2FA = Account2FA;
    var toPK = (pk) => crypto_1.PublicKey.from(pk);
  },
});

// node_modules/@near-js/accounts/lib/account_creator.js
var require_account_creator = __commonJS({
  "node_modules/@near-js/accounts/lib/account_creator.js"(exports2) {
    var __awaiter =
      (exports2 && exports2.__awaiter) ||
      function (thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P
            ? value
            : new P(function (resolve) {
                resolve(value);
              });
        }
        return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done
              ? resolve(result.value)
              : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UrlAccountCreator =
      exports2.LocalAccountCreator =
      exports2.AccountCreator =
        void 0;
    var providers_1 = require_lib8();
    var AccountCreator = class {};
    exports2.AccountCreator = AccountCreator;
    var LocalAccountCreator = class extends AccountCreator {
      constructor(masterAccount, initialBalance) {
        super();
        this.masterAccount = masterAccount;
        this.initialBalance = initialBalance;
      }
      /**
       * Creates an account using a masterAccount, meaning the new account is created from an existing account
       * @param newAccountId The name of the NEAR account to be created
       * @param publicKey The public key from the masterAccount used to create this account
       * @returns {Promise<void>}
       */
      createAccount(newAccountId, publicKey) {
        return __awaiter(this, void 0, void 0, function* () {
          yield this.masterAccount.createAccount(
            newAccountId,
            publicKey,
            this.initialBalance
          );
        });
      }
    };
    exports2.LocalAccountCreator = LocalAccountCreator;
    var UrlAccountCreator = class extends AccountCreator {
      constructor(connection, helperUrl) {
        super();
        this.connection = connection;
        this.helperUrl = helperUrl;
      }
      /**
       * Creates an account using a helperUrl
       * This is [hosted here](https://helper.nearprotocol.com) or set up locally with the [near-contract-helper](https://github.com/nearprotocol/near-contract-helper) repository
       * @param newAccountId The name of the NEAR account to be created
       * @param publicKey The public key from the masterAccount used to create this account
       * @returns {Promise<void>}
       */
      createAccount(newAccountId, publicKey) {
        return __awaiter(this, void 0, void 0, function* () {
          yield (0,
          providers_1.fetchJson)(`${this.helperUrl}/account`, JSON.stringify({ newAccountId, newAccountPublicKey: publicKey.toString() }));
        });
      }
    };
    exports2.UrlAccountCreator = UrlAccountCreator;
  },
});

// node_modules/@near-js/signers/lib/signer.js
var require_signer = __commonJS({
  "node_modules/@near-js/signers/lib/signer.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Signer = void 0;
    var Signer = class {};
    exports2.Signer = Signer;
  },
});

// node_modules/@near-js/signers/lib/in_memory_signer.js
var require_in_memory_signer = __commonJS({
  "node_modules/@near-js/signers/lib/in_memory_signer.js"(exports2) {
    var __awaiter =
      (exports2 && exports2.__awaiter) ||
      function (thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P
            ? value
            : new P(function (resolve) {
                resolve(value);
              });
        }
        return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done
              ? resolve(result.value)
              : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
    var __importDefault =
      (exports2 && exports2.__importDefault) ||
      function (mod) {
        return mod && mod.__esModule ? mod : { default: mod };
      };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InMemorySigner = void 0;
    var crypto_1 = require_lib3();
    var keystores_1 = require_lib4();
    var js_sha256_1 = __importDefault(require_sha256());
    var signer_1 = require_signer();
    var InMemorySigner = class _InMemorySigner extends signer_1.Signer {
      constructor(keyStore) {
        super();
        this.keyStore = keyStore;
      }
      /**
       * Creates a single account Signer instance with account, network and keyPair provided.
       *
       * Intended to be useful for temporary keys (e.g. claiming a Linkdrop).
       *
       * @param networkId The targeted network. (ex. default, betanet, etc)
       * @param accountId The NEAR account to assign the key pair to
       * @param keyPair The keyPair to use for signing
       */
      static fromKeyPair(networkId, accountId, keyPair) {
        return __awaiter(this, void 0, void 0, function* () {
          const keyStore = new keystores_1.InMemoryKeyStore();
          yield keyStore.setKey(networkId, accountId, keyPair);
          return new _InMemorySigner(keyStore);
        });
      }
      /**
       * Creates a public key for the account given
       * @param accountId The NEAR account to assign a public key to
       * @param networkId The targeted network. (ex. default, betanet, etc)
       * @returns {Promise<PublicKey>}
       */
      createKey(accountId, networkId) {
        return __awaiter(this, void 0, void 0, function* () {
          const keyPair = crypto_1.KeyPair.fromRandom("ed25519");
          yield this.keyStore.setKey(networkId, accountId, keyPair);
          return keyPair.getPublicKey();
        });
      }
      /**
       * Gets the existing public key for a given account
       * @param accountId The NEAR account to assign a public key to
       * @param networkId The targeted network. (ex. default, betanet, etc)
       * @returns {Promise<PublicKey>} Returns the public key or null if not found
       */
      getPublicKey(accountId, networkId) {
        return __awaiter(this, void 0, void 0, function* () {
          const keyPair = yield this.keyStore.getKey(networkId, accountId);
          if (keyPair === null) {
            return null;
          }
          return keyPair.getPublicKey();
        });
      }
      /**
       * @param message A message to be signed, typically a serialized transaction
       * @param accountId the NEAR account signing the message
       * @param networkId The targeted network. (ex. default, betanet, etc)
       * @returns {Promise<Signature>}
       */
      signMessage(message, accountId, networkId) {
        return __awaiter(this, void 0, void 0, function* () {
          const hash = new Uint8Array(
            js_sha256_1.default.sha256.array(message)
          );
          if (!accountId) {
            throw new Error("InMemorySigner requires provided account id");
          }
          const keyPair = yield this.keyStore.getKey(networkId, accountId);
          if (keyPair === null) {
            throw new Error(`Key for ${accountId} not found in ${networkId}`);
          }
          return keyPair.sign(hash);
        });
      }
      toString() {
        return `InMemorySigner(${this.keyStore})`;
      }
    };
    exports2.InMemorySigner = InMemorySigner;
  },
});

// node_modules/@near-js/signers/lib/index.js
var require_lib9 = __commonJS({
  "node_modules/@near-js/signers/lib/index.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Signer = exports2.InMemorySigner = void 0;
    var in_memory_signer_1 = require_in_memory_signer();
    Object.defineProperty(exports2, "InMemorySigner", {
      enumerable: true,
      get: function () {
        return in_memory_signer_1.InMemorySigner;
      },
    });
    var signer_1 = require_signer();
    Object.defineProperty(exports2, "Signer", {
      enumerable: true,
      get: function () {
        return signer_1.Signer;
      },
    });
  },
});

// node_modules/@near-js/accounts/lib/connection.js
var require_connection = __commonJS({
  "node_modules/@near-js/accounts/lib/connection.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Connection = void 0;
    var signers_1 = require_lib9();
    var providers_1 = require_lib8();
    function getProvider(config) {
      switch (config.type) {
        case void 0:
          return config;
        case "JsonRpcProvider":
          return new providers_1.JsonRpcProvider(
            Object.assign({}, config.args)
          );
        default:
          throw new Error(`Unknown provider type ${config.type}`);
      }
    }
    function getSigner(config) {
      switch (config.type) {
        case void 0:
          return config;
        case "InMemorySigner": {
          return new signers_1.InMemorySigner(config.keyStore);
        }
        default:
          throw new Error(`Unknown signer type ${config.type}`);
      }
    }
    var Connection = class _Connection {
      constructor(networkId, provider, signer, jsvmAccountId) {
        this.networkId = networkId;
        this.provider = provider;
        this.signer = signer;
        this.jsvmAccountId = jsvmAccountId;
      }
      /**
       * @param config Contains connection info details
       */
      static fromConfig(config) {
        const provider = getProvider(config.provider);
        const signer = getSigner(config.signer);
        return new _Connection(
          config.networkId,
          provider,
          signer,
          config.jsvmAccountId
        );
      }
    };
    exports2.Connection = Connection;
  },
});

// node_modules/@near-js/accounts/node_modules/ajv/dist/compile/codegen/code.js
var require_code = __commonJS({
  "node_modules/@near-js/accounts/node_modules/ajv/dist/compile/codegen/code.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.regexpCode =
      exports2.getEsmExportName =
      exports2.getProperty =
      exports2.safeStringify =
      exports2.stringify =
      exports2.strConcat =
      exports2.addCodeArg =
      exports2.str =
      exports2._ =
      exports2.nil =
      exports2._Code =
      exports2.Name =
      exports2.IDENTIFIER =
      exports2._CodeOrName =
        void 0;
    var _CodeOrName = class {};
    exports2._CodeOrName = _CodeOrName;
    exports2.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
    var Name = class extends _CodeOrName {
      constructor(s) {
        super();
        if (!exports2.IDENTIFIER.test(s))
          throw new Error("CodeGen: name must be a valid identifier");
        this.str = s;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        return false;
      }
      get names() {
        return { [this.str]: 1 };
      }
    };
    exports2.Name = Name;
    var _Code = class extends _CodeOrName {
      constructor(code) {
        super();
        this._items = typeof code === "string" ? [code] : code;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        if (this._items.length > 1) return false;
        const item = this._items[0];
        return item === "" || item === '""';
      }
      get str() {
        var _a;
        return (_a = this._str) !== null && _a !== void 0
          ? _a
          : (this._str = this._items.reduce((s, c) => `${s}${c}`, ""));
      }
      get names() {
        var _a;
        return (_a = this._names) !== null && _a !== void 0
          ? _a
          : (this._names = this._items.reduce((names, c) => {
              if (c instanceof Name) names[c.str] = (names[c.str] || 0) + 1;
              return names;
            }, {}));
      }
    };
    exports2._Code = _Code;
    exports2.nil = new _Code("");
    function _(strs, ...args) {
      const code = [strs[0]];
      let i = 0;
      while (i < args.length) {
        addCodeArg(code, args[i]);
        code.push(strs[++i]);
      }
      return new _Code(code);
    }
    exports2._ = _;
    var plus = new _Code("+");
    function str(strs, ...args) {
      const expr = [safeStringify(strs[0])];
      let i = 0;
      while (i < args.length) {
        expr.push(plus);
        addCodeArg(expr, args[i]);
        expr.push(plus, safeStringify(strs[++i]));
      }
      optimize(expr);
      return new _Code(expr);
    }
    exports2.str = str;
    function addCodeArg(code, arg) {
      if (arg instanceof _Code) code.push(...arg._items);
      else if (arg instanceof Name) code.push(arg);
      else code.push(interpolate(arg));
    }
    exports2.addCodeArg = addCodeArg;
    function optimize(expr) {
      let i = 1;
      while (i < expr.length - 1) {
        if (expr[i] === plus) {
          const res = mergeExprItems(expr[i - 1], expr[i + 1]);
          if (res !== void 0) {
            expr.splice(i - 1, 3, res);
            continue;
          }
          expr[i++] = "+";
        }
        i++;
      }
    }
    function mergeExprItems(a, b) {
      if (b === '""') return a;
      if (a === '""') return b;
      if (typeof a == "string") {
        if (b instanceof Name || a[a.length - 1] !== '"') return;
        if (typeof b != "string") return `${a.slice(0, -1)}${b}"`;
        if (b[0] === '"') return a.slice(0, -1) + b.slice(1);
        return;
      }
      if (typeof b == "string" && b[0] === '"' && !(a instanceof Name))
        return `"${a}${b.slice(1)}`;
      return;
    }
    function strConcat(c1, c2) {
      return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`;
    }
    exports2.strConcat = strConcat;
    function interpolate(x) {
      return typeof x == "number" || typeof x == "boolean" || x === null
        ? x
        : safeStringify(Array.isArray(x) ? x.join(",") : x);
    }
    function stringify(x) {
      return new _Code(safeStringify(x));
    }
    exports2.stringify = stringify;
    function safeStringify(x) {
      return JSON.stringify(x)
        .replace(/\u2028/g, "\\u2028")
        .replace(/\u2029/g, "\\u2029");
    }
    exports2.safeStringify = safeStringify;
    function getProperty(key) {
      return typeof key == "string" && exports2.IDENTIFIER.test(key)
        ? new _Code(`.${key}`)
        : _`[${key}]`;
    }
    exports2.getProperty = getProperty;
    function getEsmExportName(key) {
      if (typeof key == "string" && exports2.IDENTIFIER.test(key)) {
        return new _Code(`${key}`);
      }
      throw new Error(
        `CodeGen: invalid export name: ${key}, use explicit $id name mapping`
      );
    }
    exports2.getEsmExportName = getEsmExportName;
    function regexpCode(rx) {
      return new _Code(rx.toString());
    }
    exports2.regexpCode = regexpCode;
  },
});

// node_modules/@near-js/accounts/node_modules/ajv/dist/compile/codegen/scope.js
var require_scope = __commonJS({
  "node_modules/@near-js/accounts/node_modules/ajv/dist/compile/codegen/scope.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ValueScope =
      exports2.ValueScopeName =
      exports2.Scope =
      exports2.varKinds =
      exports2.UsedValueState =
        void 0;
    var code_1 = require_code();
    var ValueError = class extends Error {
      constructor(name) {
        super(`CodeGen: "code" for ${name} not defined`);
        this.value = name.value;
      }
    };
    var UsedValueState;
    (function (UsedValueState2) {
      UsedValueState2[(UsedValueState2["Started"] = 0)] = "Started";
      UsedValueState2[(UsedValueState2["Completed"] = 1)] = "Completed";
    })(
      (UsedValueState =
        exports2.UsedValueState || (exports2.UsedValueState = {}))
    );
    exports2.varKinds = {
      const: new code_1.Name("const"),
      let: new code_1.Name("let"),
      var: new code_1.Name("var"),
    };
    var Scope = class {
      constructor({ prefixes, parent } = {}) {
        this._names = {};
        this._prefixes = prefixes;
        this._parent = parent;
      }
      toName(nameOrPrefix) {
        return nameOrPrefix instanceof code_1.Name
          ? nameOrPrefix
          : this.name(nameOrPrefix);
      }
      name(prefix) {
        return new code_1.Name(this._newName(prefix));
      }
      _newName(prefix) {
        const ng = this._names[prefix] || this._nameGroup(prefix);
        return `${prefix}${ng.index++}`;
      }
      _nameGroup(prefix) {
        var _a, _b;
        if (
          ((_b =
            (_a = this._parent) === null || _a === void 0
              ? void 0
              : _a._prefixes) === null || _b === void 0
            ? void 0
            : _b.has(prefix)) ||
          (this._prefixes && !this._prefixes.has(prefix))
        ) {
          throw new Error(
            `CodeGen: prefix "${prefix}" is not allowed in this scope`
          );
        }
        return (this._names[prefix] = { prefix, index: 0 });
      }
    };
    exports2.Scope = Scope;
    var ValueScopeName = class extends code_1.Name {
      constructor(prefix, nameStr) {
        super(nameStr);
        this.prefix = prefix;
      }
      setValue(value, { property, itemIndex }) {
        this.value = value;
        this.scopePath = (0, code_1._)`.${new code_1.Name(
          property
        )}[${itemIndex}]`;
      }
    };
    exports2.ValueScopeName = ValueScopeName;
    var line = (0, code_1._)`\n`;
    var ValueScope = class extends Scope {
      constructor(opts) {
        super(opts);
        this._values = {};
        this._scope = opts.scope;
        this.opts = { ...opts, _n: opts.lines ? line : code_1.nil };
      }
      get() {
        return this._scope;
      }
      name(prefix) {
        return new ValueScopeName(prefix, this._newName(prefix));
      }
      value(nameOrPrefix, value) {
        var _a;
        if (value.ref === void 0)
          throw new Error("CodeGen: ref must be passed in value");
        const name = this.toName(nameOrPrefix);
        const { prefix } = name;
        const valueKey =
          (_a = value.key) !== null && _a !== void 0 ? _a : value.ref;
        let vs = this._values[prefix];
        if (vs) {
          const _name = vs.get(valueKey);
          if (_name) return _name;
        } else {
          vs = this._values[prefix] = /* @__PURE__ */ new Map();
        }
        vs.set(valueKey, name);
        const s = this._scope[prefix] || (this._scope[prefix] = []);
        const itemIndex = s.length;
        s[itemIndex] = value.ref;
        name.setValue(value, { property: prefix, itemIndex });
        return name;
      }
      getValue(prefix, keyOrRef) {
        const vs = this._values[prefix];
        if (!vs) return;
        return vs.get(keyOrRef);
      }
      scopeRefs(scopeName, values = this._values) {
        return this._reduceValues(values, (name) => {
          if (name.scopePath === void 0)
            throw new Error(`CodeGen: name "${name}" has no value`);
          return (0, code_1._)`${scopeName}${name.scopePath}`;
        });
      }
      scopeCode(values = this._values, usedValues, getCode) {
        return this._reduceValues(
          values,
          (name) => {
            if (name.value === void 0)
              throw new Error(`CodeGen: name "${name}" has no value`);
            return name.value.code;
          },
          usedValues,
          getCode
        );
      }
      _reduceValues(values, valueCode, usedValues = {}, getCode) {
        let code = code_1.nil;
        for (const prefix in values) {
          const vs = values[prefix];
          if (!vs) continue;
          const nameSet = (usedValues[prefix] =
            usedValues[prefix] || /* @__PURE__ */ new Map());
          vs.forEach((name) => {
            if (nameSet.has(name)) return;
            nameSet.set(name, UsedValueState.Started);
            let c = valueCode(name);
            if (c) {
              const def = this.opts.es5
                ? exports2.varKinds.var
                : exports2.varKinds.const;
              code = (0,
              code_1._)`${code}${def} ${name} = ${c};${this.opts._n}`;
            } else if (
              (c =
                getCode === null || getCode === void 0 ? void 0 : getCode(name))
            ) {
              code = (0, code_1._)`${code}${c}${this.opts._n}`;
            } else {
              throw new ValueError(name);
            }
            nameSet.set(name, UsedValueState.Completed);
          });
        }
        return code;
      }
    };
    exports2.ValueScope = ValueScope;
  },
});

// node_modules/@near-js/accounts/node_modules/ajv/dist/compile/codegen/index.js
var require_codegen = __commonJS({
  "node_modules/@near-js/accounts/node_modules/ajv/dist/compile/codegen/index.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.or =
      exports2.and =
      exports2.not =
      exports2.CodeGen =
      exports2.operators =
      exports2.varKinds =
      exports2.ValueScopeName =
      exports2.ValueScope =
      exports2.Scope =
      exports2.Name =
      exports2.regexpCode =
      exports2.stringify =
      exports2.getProperty =
      exports2.nil =
      exports2.strConcat =
      exports2.str =
      exports2._ =
        void 0;
    var code_1 = require_code();
    var scope_1 = require_scope();
    var code_2 = require_code();
    Object.defineProperty(exports2, "_", {
      enumerable: true,
      get: function () {
        return code_2._;
      },
    });
    Object.defineProperty(exports2, "str", {
      enumerable: true,
      get: function () {
        return code_2.str;
      },
    });
    Object.defineProperty(exports2, "strConcat", {
      enumerable: true,
      get: function () {
        return code_2.strConcat;
      },
    });
    Object.defineProperty(exports2, "nil", {
      enumerable: true,
      get: function () {
        return code_2.nil;
      },
    });
    Object.defineProperty(exports2, "getProperty", {
      enumerable: true,
      get: function () {
        return code_2.getProperty;
      },
    });
    Object.defineProperty(exports2, "stringify", {
      enumerable: true,
      get: function () {
        return code_2.stringify;
      },
    });
    Object.defineProperty(exports2, "regexpCode", {
      enumerable: true,
      get: function () {
        return code_2.regexpCode;
      },
    });
    Object.defineProperty(exports2, "Name", {
      enumerable: true,
      get: function () {
        return code_2.Name;
      },
    });
    var scope_2 = require_scope();
    Object.defineProperty(exports2, "Scope", {
      enumerable: true,
      get: function () {
        return scope_2.Scope;
      },
    });
    Object.defineProperty(exports2, "ValueScope", {
      enumerable: true,
      get: function () {
        return scope_2.ValueScope;
      },
    });
    Object.defineProperty(exports2, "ValueScopeName", {
      enumerable: true,
      get: function () {
        return scope_2.ValueScopeName;
      },
    });
    Object.defineProperty(exports2, "varKinds", {
      enumerable: true,
      get: function () {
        return scope_2.varKinds;
      },
    });
    exports2.operators = {
      GT: new code_1._Code(">"),
      GTE: new code_1._Code(">="),
      LT: new code_1._Code("<"),
      LTE: new code_1._Code("<="),
      EQ: new code_1._Code("==="),
      NEQ: new code_1._Code("!=="),
      NOT: new code_1._Code("!"),
      OR: new code_1._Code("||"),
      AND: new code_1._Code("&&"),
      ADD: new code_1._Code("+"),
    };
    var Node = class {
      optimizeNodes() {
        return this;
      }
      optimizeNames(_names, _constants) {
        return this;
      }
    };
    var Def = class extends Node {
      constructor(varKind, name, rhs) {
        super();
        this.varKind = varKind;
        this.name = name;
        this.rhs = rhs;
      }
      render({ es5, _n }) {
        const varKind = es5 ? scope_1.varKinds.var : this.varKind;
        const rhs = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
        return `${varKind} ${this.name}${rhs};` + _n;
      }
      optimizeNames(names, constants) {
        if (!names[this.name.str]) return;
        if (this.rhs) this.rhs = optimizeExpr(this.rhs, names, constants);
        return this;
      }
      get names() {
        return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};
      }
    };
    var Assign = class extends Node {
      constructor(lhs, rhs, sideEffects) {
        super();
        this.lhs = lhs;
        this.rhs = rhs;
        this.sideEffects = sideEffects;
      }
      render({ _n }) {
        return `${this.lhs} = ${this.rhs};` + _n;
      }
      optimizeNames(names, constants) {
        if (
          this.lhs instanceof code_1.Name &&
          !names[this.lhs.str] &&
          !this.sideEffects
        )
          return;
        this.rhs = optimizeExpr(this.rhs, names, constants);
        return this;
      }
      get names() {
        const names =
          this.lhs instanceof code_1.Name ? {} : { ...this.lhs.names };
        return addExprNames(names, this.rhs);
      }
    };
    var AssignOp = class extends Assign {
      constructor(lhs, op, rhs, sideEffects) {
        super(lhs, rhs, sideEffects);
        this.op = op;
      }
      render({ _n }) {
        return `${this.lhs} ${this.op}= ${this.rhs};` + _n;
      }
    };
    var Label = class extends Node {
      constructor(label) {
        super();
        this.label = label;
        this.names = {};
      }
      render({ _n }) {
        return `${this.label}:` + _n;
      }
    };
    var Break = class extends Node {
      constructor(label) {
        super();
        this.label = label;
        this.names = {};
      }
      render({ _n }) {
        const label = this.label ? ` ${this.label}` : "";
        return `break${label};` + _n;
      }
    };
    var Throw = class extends Node {
      constructor(error) {
        super();
        this.error = error;
      }
      render({ _n }) {
        return `throw ${this.error};` + _n;
      }
      get names() {
        return this.error.names;
      }
    };
    var AnyCode = class extends Node {
      constructor(code) {
        super();
        this.code = code;
      }
      render({ _n }) {
        return `${this.code};` + _n;
      }
      optimizeNodes() {
        return `${this.code}` ? this : void 0;
      }
      optimizeNames(names, constants) {
        this.code = optimizeExpr(this.code, names, constants);
        return this;
      }
      get names() {
        return this.code instanceof code_1._CodeOrName ? this.code.names : {};
      }
    };
    var ParentNode = class extends Node {
      constructor(nodes = []) {
        super();
        this.nodes = nodes;
      }
      render(opts) {
        return this.nodes.reduce((code, n) => code + n.render(opts), "");
      }
      optimizeNodes() {
        const { nodes } = this;
        let i = nodes.length;
        while (i--) {
          const n = nodes[i].optimizeNodes();
          if (Array.isArray(n)) nodes.splice(i, 1, ...n);
          else if (n) nodes[i] = n;
          else nodes.splice(i, 1);
        }
        return nodes.length > 0 ? this : void 0;
      }
      optimizeNames(names, constants) {
        const { nodes } = this;
        let i = nodes.length;
        while (i--) {
          const n = nodes[i];
          if (n.optimizeNames(names, constants)) continue;
          subtractNames(names, n.names);
          nodes.splice(i, 1);
        }
        return nodes.length > 0 ? this : void 0;
      }
      get names() {
        return this.nodes.reduce((names, n) => addNames(names, n.names), {});
      }
    };
    var BlockNode = class extends ParentNode {
      render(opts) {
        return "{" + opts._n + super.render(opts) + "}" + opts._n;
      }
    };
    var Root = class extends ParentNode {};
    var Else = class extends BlockNode {};
    Else.kind = "else";
    var If = class _If extends BlockNode {
      constructor(condition, nodes) {
        super(nodes);
        this.condition = condition;
      }
      render(opts) {
        let code = `if(${this.condition})` + super.render(opts);
        if (this.else) code += "else " + this.else.render(opts);
        return code;
      }
      optimizeNodes() {
        super.optimizeNodes();
        const cond = this.condition;
        if (cond === true) return this.nodes;
        let e = this.else;
        if (e) {
          const ns = e.optimizeNodes();
          e = this.else = Array.isArray(ns) ? new Else(ns) : ns;
        }
        if (e) {
          if (cond === false) return e instanceof _If ? e : e.nodes;
          if (this.nodes.length) return this;
          return new _If(not(cond), e instanceof _If ? [e] : e.nodes);
        }
        if (cond === false || !this.nodes.length) return void 0;
        return this;
      }
      optimizeNames(names, constants) {
        var _a;
        this.else =
          (_a = this.else) === null || _a === void 0
            ? void 0
            : _a.optimizeNames(names, constants);
        if (!(super.optimizeNames(names, constants) || this.else)) return;
        this.condition = optimizeExpr(this.condition, names, constants);
        return this;
      }
      get names() {
        const names = super.names;
        addExprNames(names, this.condition);
        if (this.else) addNames(names, this.else.names);
        return names;
      }
    };
    If.kind = "if";
    var For = class extends BlockNode {};
    For.kind = "for";
    var ForLoop = class extends For {
      constructor(iteration) {
        super();
        this.iteration = iteration;
      }
      render(opts) {
        return `for(${this.iteration})` + super.render(opts);
      }
      optimizeNames(names, constants) {
        if (!super.optimizeNames(names, constants)) return;
        this.iteration = optimizeExpr(this.iteration, names, constants);
        return this;
      }
      get names() {
        return addNames(super.names, this.iteration.names);
      }
    };
    var ForRange = class extends For {
      constructor(varKind, name, from, to) {
        super();
        this.varKind = varKind;
        this.name = name;
        this.from = from;
        this.to = to;
      }
      render(opts) {
        const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;
        const { name, from, to } = this;
        return (
          `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` +
          super.render(opts)
        );
      }
      get names() {
        const names = addExprNames(super.names, this.from);
        return addExprNames(names, this.to);
      }
    };
    var ForIter = class extends For {
      constructor(loop, varKind, name, iterable) {
        super();
        this.loop = loop;
        this.varKind = varKind;
        this.name = name;
        this.iterable = iterable;
      }
      render(opts) {
        return (
          `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` +
          super.render(opts)
        );
      }
      optimizeNames(names, constants) {
        if (!super.optimizeNames(names, constants)) return;
        this.iterable = optimizeExpr(this.iterable, names, constants);
        return this;
      }
      get names() {
        return addNames(super.names, this.iterable.names);
      }
    };
    var Func = class extends BlockNode {
      constructor(name, args, async) {
        super();
        this.name = name;
        this.args = args;
        this.async = async;
      }
      render(opts) {
        const _async = this.async ? "async " : "";
        return (
          `${_async}function ${this.name}(${this.args})` + super.render(opts)
        );
      }
    };
    Func.kind = "func";
    var Return = class extends ParentNode {
      render(opts) {
        return "return " + super.render(opts);
      }
    };
    Return.kind = "return";
    var Try = class extends BlockNode {
      render(opts) {
        let code = "try" + super.render(opts);
        if (this.catch) code += this.catch.render(opts);
        if (this.finally) code += this.finally.render(opts);
        return code;
      }
      optimizeNodes() {
        var _a, _b;
        super.optimizeNodes();
        (_a = this.catch) === null || _a === void 0
          ? void 0
          : _a.optimizeNodes();
        (_b = this.finally) === null || _b === void 0
          ? void 0
          : _b.optimizeNodes();
        return this;
      }
      optimizeNames(names, constants) {
        var _a, _b;
        super.optimizeNames(names, constants);
        (_a = this.catch) === null || _a === void 0
          ? void 0
          : _a.optimizeNames(names, constants);
        (_b = this.finally) === null || _b === void 0
          ? void 0
          : _b.optimizeNames(names, constants);
        return this;
      }
      get names() {
        const names = super.names;
        if (this.catch) addNames(names, this.catch.names);
        if (this.finally) addNames(names, this.finally.names);
        return names;
      }
    };
    var Catch = class extends BlockNode {
      constructor(error) {
        super();
        this.error = error;
      }
      render(opts) {
        return `catch(${this.error})` + super.render(opts);
      }
    };
    Catch.kind = "catch";
    var Finally = class extends BlockNode {
      render(opts) {
        return "finally" + super.render(opts);
      }
    };
    Finally.kind = "finally";
    var CodeGen = class {
      constructor(extScope, opts = {}) {
        this._values = {};
        this._blockStarts = [];
        this._constants = {};
        this.opts = { ...opts, _n: opts.lines ? "\n" : "" };
        this._extScope = extScope;
        this._scope = new scope_1.Scope({ parent: extScope });
        this._nodes = [new Root()];
      }
      toString() {
        return this._root.render(this.opts);
      }
      // returns unique name in the internal scope
      name(prefix) {
        return this._scope.name(prefix);
      }
      // reserves unique name in the external scope
      scopeName(prefix) {
        return this._extScope.name(prefix);
      }
      // reserves unique name in the external scope and assigns value to it
      scopeValue(prefixOrName, value) {
        const name = this._extScope.value(prefixOrName, value);
        const vs =
          this._values[name.prefix] ||
          (this._values[name.prefix] = /* @__PURE__ */ new Set());
        vs.add(name);
        return name;
      }
      getScopeValue(prefix, keyOrRef) {
        return this._extScope.getValue(prefix, keyOrRef);
      }
      // return code that assigns values in the external scope to the names that are used internally
      // (same names that were returned by gen.scopeName or gen.scopeValue)
      scopeRefs(scopeName) {
        return this._extScope.scopeRefs(scopeName, this._values);
      }
      scopeCode() {
        return this._extScope.scopeCode(this._values);
      }
      _def(varKind, nameOrPrefix, rhs, constant) {
        const name = this._scope.toName(nameOrPrefix);
        if (rhs !== void 0 && constant) this._constants[name.str] = rhs;
        this._leafNode(new Def(varKind, name, rhs));
        return name;
      }
      // `const` declaration (`var` in es5 mode)
      const(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
      }
      // `let` declaration with optional assignment (`var` in es5 mode)
      let(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
      }
      // `var` declaration with optional assignment
      var(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
      }
      // assignment code
      assign(lhs, rhs, sideEffects) {
        return this._leafNode(new Assign(lhs, rhs, sideEffects));
      }
      // `+=` code
      add(lhs, rhs) {
        return this._leafNode(new AssignOp(lhs, exports2.operators.ADD, rhs));
      }
      // appends passed SafeExpr to code or executes Block
      code(c) {
        if (typeof c == "function") c();
        else if (c !== code_1.nil) this._leafNode(new AnyCode(c));
        return this;
      }
      // returns code for object literal for the passed argument list of key-value pairs
      object(...keyValues) {
        const code = ["{"];
        for (const [key, value] of keyValues) {
          if (code.length > 1) code.push(",");
          code.push(key);
          if (key !== value || this.opts.es5) {
            code.push(":");
            (0, code_1.addCodeArg)(code, value);
          }
        }
        code.push("}");
        return new code_1._Code(code);
      }
      // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
      if(condition, thenBody, elseBody) {
        this._blockNode(new If(condition));
        if (thenBody && elseBody) {
          this.code(thenBody).else().code(elseBody).endIf();
        } else if (thenBody) {
          this.code(thenBody).endIf();
        } else if (elseBody) {
          throw new Error('CodeGen: "else" body without "then" body');
        }
        return this;
      }
      // `else if` clause - invalid without `if` or after `else` clauses
      elseIf(condition) {
        return this._elseNode(new If(condition));
      }
      // `else` clause - only valid after `if` or `else if` clauses
      else() {
        return this._elseNode(new Else());
      }
      // end `if` statement (needed if gen.if was used only with condition)
      endIf() {
        return this._endBlockNode(If, Else);
      }
      _for(node, forBody) {
        this._blockNode(node);
        if (forBody) this.code(forBody).endFor();
        return this;
      }
      // a generic `for` clause (or statement if `forBody` is passed)
      for(iteration, forBody) {
        return this._for(new ForLoop(iteration), forBody);
      }
      // `for` statement for a range of values
      forRange(
        nameOrPrefix,
        from,
        to,
        forBody,
        varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let
      ) {
        const name = this._scope.toName(nameOrPrefix);
        return this._for(new ForRange(varKind, name, from, to), () =>
          forBody(name)
        );
      }
      // `for-of` statement (in es5 mode replace with a normal for loop)
      forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
        const name = this._scope.toName(nameOrPrefix);
        if (this.opts.es5) {
          const arr =
            iterable instanceof code_1.Name
              ? iterable
              : this.var("_arr", iterable);
          return this.forRange("_i", 0, (0, code_1._)`${arr}.length`, (i) => {
            this.var(name, (0, code_1._)`${arr}[${i}]`);
            forBody(name);
          });
        }
        return this._for(new ForIter("of", varKind, name, iterable), () =>
          forBody(name)
        );
      }
      // `for-in` statement.
      // With option `ownProperties` replaced with a `for-of` loop for object keys
      forIn(
        nameOrPrefix,
        obj,
        forBody,
        varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const
      ) {
        if (this.opts.ownProperties) {
          return this.forOf(
            nameOrPrefix,
            (0, code_1._)`Object.keys(${obj})`,
            forBody
          );
        }
        const name = this._scope.toName(nameOrPrefix);
        return this._for(new ForIter("in", varKind, name, obj), () =>
          forBody(name)
        );
      }
      // end `for` loop
      endFor() {
        return this._endBlockNode(For);
      }
      // `label` statement
      label(label) {
        return this._leafNode(new Label(label));
      }
      // `break` statement
      break(label) {
        return this._leafNode(new Break(label));
      }
      // `return` statement
      return(value) {
        const node = new Return();
        this._blockNode(node);
        this.code(value);
        if (node.nodes.length !== 1)
          throw new Error('CodeGen: "return" should have one node');
        return this._endBlockNode(Return);
      }
      // `try` statement
      try(tryBody, catchCode, finallyCode) {
        if (!catchCode && !finallyCode)
          throw new Error('CodeGen: "try" without "catch" and "finally"');
        const node = new Try();
        this._blockNode(node);
        this.code(tryBody);
        if (catchCode) {
          const error = this.name("e");
          this._currNode = node.catch = new Catch(error);
          catchCode(error);
        }
        if (finallyCode) {
          this._currNode = node.finally = new Finally();
          this.code(finallyCode);
        }
        return this._endBlockNode(Catch, Finally);
      }
      // `throw` statement
      throw(error) {
        return this._leafNode(new Throw(error));
      }
      // start self-balancing block
      block(body, nodeCount) {
        this._blockStarts.push(this._nodes.length);
        if (body) this.code(body).endBlock(nodeCount);
        return this;
      }
      // end the current self-balancing block
      endBlock(nodeCount) {
        const len = this._blockStarts.pop();
        if (len === void 0)
          throw new Error("CodeGen: not in self-balancing block");
        const toClose = this._nodes.length - len;
        if (toClose < 0 || (nodeCount !== void 0 && toClose !== nodeCount)) {
          throw new Error(
            `CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`
          );
        }
        this._nodes.length = len;
        return this;
      }
      // `function` heading (or definition if funcBody is passed)
      func(name, args = code_1.nil, async, funcBody) {
        this._blockNode(new Func(name, args, async));
        if (funcBody) this.code(funcBody).endFunc();
        return this;
      }
      // end function definition
      endFunc() {
        return this._endBlockNode(Func);
      }
      optimize(n = 1) {
        while (n-- > 0) {
          this._root.optimizeNodes();
          this._root.optimizeNames(this._root.names, this._constants);
        }
      }
      _leafNode(node) {
        this._currNode.nodes.push(node);
        return this;
      }
      _blockNode(node) {
        this._currNode.nodes.push(node);
        this._nodes.push(node);
      }
      _endBlockNode(N1, N2) {
        const n = this._currNode;
        if (n instanceof N1 || (N2 && n instanceof N2)) {
          this._nodes.pop();
          return this;
        }
        throw new Error(
          `CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`
        );
      }
      _elseNode(node) {
        const n = this._currNode;
        if (!(n instanceof If)) {
          throw new Error('CodeGen: "else" without "if"');
        }
        this._currNode = n.else = node;
        return this;
      }
      get _root() {
        return this._nodes[0];
      }
      get _currNode() {
        const ns = this._nodes;
        return ns[ns.length - 1];
      }
      set _currNode(node) {
        const ns = this._nodes;
        ns[ns.length - 1] = node;
      }
    };
    exports2.CodeGen = CodeGen;
    function addNames(names, from) {
      for (const n in from) names[n] = (names[n] || 0) + (from[n] || 0);
      return names;
    }
    function addExprNames(names, from) {
      return from instanceof code_1._CodeOrName
        ? addNames(names, from.names)
        : names;
    }
    function optimizeExpr(expr, names, constants) {
      if (expr instanceof code_1.Name) return replaceName(expr);
      if (!canOptimize(expr)) return expr;
      return new code_1._Code(
        expr._items.reduce((items, c) => {
          if (c instanceof code_1.Name) c = replaceName(c);
          if (c instanceof code_1._Code) items.push(...c._items);
          else items.push(c);
          return items;
        }, [])
      );
      function replaceName(n) {
        const c = constants[n.str];
        if (c === void 0 || names[n.str] !== 1) return n;
        delete names[n.str];
        return c;
      }
      function canOptimize(e) {
        return (
          e instanceof code_1._Code &&
          e._items.some(
            (c) =>
              c instanceof code_1.Name &&
              names[c.str] === 1 &&
              constants[c.str] !== void 0
          )
        );
      }
    }
    function subtractNames(names, from) {
      for (const n in from) names[n] = (names[n] || 0) - (from[n] || 0);
    }
    function not(x) {
      return typeof x == "boolean" || typeof x == "number" || x === null
        ? !x
        : (0, code_1._)`!${par(x)}`;
    }
    exports2.not = not;
    var andCode = mappend(exports2.operators.AND);
    function and(...args) {
      return args.reduce(andCode);
    }
    exports2.and = and;
    var orCode = mappend(exports2.operators.OR);
    function or(...args) {
      return args.reduce(orCode);
    }
    exports2.or = or;
    function mappend(op) {
      return (x, y) =>
        x === code_1.nil
          ? y
          : y === code_1.nil
          ? x
          : (0, code_1._)`${par(x)} ${op} ${par(y)}`;
    }
    function par(x) {
      return x instanceof code_1.Name ? x : (0, code_1._)`(${x})`;
    }
  },
});

// node_modules/@near-js/accounts/node_modules/ajv/dist/compile/util.js
var require_util = __commonJS({
  "node_modules/@near-js/accounts/node_modules/ajv/dist/compile/util.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.checkStrictMode =
      exports2.getErrorPath =
      exports2.Type =
      exports2.useFunc =
      exports2.setEvaluated =
      exports2.evaluatedPropsToName =
      exports2.mergeEvaluated =
      exports2.eachItem =
      exports2.unescapeJsonPointer =
      exports2.escapeJsonPointer =
      exports2.escapeFragment =
      exports2.unescapeFragment =
      exports2.schemaRefOrVal =
      exports2.schemaHasRulesButRef =
      exports2.schemaHasRules =
      exports2.checkUnknownRules =
      exports2.alwaysValidSchema =
      exports2.toHash =
        void 0;
    var codegen_1 = require_codegen();
    var code_1 = require_code();
    function toHash(arr) {
      const hash = {};
      for (const item of arr) hash[item] = true;
      return hash;
    }
    exports2.toHash = toHash;
    function alwaysValidSchema(it, schema) {
      if (typeof schema == "boolean") return schema;
      if (Object.keys(schema).length === 0) return true;
      checkUnknownRules(it, schema);
      return !schemaHasRules(schema, it.self.RULES.all);
    }
    exports2.alwaysValidSchema = alwaysValidSchema;
    function checkUnknownRules(it, schema = it.schema) {
      const { opts, self: self2 } = it;
      if (!opts.strictSchema) return;
      if (typeof schema === "boolean") return;
      const rules = self2.RULES.keywords;
      for (const key in schema) {
        if (!rules[key]) checkStrictMode(it, `unknown keyword: "${key}"`);
      }
    }
    exports2.checkUnknownRules = checkUnknownRules;
    function schemaHasRules(schema, rules) {
      if (typeof schema == "boolean") return !schema;
      for (const key in schema) if (rules[key]) return true;
      return false;
    }
    exports2.schemaHasRules = schemaHasRules;
    function schemaHasRulesButRef(schema, RULES) {
      if (typeof schema == "boolean") return !schema;
      for (const key in schema)
        if (key !== "$ref" && RULES.all[key]) return true;
      return false;
    }
    exports2.schemaHasRulesButRef = schemaHasRulesButRef;
    function schemaRefOrVal(
      { topSchemaRef, schemaPath },
      schema,
      keyword,
      $data
    ) {
      if (!$data) {
        if (typeof schema == "number" || typeof schema == "boolean")
          return schema;
        if (typeof schema == "string") return (0, codegen_1._)`${schema}`;
      }
      return (0, codegen_1._)`${topSchemaRef}${schemaPath}${(0,
      codegen_1.getProperty)(keyword)}`;
    }
    exports2.schemaRefOrVal = schemaRefOrVal;
    function unescapeFragment(str) {
      return unescapeJsonPointer(decodeURIComponent(str));
    }
    exports2.unescapeFragment = unescapeFragment;
    function escapeFragment(str) {
      return encodeURIComponent(escapeJsonPointer(str));
    }
    exports2.escapeFragment = escapeFragment;
    function escapeJsonPointer(str) {
      if (typeof str == "number") return `${str}`;
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
    exports2.escapeJsonPointer = escapeJsonPointer;
    function unescapeJsonPointer(str) {
      return str.replace(/~1/g, "/").replace(/~0/g, "~");
    }
    exports2.unescapeJsonPointer = unescapeJsonPointer;
    function eachItem(xs, f) {
      if (Array.isArray(xs)) {
        for (const x of xs) f(x);
      } else {
        f(xs);
      }
    }
    exports2.eachItem = eachItem;
    function makeMergeEvaluated({
      mergeNames,
      mergeToName,
      mergeValues,
      resultToName,
    }) {
      return (gen, from, to, toName) => {
        const res =
          to === void 0
            ? from
            : to instanceof codegen_1.Name
            ? (from instanceof codegen_1.Name
                ? mergeNames(gen, from, to)
                : mergeToName(gen, from, to),
              to)
            : from instanceof codegen_1.Name
            ? (mergeToName(gen, to, from), from)
            : mergeValues(from, to);
        return toName === codegen_1.Name && !(res instanceof codegen_1.Name)
          ? resultToName(gen, res)
          : res;
      };
    }
    exports2.mergeEvaluated = {
      props: makeMergeEvaluated({
        mergeNames: (gen, from, to) =>
          gen.if(
            (0, codegen_1._)`${to} !== true && ${from} !== undefined`,
            () => {
              gen.if(
                (0, codegen_1._)`${from} === true`,
                () => gen.assign(to, true),
                () =>
                  gen
                    .assign(to, (0, codegen_1._)`${to} || {}`)
                    .code((0, codegen_1._)`Object.assign(${to}, ${from})`)
              );
            }
          ),
        mergeToName: (gen, from, to) =>
          gen.if((0, codegen_1._)`${to} !== true`, () => {
            if (from === true) {
              gen.assign(to, true);
            } else {
              gen.assign(to, (0, codegen_1._)`${to} || {}`);
              setEvaluated(gen, to, from);
            }
          }),
        mergeValues: (from, to) => (from === true ? true : { ...from, ...to }),
        resultToName: evaluatedPropsToName,
      }),
      items: makeMergeEvaluated({
        mergeNames: (gen, from, to) =>
          gen.if(
            (0, codegen_1._)`${to} !== true && ${from} !== undefined`,
            () =>
              gen.assign(
                to,
                (0,
                codegen_1._)`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`
              )
          ),
        mergeToName: (gen, from, to) =>
          gen.if((0, codegen_1._)`${to} !== true`, () =>
            gen.assign(
              to,
              from === true
                ? true
                : (0, codegen_1._)`${to} > ${from} ? ${to} : ${from}`
            )
          ),
        mergeValues: (from, to) => (from === true ? true : Math.max(from, to)),
        resultToName: (gen, items) => gen.var("items", items),
      }),
    };
    function evaluatedPropsToName(gen, ps) {
      if (ps === true) return gen.var("props", true);
      const props = gen.var("props", (0, codegen_1._)`{}`);
      if (ps !== void 0) setEvaluated(gen, props, ps);
      return props;
    }
    exports2.evaluatedPropsToName = evaluatedPropsToName;
    function setEvaluated(gen, props, ps) {
      Object.keys(ps).forEach((p) =>
        gen.assign(
          (0, codegen_1._)`${props}${(0, codegen_1.getProperty)(p)}`,
          true
        )
      );
    }
    exports2.setEvaluated = setEvaluated;
    var snippets = {};
    function useFunc(gen, f) {
      return gen.scopeValue("func", {
        ref: f,
        code: snippets[f.code] || (snippets[f.code] = new code_1._Code(f.code)),
      });
    }
    exports2.useFunc = useFunc;
    var Type;
    (function (Type2) {
      Type2[(Type2["Num"] = 0)] = "Num";
      Type2[(Type2["Str"] = 1)] = "Str";
    })((Type = exports2.Type || (exports2.Type = {})));
    function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
      if (dataProp instanceof codegen_1.Name) {
        const isNumber = dataPropType === Type.Num;
        return jsPropertySyntax
          ? isNumber
            ? (0, codegen_1._)`"[" + ${dataProp} + "]"`
            : (0, codegen_1._)`"['" + ${dataProp} + "']"`
          : isNumber
          ? (0, codegen_1._)`"/" + ${dataProp}`
          : (0,
            codegen_1._)`"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
      }
      return jsPropertySyntax
        ? (0, codegen_1.getProperty)(dataProp).toString()
        : "/" + escapeJsonPointer(dataProp);
    }
    exports2.getErrorPath = getErrorPath;
    function checkStrictMode(it, msg, mode = it.opts.strictSchema) {
      if (!mode) return;
      msg = `strict mode: ${msg}`;
      if (mode === true) throw new Error(msg);
      it.self.logger.warn(msg);
    }
    exports2.checkStrictMode = checkStrictMode;
  },
});

// node_modules/@near-js/accounts/node_modules/ajv/dist/compile/names.js
var require_names = __commonJS({
  "node_modules/@near-js/accounts/node_modules/ajv/dist/compile/names.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var names = {
      // validation function arguments
      data: new codegen_1.Name("data"),
      // args passed from referencing schema
      valCxt: new codegen_1.Name("valCxt"),
      instancePath: new codegen_1.Name("instancePath"),
      parentData: new codegen_1.Name("parentData"),
      parentDataProperty: new codegen_1.Name("parentDataProperty"),
      rootData: new codegen_1.Name("rootData"),
      dynamicAnchors: new codegen_1.Name("dynamicAnchors"),
      // function scoped variables
      vErrors: new codegen_1.Name("vErrors"),
      errors: new codegen_1.Name("errors"),
      this: new codegen_1.Name("this"),
      // "globals"
      self: new codegen_1.Name("self"),
      scope: new codegen_1.Name("scope"),
      // JTD serialize/parse name for JSON string and position
      json: new codegen_1.Name("json"),
      jsonPos: new codegen_1.Name("jsonPos"),
      jsonLen: new codegen_1.Name("jsonLen"),
      jsonPart: new codegen_1.Name("jsonPart"),
    };
    exports2.default = names;
  },
});

// node_modules/@near-js/accounts/node_modules/ajv/dist/compile/errors.js
var require_errors4 = __commonJS({
  "node_modules/@near-js/accounts/node_modules/ajv/dist/compile/errors.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.extendErrors =
      exports2.resetErrorsCount =
      exports2.reportExtraError =
      exports2.reportError =
      exports2.keyword$DataError =
      exports2.keywordError =
        void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var names_1 = require_names();
    exports2.keywordError = {
      message: ({ keyword }) =>
        (0, codegen_1.str)`must pass "${keyword}" keyword validation`,
    };
    exports2.keyword$DataError = {
      message: ({ keyword, schemaType }) =>
        schemaType
          ? (0,
            codegen_1.str)`"${keyword}" keyword must be ${schemaType} ($data)`
          : (0, codegen_1.str)`"${keyword}" keyword is invalid ($data)`,
    };
    function reportError(
      cxt,
      error = exports2.keywordError,
      errorPaths,
      overrideAllErrors
    ) {
      const { it } = cxt;
      const { gen, compositeRule, allErrors } = it;
      const errObj = errorObjectCode(cxt, error, errorPaths);
      if (
        overrideAllErrors !== null && overrideAllErrors !== void 0
          ? overrideAllErrors
          : compositeRule || allErrors
      ) {
        addError(gen, errObj);
      } else {
        returnErrors(it, (0, codegen_1._)`[${errObj}]`);
      }
    }
    exports2.reportError = reportError;
    function reportExtraError(cxt, error = exports2.keywordError, errorPaths) {
      const { it } = cxt;
      const { gen, compositeRule, allErrors } = it;
      const errObj = errorObjectCode(cxt, error, errorPaths);
      addError(gen, errObj);
      if (!(compositeRule || allErrors)) {
        returnErrors(it, names_1.default.vErrors);
      }
    }
    exports2.reportExtraError = reportExtraError;
    function resetErrorsCount(gen, errsCount) {
      gen.assign(names_1.default.errors, errsCount);
      gen.if((0, codegen_1._)`${names_1.default.vErrors} !== null`, () =>
        gen.if(
          errsCount,
          () =>
            gen.assign(
              (0, codegen_1._)`${names_1.default.vErrors}.length`,
              errsCount
            ),
          () => gen.assign(names_1.default.vErrors, null)
        )
      );
    }
    exports2.resetErrorsCount = resetErrorsCount;
    function extendErrors({ gen, keyword, schemaValue, data, errsCount, it }) {
      if (errsCount === void 0) throw new Error("ajv implementation error");
      const err = gen.name("err");
      gen.forRange("i", errsCount, names_1.default.errors, (i) => {
        gen.const(err, (0, codegen_1._)`${names_1.default.vErrors}[${i}]`);
        gen.if((0, codegen_1._)`${err}.instancePath === undefined`, () =>
          gen.assign(
            (0, codegen_1._)`${err}.instancePath`,
            (0, codegen_1.strConcat)(names_1.default.instancePath, it.errorPath)
          )
        );
        gen.assign(
          (0, codegen_1._)`${err}.schemaPath`,
          (0, codegen_1.str)`${it.errSchemaPath}/${keyword}`
        );
        if (it.opts.verbose) {
          gen.assign((0, codegen_1._)`${err}.schema`, schemaValue);
          gen.assign((0, codegen_1._)`${err}.data`, data);
        }
      });
    }
    exports2.extendErrors = extendErrors;
    function addError(gen, errObj) {
      const err = gen.const("err", errObj);
      gen.if(
        (0, codegen_1._)`${names_1.default.vErrors} === null`,
        () => gen.assign(names_1.default.vErrors, (0, codegen_1._)`[${err}]`),
        (0, codegen_1._)`${names_1.default.vErrors}.push(${err})`
      );
      gen.code((0, codegen_1._)`${names_1.default.errors}++`);
    }
    function returnErrors(it, errs) {
      const { gen, validateName, schemaEnv } = it;
      if (schemaEnv.$async) {
        gen.throw((0, codegen_1._)`new ${it.ValidationError}(${errs})`);
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, errs);
        gen.return(false);
      }
    }
    var E = {
      keyword: new codegen_1.Name("keyword"),
      schemaPath: new codegen_1.Name("schemaPath"),
      params: new codegen_1.Name("params"),
      propertyName: new codegen_1.Name("propertyName"),
      message: new codegen_1.Name("message"),
      schema: new codegen_1.Name("schema"),
      parentSchema: new codegen_1.Name("parentSchema"),
    };
    function errorObjectCode(cxt, error, errorPaths) {
      const { createErrors } = cxt.it;
      if (createErrors === false) return (0, codegen_1._)`{}`;
      return errorObject(cxt, error, errorPaths);
    }
    function errorObject(cxt, error, errorPaths = {}) {
      const { gen, it } = cxt;
      const keyValues = [
        errorInstancePath(it, errorPaths),
        errorSchemaPath(cxt, errorPaths),
      ];
      extraErrorProps(cxt, error, keyValues);
      return gen.object(...keyValues);
    }
    function errorInstancePath({ errorPath }, { instancePath }) {
      const instPath = instancePath
        ? (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(
            instancePath,
            util_1.Type.Str
          )}`
        : errorPath;
      return [
        names_1.default.instancePath,
        (0, codegen_1.strConcat)(names_1.default.instancePath, instPath),
      ];
    }
    function errorSchemaPath(
      { keyword, it: { errSchemaPath } },
      { schemaPath, parentSchema }
    ) {
      let schPath = parentSchema
        ? errSchemaPath
        : (0, codegen_1.str)`${errSchemaPath}/${keyword}`;
      if (schemaPath) {
        schPath = (0, codegen_1.str)`${schPath}${(0, util_1.getErrorPath)(
          schemaPath,
          util_1.Type.Str
        )}`;
      }
      return [E.schemaPath, schPath];
    }
    function extraErrorProps(cxt, { params, message }, keyValues) {
      const { keyword, data, schemaValue, it } = cxt;
      const { opts, propertyName, topSchemaRef, schemaPath } = it;
      keyValues.push(
        [E.keyword, keyword],
        [
          E.params,
          typeof params == "function"
            ? params(cxt)
            : params || (0, codegen_1._)`{}`,
        ]
      );
      if (opts.messages) {
        keyValues.push([
          E.message,
          typeof message == "function" ? message(cxt) : message,
        ]);
      }
      if (opts.verbose) {
        keyValues.push(
          [E.schema, schemaValue],
          [E.parentSchema, (0, codegen_1._)`${topSchemaRef}${schemaPath}`],
          [names_1.default.data, data]
        );
      }
      if (propertyName) keyValues.push([E.propertyName, propertyName]);
    }
  },
});

// node_modules/@near-js/accounts/node_modules/ajv/dist/compile/validate/boolSchema.js
var require_boolSchema = __commonJS({
  "node_modules/@near-js/accounts/node_modules/ajv/dist/compile/validate/boolSchema.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.boolOrEmptySchema = exports2.topBoolOrEmptySchema = void 0;
    var errors_1 = require_errors4();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var boolError = {
      message: "boolean schema is false",
    };
    function topBoolOrEmptySchema(it) {
      const { gen, schema, validateName } = it;
      if (schema === false) {
        falseSchemaError(it, false);
      } else if (typeof schema == "object" && schema.$async === true) {
        gen.return(names_1.default.data);
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, null);
        gen.return(true);
      }
    }
    exports2.topBoolOrEmptySchema = topBoolOrEmptySchema;
    function boolOrEmptySchema(it, valid) {
      const { gen, schema } = it;
      if (schema === false) {
        gen.var(valid, false);
        falseSchemaError(it);
      } else {
        gen.var(valid, true);
      }
    }
    exports2.boolOrEmptySchema = boolOrEmptySchema;
    function falseSchemaError(it, overrideAllErrors) {
      const { gen, data } = it;
      const cxt = {
        gen,
        keyword: "false schema",
        data,
        schema: false,
        schemaCode: false,
        schemaValue: false,
        params: {},
        it,
      };
      (0, errors_1.reportError)(cxt, boolError, void 0, overrideAllErrors);
    }
  },
});

// node_modules/@near-js/accounts/node_modules/ajv/dist/compile/rules.js
var require_rules = __commonJS({
  "node_modules/@near-js/accounts/node_modules/ajv/dist/compile/rules.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getRules = exports2.isJSONType = void 0;
    var _jsonTypes = [
      "string",
      "number",
      "integer",
      "boolean",
      "null",
      "object",
      "array",
    ];
    var jsonTypes = new Set(_jsonTypes);
    function isJSONType(x) {
      return typeof x == "string" && jsonTypes.has(x);
    }
    exports2.isJSONType = isJSONType;
    function getRules() {
      const groups = {
        number: { type: "number", rules: [] },
        string: { type: "string", rules: [] },
        array: { type: "array", rules: [] },
        object: { type: "object", rules: [] },
      };
      return {
        types: { ...groups, integer: true, boolean: true, null: true },
        rules: [
          { rules: [] },
          groups.number,
          groups.string,
          groups.array,
          groups.object,
        ],
        post: { rules: [] },
        all: {},
        keywords: {},
      };
    }
    exports2.getRules = getRules;
  },
});

// node_modules/@near-js/accounts/node_modules/ajv/dist/compile/validate/applicability.js
var require_applicability = __commonJS({
  "node_modules/@near-js/accounts/node_modules/ajv/dist/compile/validate/applicability.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.shouldUseRule =
      exports2.shouldUseGroup =
      exports2.schemaHasRulesForType =
        void 0;
    function schemaHasRulesForType({ schema, self: self2 }, type) {
      const group = self2.RULES.types[type];
      return group && group !== true && shouldUseGroup(schema, group);
    }
    exports2.schemaHasRulesForType = schemaHasRulesForType;
    function shouldUseGroup(schema, group) {
      return group.rules.some((rule) => shouldUseRule(schema, rule));
    }
    exports2.shouldUseGroup = shouldUseGroup;
    function shouldUseRule(schema, rule) {
      var _a;
      return (
        schema[rule.keyword] !== void 0 ||
        ((_a = rule.definition.implements) === null || _a === void 0
          ? void 0
          : _a.some((kwd) => schema[kwd] !== void 0))
      );
    }
    exports2.shouldUseRule = shouldUseRule;
  },
});

// node_modules/@near-js/accounts/node_modules/ajv/dist/compile/validate/dataType.js
var require_dataType = __commonJS({
  "node_modules/@near-js/accounts/node_modules/ajv/dist/compile/validate/dataType.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.reportTypeError =
      exports2.checkDataTypes =
      exports2.checkDataType =
      exports2.coerceAndCheckDataType =
      exports2.getJSONTypes =
      exports2.getSchemaTypes =
      exports2.DataType =
        void 0;
    var rules_1 = require_rules();
    var applicability_1 = require_applicability();
    var errors_1 = require_errors4();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var DataType;
    (function (DataType2) {
      DataType2[(DataType2["Correct"] = 0)] = "Correct";
      DataType2[(DataType2["Wrong"] = 1)] = "Wrong";
    })((DataType = exports2.DataType || (exports2.DataType = {})));
    function getSchemaTypes(schema) {
      const types = getJSONTypes(schema.type);
      const hasNull = types.includes("null");
      if (hasNull) {
        if (schema.nullable === false)
          throw new Error("type: null contradicts nullable: false");
      } else {
        if (!types.length && schema.nullable !== void 0) {
          throw new Error('"nullable" cannot be used without "type"');
        }
        if (schema.nullable === true) types.push("null");
      }
      return types;
    }
    exports2.getSchemaTypes = getSchemaTypes;
    function getJSONTypes(ts) {
      const types = Array.isArray(ts) ? ts : ts ? [ts] : [];
      if (types.every(rules_1.isJSONType)) return types;
      throw new Error(
        "type must be JSONType or JSONType[]: " + types.join(",")
      );
    }
    exports2.getJSONTypes = getJSONTypes;
    function coerceAndCheckDataType(it, types) {
      const { gen, data, opts } = it;
      const coerceTo = coerceToTypes(types, opts.coerceTypes);
      const checkTypes =
        types.length > 0 &&
        !(
          coerceTo.length === 0 &&
          types.length === 1 &&
          (0, applicability_1.schemaHasRulesForType)(it, types[0])
        );
      if (checkTypes) {
        const wrongType = checkDataTypes(
          types,
          data,
          opts.strictNumbers,
          DataType.Wrong
        );
        gen.if(wrongType, () => {
          if (coerceTo.length) coerceData(it, types, coerceTo);
          else reportTypeError(it);
        });
      }
      return checkTypes;
    }
    exports2.coerceAndCheckDataType = coerceAndCheckDataType;
    var COERCIBLE = /* @__PURE__ */ new Set([
      "string",
      "number",
      "integer",
      "boolean",
      "null",
    ]);
    function coerceToTypes(types, coerceTypes) {
      return coerceTypes
        ? types.filter(
            (t) =>
              COERCIBLE.has(t) || (coerceTypes === "array" && t === "array")
          )
        : [];
    }
    function coerceData(it, types, coerceTo) {
      const { gen, data, opts } = it;
      const dataType = gen.let("dataType", (0, codegen_1._)`typeof ${data}`);
      const coerced = gen.let("coerced", (0, codegen_1._)`undefined`);
      if (opts.coerceTypes === "array") {
        gen.if(
          (0,
          codegen_1._)`${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`,
          () =>
            gen
              .assign(data, (0, codegen_1._)`${data}[0]`)
              .assign(dataType, (0, codegen_1._)`typeof ${data}`)
              .if(checkDataTypes(types, data, opts.strictNumbers), () =>
                gen.assign(coerced, data)
              )
        );
      }
      gen.if((0, codegen_1._)`${coerced} !== undefined`);
      for (const t of coerceTo) {
        if (
          COERCIBLE.has(t) ||
          (t === "array" && opts.coerceTypes === "array")
        ) {
          coerceSpecificType(t);
        }
      }
      gen.else();
      reportTypeError(it);
      gen.endIf();
      gen.if((0, codegen_1._)`${coerced} !== undefined`, () => {
        gen.assign(data, coerced);
        assignParentData(it, coerced);
      });
      function coerceSpecificType(t) {
        switch (t) {
          case "string":
            gen
              .elseIf(
                (0,
                codegen_1._)`${dataType} == "number" || ${dataType} == "boolean"`
              )
              .assign(coerced, (0, codegen_1._)`"" + ${data}`)
              .elseIf((0, codegen_1._)`${data} === null`)
              .assign(coerced, (0, codegen_1._)`""`);
            return;
          case "number":
            gen
              .elseIf(
                (0, codegen_1._)`${dataType} == "boolean" || ${data} === null
              || (${dataType} == "string" && ${data} && ${data} == +${data})`
              )
              .assign(coerced, (0, codegen_1._)`+${data}`);
            return;
          case "integer":
            gen
              .elseIf(
                (0, codegen_1._)`${dataType} === "boolean" || ${data} === null
              || (${dataType} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`
              )
              .assign(coerced, (0, codegen_1._)`+${data}`);
            return;
          case "boolean":
            gen
              .elseIf(
                (0,
                codegen_1._)`${data} === "false" || ${data} === 0 || ${data} === null`
              )
              .assign(coerced, false)
              .elseIf((0, codegen_1._)`${data} === "true" || ${data} === 1`)
              .assign(coerced, true);
            return;
          case "null":
            gen.elseIf(
              (0,
              codegen_1._)`${data} === "" || ${data} === 0 || ${data} === false`
            );
            gen.assign(coerced, null);
            return;
          case "array":
            gen
              .elseIf(
                (0,
                codegen_1._)`${dataType} === "string" || ${dataType} === "number"
              || ${dataType} === "boolean" || ${data} === null`
              )
              .assign(coerced, (0, codegen_1._)`[${data}]`);
        }
      }
    }
    function assignParentData({ gen, parentData, parentDataProperty }, expr) {
      gen.if((0, codegen_1._)`${parentData} !== undefined`, () =>
        gen.assign((0, codegen_1._)`${parentData}[${parentDataProperty}]`, expr)
      );
    }
    function checkDataType(
      dataType,
      data,
      strictNums,
      correct = DataType.Correct
    ) {
      const EQ =
        correct === DataType.Correct
          ? codegen_1.operators.EQ
          : codegen_1.operators.NEQ;
      let cond;
      switch (dataType) {
        case "null":
          return (0, codegen_1._)`${data} ${EQ} null`;
        case "array":
          cond = (0, codegen_1._)`Array.isArray(${data})`;
          break;
        case "object":
          cond = (0,
          codegen_1._)`${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
          break;
        case "integer":
          cond = numCond((0, codegen_1._)`!(${data} % 1) && !isNaN(${data})`);
          break;
        case "number":
          cond = numCond();
          break;
        default:
          return (0, codegen_1._)`typeof ${data} ${EQ} ${dataType}`;
      }
      return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);
      function numCond(_cond = codegen_1.nil) {
        return (0, codegen_1.and)(
          (0, codegen_1._)`typeof ${data} == "number"`,
          _cond,
          strictNums ? (0, codegen_1._)`isFinite(${data})` : codegen_1.nil
        );
      }
    }
    exports2.checkDataType = checkDataType;
    function checkDataTypes(dataTypes, data, strictNums, correct) {
      if (dataTypes.length === 1) {
        return checkDataType(dataTypes[0], data, strictNums, correct);
      }
      let cond;
      const types = (0, util_1.toHash)(dataTypes);
      if (types.array && types.object) {
        const notObj = (0, codegen_1._)`typeof ${data} != "object"`;
        cond = types.null ? notObj : (0, codegen_1._)`!${data} || ${notObj}`;
        delete types.null;
        delete types.array;
        delete types.object;
      } else {
        cond = codegen_1.nil;
      }
      if (types.number) delete types.integer;
      for (const t in types)
        cond = (0, codegen_1.and)(
          cond,
          checkDataType(t, data, strictNums, correct)
        );
      return cond;
    }
    exports2.checkDataTypes = checkDataTypes;
    var typeError = {
      message: ({ schema }) => `must be ${schema}`,
      params: ({ schema, schemaValue }) =>
        typeof schema == "string"
          ? (0, codegen_1._)`{type: ${schema}}`
          : (0, codegen_1._)`{type: ${schemaValue}}`,
    };
    function reportTypeError(it) {
      const cxt = getTypeErrorContext(it);
      (0, errors_1.reportError)(cxt, typeError);
    }
    exports2.reportTypeError = reportTypeError;
    function getTypeErrorContext(it) {
      const { gen, data, schema } = it;
      const schemaCode = (0, util_1.schemaRefOrVal)(it, schema, "type");
      return {
        gen,
        keyword: "type",
        data,
        schema: schema.type,
        schemaCode,
        schemaValue: schemaCode,
        parentSchema: schema,
        params: {},
        it,
      };
    }
  },
});

// node_modules/@near-js/accounts/node_modules/ajv/dist/compile/validate/defaults.js
var require_defaults = __commonJS({
  "node_modules/@near-js/accounts/node_modules/ajv/dist/compile/validate/defaults.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.assignDefaults = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    function assignDefaults(it, ty) {
      const { properties, items } = it.schema;
      if (ty === "object" && properties) {
        for (const key in properties) {
          assignDefault(it, key, properties[key].default);
        }
      } else if (ty === "array" && Array.isArray(items)) {
        items.forEach((sch, i) => assignDefault(it, i, sch.default));
      }
    }
    exports2.assignDefaults = assignDefaults;
    function assignDefault(it, prop, defaultValue) {
      const { gen, compositeRule, data, opts } = it;
      if (defaultValue === void 0) return;
      const childData = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(
        prop
      )}`;
      if (compositeRule) {
        (0, util_1.checkStrictMode)(it, `default is ignored for: ${childData}`);
        return;
      }
      let condition = (0, codegen_1._)`${childData} === undefined`;
      if (opts.useDefaults === "empty") {
        condition = (0,
        codegen_1._)`${condition} || ${childData} === null || ${childData} === ""`;
      }
      gen.if(
        condition,
        (0, codegen_1._)`${childData} = ${(0, codegen_1.stringify)(
          defaultValue
        )}`
      );
    }
  },
});

// node_modules/@near-js/accounts/node_modules/ajv/dist/vocabularies/code.js
var require_code2 = __commonJS({
  "node_modules/@near-js/accounts/node_modules/ajv/dist/vocabularies/code.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateUnion =
      exports2.validateArray =
      exports2.usePattern =
      exports2.callValidateCode =
      exports2.schemaProperties =
      exports2.allSchemaProperties =
      exports2.noPropertyInData =
      exports2.propertyInData =
      exports2.isOwnProperty =
      exports2.hasPropFunc =
      exports2.reportMissingProp =
      exports2.checkMissingProp =
      exports2.checkReportMissingProp =
        void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var names_1 = require_names();
    var util_2 = require_util();
    function checkReportMissingProp(cxt, prop) {
      const { gen, data, it } = cxt;
      gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {
        cxt.setParams({ missingProperty: (0, codegen_1._)`${prop}` }, true);
        cxt.error();
      });
    }
    exports2.checkReportMissingProp = checkReportMissingProp;
    function checkMissingProp(
      { gen, data, it: { opts } },
      properties,
      missing
    ) {
      return (0, codegen_1.or)(
        ...properties.map((prop) =>
          (0, codegen_1.and)(
            noPropertyInData(gen, data, prop, opts.ownProperties),
            (0, codegen_1._)`${missing} = ${prop}`
          )
        )
      );
    }
    exports2.checkMissingProp = checkMissingProp;
    function reportMissingProp(cxt, missing) {
      cxt.setParams({ missingProperty: missing }, true);
      cxt.error();
    }
    exports2.reportMissingProp = reportMissingProp;
    function hasPropFunc(gen) {
      return gen.scopeValue("func", {
        // eslint-disable-next-line @typescript-eslint/unbound-method
        ref: Object.prototype.hasOwnProperty,
        code: (0, codegen_1._)`Object.prototype.hasOwnProperty`,
      });
    }
    exports2.hasPropFunc = hasPropFunc;
    function isOwnProperty(gen, data, property) {
      return (0, codegen_1._)`${hasPropFunc(gen)}.call(${data}, ${property})`;
    }
    exports2.isOwnProperty = isOwnProperty;
    function propertyInData(gen, data, property, ownProperties) {
      const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(
        property
      )} !== undefined`;
      return ownProperties
        ? (0, codegen_1._)`${cond} && ${isOwnProperty(gen, data, property)}`
        : cond;
    }
    exports2.propertyInData = propertyInData;
    function noPropertyInData(gen, data, property, ownProperties) {
      const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(
        property
      )} === undefined`;
      return ownProperties
        ? (0, codegen_1.or)(
            cond,
            (0, codegen_1.not)(isOwnProperty(gen, data, property))
          )
        : cond;
    }
    exports2.noPropertyInData = noPropertyInData;
    function allSchemaProperties(schemaMap) {
      return schemaMap
        ? Object.keys(schemaMap).filter((p) => p !== "__proto__")
        : [];
    }
    exports2.allSchemaProperties = allSchemaProperties;
    function schemaProperties(it, schemaMap) {
      return allSchemaProperties(schemaMap).filter(
        (p) => !(0, util_1.alwaysValidSchema)(it, schemaMap[p])
      );
    }
    exports2.schemaProperties = schemaProperties;
    function callValidateCode(
      {
        schemaCode,
        data,
        it: { gen, topSchemaRef, schemaPath, errorPath },
        it,
      },
      func,
      context,
      passSchema
    ) {
      const dataAndSchema = passSchema
        ? (0, codegen_1._)`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}`
        : data;
      const valCxt = [
        [
          names_1.default.instancePath,
          (0, codegen_1.strConcat)(names_1.default.instancePath, errorPath),
        ],
        [names_1.default.parentData, it.parentData],
        [names_1.default.parentDataProperty, it.parentDataProperty],
        [names_1.default.rootData, names_1.default.rootData],
      ];
      if (it.opts.dynamicRef)
        valCxt.push([
          names_1.default.dynamicAnchors,
          names_1.default.dynamicAnchors,
        ]);
      const args = (0, codegen_1._)`${dataAndSchema}, ${gen.object(...valCxt)}`;
      return context !== codegen_1.nil
        ? (0, codegen_1._)`${func}.call(${context}, ${args})`
        : (0, codegen_1._)`${func}(${args})`;
    }
    exports2.callValidateCode = callValidateCode;
    var newRegExp = (0, codegen_1._)`new RegExp`;
    function usePattern({ gen, it: { opts } }, pattern) {
      const u = opts.unicodeRegExp ? "u" : "";
      const { regExp } = opts.code;
      const rx = regExp(pattern, u);
      return gen.scopeValue("pattern", {
        key: rx.toString(),
        ref: rx,
        code: (0, codegen_1._)`${
          regExp.code === "new RegExp"
            ? newRegExp
            : (0, util_2.useFunc)(gen, regExp)
        }(${pattern}, ${u})`,
      });
    }
    exports2.usePattern = usePattern;
    function validateArray(cxt) {
      const { gen, data, keyword, it } = cxt;
      const valid = gen.name("valid");
      if (it.allErrors) {
        const validArr = gen.let("valid", true);
        validateItems(() => gen.assign(validArr, false));
        return validArr;
      }
      gen.var(valid, true);
      validateItems(() => gen.break());
      return valid;
      function validateItems(notValid) {
        const len = gen.const("len", (0, codegen_1._)`${data}.length`);
        gen.forRange("i", 0, len, (i) => {
          cxt.subschema(
            {
              keyword,
              dataProp: i,
              dataPropType: util_1.Type.Num,
            },
            valid
          );
          gen.if((0, codegen_1.not)(valid), notValid);
        });
      }
    }
    exports2.validateArray = validateArray;
    function validateUnion(cxt) {
      const { gen, schema, keyword, it } = cxt;
      if (!Array.isArray(schema)) throw new Error("ajv implementation error");
      const alwaysValid = schema.some((sch) =>
        (0, util_1.alwaysValidSchema)(it, sch)
      );
      if (alwaysValid && !it.opts.unevaluated) return;
      const valid = gen.let("valid", false);
      const schValid = gen.name("_valid");
      gen.block(() =>
        schema.forEach((_sch, i) => {
          const schCxt = cxt.subschema(
            {
              keyword,
              schemaProp: i,
              compositeRule: true,
            },
            schValid
          );
          gen.assign(valid, (0, codegen_1._)`${valid} || ${schValid}`);
          const merged = cxt.mergeValidEvaluated(schCxt, schValid);
          if (!merged) gen.if((0, codegen_1.not)(valid));
        })
      );
      cxt.result(
        valid,
        () => cxt.reset(),
        () => cxt.error(true)
      );
    }
    exports2.validateUnion = validateUnion;
  },
});

// node_modules/@near-js/accounts/node_modules/ajv/dist/compile/validate/keyword.js
var require_keyword = __commonJS({
  "node_modules/@near-js/accounts/node_modules/ajv/dist/compile/validate/keyword.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateKeywordUsage =
      exports2.validSchemaType =
      exports2.funcKeywordCode =
      exports2.macroKeywordCode =
        void 0;
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var code_1 = require_code2();
    var errors_1 = require_errors4();
    function macroKeywordCode(cxt, def) {
      const { gen, keyword, schema, parentSchema, it } = cxt;
      const macroSchema = def.macro.call(it.self, schema, parentSchema, it);
      const schemaRef = useKeyword(gen, keyword, macroSchema);
      if (it.opts.validateSchema !== false)
        it.self.validateSchema(macroSchema, true);
      const valid = gen.name("valid");
      cxt.subschema(
        {
          schema: macroSchema,
          schemaPath: codegen_1.nil,
          errSchemaPath: `${it.errSchemaPath}/${keyword}`,
          topSchemaRef: schemaRef,
          compositeRule: true,
        },
        valid
      );
      cxt.pass(valid, () => cxt.error(true));
    }
    exports2.macroKeywordCode = macroKeywordCode;
    function funcKeywordCode(cxt, def) {
      var _a;
      const { gen, keyword, schema, parentSchema, $data, it } = cxt;
      checkAsyncKeyword(it, def);
      const validate =
        !$data && def.compile
          ? def.compile.call(it.self, schema, parentSchema, it)
          : def.validate;
      const validateRef = useKeyword(gen, keyword, validate);
      const valid = gen.let("valid");
      cxt.block$data(valid, validateKeyword);
      cxt.ok((_a = def.valid) !== null && _a !== void 0 ? _a : valid);
      function validateKeyword() {
        if (def.errors === false) {
          assignValid();
          if (def.modifying) modifyData(cxt);
          reportErrs(() => cxt.error());
        } else {
          const ruleErrs = def.async ? validateAsync() : validateSync();
          if (def.modifying) modifyData(cxt);
          reportErrs(() => addErrs(cxt, ruleErrs));
        }
      }
      function validateAsync() {
        const ruleErrs = gen.let("ruleErrs", null);
        gen.try(
          () => assignValid((0, codegen_1._)`await `),
          (e) =>
            gen.assign(valid, false).if(
              (0, codegen_1._)`${e} instanceof ${it.ValidationError}`,
              () => gen.assign(ruleErrs, (0, codegen_1._)`${e}.errors`),
              () => gen.throw(e)
            )
        );
        return ruleErrs;
      }
      function validateSync() {
        const validateErrs = (0, codegen_1._)`${validateRef}.errors`;
        gen.assign(validateErrs, null);
        assignValid(codegen_1.nil);
        return validateErrs;
      }
      function assignValid(
        _await = def.async ? (0, codegen_1._)`await ` : codegen_1.nil
      ) {
        const passCxt = it.opts.passContext
          ? names_1.default.this
          : names_1.default.self;
        const passSchema = !(
          ("compile" in def && !$data) ||
          def.schema === false
        );
        gen.assign(
          valid,
          (0, codegen_1._)`${_await}${(0, code_1.callValidateCode)(
            cxt,
            validateRef,
            passCxt,
            passSchema
          )}`,
          def.modifying
        );
      }
      function reportErrs(errors) {
        var _a2;
        gen.if(
          (0, codegen_1.not)(
            (_a2 = def.valid) !== null && _a2 !== void 0 ? _a2 : valid
          ),
          errors
        );
      }
    }
    exports2.funcKeywordCode = funcKeywordCode;
    function modifyData(cxt) {
      const { gen, data, it } = cxt;
      gen.if(it.parentData, () =>
        gen.assign(
          data,
          (0, codegen_1._)`${it.parentData}[${it.parentDataProperty}]`
        )
      );
    }
    function addErrs(cxt, errs) {
      const { gen } = cxt;
      gen.if(
        (0, codegen_1._)`Array.isArray(${errs})`,
        () => {
          gen
            .assign(
              names_1.default.vErrors,
              (0,
              codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`
            )
            .assign(
              names_1.default.errors,
              (0, codegen_1._)`${names_1.default.vErrors}.length`
            );
          (0, errors_1.extendErrors)(cxt);
        },
        () => cxt.error()
      );
    }
    function checkAsyncKeyword({ schemaEnv }, def) {
      if (def.async && !schemaEnv.$async)
        throw new Error("async keyword in sync schema");
    }
    function useKeyword(gen, keyword, result) {
      if (result === void 0)
        throw new Error(`keyword "${keyword}" failed to compile`);
      return gen.scopeValue(
        "keyword",
        typeof result == "function"
          ? { ref: result }
          : { ref: result, code: (0, codegen_1.stringify)(result) }
      );
    }
    function validSchemaType(schema, schemaType, allowUndefined = false) {
      return (
        !schemaType.length ||
        schemaType.some((st) =>
          st === "array"
            ? Array.isArray(schema)
            : st === "object"
            ? schema && typeof schema == "object" && !Array.isArray(schema)
            : typeof schema == st ||
              (allowUndefined && typeof schema == "undefined")
        )
      );
    }
    exports2.validSchemaType = validSchemaType;
    function validateKeywordUsage(
      { schema, opts, self: self2, errSchemaPath },
      def,
      keyword
    ) {
      if (
        Array.isArray(def.keyword)
          ? !def.keyword.includes(keyword)
          : def.keyword !== keyword
      ) {
        throw new Error("ajv implementation error");
      }
      const deps = def.dependencies;
      if (
        deps === null || deps === void 0
          ? void 0
          : deps.some(
              (kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd)
            )
      ) {
        throw new Error(
          `parent schema must have dependencies of ${keyword}: ${deps.join(
            ","
          )}`
        );
      }
      if (def.validateSchema) {
        const valid = def.validateSchema(schema[keyword]);
        if (!valid) {
          const msg =
            `keyword "${keyword}" value is invalid at path "${errSchemaPath}": ` +
            self2.errorsText(def.validateSchema.errors);
          if (opts.validateSchema === "log") self2.logger.error(msg);
          else throw new Error(msg);
        }
      }
    }
    exports2.validateKeywordUsage = validateKeywordUsage;
  },
});

// node_modules/@near-js/accounts/node_modules/ajv/dist/compile/validate/subschema.js
var require_subschema = __commonJS({
  "node_modules/@near-js/accounts/node_modules/ajv/dist/compile/validate/subschema.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.extendSubschemaMode =
      exports2.extendSubschemaData =
      exports2.getSubschema =
        void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    function getSubschema(
      it,
      { keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }
    ) {
      if (keyword !== void 0 && schema !== void 0) {
        throw new Error('both "keyword" and "schema" passed, only one allowed');
      }
      if (keyword !== void 0) {
        const sch = it.schema[keyword];
        return schemaProp === void 0
          ? {
              schema: sch,
              schemaPath: (0, codegen_1._)`${it.schemaPath}${(0,
              codegen_1.getProperty)(keyword)}`,
              errSchemaPath: `${it.errSchemaPath}/${keyword}`,
            }
          : {
              schema: sch[schemaProp],
              schemaPath: (0, codegen_1._)`${it.schemaPath}${(0,
              codegen_1.getProperty)(keyword)}${(0, codegen_1.getProperty)(
                schemaProp
              )}`,
              errSchemaPath: `${it.errSchemaPath}/${keyword}/${(0,
              util_1.escapeFragment)(schemaProp)}`,
            };
      }
      if (schema !== void 0) {
        if (
          schemaPath === void 0 ||
          errSchemaPath === void 0 ||
          topSchemaRef === void 0
        ) {
          throw new Error(
            '"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"'
          );
        }
        return {
          schema,
          schemaPath,
          topSchemaRef,
          errSchemaPath,
        };
      }
      throw new Error('either "keyword" or "schema" must be passed');
    }
    exports2.getSubschema = getSubschema;
    function extendSubschemaData(
      subschema,
      it,
      { dataProp, dataPropType: dpType, data, dataTypes, propertyName }
    ) {
      if (data !== void 0 && dataProp !== void 0) {
        throw new Error('both "data" and "dataProp" passed, only one allowed');
      }
      const { gen } = it;
      if (dataProp !== void 0) {
        const { errorPath, dataPathArr, opts } = it;
        const nextData = gen.let(
          "data",
          (0, codegen_1._)`${it.data}${(0, codegen_1.getProperty)(dataProp)}`,
          true
        );
        dataContextProps(nextData);
        subschema.errorPath = (0, codegen_1.str)`${errorPath}${(0,
        util_1.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;
        subschema.parentDataProperty = (0, codegen_1._)`${dataProp}`;
        subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty];
      }
      if (data !== void 0) {
        const nextData =
          data instanceof codegen_1.Name ? data : gen.let("data", data, true);
        dataContextProps(nextData);
        if (propertyName !== void 0) subschema.propertyName = propertyName;
      }
      if (dataTypes) subschema.dataTypes = dataTypes;
      function dataContextProps(_nextData) {
        subschema.data = _nextData;
        subschema.dataLevel = it.dataLevel + 1;
        subschema.dataTypes = [];
        it.definedProperties = /* @__PURE__ */ new Set();
        subschema.parentData = it.data;
        subschema.dataNames = [...it.dataNames, _nextData];
      }
    }
    exports2.extendSubschemaData = extendSubschemaData;
    function extendSubschemaMode(
      subschema,
      { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }
    ) {
      if (compositeRule !== void 0) subschema.compositeRule = compositeRule;
      if (createErrors !== void 0) subschema.createErrors = createErrors;
      if (allErrors !== void 0) subschema.allErrors = allErrors;
      subschema.jtdDiscriminator = jtdDiscriminator;
      subschema.jtdMetadata = jtdMetadata;
    }
    exports2.extendSubschemaMode = extendSubschemaMode;
  },
});

// node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS({
  "node_modules/fast-deep-equal/index.js"(exports2, module2) {
    module2.exports = function equal(a, b) {
      if (a === b) return true;
      if (a && b && typeof a == "object" && typeof b == "object") {
        if (a.constructor !== b.constructor) return false;
        var length, i, keys;
        if (Array.isArray(a)) {
          length = a.length;
          if (length != b.length) return false;
          for (i = length; i-- !== 0; ) if (!equal(a[i], b[i])) return false;
          return true;
        }
        if (a.constructor === RegExp)
          return a.source === b.source && a.flags === b.flags;
        if (a.valueOf !== Object.prototype.valueOf)
          return a.valueOf() === b.valueOf();
        if (a.toString !== Object.prototype.toString)
          return a.toString() === b.toString();
        keys = Object.keys(a);
        length = keys.length;
        if (length !== Object.keys(b).length) return false;
        for (i = length; i-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
        for (i = length; i-- !== 0; ) {
          var key = keys[i];
          if (!equal(a[key], b[key])) return false;
        }
        return true;
      }
      return a !== a && b !== b;
    };
  },
});

// node_modules/@near-js/accounts/node_modules/json-schema-traverse/index.js
var require_json_schema_traverse = __commonJS({
  "node_modules/@near-js/accounts/node_modules/json-schema-traverse/index.js"(
    exports2,
    module2
  ) {
    var traverse = (module2.exports = function (schema, opts, cb) {
      if (typeof opts == "function") {
        cb = opts;
        opts = {};
      }
      cb = opts.cb || cb;
      var pre = typeof cb == "function" ? cb : cb.pre || function () {};
      var post = cb.post || function () {};
      _traverse(opts, pre, post, schema, "", schema);
    });
    traverse.keywords = {
      additionalItems: true,
      items: true,
      contains: true,
      additionalProperties: true,
      propertyNames: true,
      not: true,
      if: true,
      then: true,
      else: true,
    };
    traverse.arrayKeywords = {
      items: true,
      allOf: true,
      anyOf: true,
      oneOf: true,
    };
    traverse.propsKeywords = {
      $defs: true,
      definitions: true,
      properties: true,
      patternProperties: true,
      dependencies: true,
    };
    traverse.skipKeywords = {
      default: true,
      enum: true,
      const: true,
      required: true,
      maximum: true,
      minimum: true,
      exclusiveMaximum: true,
      exclusiveMinimum: true,
      multipleOf: true,
      maxLength: true,
      minLength: true,
      pattern: true,
      format: true,
      maxItems: true,
      minItems: true,
      uniqueItems: true,
      maxProperties: true,
      minProperties: true,
    };
    function _traverse(
      opts,
      pre,
      post,
      schema,
      jsonPtr,
      rootSchema,
      parentJsonPtr,
      parentKeyword,
      parentSchema,
      keyIndex
    ) {
      if (schema && typeof schema == "object" && !Array.isArray(schema)) {
        pre(
          schema,
          jsonPtr,
          rootSchema,
          parentJsonPtr,
          parentKeyword,
          parentSchema,
          keyIndex
        );
        for (var key in schema) {
          var sch = schema[key];
          if (Array.isArray(sch)) {
            if (key in traverse.arrayKeywords) {
              for (var i = 0; i < sch.length; i++)
                _traverse(
                  opts,
                  pre,
                  post,
                  sch[i],
                  jsonPtr + "/" + key + "/" + i,
                  rootSchema,
                  jsonPtr,
                  key,
                  schema,
                  i
                );
            }
          } else if (key in traverse.propsKeywords) {
            if (sch && typeof sch == "object") {
              for (var prop in sch)
                _traverse(
                  opts,
                  pre,
                  post,
                  sch[prop],
                  jsonPtr + "/" + key + "/" + escapeJsonPtr(prop),
                  rootSchema,
                  jsonPtr,
                  key,
                  schema,
                  prop
                );
            }
          } else if (
            key in traverse.keywords ||
            (opts.allKeys && !(key in traverse.skipKeywords))
          ) {
            _traverse(
              opts,
              pre,
              post,
              sch,
              jsonPtr + "/" + key,
              rootSchema,
              jsonPtr,
              key,
              schema
            );
          }
        }
        post(
          schema,
          jsonPtr,
          rootSchema,
          parentJsonPtr,
          parentKeyword,
          parentSchema,
          keyIndex
        );
      }
    }
    function escapeJsonPtr(str) {
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
  },
});

// node_modules/@near-js/accounts/node_modules/ajv/dist/compile/resolve.js
var require_resolve = __commonJS({
  "node_modules/@near-js/accounts/node_modules/ajv/dist/compile/resolve.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getSchemaRefs =
      exports2.resolveUrl =
      exports2.normalizeId =
      exports2._getFullPath =
      exports2.getFullPath =
      exports2.inlineRef =
        void 0;
    var util_1 = require_util();
    var equal = require_fast_deep_equal();
    var traverse = require_json_schema_traverse();
    var SIMPLE_INLINED = /* @__PURE__ */ new Set([
      "type",
      "format",
      "pattern",
      "maxLength",
      "minLength",
      "maxProperties",
      "minProperties",
      "maxItems",
      "minItems",
      "maximum",
      "minimum",
      "uniqueItems",
      "multipleOf",
      "required",
      "enum",
      "const",
    ]);
    function inlineRef(schema, limit = true) {
      if (typeof schema == "boolean") return true;
      if (limit === true) return !hasRef(schema);
      if (!limit) return false;
      return countKeys(schema) <= limit;
    }
    exports2.inlineRef = inlineRef;
    var REF_KEYWORDS = /* @__PURE__ */ new Set([
      "$ref",
      "$recursiveRef",
      "$recursiveAnchor",
      "$dynamicRef",
      "$dynamicAnchor",
    ]);
    function hasRef(schema) {
      for (const key in schema) {
        if (REF_KEYWORDS.has(key)) return true;
        const sch = schema[key];
        if (Array.isArray(sch) && sch.some(hasRef)) return true;
        if (typeof sch == "object" && hasRef(sch)) return true;
      }
      return false;
    }
    function countKeys(schema) {
      let count = 0;
      for (const key in schema) {
        if (key === "$ref") return Infinity;
        count++;
        if (SIMPLE_INLINED.has(key)) continue;
        if (typeof schema[key] == "object") {
          (0, util_1.eachItem)(schema[key], (sch) => (count += countKeys(sch)));
        }
        if (count === Infinity) return Infinity;
      }
      return count;
    }
    function getFullPath(resolver, id = "", normalize) {
      if (normalize !== false) id = normalizeId(id);
      const p = resolver.parse(id);
      return _getFullPath(resolver, p);
    }
    exports2.getFullPath = getFullPath;
    function _getFullPath(resolver, p) {
      const serialized = resolver.serialize(p);
      return serialized.split("#")[0] + "#";
    }
    exports2._getFullPath = _getFullPath;
    var TRAILING_SLASH_HASH = /#\/?$/;
    function normalizeId(id) {
      return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
    }
    exports2.normalizeId = normalizeId;
    function resolveUrl(resolver, baseId, id) {
      id = normalizeId(id);
      return resolver.resolve(baseId, id);
    }
    exports2.resolveUrl = resolveUrl;
    var ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
    function getSchemaRefs(schema, baseId) {
      if (typeof schema == "boolean") return {};
      const { schemaId, uriResolver } = this.opts;
      const schId = normalizeId(schema[schemaId] || baseId);
      const baseIds = { "": schId };
      const pathPrefix = getFullPath(uriResolver, schId, false);
      const localRefs = {};
      const schemaRefs = /* @__PURE__ */ new Set();
      traverse(schema, { allKeys: true }, (sch, jsonPtr, _, parentJsonPtr) => {
        if (parentJsonPtr === void 0) return;
        const fullPath = pathPrefix + jsonPtr;
        let baseId2 = baseIds[parentJsonPtr];
        if (typeof sch[schemaId] == "string")
          baseId2 = addRef.call(this, sch[schemaId]);
        addAnchor.call(this, sch.$anchor);
        addAnchor.call(this, sch.$dynamicAnchor);
        baseIds[jsonPtr] = baseId2;
        function addRef(ref) {
          const _resolve = this.opts.uriResolver.resolve;
          ref = normalizeId(baseId2 ? _resolve(baseId2, ref) : ref);
          if (schemaRefs.has(ref)) throw ambiguos(ref);
          schemaRefs.add(ref);
          let schOrRef = this.refs[ref];
          if (typeof schOrRef == "string") schOrRef = this.refs[schOrRef];
          if (typeof schOrRef == "object") {
            checkAmbiguosRef(sch, schOrRef.schema, ref);
          } else if (ref !== normalizeId(fullPath)) {
            if (ref[0] === "#") {
              checkAmbiguosRef(sch, localRefs[ref], ref);
              localRefs[ref] = sch;
            } else {
              this.refs[ref] = fullPath;
            }
          }
          return ref;
        }
        function addAnchor(anchor) {
          if (typeof anchor == "string") {
            if (!ANCHOR.test(anchor))
              throw new Error(`invalid anchor "${anchor}"`);
            addRef.call(this, `#${anchor}`);
          }
        }
      });
      return localRefs;
      function checkAmbiguosRef(sch1, sch2, ref) {
        if (sch2 !== void 0 && !equal(sch1, sch2)) throw ambiguos(ref);
      }
      function ambiguos(ref) {
        return new Error(`reference "${ref}" resolves to more than one schema`);
      }
    }
    exports2.getSchemaRefs = getSchemaRefs;
  },
});

// node_modules/@near-js/accounts/node_modules/ajv/dist/compile/validate/index.js
var require_validate = __commonJS({
  "node_modules/@near-js/accounts/node_modules/ajv/dist/compile/validate/index.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getData =
      exports2.KeywordCxt =
      exports2.validateFunctionCode =
        void 0;
    var boolSchema_1 = require_boolSchema();
    var dataType_1 = require_dataType();
    var applicability_1 = require_applicability();
    var dataType_2 = require_dataType();
    var defaults_1 = require_defaults();
    var keyword_1 = require_keyword();
    var subschema_1 = require_subschema();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var resolve_1 = require_resolve();
    var util_1 = require_util();
    var errors_1 = require_errors4();
    function validateFunctionCode(it) {
      if (isSchemaObj(it)) {
        checkKeywords(it);
        if (schemaCxtHasRules(it)) {
          topSchemaObjCode(it);
          return;
        }
      }
      validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));
    }
    exports2.validateFunctionCode = validateFunctionCode;
    function validateFunction(
      { gen, validateName, schema, schemaEnv, opts },
      body
    ) {
      if (opts.code.es5) {
        gen.func(
          validateName,
          (0, codegen_1._)`${names_1.default.data}, ${names_1.default.valCxt}`,
          schemaEnv.$async,
          () => {
            gen.code(
              (0, codegen_1._)`"use strict"; ${funcSourceUrl(schema, opts)}`
            );
            destructureValCxtES5(gen, opts);
            gen.code(body);
          }
        );
      } else {
        gen.func(
          validateName,
          (0, codegen_1._)`${names_1.default.data}, ${destructureValCxt(opts)}`,
          schemaEnv.$async,
          () => gen.code(funcSourceUrl(schema, opts)).code(body)
        );
      }
    }
    function destructureValCxt(opts) {
      return (0, codegen_1._)`{${names_1.default.instancePath}="", ${
        names_1.default.parentData
      }, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${
        names_1.default.data
      }${
        opts.dynamicRef
          ? (0, codegen_1._)`, ${names_1.default.dynamicAnchors}={}`
          : codegen_1.nil
      }}={}`;
    }
    function destructureValCxtES5(gen, opts) {
      gen.if(
        names_1.default.valCxt,
        () => {
          gen.var(
            names_1.default.instancePath,
            (0,
            codegen_1._)`${names_1.default.valCxt}.${names_1.default.instancePath}`
          );
          gen.var(
            names_1.default.parentData,
            (0,
            codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentData}`
          );
          gen.var(
            names_1.default.parentDataProperty,
            (0,
            codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentDataProperty}`
          );
          gen.var(
            names_1.default.rootData,
            (0,
            codegen_1._)`${names_1.default.valCxt}.${names_1.default.rootData}`
          );
          if (opts.dynamicRef)
            gen.var(
              names_1.default.dynamicAnchors,
              (0,
              codegen_1._)`${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`
            );
        },
        () => {
          gen.var(names_1.default.instancePath, (0, codegen_1._)`""`);
          gen.var(names_1.default.parentData, (0, codegen_1._)`undefined`);
          gen.var(
            names_1.default.parentDataProperty,
            (0, codegen_1._)`undefined`
          );
          gen.var(names_1.default.rootData, names_1.default.data);
          if (opts.dynamicRef)
            gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`{}`);
        }
      );
    }
    function topSchemaObjCode(it) {
      const { schema, opts, gen } = it;
      validateFunction(it, () => {
        if (opts.$comment && schema.$comment) commentKeyword(it);
        checkNoDefault(it);
        gen.let(names_1.default.vErrors, null);
        gen.let(names_1.default.errors, 0);
        if (opts.unevaluated) resetEvaluated(it);
        typeAndKeywords(it);
        returnResults(it);
      });
      return;
    }
    function resetEvaluated(it) {
      const { gen, validateName } = it;
      it.evaluated = gen.const(
        "evaluated",
        (0, codegen_1._)`${validateName}.evaluated`
      );
      gen.if((0, codegen_1._)`${it.evaluated}.dynamicProps`, () =>
        gen.assign(
          (0, codegen_1._)`${it.evaluated}.props`,
          (0, codegen_1._)`undefined`
        )
      );
      gen.if((0, codegen_1._)`${it.evaluated}.dynamicItems`, () =>
        gen.assign(
          (0, codegen_1._)`${it.evaluated}.items`,
          (0, codegen_1._)`undefined`
        )
      );
    }
    function funcSourceUrl(schema, opts) {
      const schId = typeof schema == "object" && schema[opts.schemaId];
      return schId && (opts.code.source || opts.code.process)
        ? (0, codegen_1._)`/*# sourceURL=${schId} */`
        : codegen_1.nil;
    }
    function subschemaCode(it, valid) {
      if (isSchemaObj(it)) {
        checkKeywords(it);
        if (schemaCxtHasRules(it)) {
          subSchemaObjCode(it, valid);
          return;
        }
      }
      (0, boolSchema_1.boolOrEmptySchema)(it, valid);
    }
    function schemaCxtHasRules({ schema, self: self2 }) {
      if (typeof schema == "boolean") return !schema;
      for (const key in schema) if (self2.RULES.all[key]) return true;
      return false;
    }
    function isSchemaObj(it) {
      return typeof it.schema != "boolean";
    }
    function subSchemaObjCode(it, valid) {
      const { schema, gen, opts } = it;
      if (opts.$comment && schema.$comment) commentKeyword(it);
      updateContext(it);
      checkAsyncSchema(it);
      const errsCount = gen.const("_errs", names_1.default.errors);
      typeAndKeywords(it, errsCount);
      gen.var(
        valid,
        (0, codegen_1._)`${errsCount} === ${names_1.default.errors}`
      );
    }
    function checkKeywords(it) {
      (0, util_1.checkUnknownRules)(it);
      checkRefsAndKeywords(it);
    }
    function typeAndKeywords(it, errsCount) {
      if (it.opts.jtd) return schemaKeywords(it, [], false, errsCount);
      const types = (0, dataType_1.getSchemaTypes)(it.schema);
      const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it, types);
      schemaKeywords(it, types, !checkedTypes, errsCount);
    }
    function checkRefsAndKeywords(it) {
      const { schema, errSchemaPath, opts, self: self2 } = it;
      if (
        schema.$ref &&
        opts.ignoreKeywordsWithRef &&
        (0, util_1.schemaHasRulesButRef)(schema, self2.RULES)
      ) {
        self2.logger.warn(
          `$ref: keywords ignored in schema at path "${errSchemaPath}"`
        );
      }
    }
    function checkNoDefault(it) {
      const { schema, opts } = it;
      if (schema.default !== void 0 && opts.useDefaults && opts.strictSchema) {
        (0, util_1.checkStrictMode)(
          it,
          "default is ignored in the schema root"
        );
      }
    }
    function updateContext(it) {
      const schId = it.schema[it.opts.schemaId];
      if (schId)
        it.baseId = (0, resolve_1.resolveUrl)(
          it.opts.uriResolver,
          it.baseId,
          schId
        );
    }
    function checkAsyncSchema(it) {
      if (it.schema.$async && !it.schemaEnv.$async)
        throw new Error("async schema in sync schema");
    }
    function commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {
      const msg = schema.$comment;
      if (opts.$comment === true) {
        gen.code((0, codegen_1._)`${names_1.default.self}.logger.log(${msg})`);
      } else if (typeof opts.$comment == "function") {
        const schemaPath = (0, codegen_1.str)`${errSchemaPath}/$comment`;
        const rootName = gen.scopeValue("root", { ref: schemaEnv.root });
        gen.code(
          (0,
          codegen_1._)`${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`
        );
      }
    }
    function returnResults(it) {
      const { gen, schemaEnv, validateName, ValidationError, opts } = it;
      if (schemaEnv.$async) {
        gen.if(
          (0, codegen_1._)`${names_1.default.errors} === 0`,
          () => gen.return(names_1.default.data),
          () =>
            gen.throw(
              (0,
              codegen_1._)`new ${ValidationError}(${names_1.default.vErrors})`
            )
        );
      } else {
        gen.assign(
          (0, codegen_1._)`${validateName}.errors`,
          names_1.default.vErrors
        );
        if (opts.unevaluated) assignEvaluated(it);
        gen.return((0, codegen_1._)`${names_1.default.errors} === 0`);
      }
    }
    function assignEvaluated({ gen, evaluated, props, items }) {
      if (props instanceof codegen_1.Name)
        gen.assign((0, codegen_1._)`${evaluated}.props`, props);
      if (items instanceof codegen_1.Name)
        gen.assign((0, codegen_1._)`${evaluated}.items`, items);
    }
    function schemaKeywords(it, types, typeErrors, errsCount) {
      const { gen, schema, data, allErrors, opts, self: self2 } = it;
      const { RULES } = self2;
      if (
        schema.$ref &&
        (opts.ignoreKeywordsWithRef ||
          !(0, util_1.schemaHasRulesButRef)(schema, RULES))
      ) {
        gen.block(() => keywordCode(it, "$ref", RULES.all.$ref.definition));
        return;
      }
      if (!opts.jtd) checkStrictTypes(it, types);
      gen.block(() => {
        for (const group of RULES.rules) groupKeywords(group);
        groupKeywords(RULES.post);
      });
      function groupKeywords(group) {
        if (!(0, applicability_1.shouldUseGroup)(schema, group)) return;
        if (group.type) {
          gen.if(
            (0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers)
          );
          iterateKeywords(it, group);
          if (types.length === 1 && types[0] === group.type && typeErrors) {
            gen.else();
            (0, dataType_2.reportTypeError)(it);
          }
          gen.endIf();
        } else {
          iterateKeywords(it, group);
        }
        if (!allErrors)
          gen.if(
            (0, codegen_1._)`${names_1.default.errors} === ${errsCount || 0}`
          );
      }
    }
    function iterateKeywords(it, group) {
      const {
        gen,
        schema,
        opts: { useDefaults },
      } = it;
      if (useDefaults) (0, defaults_1.assignDefaults)(it, group.type);
      gen.block(() => {
        for (const rule of group.rules) {
          if ((0, applicability_1.shouldUseRule)(schema, rule)) {
            keywordCode(it, rule.keyword, rule.definition, group.type);
          }
        }
      });
    }
    function checkStrictTypes(it, types) {
      if (it.schemaEnv.meta || !it.opts.strictTypes) return;
      checkContextTypes(it, types);
      if (!it.opts.allowUnionTypes) checkMultipleTypes(it, types);
      checkKeywordTypes(it, it.dataTypes);
    }
    function checkContextTypes(it, types) {
      if (!types.length) return;
      if (!it.dataTypes.length) {
        it.dataTypes = types;
        return;
      }
      types.forEach((t) => {
        if (!includesType(it.dataTypes, t)) {
          strictTypesError(
            it,
            `type "${t}" not allowed by context "${it.dataTypes.join(",")}"`
          );
        }
      });
      narrowSchemaTypes(it, types);
    }
    function checkMultipleTypes(it, ts) {
      if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) {
        strictTypesError(it, "use allowUnionTypes to allow union type keyword");
      }
    }
    function checkKeywordTypes(it, ts) {
      const rules = it.self.RULES.all;
      for (const keyword in rules) {
        const rule = rules[keyword];
        if (
          typeof rule == "object" &&
          (0, applicability_1.shouldUseRule)(it.schema, rule)
        ) {
          const { type } = rule.definition;
          if (type.length && !type.some((t) => hasApplicableType(ts, t))) {
            strictTypesError(
              it,
              `missing type "${type.join(",")}" for keyword "${keyword}"`
            );
          }
        }
      }
    }
    function hasApplicableType(schTs, kwdT) {
      return (
        schTs.includes(kwdT) || (kwdT === "number" && schTs.includes("integer"))
      );
    }
    function includesType(ts, t) {
      return ts.includes(t) || (t === "integer" && ts.includes("number"));
    }
    function narrowSchemaTypes(it, withTypes) {
      const ts = [];
      for (const t of it.dataTypes) {
        if (includesType(withTypes, t)) ts.push(t);
        else if (withTypes.includes("integer") && t === "number")
          ts.push("integer");
      }
      it.dataTypes = ts;
    }
    function strictTypesError(it, msg) {
      const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
      msg += ` at "${schemaPath}" (strictTypes)`;
      (0, util_1.checkStrictMode)(it, msg, it.opts.strictTypes);
    }
    var KeywordCxt = class {
      constructor(it, def, keyword) {
        (0, keyword_1.validateKeywordUsage)(it, def, keyword);
        this.gen = it.gen;
        this.allErrors = it.allErrors;
        this.keyword = keyword;
        this.data = it.data;
        this.schema = it.schema[keyword];
        this.$data =
          def.$data && it.opts.$data && this.schema && this.schema.$data;
        this.schemaValue = (0, util_1.schemaRefOrVal)(
          it,
          this.schema,
          keyword,
          this.$data
        );
        this.schemaType = def.schemaType;
        this.parentSchema = it.schema;
        this.params = {};
        this.it = it;
        this.def = def;
        if (this.$data) {
          this.schemaCode = it.gen.const("vSchema", getData(this.$data, it));
        } else {
          this.schemaCode = this.schemaValue;
          if (
            !(0, keyword_1.validSchemaType)(
              this.schema,
              def.schemaType,
              def.allowUndefined
            )
          ) {
            throw new Error(
              `${keyword} value must be ${JSON.stringify(def.schemaType)}`
            );
          }
        }
        if ("code" in def ? def.trackErrors : def.errors !== false) {
          this.errsCount = it.gen.const("_errs", names_1.default.errors);
        }
      }
      result(condition, successAction, failAction) {
        this.failResult(
          (0, codegen_1.not)(condition),
          successAction,
          failAction
        );
      }
      failResult(condition, successAction, failAction) {
        this.gen.if(condition);
        if (failAction) failAction();
        else this.error();
        if (successAction) {
          this.gen.else();
          successAction();
          if (this.allErrors) this.gen.endIf();
        } else {
          if (this.allErrors) this.gen.endIf();
          else this.gen.else();
        }
      }
      pass(condition, failAction) {
        this.failResult((0, codegen_1.not)(condition), void 0, failAction);
      }
      fail(condition) {
        if (condition === void 0) {
          this.error();
          if (!this.allErrors) this.gen.if(false);
          return;
        }
        this.gen.if(condition);
        this.error();
        if (this.allErrors) this.gen.endIf();
        else this.gen.else();
      }
      fail$data(condition) {
        if (!this.$data) return this.fail(condition);
        const { schemaCode } = this;
        this.fail(
          (0, codegen_1._)`${schemaCode} !== undefined && (${(0, codegen_1.or)(
            this.invalid$data(),
            condition
          )})`
        );
      }
      error(append, errorParams, errorPaths) {
        if (errorParams) {
          this.setParams(errorParams);
          this._error(append, errorPaths);
          this.setParams({});
          return;
        }
        this._error(append, errorPaths);
      }
      _error(append, errorPaths) {
        (append ? errors_1.reportExtraError : errors_1.reportError)(
          this,
          this.def.error,
          errorPaths
        );
      }
      $dataError() {
        (0, errors_1.reportError)(
          this,
          this.def.$dataError || errors_1.keyword$DataError
        );
      }
      reset() {
        if (this.errsCount === void 0)
          throw new Error('add "trackErrors" to keyword definition');
        (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);
      }
      ok(cond) {
        if (!this.allErrors) this.gen.if(cond);
      }
      setParams(obj, assign) {
        if (assign) Object.assign(this.params, obj);
        else this.params = obj;
      }
      block$data(valid, codeBlock, $dataValid = codegen_1.nil) {
        this.gen.block(() => {
          this.check$data(valid, $dataValid);
          codeBlock();
        });
      }
      check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {
        if (!this.$data) return;
        const { gen, schemaCode, schemaType, def } = this;
        gen.if(
          (0, codegen_1.or)(
            (0, codegen_1._)`${schemaCode} === undefined`,
            $dataValid
          )
        );
        if (valid !== codegen_1.nil) gen.assign(valid, true);
        if (schemaType.length || def.validateSchema) {
          gen.elseIf(this.invalid$data());
          this.$dataError();
          if (valid !== codegen_1.nil) gen.assign(valid, false);
        }
        gen.else();
      }
      invalid$data() {
        const { gen, schemaCode, schemaType, def, it } = this;
        return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());
        function wrong$DataType() {
          if (schemaType.length) {
            if (!(schemaCode instanceof codegen_1.Name))
              throw new Error("ajv implementation error");
            const st = Array.isArray(schemaType) ? schemaType : [schemaType];
            return (0, codegen_1._)`${(0, dataType_2.checkDataTypes)(
              st,
              schemaCode,
              it.opts.strictNumbers,
              dataType_2.DataType.Wrong
            )}`;
          }
          return codegen_1.nil;
        }
        function invalid$DataSchema() {
          if (def.validateSchema) {
            const validateSchemaRef = gen.scopeValue("validate$data", {
              ref: def.validateSchema,
            });
            return (0, codegen_1._)`!${validateSchemaRef}(${schemaCode})`;
          }
          return codegen_1.nil;
        }
      }
      subschema(appl, valid) {
        const subschema = (0, subschema_1.getSubschema)(this.it, appl);
        (0, subschema_1.extendSubschemaData)(subschema, this.it, appl);
        (0, subschema_1.extendSubschemaMode)(subschema, appl);
        const nextContext = {
          ...this.it,
          ...subschema,
          items: void 0,
          props: void 0,
        };
        subschemaCode(nextContext, valid);
        return nextContext;
      }
      mergeEvaluated(schemaCxt, toName) {
        const { it, gen } = this;
        if (!it.opts.unevaluated) return;
        if (it.props !== true && schemaCxt.props !== void 0) {
          it.props = util_1.mergeEvaluated.props(
            gen,
            schemaCxt.props,
            it.props,
            toName
          );
        }
        if (it.items !== true && schemaCxt.items !== void 0) {
          it.items = util_1.mergeEvaluated.items(
            gen,
            schemaCxt.items,
            it.items,
            toName
          );
        }
      }
      mergeValidEvaluated(schemaCxt, valid) {
        const { it, gen } = this;
        if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {
          gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));
          return true;
        }
      }
    };
    exports2.KeywordCxt = KeywordCxt;
    function keywordCode(it, keyword, def, ruleType) {
      const cxt = new KeywordCxt(it, def, keyword);
      if ("code" in def) {
        def.code(cxt, ruleType);
      } else if (cxt.$data && def.validate) {
        (0, keyword_1.funcKeywordCode)(cxt, def);
      } else if ("macro" in def) {
        (0, keyword_1.macroKeywordCode)(cxt, def);
      } else if (def.compile || def.validate) {
        (0, keyword_1.funcKeywordCode)(cxt, def);
      }
    }
    var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
    var RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
    function getData($data, { dataLevel, dataNames, dataPathArr }) {
      let jsonPointer;
      let data;
      if ($data === "") return names_1.default.rootData;
      if ($data[0] === "/") {
        if (!JSON_POINTER.test($data))
          throw new Error(`Invalid JSON-pointer: ${$data}`);
        jsonPointer = $data;
        data = names_1.default.rootData;
      } else {
        const matches = RELATIVE_JSON_POINTER.exec($data);
        if (!matches) throw new Error(`Invalid JSON-pointer: ${$data}`);
        const up = +matches[1];
        jsonPointer = matches[2];
        if (jsonPointer === "#") {
          if (up >= dataLevel) throw new Error(errorMsg("property/index", up));
          return dataPathArr[dataLevel - up];
        }
        if (up > dataLevel) throw new Error(errorMsg("data", up));
        data = dataNames[dataLevel - up];
        if (!jsonPointer) return data;
      }
      let expr = data;
      const segments = jsonPointer.split("/");
      for (const segment of segments) {
        if (segment) {
          data = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(
            (0, util_1.unescapeJsonPointer)(segment)
          )}`;
          expr = (0, codegen_1._)`${expr} && ${data}`;
        }
      }
      return expr;
      function errorMsg(pointerType, up) {
        return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
      }
    }
    exports2.getData = getData;
  },
});

// node_modules/@near-js/accounts/node_modules/ajv/dist/runtime/validation_error.js
var require_validation_error = __commonJS({
  "node_modules/@near-js/accounts/node_modules/ajv/dist/runtime/validation_error.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var ValidationError = class extends Error {
      constructor(errors) {
        super("validation failed");
        this.errors = errors;
        this.ajv = this.validation = true;
      }
    };
    exports2.default = ValidationError;
  },
});

// node_modules/@near-js/accounts/node_modules/ajv/dist/compile/ref_error.js
var require_ref_error = __commonJS({
  "node_modules/@near-js/accounts/node_modules/ajv/dist/compile/ref_error.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var resolve_1 = require_resolve();
    var MissingRefError = class extends Error {
      constructor(resolver, baseId, ref, msg) {
        super(msg || `can't resolve reference ${ref} from id ${baseId}`);
        this.missingRef = (0, resolve_1.resolveUrl)(resolver, baseId, ref);
        this.missingSchema = (0, resolve_1.normalizeId)(
          (0, resolve_1.getFullPath)(resolver, this.missingRef)
        );
      }
    };
    exports2.default = MissingRefError;
  },
});

// node_modules/@near-js/accounts/node_modules/ajv/dist/compile/index.js
var require_compile = __commonJS({
  "node_modules/@near-js/accounts/node_modules/ajv/dist/compile/index.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resolveSchema =
      exports2.getCompilingSchema =
      exports2.resolveRef =
      exports2.compileSchema =
      exports2.SchemaEnv =
        void 0;
    var codegen_1 = require_codegen();
    var validation_error_1 = require_validation_error();
    var names_1 = require_names();
    var resolve_1 = require_resolve();
    var util_1 = require_util();
    var validate_1 = require_validate();
    var SchemaEnv = class {
      constructor(env) {
        var _a;
        this.refs = {};
        this.dynamicAnchors = {};
        let schema;
        if (typeof env.schema == "object") schema = env.schema;
        this.schema = env.schema;
        this.schemaId = env.schemaId;
        this.root = env.root || this;
        this.baseId =
          (_a = env.baseId) !== null && _a !== void 0
            ? _a
            : (0, resolve_1.normalizeId)(
                schema === null || schema === void 0
                  ? void 0
                  : schema[env.schemaId || "$id"]
              );
        this.schemaPath = env.schemaPath;
        this.localRefs = env.localRefs;
        this.meta = env.meta;
        this.$async =
          schema === null || schema === void 0 ? void 0 : schema.$async;
        this.refs = {};
      }
    };
    exports2.SchemaEnv = SchemaEnv;
    function compileSchema(sch) {
      const _sch = getCompilingSchema.call(this, sch);
      if (_sch) return _sch;
      const rootId = (0, resolve_1.getFullPath)(
        this.opts.uriResolver,
        sch.root.baseId
      );
      const { es5, lines } = this.opts.code;
      const { ownProperties } = this.opts;
      const gen = new codegen_1.CodeGen(this.scope, {
        es5,
        lines,
        ownProperties,
      });
      let _ValidationError;
      if (sch.$async) {
        _ValidationError = gen.scopeValue("Error", {
          ref: validation_error_1.default,
          code: (0,
          codegen_1._)`require("ajv/dist/runtime/validation_error").default`,
        });
      }
      const validateName = gen.scopeName("validate");
      sch.validateName = validateName;
      const schemaCxt = {
        gen,
        allErrors: this.opts.allErrors,
        data: names_1.default.data,
        parentData: names_1.default.parentData,
        parentDataProperty: names_1.default.parentDataProperty,
        dataNames: [names_1.default.data],
        dataPathArr: [codegen_1.nil],
        dataLevel: 0,
        dataTypes: [],
        definedProperties: /* @__PURE__ */ new Set(),
        topSchemaRef: gen.scopeValue(
          "schema",
          this.opts.code.source === true
            ? { ref: sch.schema, code: (0, codegen_1.stringify)(sch.schema) }
            : { ref: sch.schema }
        ),
        validateName,
        ValidationError: _ValidationError,
        schema: sch.schema,
        schemaEnv: sch,
        rootId,
        baseId: sch.baseId || rootId,
        schemaPath: codegen_1.nil,
        errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
        errorPath: (0, codegen_1._)`""`,
        opts: this.opts,
        self: this,
      };
      let sourceCode;
      try {
        this._compilations.add(sch);
        (0, validate_1.validateFunctionCode)(schemaCxt);
        gen.optimize(this.opts.code.optimize);
        const validateCode = gen.toString();
        sourceCode = `${gen.scopeRefs(
          names_1.default.scope
        )}return ${validateCode}`;
        if (this.opts.code.process)
          sourceCode = this.opts.code.process(sourceCode, sch);
        const makeValidate = new Function(
          `${names_1.default.self}`,
          `${names_1.default.scope}`,
          sourceCode
        );
        const validate = makeValidate(this, this.scope.get());
        this.scope.value(validateName, { ref: validate });
        validate.errors = null;
        validate.schema = sch.schema;
        validate.schemaEnv = sch;
        if (sch.$async) validate.$async = true;
        if (this.opts.code.source === true) {
          validate.source = {
            validateName,
            validateCode,
            scopeValues: gen._values,
          };
        }
        if (this.opts.unevaluated) {
          const { props, items } = schemaCxt;
          validate.evaluated = {
            props: props instanceof codegen_1.Name ? void 0 : props,
            items: items instanceof codegen_1.Name ? void 0 : items,
            dynamicProps: props instanceof codegen_1.Name,
            dynamicItems: items instanceof codegen_1.Name,
          };
          if (validate.source)
            validate.source.evaluated = (0, codegen_1.stringify)(
              validate.evaluated
            );
        }
        sch.validate = validate;
        return sch;
      } catch (e) {
        delete sch.validate;
        delete sch.validateName;
        if (sourceCode)
          this.logger.error(
            "Error compiling schema, function code:",
            sourceCode
          );
        throw e;
      } finally {
        this._compilations.delete(sch);
      }
    }
    exports2.compileSchema = compileSchema;
    function resolveRef(root2, baseId, ref) {
      var _a;
      ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref);
      const schOrFunc = root2.refs[ref];
      if (schOrFunc) return schOrFunc;
      let _sch = resolve.call(this, root2, ref);
      if (_sch === void 0) {
        const schema =
          (_a = root2.localRefs) === null || _a === void 0 ? void 0 : _a[ref];
        const { schemaId } = this.opts;
        if (schema)
          _sch = new SchemaEnv({ schema, schemaId, root: root2, baseId });
      }
      if (_sch === void 0) return;
      return (root2.refs[ref] = inlineOrCompile.call(this, _sch));
    }
    exports2.resolveRef = resolveRef;
    function inlineOrCompile(sch) {
      if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs))
        return sch.schema;
      return sch.validate ? sch : compileSchema.call(this, sch);
    }
    function getCompilingSchema(schEnv) {
      for (const sch of this._compilations) {
        if (sameSchemaEnv(sch, schEnv)) return sch;
      }
    }
    exports2.getCompilingSchema = getCompilingSchema;
    function sameSchemaEnv(s1, s2) {
      return (
        s1.schema === s2.schema &&
        s1.root === s2.root &&
        s1.baseId === s2.baseId
      );
    }
    function resolve(root2, ref) {
      let sch;
      while (typeof (sch = this.refs[ref]) == "string") ref = sch;
      return sch || this.schemas[ref] || resolveSchema.call(this, root2, ref);
    }
    function resolveSchema(root2, ref) {
      const p = this.opts.uriResolver.parse(ref);
      const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p);
      let baseId = (0, resolve_1.getFullPath)(
        this.opts.uriResolver,
        root2.baseId,
        void 0
      );
      if (Object.keys(root2.schema).length > 0 && refPath === baseId) {
        return getJsonPointer.call(this, p, root2);
      }
      const id = (0, resolve_1.normalizeId)(refPath);
      const schOrRef = this.refs[id] || this.schemas[id];
      if (typeof schOrRef == "string") {
        const sch = resolveSchema.call(this, root2, schOrRef);
        if (
          typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !==
          "object"
        )
          return;
        return getJsonPointer.call(this, p, sch);
      }
      if (
        typeof (schOrRef === null || schOrRef === void 0
          ? void 0
          : schOrRef.schema) !== "object"
      )
        return;
      if (!schOrRef.validate) compileSchema.call(this, schOrRef);
      if (id === (0, resolve_1.normalizeId)(ref)) {
        const { schema } = schOrRef;
        const { schemaId } = this.opts;
        const schId = schema[schemaId];
        if (schId)
          baseId = (0, resolve_1.resolveUrl)(
            this.opts.uriResolver,
            baseId,
            schId
          );
        return new SchemaEnv({ schema, schemaId, root: root2, baseId });
      }
      return getJsonPointer.call(this, p, schOrRef);
    }
    exports2.resolveSchema = resolveSchema;
    var PREVENT_SCOPE_CHANGE = /* @__PURE__ */ new Set([
      "properties",
      "patternProperties",
      "enum",
      "dependencies",
      "definitions",
    ]);
    function getJsonPointer(parsedRef, { baseId, schema, root: root2 }) {
      var _a;
      if (
        ((_a = parsedRef.fragment) === null || _a === void 0
          ? void 0
          : _a[0]) !== "/"
      )
        return;
      for (const part of parsedRef.fragment.slice(1).split("/")) {
        if (typeof schema === "boolean") return;
        const partSchema = schema[(0, util_1.unescapeFragment)(part)];
        if (partSchema === void 0) return;
        schema = partSchema;
        const schId = typeof schema === "object" && schema[this.opts.schemaId];
        if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {
          baseId = (0, resolve_1.resolveUrl)(
            this.opts.uriResolver,
            baseId,
            schId
          );
        }
      }
      let env;
      if (
        typeof schema != "boolean" &&
        schema.$ref &&
        !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)
      ) {
        const $ref = (0, resolve_1.resolveUrl)(
          this.opts.uriResolver,
          baseId,
          schema.$ref
        );
        env = resolveSchema.call(this, root2, $ref);
      }
      const { schemaId } = this.opts;
      env = env || new SchemaEnv({ schema, schemaId, root: root2, baseId });
      if (env.schema !== env.root.schema) return env;
      return void 0;
    }
  },
});

// node_modules/@near-js/accounts/node_modules/ajv/dist/refs/data.json
var require_data = __commonJS({
  "node_modules/@near-js/accounts/node_modules/ajv/dist/refs/data.json"(
    exports2,
    module2
  ) {
    module2.exports = {
      $id: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
      description:
        "Meta-schema for $data reference (JSON AnySchema extension proposal)",
      type: "object",
      required: ["$data"],
      properties: {
        $data: {
          type: "string",
          anyOf: [
            { format: "relative-json-pointer" },
            { format: "json-pointer" },
          ],
        },
      },
      additionalProperties: false,
    };
  },
});

// node_modules/uri-js/dist/es5/uri.all.js
var require_uri_all = __commonJS({
  "node_modules/uri-js/dist/es5/uri.all.js"(exports2, module2) {
    (function (global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined"
        ? factory(exports2)
        : typeof define === "function" && define.amd
        ? define(["exports"], factory)
        : factory((global2.URI = global2.URI || {}));
    })(exports2, function (exports3) {
      function merge() {
        for (
          var _len = arguments.length, sets = Array(_len), _key = 0;
          _key < _len;
          _key++
        ) {
          sets[_key] = arguments[_key];
        }
        if (sets.length > 1) {
          sets[0] = sets[0].slice(0, -1);
          var xl = sets.length - 1;
          for (var x = 1; x < xl; ++x) {
            sets[x] = sets[x].slice(1, -1);
          }
          sets[xl] = sets[xl].slice(1);
          return sets.join("");
        } else {
          return sets[0];
        }
      }
      function subexp(str) {
        return "(?:" + str + ")";
      }
      function typeOf(o) {
        return o === void 0
          ? "undefined"
          : o === null
          ? "null"
          : Object.prototype.toString
              .call(o)
              .split(" ")
              .pop()
              .split("]")
              .shift()
              .toLowerCase();
      }
      function toUpperCase(str) {
        return str.toUpperCase();
      }
      function toArray(obj) {
        return obj !== void 0 && obj !== null
          ? obj instanceof Array
            ? obj
            : typeof obj.length !== "number" ||
              obj.split ||
              obj.setInterval ||
              obj.call
            ? [obj]
            : Array.prototype.slice.call(obj)
          : [];
      }
      function assign(target, source) {
        var obj = target;
        if (source) {
          for (var key in source) {
            obj[key] = source[key];
          }
        }
        return obj;
      }
      function buildExps(isIRI2) {
        var ALPHA$$ = "[A-Za-z]",
          DIGIT$$ = "[0-9]",
          HEXDIG$$2 = merge(DIGIT$$, "[A-Fa-f]"),
          PCT_ENCODED$2 = subexp(
            subexp(
              "%[EFef]" +
                HEXDIG$$2 +
                "%" +
                HEXDIG$$2 +
                HEXDIG$$2 +
                "%" +
                HEXDIG$$2 +
                HEXDIG$$2
            ) +
              "|" +
              subexp("%[89A-Fa-f]" + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2) +
              "|" +
              subexp("%" + HEXDIG$$2 + HEXDIG$$2)
          ),
          GEN_DELIMS$$ = "[\\:\\/\\?\\#\\[\\]\\@]",
          SUB_DELIMS$$ = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]",
          RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$),
          UCSCHAR$$ = isIRI2
            ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]"
            : "[]",
          IPRIVATE$$ = isIRI2 ? "[\\uE000-\\uF8FF]" : "[]",
          UNRESERVED$$2 = merge(ALPHA$$, DIGIT$$, "[\\-\\.\\_\\~]", UCSCHAR$$);
        subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, "[\\+\\-\\.]") + "*");
        subexp(
          subexp(
            PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\:]")
          ) + "*"
        );
        var DEC_OCTET_RELAXED$ = subexp(
            subexp("25[0-5]") +
              "|" +
              subexp("2[0-4]" + DIGIT$$) +
              "|" +
              subexp("1" + DIGIT$$ + DIGIT$$) +
              "|" +
              subexp("0?[1-9]" + DIGIT$$) +
              "|0?0?" +
              DIGIT$$
          ),
          IPV4ADDRESS$ = subexp(
            DEC_OCTET_RELAXED$ +
              "\\." +
              DEC_OCTET_RELAXED$ +
              "\\." +
              DEC_OCTET_RELAXED$ +
              "\\." +
              DEC_OCTET_RELAXED$
          ),
          H16$ = subexp(HEXDIG$$2 + "{1,4}"),
          LS32$ = subexp(subexp(H16$ + "\\:" + H16$) + "|" + IPV4ADDRESS$),
          IPV6ADDRESS1$ = subexp(subexp(H16$ + "\\:") + "{6}" + LS32$),
          IPV6ADDRESS2$ = subexp(
            "\\:\\:" + subexp(H16$ + "\\:") + "{5}" + LS32$
          ),
          IPV6ADDRESS3$ = subexp(
            subexp(H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{4}" + LS32$
          ),
          IPV6ADDRESS4$ = subexp(
            subexp(subexp(H16$ + "\\:") + "{0,1}" + H16$) +
              "?\\:\\:" +
              subexp(H16$ + "\\:") +
              "{3}" +
              LS32$
          ),
          IPV6ADDRESS5$ = subexp(
            subexp(subexp(H16$ + "\\:") + "{0,2}" + H16$) +
              "?\\:\\:" +
              subexp(H16$ + "\\:") +
              "{2}" +
              LS32$
          ),
          IPV6ADDRESS6$ = subexp(
            subexp(subexp(H16$ + "\\:") + "{0,3}" + H16$) +
              "?\\:\\:" +
              H16$ +
              "\\:" +
              LS32$
          ),
          IPV6ADDRESS7$ = subexp(
            subexp(subexp(H16$ + "\\:") + "{0,4}" + H16$) + "?\\:\\:" + LS32$
          ),
          IPV6ADDRESS8$ = subexp(
            subexp(subexp(H16$ + "\\:") + "{0,5}" + H16$) + "?\\:\\:" + H16$
          ),
          IPV6ADDRESS9$ = subexp(
            subexp(subexp(H16$ + "\\:") + "{0,6}" + H16$) + "?\\:\\:"
          ),
          IPV6ADDRESS$ = subexp(
            [
              IPV6ADDRESS1$,
              IPV6ADDRESS2$,
              IPV6ADDRESS3$,
              IPV6ADDRESS4$,
              IPV6ADDRESS5$,
              IPV6ADDRESS6$,
              IPV6ADDRESS7$,
              IPV6ADDRESS8$,
              IPV6ADDRESS9$,
            ].join("|")
          ),
          ZONEID$ = subexp(subexp(UNRESERVED$$2 + "|" + PCT_ENCODED$2) + "+");
        subexp(
          "[vV]" +
            HEXDIG$$2 +
            "+\\." +
            merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\:]") +
            "+"
        );
        subexp(
          subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$)) + "*"
        );
        var PCHAR$ = subexp(
          PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@]")
        );
        subexp(
          subexp(
            PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\@]")
          ) + "+"
        );
        subexp(subexp(PCHAR$ + "|" + merge("[\\/\\?]", IPRIVATE$$)) + "*");
        return {
          NOT_SCHEME: new RegExp(
            merge("[^]", ALPHA$$, DIGIT$$, "[\\+\\-\\.]"),
            "g"
          ),
          NOT_USERINFO: new RegExp(
            merge("[^\\%\\:]", UNRESERVED$$2, SUB_DELIMS$$),
            "g"
          ),
          NOT_HOST: new RegExp(
            merge("[^\\%\\[\\]\\:]", UNRESERVED$$2, SUB_DELIMS$$),
            "g"
          ),
          NOT_PATH: new RegExp(
            merge("[^\\%\\/\\:\\@]", UNRESERVED$$2, SUB_DELIMS$$),
            "g"
          ),
          NOT_PATH_NOSCHEME: new RegExp(
            merge("[^\\%\\/\\@]", UNRESERVED$$2, SUB_DELIMS$$),
            "g"
          ),
          NOT_QUERY: new RegExp(
            merge(
              "[^\\%]",
              UNRESERVED$$2,
              SUB_DELIMS$$,
              "[\\:\\@\\/\\?]",
              IPRIVATE$$
            ),
            "g"
          ),
          NOT_FRAGMENT: new RegExp(
            merge("[^\\%]", UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@\\/\\?]"),
            "g"
          ),
          ESCAPE: new RegExp(merge("[^]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          UNRESERVED: new RegExp(UNRESERVED$$2, "g"),
          OTHER_CHARS: new RegExp(
            merge("[^\\%]", UNRESERVED$$2, RESERVED$$),
            "g"
          ),
          PCT_ENCODED: new RegExp(PCT_ENCODED$2, "g"),
          IPV4ADDRESS: new RegExp("^(" + IPV4ADDRESS$ + ")$"),
          IPV6ADDRESS: new RegExp(
            "^\\[?(" +
              IPV6ADDRESS$ +
              ")" +
              subexp(
                subexp("\\%25|\\%(?!" + HEXDIG$$2 + "{2})") +
                  "(" +
                  ZONEID$ +
                  ")"
              ) +
              "?\\]?$"
          ),
          //RFC 6874, with relaxed parsing rules
        };
      }
      var URI_PROTOCOL = buildExps(false);
      var IRI_PROTOCOL = buildExps(true);
      var slicedToArray = (function () {
        function sliceIterator(arr, i) {
          var _arr = [];
          var _n = true;
          var _d = false;
          var _e = void 0;
          try {
            for (
              var _i = arr[Symbol.iterator](), _s;
              !(_n = (_s = _i.next()).done);
              _n = true
            ) {
              _arr.push(_s.value);
              if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;
            _e = err;
          } finally {
            try {
              if (!_n && _i["return"]) _i["return"]();
            } finally {
              if (_d) throw _e;
            }
          }
          return _arr;
        }
        return function (arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError(
              "Invalid attempt to destructure non-iterable instance"
            );
          }
        };
      })();
      var toConsumableArray = function (arr) {
        if (Array.isArray(arr)) {
          for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++)
            arr2[i] = arr[i];
          return arr2;
        } else {
          return Array.from(arr);
        }
      };
      var maxInt = 2147483647;
      var base = 36;
      var tMin = 1;
      var tMax = 26;
      var skew = 38;
      var damp = 700;
      var initialBias = 72;
      var initialN = 128;
      var delimiter = "-";
      var regexPunycode = /^xn--/;
      var regexNonASCII = /[^\0-\x7E]/;
      var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
      var errors = {
        overflow: "Overflow: input needs wider integers to process",
        "not-basic": "Illegal input >= 0x80 (not a basic code point)",
        "invalid-input": "Invalid input",
      };
      var baseMinusTMin = base - tMin;
      var floor = Math.floor;
      var stringFromCharCode = String.fromCharCode;
      function error$1(type) {
        throw new RangeError(errors[type]);
      }
      function map(array, fn) {
        var result = [];
        var length = array.length;
        while (length--) {
          result[length] = fn(array[length]);
        }
        return result;
      }
      function mapDomain(string, fn) {
        var parts = string.split("@");
        var result = "";
        if (parts.length > 1) {
          result = parts[0] + "@";
          string = parts[1];
        }
        string = string.replace(regexSeparators, ".");
        var labels = string.split(".");
        var encoded = map(labels, fn).join(".");
        return result + encoded;
      }
      function ucs2decode(string) {
        var output = [];
        var counter = 0;
        var length = string.length;
        while (counter < length) {
          var value = string.charCodeAt(counter++);
          if (value >= 55296 && value <= 56319 && counter < length) {
            var extra = string.charCodeAt(counter++);
            if ((extra & 64512) == 56320) {
              output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
            } else {
              output.push(value);
              counter--;
            }
          } else {
            output.push(value);
          }
        }
        return output;
      }
      var ucs2encode = function ucs2encode2(array) {
        return String.fromCodePoint.apply(String, toConsumableArray(array));
      };
      var basicToDigit = function basicToDigit2(codePoint) {
        if (codePoint - 48 < 10) {
          return codePoint - 22;
        }
        if (codePoint - 65 < 26) {
          return codePoint - 65;
        }
        if (codePoint - 97 < 26) {
          return codePoint - 97;
        }
        return base;
      };
      var digitToBasic = function digitToBasic2(digit, flag) {
        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
      };
      var adapt = function adapt2(delta, numPoints, firstTime) {
        var k = 0;
        delta = firstTime ? floor(delta / damp) : delta >> 1;
        delta += floor(delta / numPoints);
        for (
          ;
          /* no initialization */
          delta > (baseMinusTMin * tMax) >> 1;
          k += base
        ) {
          delta = floor(delta / baseMinusTMin);
        }
        return floor(k + ((baseMinusTMin + 1) * delta) / (delta + skew));
      };
      var decode2 = function decode3(input) {
        var output = [];
        var inputLength = input.length;
        var i = 0;
        var n = initialN;
        var bias = initialBias;
        var basic = input.lastIndexOf(delimiter);
        if (basic < 0) {
          basic = 0;
        }
        for (var j = 0; j < basic; ++j) {
          if (input.charCodeAt(j) >= 128) {
            error$1("not-basic");
          }
          output.push(input.charCodeAt(j));
        }
        for (var index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
          var oldi = i;
          for (
            var w = 1, k = base;
            ;
            /* no condition */
            k += base
          ) {
            if (index >= inputLength) {
              error$1("invalid-input");
            }
            var digit = basicToDigit(input.charCodeAt(index++));
            if (digit >= base || digit > floor((maxInt - i) / w)) {
              error$1("overflow");
            }
            i += digit * w;
            var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
            if (digit < t) {
              break;
            }
            var baseMinusT = base - t;
            if (w > floor(maxInt / baseMinusT)) {
              error$1("overflow");
            }
            w *= baseMinusT;
          }
          var out = output.length + 1;
          bias = adapt(i - oldi, out, oldi == 0);
          if (floor(i / out) > maxInt - n) {
            error$1("overflow");
          }
          n += floor(i / out);
          i %= out;
          output.splice(i++, 0, n);
        }
        return String.fromCodePoint.apply(String, output);
      };
      var encode2 = function encode3(input) {
        var output = [];
        input = ucs2decode(input);
        var inputLength = input.length;
        var n = initialN;
        var delta = 0;
        var bias = initialBias;
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = void 0;
        try {
          for (
            var _iterator = input[Symbol.iterator](), _step;
            !(_iteratorNormalCompletion = (_step = _iterator.next()).done);
            _iteratorNormalCompletion = true
          ) {
            var _currentValue2 = _step.value;
            if (_currentValue2 < 128) {
              output.push(stringFromCharCode(_currentValue2));
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
        var basicLength = output.length;
        var handledCPCount = basicLength;
        if (basicLength) {
          output.push(delimiter);
        }
        while (handledCPCount < inputLength) {
          var m = maxInt;
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = void 0;
          try {
            for (
              var _iterator2 = input[Symbol.iterator](), _step2;
              !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done);
              _iteratorNormalCompletion2 = true
            ) {
              var currentValue = _step2.value;
              if (currentValue >= n && currentValue < m) {
                m = currentValue;
              }
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2.return) {
                _iterator2.return();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }
          var handledCPCountPlusOne = handledCPCount + 1;
          if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
            error$1("overflow");
          }
          delta += (m - n) * handledCPCountPlusOne;
          n = m;
          var _iteratorNormalCompletion3 = true;
          var _didIteratorError3 = false;
          var _iteratorError3 = void 0;
          try {
            for (
              var _iterator3 = input[Symbol.iterator](), _step3;
              !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done);
              _iteratorNormalCompletion3 = true
            ) {
              var _currentValue = _step3.value;
              if (_currentValue < n && ++delta > maxInt) {
                error$1("overflow");
              }
              if (_currentValue == n) {
                var q = delta;
                for (
                  var k = base;
                  ;
                  /* no condition */
                  k += base
                ) {
                  var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                  if (q < t) {
                    break;
                  }
                  var qMinusT = q - t;
                  var baseMinusT = base - t;
                  output.push(
                    stringFromCharCode(
                      digitToBasic(t + (qMinusT % baseMinusT), 0)
                    )
                  );
                  q = floor(qMinusT / baseMinusT);
                }
                output.push(stringFromCharCode(digitToBasic(q, 0)));
                bias = adapt(
                  delta,
                  handledCPCountPlusOne,
                  handledCPCount == basicLength
                );
                delta = 0;
                ++handledCPCount;
              }
            }
          } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion3 && _iterator3.return) {
                _iterator3.return();
              }
            } finally {
              if (_didIteratorError3) {
                throw _iteratorError3;
              }
            }
          }
          ++delta;
          ++n;
        }
        return output.join("");
      };
      var toUnicode = function toUnicode2(input) {
        return mapDomain(input, function (string) {
          return regexPunycode.test(string)
            ? decode2(string.slice(4).toLowerCase())
            : string;
        });
      };
      var toASCII = function toASCII2(input) {
        return mapDomain(input, function (string) {
          return regexNonASCII.test(string) ? "xn--" + encode2(string) : string;
        });
      };
      var punycode = {
        /**
         * A string representing the current Punycode.js version number.
         * @memberOf punycode
         * @type String
         */
        version: "2.1.0",
        /**
         * An object of methods to convert from JavaScript's internal character
         * representation (UCS-2) to Unicode code points, and back.
         * @see <https://mathiasbynens.be/notes/javascript-encoding>
         * @memberOf punycode
         * @type Object
         */
        ucs2: {
          decode: ucs2decode,
          encode: ucs2encode,
        },
        decode: decode2,
        encode: encode2,
        toASCII: toASCII,
        toUnicode: toUnicode,
      };
      var SCHEMES = {};
      function pctEncChar(chr) {
        var c = chr.charCodeAt(0);
        var e = void 0;
        if (c < 16) e = "%0" + c.toString(16).toUpperCase();
        else if (c < 128) e = "%" + c.toString(16).toUpperCase();
        else if (c < 2048)
          e =
            "%" +
            ((c >> 6) | 192).toString(16).toUpperCase() +
            "%" +
            ((c & 63) | 128).toString(16).toUpperCase();
        else
          e =
            "%" +
            ((c >> 12) | 224).toString(16).toUpperCase() +
            "%" +
            (((c >> 6) & 63) | 128).toString(16).toUpperCase() +
            "%" +
            ((c & 63) | 128).toString(16).toUpperCase();
        return e;
      }
      function pctDecChars(str) {
        var newStr = "";
        var i = 0;
        var il = str.length;
        while (i < il) {
          var c = parseInt(str.substr(i + 1, 2), 16);
          if (c < 128) {
            newStr += String.fromCharCode(c);
            i += 3;
          } else if (c >= 194 && c < 224) {
            if (il - i >= 6) {
              var c2 = parseInt(str.substr(i + 4, 2), 16);
              newStr += String.fromCharCode(((c & 31) << 6) | (c2 & 63));
            } else {
              newStr += str.substr(i, 6);
            }
            i += 6;
          } else if (c >= 224) {
            if (il - i >= 9) {
              var _c = parseInt(str.substr(i + 4, 2), 16);
              var c3 = parseInt(str.substr(i + 7, 2), 16);
              newStr += String.fromCharCode(
                ((c & 15) << 12) | ((_c & 63) << 6) | (c3 & 63)
              );
            } else {
              newStr += str.substr(i, 9);
            }
            i += 9;
          } else {
            newStr += str.substr(i, 3);
            i += 3;
          }
        }
        return newStr;
      }
      function _normalizeComponentEncoding(components, protocol) {
        function decodeUnreserved2(str) {
          var decStr = pctDecChars(str);
          return !decStr.match(protocol.UNRESERVED) ? str : decStr;
        }
        if (components.scheme)
          components.scheme = String(components.scheme)
            .replace(protocol.PCT_ENCODED, decodeUnreserved2)
            .toLowerCase()
            .replace(protocol.NOT_SCHEME, "");
        if (components.userinfo !== void 0)
          components.userinfo = String(components.userinfo)
            .replace(protocol.PCT_ENCODED, decodeUnreserved2)
            .replace(protocol.NOT_USERINFO, pctEncChar)
            .replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.host !== void 0)
          components.host = String(components.host)
            .replace(protocol.PCT_ENCODED, decodeUnreserved2)
            .toLowerCase()
            .replace(protocol.NOT_HOST, pctEncChar)
            .replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.path !== void 0)
          components.path = String(components.path)
            .replace(protocol.PCT_ENCODED, decodeUnreserved2)
            .replace(
              components.scheme
                ? protocol.NOT_PATH
                : protocol.NOT_PATH_NOSCHEME,
              pctEncChar
            )
            .replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.query !== void 0)
          components.query = String(components.query)
            .replace(protocol.PCT_ENCODED, decodeUnreserved2)
            .replace(protocol.NOT_QUERY, pctEncChar)
            .replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.fragment !== void 0)
          components.fragment = String(components.fragment)
            .replace(protocol.PCT_ENCODED, decodeUnreserved2)
            .replace(protocol.NOT_FRAGMENT, pctEncChar)
            .replace(protocol.PCT_ENCODED, toUpperCase);
        return components;
      }
      function _stripLeadingZeros(str) {
        return str.replace(/^0*(.*)/, "$1") || "0";
      }
      function _normalizeIPv4(host, protocol) {
        var matches = host.match(protocol.IPV4ADDRESS) || [];
        var _matches = slicedToArray(matches, 2),
          address = _matches[1];
        if (address) {
          return address.split(".").map(_stripLeadingZeros).join(".");
        } else {
          return host;
        }
      }
      function _normalizeIPv6(host, protocol) {
        var matches = host.match(protocol.IPV6ADDRESS) || [];
        var _matches2 = slicedToArray(matches, 3),
          address = _matches2[1],
          zone = _matches2[2];
        if (address) {
          var _address$toLowerCase$ = address
              .toLowerCase()
              .split("::")
              .reverse(),
            _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2),
            last = _address$toLowerCase$2[0],
            first = _address$toLowerCase$2[1];
          var firstFields = first
            ? first.split(":").map(_stripLeadingZeros)
            : [];
          var lastFields = last.split(":").map(_stripLeadingZeros);
          var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(
            lastFields[lastFields.length - 1]
          );
          var fieldCount = isLastFieldIPv4Address ? 7 : 8;
          var lastFieldsStart = lastFields.length - fieldCount;
          var fields = Array(fieldCount);
          for (var x = 0; x < fieldCount; ++x) {
            fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || "";
          }
          if (isLastFieldIPv4Address) {
            fields[fieldCount - 1] = _normalizeIPv4(
              fields[fieldCount - 1],
              protocol
            );
          }
          var allZeroFields = fields.reduce(function (acc, field, index) {
            if (!field || field === "0") {
              var lastLongest = acc[acc.length - 1];
              if (
                lastLongest &&
                lastLongest.index + lastLongest.length === index
              ) {
                lastLongest.length++;
              } else {
                acc.push({ index, length: 1 });
              }
            }
            return acc;
          }, []);
          var longestZeroFields = allZeroFields.sort(function (a, b) {
            return b.length - a.length;
          })[0];
          var newHost = void 0;
          if (longestZeroFields && longestZeroFields.length > 1) {
            var newFirst = fields.slice(0, longestZeroFields.index);
            var newLast = fields.slice(
              longestZeroFields.index + longestZeroFields.length
            );
            newHost = newFirst.join(":") + "::" + newLast.join(":");
          } else {
            newHost = fields.join(":");
          }
          if (zone) {
            newHost += "%" + zone;
          }
          return newHost;
        } else {
          return host;
        }
      }
      var URI_PARSE =
        /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i;
      var NO_MATCH_IS_UNDEFINED = "".match(/(){0}/)[1] === void 0;
      function parse(uriString) {
        var options =
          arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var components = {};
        var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
        if (options.reference === "suffix")
          uriString =
            (options.scheme ? options.scheme + ":" : "") + "//" + uriString;
        var matches = uriString.match(URI_PARSE);
        if (matches) {
          if (NO_MATCH_IS_UNDEFINED) {
            components.scheme = matches[1];
            components.userinfo = matches[3];
            components.host = matches[4];
            components.port = parseInt(matches[5], 10);
            components.path = matches[6] || "";
            components.query = matches[7];
            components.fragment = matches[8];
            if (isNaN(components.port)) {
              components.port = matches[5];
            }
          } else {
            components.scheme = matches[1] || void 0;
            components.userinfo =
              uriString.indexOf("@") !== -1 ? matches[3] : void 0;
            components.host =
              uriString.indexOf("//") !== -1 ? matches[4] : void 0;
            components.port = parseInt(matches[5], 10);
            components.path = matches[6] || "";
            components.query =
              uriString.indexOf("?") !== -1 ? matches[7] : void 0;
            components.fragment =
              uriString.indexOf("#") !== -1 ? matches[8] : void 0;
            if (isNaN(components.port)) {
              components.port = uriString.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/)
                ? matches[4]
                : void 0;
            }
          }
          if (components.host) {
            components.host = _normalizeIPv6(
              _normalizeIPv4(components.host, protocol),
              protocol
            );
          }
          if (
            components.scheme === void 0 &&
            components.userinfo === void 0 &&
            components.host === void 0 &&
            components.port === void 0 &&
            !components.path &&
            components.query === void 0
          ) {
            components.reference = "same-document";
          } else if (components.scheme === void 0) {
            components.reference = "relative";
          } else if (components.fragment === void 0) {
            components.reference = "absolute";
          } else {
            components.reference = "uri";
          }
          if (
            options.reference &&
            options.reference !== "suffix" &&
            options.reference !== components.reference
          ) {
            components.error =
              components.error ||
              "URI is not a " + options.reference + " reference.";
          }
          var schemeHandler =
            SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
          if (
            !options.unicodeSupport &&
            (!schemeHandler || !schemeHandler.unicodeSupport)
          ) {
            if (
              components.host &&
              (options.domainHost ||
                (schemeHandler && schemeHandler.domainHost))
            ) {
              try {
                components.host = punycode.toASCII(
                  components.host
                    .replace(protocol.PCT_ENCODED, pctDecChars)
                    .toLowerCase()
                );
              } catch (e) {
                components.error =
                  components.error ||
                  "Host's domain name can not be converted to ASCII via punycode: " +
                    e;
              }
            }
            _normalizeComponentEncoding(components, URI_PROTOCOL);
          } else {
            _normalizeComponentEncoding(components, protocol);
          }
          if (schemeHandler && schemeHandler.parse) {
            schemeHandler.parse(components, options);
          }
        } else {
          components.error = components.error || "URI can not be parsed.";
        }
        return components;
      }
      function _recomposeAuthority(components, options) {
        var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
        var uriTokens = [];
        if (components.userinfo !== void 0) {
          uriTokens.push(components.userinfo);
          uriTokens.push("@");
        }
        if (components.host !== void 0) {
          uriTokens.push(
            _normalizeIPv6(
              _normalizeIPv4(String(components.host), protocol),
              protocol
            ).replace(protocol.IPV6ADDRESS, function (_, $1, $2) {
              return "[" + $1 + ($2 ? "%25" + $2 : "") + "]";
            })
          );
        }
        if (
          typeof components.port === "number" ||
          typeof components.port === "string"
        ) {
          uriTokens.push(":");
          uriTokens.push(String(components.port));
        }
        return uriTokens.length ? uriTokens.join("") : void 0;
      }
      var RDS1 = /^\.\.?\//;
      var RDS2 = /^\/\.(\/|$)/;
      var RDS3 = /^\/\.\.(\/|$)/;
      var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/;
      function removeDotSegments(input) {
        var output = [];
        while (input.length) {
          if (input.match(RDS1)) {
            input = input.replace(RDS1, "");
          } else if (input.match(RDS2)) {
            input = input.replace(RDS2, "/");
          } else if (input.match(RDS3)) {
            input = input.replace(RDS3, "/");
            output.pop();
          } else if (input === "." || input === "..") {
            input = "";
          } else {
            var im = input.match(RDS5);
            if (im) {
              var s = im[0];
              input = input.slice(s.length);
              output.push(s);
            } else {
              throw new Error("Unexpected dot segment condition");
            }
          }
        }
        return output.join("");
      }
      function serialize(components) {
        var options =
          arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;
        var uriTokens = [];
        var schemeHandler =
          SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
        if (schemeHandler && schemeHandler.serialize)
          schemeHandler.serialize(components, options);
        if (components.host) {
          if (protocol.IPV6ADDRESS.test(components.host));
          else if (
            options.domainHost ||
            (schemeHandler && schemeHandler.domainHost)
          ) {
            try {
              components.host = !options.iri
                ? punycode.toASCII(
                    components.host
                      .replace(protocol.PCT_ENCODED, pctDecChars)
                      .toLowerCase()
                  )
                : punycode.toUnicode(components.host);
            } catch (e) {
              components.error =
                components.error ||
                "Host's domain name can not be converted to " +
                  (!options.iri ? "ASCII" : "Unicode") +
                  " via punycode: " +
                  e;
            }
          }
        }
        _normalizeComponentEncoding(components, protocol);
        if (options.reference !== "suffix" && components.scheme) {
          uriTokens.push(components.scheme);
          uriTokens.push(":");
        }
        var authority = _recomposeAuthority(components, options);
        if (authority !== void 0) {
          if (options.reference !== "suffix") {
            uriTokens.push("//");
          }
          uriTokens.push(authority);
          if (components.path && components.path.charAt(0) !== "/") {
            uriTokens.push("/");
          }
        }
        if (components.path !== void 0) {
          var s = components.path;
          if (
            !options.absolutePath &&
            (!schemeHandler || !schemeHandler.absolutePath)
          ) {
            s = removeDotSegments(s);
          }
          if (authority === void 0) {
            s = s.replace(/^\/\//, "/%2F");
          }
          uriTokens.push(s);
        }
        if (components.query !== void 0) {
          uriTokens.push("?");
          uriTokens.push(components.query);
        }
        if (components.fragment !== void 0) {
          uriTokens.push("#");
          uriTokens.push(components.fragment);
        }
        return uriTokens.join("");
      }
      function resolveComponents(base2, relative) {
        var options =
          arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        var skipNormalization = arguments[3];
        var target = {};
        if (!skipNormalization) {
          base2 = parse(serialize(base2, options), options);
          relative = parse(serialize(relative, options), options);
        }
        options = options || {};
        if (!options.tolerant && relative.scheme) {
          target.scheme = relative.scheme;
          target.userinfo = relative.userinfo;
          target.host = relative.host;
          target.port = relative.port;
          target.path = removeDotSegments(relative.path || "");
          target.query = relative.query;
        } else {
          if (
            relative.userinfo !== void 0 ||
            relative.host !== void 0 ||
            relative.port !== void 0
          ) {
            target.userinfo = relative.userinfo;
            target.host = relative.host;
            target.port = relative.port;
            target.path = removeDotSegments(relative.path || "");
            target.query = relative.query;
          } else {
            if (!relative.path) {
              target.path = base2.path;
              if (relative.query !== void 0) {
                target.query = relative.query;
              } else {
                target.query = base2.query;
              }
            } else {
              if (relative.path.charAt(0) === "/") {
                target.path = removeDotSegments(relative.path);
              } else {
                if (
                  (base2.userinfo !== void 0 ||
                    base2.host !== void 0 ||
                    base2.port !== void 0) &&
                  !base2.path
                ) {
                  target.path = "/" + relative.path;
                } else if (!base2.path) {
                  target.path = relative.path;
                } else {
                  target.path =
                    base2.path.slice(0, base2.path.lastIndexOf("/") + 1) +
                    relative.path;
                }
                target.path = removeDotSegments(target.path);
              }
              target.query = relative.query;
            }
            target.userinfo = base2.userinfo;
            target.host = base2.host;
            target.port = base2.port;
          }
          target.scheme = base2.scheme;
        }
        target.fragment = relative.fragment;
        return target;
      }
      function resolve(baseURI, relativeURI, options) {
        var schemelessOptions = assign({ scheme: "null" }, options);
        return serialize(
          resolveComponents(
            parse(baseURI, schemelessOptions),
            parse(relativeURI, schemelessOptions),
            schemelessOptions,
            true
          ),
          schemelessOptions
        );
      }
      function normalize(uri, options) {
        if (typeof uri === "string") {
          uri = serialize(parse(uri, options), options);
        } else if (typeOf(uri) === "object") {
          uri = parse(serialize(uri, options), options);
        }
        return uri;
      }
      function equal(uriA, uriB, options) {
        if (typeof uriA === "string") {
          uriA = serialize(parse(uriA, options), options);
        } else if (typeOf(uriA) === "object") {
          uriA = serialize(uriA, options);
        }
        if (typeof uriB === "string") {
          uriB = serialize(parse(uriB, options), options);
        } else if (typeOf(uriB) === "object") {
          uriB = serialize(uriB, options);
        }
        return uriA === uriB;
      }
      function escapeComponent(str, options) {
        return (
          str &&
          str
            .toString()
            .replace(
              !options || !options.iri
                ? URI_PROTOCOL.ESCAPE
                : IRI_PROTOCOL.ESCAPE,
              pctEncChar
            )
        );
      }
      function unescapeComponent(str, options) {
        return (
          str &&
          str
            .toString()
            .replace(
              !options || !options.iri
                ? URI_PROTOCOL.PCT_ENCODED
                : IRI_PROTOCOL.PCT_ENCODED,
              pctDecChars
            )
        );
      }
      var handler = {
        scheme: "http",
        domainHost: true,
        parse: function parse2(components, options) {
          if (!components.host) {
            components.error =
              components.error || "HTTP URIs must have a host.";
          }
          return components;
        },
        serialize: function serialize2(components, options) {
          var secure = String(components.scheme).toLowerCase() === "https";
          if (
            components.port === (secure ? 443 : 80) ||
            components.port === ""
          ) {
            components.port = void 0;
          }
          if (!components.path) {
            components.path = "/";
          }
          return components;
        },
      };
      var handler$1 = {
        scheme: "https",
        domainHost: handler.domainHost,
        parse: handler.parse,
        serialize: handler.serialize,
      };
      function isSecure(wsComponents) {
        return typeof wsComponents.secure === "boolean"
          ? wsComponents.secure
          : String(wsComponents.scheme).toLowerCase() === "wss";
      }
      var handler$2 = {
        scheme: "ws",
        domainHost: true,
        parse: function parse2(components, options) {
          var wsComponents = components;
          wsComponents.secure = isSecure(wsComponents);
          wsComponents.resourceName =
            (wsComponents.path || "/") +
            (wsComponents.query ? "?" + wsComponents.query : "");
          wsComponents.path = void 0;
          wsComponents.query = void 0;
          return wsComponents;
        },
        serialize: function serialize2(wsComponents, options) {
          if (
            wsComponents.port === (isSecure(wsComponents) ? 443 : 80) ||
            wsComponents.port === ""
          ) {
            wsComponents.port = void 0;
          }
          if (typeof wsComponents.secure === "boolean") {
            wsComponents.scheme = wsComponents.secure ? "wss" : "ws";
            wsComponents.secure = void 0;
          }
          if (wsComponents.resourceName) {
            var _wsComponents$resourc = wsComponents.resourceName.split("?"),
              _wsComponents$resourc2 = slicedToArray(_wsComponents$resourc, 2),
              path = _wsComponents$resourc2[0],
              query = _wsComponents$resourc2[1];
            wsComponents.path = path && path !== "/" ? path : void 0;
            wsComponents.query = query;
            wsComponents.resourceName = void 0;
          }
          wsComponents.fragment = void 0;
          return wsComponents;
        },
      };
      var handler$3 = {
        scheme: "wss",
        domainHost: handler$2.domainHost,
        parse: handler$2.parse,
        serialize: handler$2.serialize,
      };
      var O = {};
      var UNRESERVED$$ =
        "[A-Za-z0-9\\-\\.\\_\\~" +
        "\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF" +
        "]";
      var HEXDIG$$ = "[0-9A-Fa-f]";
      var PCT_ENCODED$ = subexp(
        subexp(
          "%[EFef]" +
            HEXDIG$$ +
            "%" +
            HEXDIG$$ +
            HEXDIG$$ +
            "%" +
            HEXDIG$$ +
            HEXDIG$$
        ) +
          "|" +
          subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) +
          "|" +
          subexp("%" + HEXDIG$$ + HEXDIG$$)
      );
      var ATEXT$$ = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]";
      var QTEXT$$ =
        "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]";
      var VCHAR$$ = merge(QTEXT$$, '[\\"\\\\]');
      var SOME_DELIMS$$ = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]";
      var UNRESERVED = new RegExp(UNRESERVED$$, "g");
      var PCT_ENCODED = new RegExp(PCT_ENCODED$, "g");
      var NOT_LOCAL_PART = new RegExp(
        merge("[^]", ATEXT$$, "[\\.]", '[\\"]', VCHAR$$),
        "g"
      );
      var NOT_HFNAME = new RegExp(
        merge("[^]", UNRESERVED$$, SOME_DELIMS$$),
        "g"
      );
      var NOT_HFVALUE = NOT_HFNAME;
      function decodeUnreserved(str) {
        var decStr = pctDecChars(str);
        return !decStr.match(UNRESERVED) ? str : decStr;
      }
      var handler$4 = {
        scheme: "mailto",
        parse: function parse$$1(components, options) {
          var mailtoComponents = components;
          var to = (mailtoComponents.to = mailtoComponents.path
            ? mailtoComponents.path.split(",")
            : []);
          mailtoComponents.path = void 0;
          if (mailtoComponents.query) {
            var unknownHeaders = false;
            var headers = {};
            var hfields = mailtoComponents.query.split("&");
            for (var x = 0, xl = hfields.length; x < xl; ++x) {
              var hfield = hfields[x].split("=");
              switch (hfield[0]) {
                case "to":
                  var toAddrs = hfield[1].split(",");
                  for (var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) {
                    to.push(toAddrs[_x]);
                  }
                  break;
                case "subject":
                  mailtoComponents.subject = unescapeComponent(
                    hfield[1],
                    options
                  );
                  break;
                case "body":
                  mailtoComponents.body = unescapeComponent(hfield[1], options);
                  break;
                default:
                  unknownHeaders = true;
                  headers[unescapeComponent(hfield[0], options)] =
                    unescapeComponent(hfield[1], options);
                  break;
              }
            }
            if (unknownHeaders) mailtoComponents.headers = headers;
          }
          mailtoComponents.query = void 0;
          for (var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2) {
            var addr = to[_x2].split("@");
            addr[0] = unescapeComponent(addr[0]);
            if (!options.unicodeSupport) {
              try {
                addr[1] = punycode.toASCII(
                  unescapeComponent(addr[1], options).toLowerCase()
                );
              } catch (e) {
                mailtoComponents.error =
                  mailtoComponents.error ||
                  "Email address's domain name can not be converted to ASCII via punycode: " +
                    e;
              }
            } else {
              addr[1] = unescapeComponent(addr[1], options).toLowerCase();
            }
            to[_x2] = addr.join("@");
          }
          return mailtoComponents;
        },
        serialize: function serialize$$1(mailtoComponents, options) {
          var components = mailtoComponents;
          var to = toArray(mailtoComponents.to);
          if (to) {
            for (var x = 0, xl = to.length; x < xl; ++x) {
              var toAddr = String(to[x]);
              var atIdx = toAddr.lastIndexOf("@");
              var localPart = toAddr
                .slice(0, atIdx)
                .replace(PCT_ENCODED, decodeUnreserved)
                .replace(PCT_ENCODED, toUpperCase)
                .replace(NOT_LOCAL_PART, pctEncChar);
              var domain = toAddr.slice(atIdx + 1);
              try {
                domain = !options.iri
                  ? punycode.toASCII(
                      unescapeComponent(domain, options).toLowerCase()
                    )
                  : punycode.toUnicode(domain);
              } catch (e) {
                components.error =
                  components.error ||
                  "Email address's domain name can not be converted to " +
                    (!options.iri ? "ASCII" : "Unicode") +
                    " via punycode: " +
                    e;
              }
              to[x] = localPart + "@" + domain;
            }
            components.path = to.join(",");
          }
          var headers = (mailtoComponents.headers =
            mailtoComponents.headers || {});
          if (mailtoComponents.subject)
            headers["subject"] = mailtoComponents.subject;
          if (mailtoComponents.body) headers["body"] = mailtoComponents.body;
          var fields = [];
          for (var name in headers) {
            if (headers[name] !== O[name]) {
              fields.push(
                name
                  .replace(PCT_ENCODED, decodeUnreserved)
                  .replace(PCT_ENCODED, toUpperCase)
                  .replace(NOT_HFNAME, pctEncChar) +
                  "=" +
                  headers[name]
                    .replace(PCT_ENCODED, decodeUnreserved)
                    .replace(PCT_ENCODED, toUpperCase)
                    .replace(NOT_HFVALUE, pctEncChar)
              );
            }
          }
          if (fields.length) {
            components.query = fields.join("&");
          }
          return components;
        },
      };
      var URN_PARSE = /^([^\:]+)\:(.*)/;
      var handler$5 = {
        scheme: "urn",
        parse: function parse$$1(components, options) {
          var matches = components.path && components.path.match(URN_PARSE);
          var urnComponents = components;
          if (matches) {
            var scheme = options.scheme || urnComponents.scheme || "urn";
            var nid = matches[1].toLowerCase();
            var nss = matches[2];
            var urnScheme = scheme + ":" + (options.nid || nid);
            var schemeHandler = SCHEMES[urnScheme];
            urnComponents.nid = nid;
            urnComponents.nss = nss;
            urnComponents.path = void 0;
            if (schemeHandler) {
              urnComponents = schemeHandler.parse(urnComponents, options);
            }
          } else {
            urnComponents.error =
              urnComponents.error || "URN can not be parsed.";
          }
          return urnComponents;
        },
        serialize: function serialize$$1(urnComponents, options) {
          var scheme = options.scheme || urnComponents.scheme || "urn";
          var nid = urnComponents.nid;
          var urnScheme = scheme + ":" + (options.nid || nid);
          var schemeHandler = SCHEMES[urnScheme];
          if (schemeHandler) {
            urnComponents = schemeHandler.serialize(urnComponents, options);
          }
          var uriComponents = urnComponents;
          var nss = urnComponents.nss;
          uriComponents.path = (nid || options.nid) + ":" + nss;
          return uriComponents;
        },
      };
      var UUID = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/;
      var handler$6 = {
        scheme: "urn:uuid",
        parse: function parse2(urnComponents, options) {
          var uuidComponents = urnComponents;
          uuidComponents.uuid = uuidComponents.nss;
          uuidComponents.nss = void 0;
          if (
            !options.tolerant &&
            (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))
          ) {
            uuidComponents.error = uuidComponents.error || "UUID is not valid.";
          }
          return uuidComponents;
        },
        serialize: function serialize2(uuidComponents, options) {
          var urnComponents = uuidComponents;
          urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
          return urnComponents;
        },
      };
      SCHEMES[handler.scheme] = handler;
      SCHEMES[handler$1.scheme] = handler$1;
      SCHEMES[handler$2.scheme] = handler$2;
      SCHEMES[handler$3.scheme] = handler$3;
      SCHEMES[handler$4.scheme] = handler$4;
      SCHEMES[handler$5.scheme] = handler$5;
      SCHEMES[handler$6.scheme] = handler$6;
      exports3.SCHEMES = SCHEMES;
      exports3.pctEncChar = pctEncChar;
      exports3.pctDecChars = pctDecChars;
      exports3.parse = parse;
      exports3.removeDotSegments = removeDotSegments;
      exports3.serialize = serialize;
      exports3.resolveComponents = resolveComponents;
      exports3.resolve = resolve;
      exports3.normalize = normalize;
      exports3.equal = equal;
      exports3.escapeComponent = escapeComponent;
      exports3.unescapeComponent = unescapeComponent;
      Object.defineProperty(exports3, "__esModule", { value: true });
    });
  },
});

// node_modules/@near-js/accounts/node_modules/ajv/dist/runtime/uri.js
var require_uri = __commonJS({
  "node_modules/@near-js/accounts/node_modules/ajv/dist/runtime/uri.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var uri = require_uri_all();
    uri.code = 'require("ajv/dist/runtime/uri").default';
    exports2.default = uri;
  },
});

// node_modules/@near-js/accounts/node_modules/ajv/dist/core.js
var require_core = __commonJS({
  "node_modules/@near-js/accounts/node_modules/ajv/dist/core.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CodeGen =
      exports2.Name =
      exports2.nil =
      exports2.stringify =
      exports2.str =
      exports2._ =
      exports2.KeywordCxt =
        void 0;
    var validate_1 = require_validate();
    Object.defineProperty(exports2, "KeywordCxt", {
      enumerable: true,
      get: function () {
        return validate_1.KeywordCxt;
      },
    });
    var codegen_1 = require_codegen();
    Object.defineProperty(exports2, "_", {
      enumerable: true,
      get: function () {
        return codegen_1._;
      },
    });
    Object.defineProperty(exports2, "str", {
      enumerable: true,
      get: function () {
        return codegen_1.str;
      },
    });
    Object.defineProperty(exports2, "stringify", {
      enumerable: true,
      get: function () {
        return codegen_1.stringify;
      },
    });
    Object.defineProperty(exports2, "nil", {
      enumerable: true,
      get: function () {
        return codegen_1.nil;
      },
    });
    Object.defineProperty(exports2, "Name", {
      enumerable: true,
      get: function () {
        return codegen_1.Name;
      },
    });
    Object.defineProperty(exports2, "CodeGen", {
      enumerable: true,
      get: function () {
        return codegen_1.CodeGen;
      },
    });
    var validation_error_1 = require_validation_error();
    var ref_error_1 = require_ref_error();
    var rules_1 = require_rules();
    var compile_1 = require_compile();
    var codegen_2 = require_codegen();
    var resolve_1 = require_resolve();
    var dataType_1 = require_dataType();
    var util_1 = require_util();
    var $dataRefSchema = require_data();
    var uri_1 = require_uri();
    var defaultRegExp = (str, flags) => new RegExp(str, flags);
    defaultRegExp.code = "new RegExp";
    var META_IGNORE_OPTIONS = [
      "removeAdditional",
      "useDefaults",
      "coerceTypes",
    ];
    var EXT_SCOPE_NAMES = /* @__PURE__ */ new Set([
      "validate",
      "serialize",
      "parse",
      "wrapper",
      "root",
      "schema",
      "keyword",
      "pattern",
      "formats",
      "validate$data",
      "func",
      "obj",
      "Error",
    ]);
    var removedOptions = {
      errorDataPath: "",
      format: "`validateFormats: false` can be used instead.",
      nullable: '"nullable" keyword is supported by default.',
      jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
      extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
      missingRefs:
        "Pass empty schema with $id that should be ignored to ajv.addSchema.",
      processCode:
        "Use option `code: {process: (code, schemaEnv: object) => string}`",
      sourceCode: "Use option `code: {source: true}`",
      strictDefaults: "It is default now, see option `strict`.",
      strictKeywords: "It is default now, see option `strict`.",
      uniqueItems: '"uniqueItems" keyword is always validated.',
      unknownFormats:
        "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
      cache: "Map is used as cache, schema object as key.",
      serialize: "Map is used as cache, schema object as key.",
      ajvErrors: "It is default now.",
    };
    var deprecatedOptions = {
      ignoreKeywordsWithRef: "",
      jsPropertySyntax: "",
      unicode:
        '"minLength"/"maxLength" account for unicode characters by default.',
    };
    var MAX_EXPRESSION = 200;
    function requiredOptions(o) {
      var _a,
        _b,
        _c,
        _d,
        _e,
        _f,
        _g,
        _h,
        _j,
        _k,
        _l,
        _m,
        _o,
        _p,
        _q,
        _r,
        _s,
        _t,
        _u,
        _v,
        _w,
        _x,
        _y,
        _z,
        _0;
      const s = o.strict;
      const _optz =
        (_a = o.code) === null || _a === void 0 ? void 0 : _a.optimize;
      const optimize = _optz === true || _optz === void 0 ? 1 : _optz || 0;
      const regExp =
        (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !==
          null && _c !== void 0
          ? _c
          : defaultRegExp;
      const uriResolver =
        (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;
      return {
        strictSchema:
          (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !==
            null && _f !== void 0
            ? _f
            : true,
        strictNumbers:
          (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !==
            null && _h !== void 0
            ? _h
            : true,
        strictTypes:
          (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !==
            null && _k !== void 0
            ? _k
            : "log",
        strictTuples:
          (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !==
            null && _m !== void 0
            ? _m
            : "log",
        strictRequired:
          (_p = (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s) !==
            null && _p !== void 0
            ? _p
            : false,
        code: o.code ? { ...o.code, optimize, regExp } : { optimize, regExp },
        loopRequired:
          (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,
        loopEnum:
          (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,
        meta: (_s = o.meta) !== null && _s !== void 0 ? _s : true,
        messages: (_t = o.messages) !== null && _t !== void 0 ? _t : true,
        inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : true,
        schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : "$id",
        addUsedSchema:
          (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,
        validateSchema:
          (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,
        validateFormats:
          (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,
        unicodeRegExp:
          (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,
        int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,
        uriResolver,
      };
    }
    var Ajv = class {
      constructor(opts = {}) {
        this.schemas = {};
        this.refs = {};
        this.formats = {};
        this._compilations = /* @__PURE__ */ new Set();
        this._loading = {};
        this._cache = /* @__PURE__ */ new Map();
        opts = this.opts = { ...opts, ...requiredOptions(opts) };
        const { es5, lines } = this.opts.code;
        this.scope = new codegen_2.ValueScope({
          scope: {},
          prefixes: EXT_SCOPE_NAMES,
          es5,
          lines,
        });
        this.logger = getLogger(opts.logger);
        const formatOpt = opts.validateFormats;
        opts.validateFormats = false;
        this.RULES = (0, rules_1.getRules)();
        checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
        checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
        this._metaOpts = getMetaSchemaOptions.call(this);
        if (opts.formats) addInitialFormats.call(this);
        this._addVocabularies();
        this._addDefaultMetaSchema();
        if (opts.keywords) addInitialKeywords.call(this, opts.keywords);
        if (typeof opts.meta == "object") this.addMetaSchema(opts.meta);
        addInitialSchemas.call(this);
        opts.validateFormats = formatOpt;
      }
      _addVocabularies() {
        this.addKeyword("$async");
      }
      _addDefaultMetaSchema() {
        const { $data, meta, schemaId } = this.opts;
        let _dataRefSchema = $dataRefSchema;
        if (schemaId === "id") {
          _dataRefSchema = { ...$dataRefSchema };
          _dataRefSchema.id = _dataRefSchema.$id;
          delete _dataRefSchema.$id;
        }
        if (meta && $data)
          this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
      }
      defaultMeta() {
        const { meta, schemaId } = this.opts;
        return (this.opts.defaultMeta =
          typeof meta == "object" ? meta[schemaId] || meta : void 0);
      }
      validate(schemaKeyRef, data) {
        let v;
        if (typeof schemaKeyRef == "string") {
          v = this.getSchema(schemaKeyRef);
          if (!v)
            throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
        } else {
          v = this.compile(schemaKeyRef);
        }
        const valid = v(data);
        if (!("$async" in v)) this.errors = v.errors;
        return valid;
      }
      compile(schema, _meta) {
        const sch = this._addSchema(schema, _meta);
        return sch.validate || this._compileSchemaEnv(sch);
      }
      compileAsync(schema, meta) {
        if (typeof this.opts.loadSchema != "function") {
          throw new Error("options.loadSchema should be a function");
        }
        const { loadSchema } = this.opts;
        return runCompileAsync.call(this, schema, meta);
        async function runCompileAsync(_schema, _meta) {
          await loadMetaSchema.call(this, _schema.$schema);
          const sch = this._addSchema(_schema, _meta);
          return sch.validate || _compileAsync.call(this, sch);
        }
        async function loadMetaSchema($ref) {
          if ($ref && !this.getSchema($ref)) {
            await runCompileAsync.call(this, { $ref }, true);
          }
        }
        async function _compileAsync(sch) {
          try {
            return this._compileSchemaEnv(sch);
          } catch (e) {
            if (!(e instanceof ref_error_1.default)) throw e;
            checkLoaded.call(this, e);
            await loadMissingSchema.call(this, e.missingSchema);
            return _compileAsync.call(this, sch);
          }
        }
        function checkLoaded({ missingSchema: ref, missingRef }) {
          if (this.refs[ref]) {
            throw new Error(
              `AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`
            );
          }
        }
        async function loadMissingSchema(ref) {
          const _schema = await _loadSchema.call(this, ref);
          if (!this.refs[ref]) await loadMetaSchema.call(this, _schema.$schema);
          if (!this.refs[ref]) this.addSchema(_schema, ref, meta);
        }
        async function _loadSchema(ref) {
          const p = this._loading[ref];
          if (p) return p;
          try {
            return await (this._loading[ref] = loadSchema(ref));
          } finally {
            delete this._loading[ref];
          }
        }
      }
      // Adds schema to the instance
      addSchema(
        schema,
        key,
        _meta,
        _validateSchema = this.opts.validateSchema
      ) {
        if (Array.isArray(schema)) {
          for (const sch of schema)
            this.addSchema(sch, void 0, _meta, _validateSchema);
          return this;
        }
        let id;
        if (typeof schema === "object") {
          const { schemaId } = this.opts;
          id = schema[schemaId];
          if (id !== void 0 && typeof id != "string") {
            throw new Error(`schema ${schemaId} must be string`);
          }
        }
        key = (0, resolve_1.normalizeId)(key || id);
        this._checkUnique(key);
        this.schemas[key] = this._addSchema(
          schema,
          _meta,
          key,
          _validateSchema,
          true
        );
        return this;
      }
      // Add schema that will be used to validate other schemas
      // options in META_IGNORE_OPTIONS are alway set to false
      addMetaSchema(schema, key, _validateSchema = this.opts.validateSchema) {
        this.addSchema(schema, key, true, _validateSchema);
        return this;
      }
      //  Validate schema against its meta-schema
      validateSchema(schema, throwOrLogError) {
        if (typeof schema == "boolean") return true;
        let $schema;
        $schema = schema.$schema;
        if ($schema !== void 0 && typeof $schema != "string") {
          throw new Error("$schema must be a string");
        }
        $schema = $schema || this.opts.defaultMeta || this.defaultMeta();
        if (!$schema) {
          this.logger.warn("meta-schema not available");
          this.errors = null;
          return true;
        }
        const valid = this.validate($schema, schema);
        if (!valid && throwOrLogError) {
          const message = "schema is invalid: " + this.errorsText();
          if (this.opts.validateSchema === "log") this.logger.error(message);
          else throw new Error(message);
        }
        return valid;
      }
      // Get compiled schema by `key` or `ref`.
      // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
      getSchema(keyRef) {
        let sch;
        while (typeof (sch = getSchEnv.call(this, keyRef)) == "string")
          keyRef = sch;
        if (sch === void 0) {
          const { schemaId } = this.opts;
          const root2 = new compile_1.SchemaEnv({ schema: {}, schemaId });
          sch = compile_1.resolveSchema.call(this, root2, keyRef);
          if (!sch) return;
          this.refs[keyRef] = sch;
        }
        return sch.validate || this._compileSchemaEnv(sch);
      }
      // Remove cached schema(s).
      // If no parameter is passed all schemas but meta-schemas are removed.
      // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
      // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
      removeSchema(schemaKeyRef) {
        if (schemaKeyRef instanceof RegExp) {
          this._removeAllSchemas(this.schemas, schemaKeyRef);
          this._removeAllSchemas(this.refs, schemaKeyRef);
          return this;
        }
        switch (typeof schemaKeyRef) {
          case "undefined":
            this._removeAllSchemas(this.schemas);
            this._removeAllSchemas(this.refs);
            this._cache.clear();
            return this;
          case "string": {
            const sch = getSchEnv.call(this, schemaKeyRef);
            if (typeof sch == "object") this._cache.delete(sch.schema);
            delete this.schemas[schemaKeyRef];
            delete this.refs[schemaKeyRef];
            return this;
          }
          case "object": {
            const cacheKey = schemaKeyRef;
            this._cache.delete(cacheKey);
            let id = schemaKeyRef[this.opts.schemaId];
            if (id) {
              id = (0, resolve_1.normalizeId)(id);
              delete this.schemas[id];
              delete this.refs[id];
            }
            return this;
          }
          default:
            throw new Error("ajv.removeSchema: invalid parameter");
        }
      }
      // add "vocabulary" - a collection of keywords
      addVocabulary(definitions) {
        for (const def of definitions) this.addKeyword(def);
        return this;
      }
      addKeyword(kwdOrDef, def) {
        let keyword;
        if (typeof kwdOrDef == "string") {
          keyword = kwdOrDef;
          if (typeof def == "object") {
            this.logger.warn(
              "these parameters are deprecated, see docs for addKeyword"
            );
            def.keyword = keyword;
          }
        } else if (typeof kwdOrDef == "object" && def === void 0) {
          def = kwdOrDef;
          keyword = def.keyword;
          if (Array.isArray(keyword) && !keyword.length) {
            throw new Error(
              "addKeywords: keyword must be string or non-empty array"
            );
          }
        } else {
          throw new Error("invalid addKeywords parameters");
        }
        checkKeyword.call(this, keyword, def);
        if (!def) {
          (0, util_1.eachItem)(keyword, (kwd) => addRule.call(this, kwd));
          return this;
        }
        keywordMetaschema.call(this, def);
        const definition = {
          ...def,
          type: (0, dataType_1.getJSONTypes)(def.type),
          schemaType: (0, dataType_1.getJSONTypes)(def.schemaType),
        };
        (0, util_1.eachItem)(
          keyword,
          definition.type.length === 0
            ? (k) => addRule.call(this, k, definition)
            : (k) =>
                definition.type.forEach((t) =>
                  addRule.call(this, k, definition, t)
                )
        );
        return this;
      }
      getKeyword(keyword) {
        const rule = this.RULES.all[keyword];
        return typeof rule == "object" ? rule.definition : !!rule;
      }
      // Remove keyword
      removeKeyword(keyword) {
        const { RULES } = this;
        delete RULES.keywords[keyword];
        delete RULES.all[keyword];
        for (const group of RULES.rules) {
          const i = group.rules.findIndex((rule) => rule.keyword === keyword);
          if (i >= 0) group.rules.splice(i, 1);
        }
        return this;
      }
      // Add format
      addFormat(name, format) {
        if (typeof format == "string") format = new RegExp(format);
        this.formats[name] = format;
        return this;
      }
      errorsText(
        errors = this.errors,
        { separator = ", ", dataVar = "data" } = {}
      ) {
        if (!errors || errors.length === 0) return "No errors";
        return errors
          .map((e) => `${dataVar}${e.instancePath} ${e.message}`)
          .reduce((text, msg) => text + separator + msg);
      }
      $dataMetaSchema(metaSchema, keywordsJsonPointers) {
        const rules = this.RULES.all;
        metaSchema = JSON.parse(JSON.stringify(metaSchema));
        for (const jsonPointer of keywordsJsonPointers) {
          const segments = jsonPointer.split("/").slice(1);
          let keywords = metaSchema;
          for (const seg of segments) keywords = keywords[seg];
          for (const key in rules) {
            const rule = rules[key];
            if (typeof rule != "object") continue;
            const { $data } = rule.definition;
            const schema = keywords[key];
            if ($data && schema) keywords[key] = schemaOrData(schema);
          }
        }
        return metaSchema;
      }
      _removeAllSchemas(schemas, regex) {
        for (const keyRef in schemas) {
          const sch = schemas[keyRef];
          if (!regex || regex.test(keyRef)) {
            if (typeof sch == "string") {
              delete schemas[keyRef];
            } else if (sch && !sch.meta) {
              this._cache.delete(sch.schema);
              delete schemas[keyRef];
            }
          }
        }
      }
      _addSchema(
        schema,
        meta,
        baseId,
        validateSchema = this.opts.validateSchema,
        addSchema = this.opts.addUsedSchema
      ) {
        let id;
        const { schemaId } = this.opts;
        if (typeof schema == "object") {
          id = schema[schemaId];
        } else {
          if (this.opts.jtd) throw new Error("schema must be object");
          else if (typeof schema != "boolean")
            throw new Error("schema must be object or boolean");
        }
        let sch = this._cache.get(schema);
        if (sch !== void 0) return sch;
        baseId = (0, resolve_1.normalizeId)(id || baseId);
        const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);
        sch = new compile_1.SchemaEnv({
          schema,
          schemaId,
          meta,
          baseId,
          localRefs,
        });
        this._cache.set(sch.schema, sch);
        if (addSchema && !baseId.startsWith("#")) {
          if (baseId) this._checkUnique(baseId);
          this.refs[baseId] = sch;
        }
        if (validateSchema) this.validateSchema(schema, true);
        return sch;
      }
      _checkUnique(id) {
        if (this.schemas[id] || this.refs[id]) {
          throw new Error(`schema with key or id "${id}" already exists`);
        }
      }
      _compileSchemaEnv(sch) {
        if (sch.meta) this._compileMetaSchema(sch);
        else compile_1.compileSchema.call(this, sch);
        if (!sch.validate) throw new Error("ajv implementation error");
        return sch.validate;
      }
      _compileMetaSchema(sch) {
        const currentOpts = this.opts;
        this.opts = this._metaOpts;
        try {
          compile_1.compileSchema.call(this, sch);
        } finally {
          this.opts = currentOpts;
        }
      }
    };
    exports2.default = Ajv;
    Ajv.ValidationError = validation_error_1.default;
    Ajv.MissingRefError = ref_error_1.default;
    function checkOptions(checkOpts, options, msg, log = "error") {
      for (const key in checkOpts) {
        const opt = key;
        if (opt in options)
          this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);
      }
    }
    function getSchEnv(keyRef) {
      keyRef = (0, resolve_1.normalizeId)(keyRef);
      return this.schemas[keyRef] || this.refs[keyRef];
    }
    function addInitialSchemas() {
      const optsSchemas = this.opts.schemas;
      if (!optsSchemas) return;
      if (Array.isArray(optsSchemas)) this.addSchema(optsSchemas);
      else for (const key in optsSchemas) this.addSchema(optsSchemas[key], key);
    }
    function addInitialFormats() {
      for (const name in this.opts.formats) {
        const format = this.opts.formats[name];
        if (format) this.addFormat(name, format);
      }
    }
    function addInitialKeywords(defs) {
      if (Array.isArray(defs)) {
        this.addVocabulary(defs);
        return;
      }
      this.logger.warn("keywords option as map is deprecated, pass array");
      for (const keyword in defs) {
        const def = defs[keyword];
        if (!def.keyword) def.keyword = keyword;
        this.addKeyword(def);
      }
    }
    function getMetaSchemaOptions() {
      const metaOpts = { ...this.opts };
      for (const opt of META_IGNORE_OPTIONS) delete metaOpts[opt];
      return metaOpts;
    }
    var noLogs = { log() {}, warn() {}, error() {} };
    function getLogger(logger) {
      if (logger === false) return noLogs;
      if (logger === void 0) return console;
      if (logger.log && logger.warn && logger.error) return logger;
      throw new Error("logger must implement log, warn and error methods");
    }
    var KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
    function checkKeyword(keyword, def) {
      const { RULES } = this;
      (0, util_1.eachItem)(keyword, (kwd) => {
        if (RULES.keywords[kwd])
          throw new Error(`Keyword ${kwd} is already defined`);
        if (!KEYWORD_NAME.test(kwd))
          throw new Error(`Keyword ${kwd} has invalid name`);
      });
      if (!def) return;
      if (def.$data && !("code" in def || "validate" in def)) {
        throw new Error(
          '$data keyword must have "code" or "validate" function'
        );
      }
    }
    function addRule(keyword, definition, dataType) {
      var _a;
      const post =
        definition === null || definition === void 0 ? void 0 : definition.post;
      if (dataType && post)
        throw new Error('keyword with "post" flag cannot have "type"');
      const { RULES } = this;
      let ruleGroup = post
        ? RULES.post
        : RULES.rules.find(({ type: t }) => t === dataType);
      if (!ruleGroup) {
        ruleGroup = { type: dataType, rules: [] };
        RULES.rules.push(ruleGroup);
      }
      RULES.keywords[keyword] = true;
      if (!definition) return;
      const rule = {
        keyword,
        definition: {
          ...definition,
          type: (0, dataType_1.getJSONTypes)(definition.type),
          schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType),
        },
      };
      if (definition.before)
        addBeforeRule.call(this, ruleGroup, rule, definition.before);
      else ruleGroup.rules.push(rule);
      RULES.all[keyword] = rule;
      (_a = definition.implements) === null || _a === void 0
        ? void 0
        : _a.forEach((kwd) => this.addKeyword(kwd));
    }
    function addBeforeRule(ruleGroup, rule, before) {
      const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
      if (i >= 0) {
        ruleGroup.rules.splice(i, 0, rule);
      } else {
        ruleGroup.rules.push(rule);
        this.logger.warn(`rule ${before} is not defined`);
      }
    }
    function keywordMetaschema(def) {
      let { metaSchema } = def;
      if (metaSchema === void 0) return;
      if (def.$data && this.opts.$data) metaSchema = schemaOrData(metaSchema);
      def.validateSchema = this.compile(metaSchema, true);
    }
    var $dataRef = {
      $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
    };
    function schemaOrData(schema) {
      return { anyOf: [schema, $dataRef] };
    }
  },
});

// node_modules/@near-js/accounts/node_modules/ajv/dist/vocabularies/core/id.js
var require_id = __commonJS({
  "node_modules/@near-js/accounts/node_modules/ajv/dist/vocabularies/core/id.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var def = {
      keyword: "id",
      code() {
        throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
      },
    };
    exports2.default = def;
  },
});

// node_modules/@near-js/accounts/node_modules/ajv/dist/vocabularies/core/ref.js
var require_ref = __commonJS({
  "node_modules/@near-js/accounts/node_modules/ajv/dist/vocabularies/core/ref.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.callRef = exports2.getValidate = void 0;
    var ref_error_1 = require_ref_error();
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var compile_1 = require_compile();
    var util_1 = require_util();
    var def = {
      keyword: "$ref",
      schemaType: "string",
      code(cxt) {
        const { gen, schema: $ref, it } = cxt;
        const { baseId, schemaEnv: env, validateName, opts, self: self2 } = it;
        const { root: root2 } = env;
        if (($ref === "#" || $ref === "#/") && baseId === root2.baseId)
          return callRootRef();
        const schOrEnv = compile_1.resolveRef.call(self2, root2, baseId, $ref);
        if (schOrEnv === void 0)
          throw new ref_error_1.default(it.opts.uriResolver, baseId, $ref);
        if (schOrEnv instanceof compile_1.SchemaEnv)
          return callValidate(schOrEnv);
        return inlineRefSchema(schOrEnv);
        function callRootRef() {
          if (env === root2) return callRef(cxt, validateName, env, env.$async);
          const rootName = gen.scopeValue("root", { ref: root2 });
          return callRef(
            cxt,
            (0, codegen_1._)`${rootName}.validate`,
            root2,
            root2.$async
          );
        }
        function callValidate(sch) {
          const v = getValidate(cxt, sch);
          callRef(cxt, v, sch, sch.$async);
        }
        function inlineRefSchema(sch) {
          const schName = gen.scopeValue(
            "schema",
            opts.code.source === true
              ? { ref: sch, code: (0, codegen_1.stringify)(sch) }
              : { ref: sch }
          );
          const valid = gen.name("valid");
          const schCxt = cxt.subschema(
            {
              schema: sch,
              dataTypes: [],
              schemaPath: codegen_1.nil,
              topSchemaRef: schName,
              errSchemaPath: $ref,
            },
            valid
          );
          cxt.mergeEvaluated(schCxt);
          cxt.ok(valid);
        }
      },
    };
    function getValidate(cxt, sch) {
      const { gen } = cxt;
      return sch.validate
        ? gen.scopeValue("validate", { ref: sch.validate })
        : (0, codegen_1._)`${gen.scopeValue("wrapper", { ref: sch })}.validate`;
    }
    exports2.getValidate = getValidate;
    function callRef(cxt, v, sch, $async) {
      const { gen, it } = cxt;
      const { allErrors, schemaEnv: env, opts } = it;
      const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;
      if ($async) callAsyncRef();
      else callSyncRef();
      function callAsyncRef() {
        if (!env.$async)
          throw new Error("async schema referenced by sync schema");
        const valid = gen.let("valid");
        gen.try(
          () => {
            gen.code(
              (0, codegen_1._)`await ${(0, code_1.callValidateCode)(
                cxt,
                v,
                passCxt
              )}`
            );
            addEvaluatedFrom(v);
            if (!allErrors) gen.assign(valid, true);
          },
          (e) => {
            gen.if(
              (0, codegen_1._)`!(${e} instanceof ${it.ValidationError})`,
              () => gen.throw(e)
            );
            addErrorsFrom(e);
            if (!allErrors) gen.assign(valid, false);
          }
        );
        cxt.ok(valid);
      }
      function callSyncRef() {
        cxt.result(
          (0, code_1.callValidateCode)(cxt, v, passCxt),
          () => addEvaluatedFrom(v),
          () => addErrorsFrom(v)
        );
      }
      function addErrorsFrom(source) {
        const errs = (0, codegen_1._)`${source}.errors`;
        gen.assign(
          names_1.default.vErrors,
          (0,
          codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`
        );
        gen.assign(
          names_1.default.errors,
          (0, codegen_1._)`${names_1.default.vErrors}.length`
        );
      }
      function addEvaluatedFrom(source) {
        var _a;
        if (!it.opts.unevaluated) return;
        const schEvaluated =
          (_a = sch === null || sch === void 0 ? void 0 : sch.validate) ===
            null || _a === void 0
            ? void 0
            : _a.evaluated;
        if (it.props !== true) {
          if (schEvaluated && !schEvaluated.dynamicProps) {
            if (schEvaluated.props !== void 0) {
              it.props = util_1.mergeEvaluated.props(
                gen,
                schEvaluated.props,
                it.props
              );
            }
          } else {
            const props = gen.var(
              "props",
              (0, codegen_1._)`${source}.evaluated.props`
            );
            it.props = util_1.mergeEvaluated.props(
              gen,
              props,
              it.props,
              codegen_1.Name
            );
          }
        }
        if (it.items !== true) {
          if (schEvaluated && !schEvaluated.dynamicItems) {
            if (schEvaluated.items !== void 0) {
              it.items = util_1.mergeEvaluated.items(
                gen,
                schEvaluated.items,
                it.items
              );
            }
          } else {
            const items = gen.var(
              "items",
              (0, codegen_1._)`${source}.evaluated.items`
            );
            it.items = util_1.mergeEvaluated.items(
              gen,
              items,
              it.items,
              codegen_1.Name
            );
          }
        }
      }
    }
    exports2.callRef = callRef;
    exports2.default = def;
  },
});

// node_modules/@near-js/accounts/node_modules/ajv/dist/vocabularies/core/index.js
var require_core2 = __commonJS({
  "node_modules/@near-js/accounts/node_modules/ajv/dist/vocabularies/core/index.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var id_1 = require_id();
    var ref_1 = require_ref();
    var core = [
      "$schema",
      "$id",
      "$defs",
      "$vocabulary",
      { keyword: "$comment" },
      "definitions",
      id_1.default,
      ref_1.default,
    ];
    exports2.default = core;
  },
});

// node_modules/@near-js/accounts/node_modules/ajv/dist/vocabularies/validation/limitNumber.js
var require_limitNumber = __commonJS({
  "node_modules/@near-js/accounts/node_modules/ajv/dist/vocabularies/validation/limitNumber.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var ops = codegen_1.operators;
    var KWDs = {
      maximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
      minimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
      exclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
      exclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE },
    };
    var error = {
      message: ({ keyword, schemaCode }) =>
        (0, codegen_1.str)`must be ${KWDs[keyword].okStr} ${schemaCode}`,
      params: ({ keyword, schemaCode }) =>
        (0,
        codegen_1._)`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`,
    };
    var def = {
      keyword: Object.keys(KWDs),
      type: "number",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        cxt.fail$data(
          (0,
          codegen_1._)`${data} ${KWDs[keyword].fail} ${schemaCode} || isNaN(${data})`
        );
      },
    };
    exports2.default = def;
  },
});

// node_modules/@near-js/accounts/node_modules/ajv/dist/vocabularies/validation/multipleOf.js
var require_multipleOf = __commonJS({
  "node_modules/@near-js/accounts/node_modules/ajv/dist/vocabularies/validation/multipleOf.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message: ({ schemaCode }) =>
        (0, codegen_1.str)`must be multiple of ${schemaCode}`,
      params: ({ schemaCode }) => (0, codegen_1._)`{multipleOf: ${schemaCode}}`,
    };
    var def = {
      keyword: "multipleOf",
      type: "number",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, schemaCode, it } = cxt;
        const prec = it.opts.multipleOfPrecision;
        const res = gen.let("res");
        const invalid = prec
          ? (0, codegen_1._)`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}`
          : (0, codegen_1._)`${res} !== parseInt(${res})`;
        cxt.fail$data(
          (0,
          codegen_1._)`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`
        );
      },
    };
    exports2.default = def;
  },
});

// node_modules/@near-js/accounts/node_modules/ajv/dist/runtime/ucs2length.js
var require_ucs2length = __commonJS({
  "node_modules/@near-js/accounts/node_modules/ajv/dist/runtime/ucs2length.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    function ucs2length(str) {
      const len = str.length;
      let length = 0;
      let pos = 0;
      let value;
      while (pos < len) {
        length++;
        value = str.charCodeAt(pos++);
        if (value >= 55296 && value <= 56319 && pos < len) {
          value = str.charCodeAt(pos);
          if ((value & 64512) === 56320) pos++;
        }
      }
      return length;
    }
    exports2.default = ucs2length;
    ucs2length.code = 'require("ajv/dist/runtime/ucs2length").default';
  },
});

// node_modules/@near-js/accounts/node_modules/ajv/dist/vocabularies/validation/limitLength.js
var require_limitLength = __commonJS({
  "node_modules/@near-js/accounts/node_modules/ajv/dist/vocabularies/validation/limitLength.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var ucs2length_1 = require_ucs2length();
    var error = {
      message({ keyword, schemaCode }) {
        const comp = keyword === "maxLength" ? "more" : "fewer";
        return (0,
        codegen_1.str)`must NOT have ${comp} than ${schemaCode} characters`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`,
    };
    var def = {
      keyword: ["maxLength", "minLength"],
      type: "string",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode, it } = cxt;
        const op =
          keyword === "maxLength"
            ? codegen_1.operators.GT
            : codegen_1.operators.LT;
        const len =
          it.opts.unicode === false
            ? (0, codegen_1._)`${data}.length`
            : (0, codegen_1._)`${(0, util_1.useFunc)(
                cxt.gen,
                ucs2length_1.default
              )}(${data})`;
        cxt.fail$data((0, codegen_1._)`${len} ${op} ${schemaCode}`);
      },
    };
    exports2.default = def;
  },
});

// node_modules/@near-js/accounts/node_modules/ajv/dist/vocabularies/validation/pattern.js
var require_pattern = __commonJS({
  "node_modules/@near-js/accounts/node_modules/ajv/dist/vocabularies/validation/pattern.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var error = {
      message: ({ schemaCode }) =>
        (0, codegen_1.str)`must match pattern "${schemaCode}"`,
      params: ({ schemaCode }) => (0, codegen_1._)`{pattern: ${schemaCode}}`,
    };
    var def = {
      keyword: "pattern",
      type: "string",
      schemaType: "string",
      $data: true,
      error,
      code(cxt) {
        const { data, $data, schema, schemaCode, it } = cxt;
        const u = it.opts.unicodeRegExp ? "u" : "";
        const regExp = $data
          ? (0, codegen_1._)`(new RegExp(${schemaCode}, ${u}))`
          : (0, code_1.usePattern)(cxt, schema);
        cxt.fail$data((0, codegen_1._)`!${regExp}.test(${data})`);
      },
    };
    exports2.default = def;
  },
});

// node_modules/@near-js/accounts/node_modules/ajv/dist/vocabularies/validation/limitProperties.js
var require_limitProperties = __commonJS({
  "node_modules/@near-js/accounts/node_modules/ajv/dist/vocabularies/validation/limitProperties.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message({ keyword, schemaCode }) {
        const comp = keyword === "maxProperties" ? "more" : "fewer";
        return (0,
        codegen_1.str)`must NOT have ${comp} than ${schemaCode} properties`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`,
    };
    var def = {
      keyword: ["maxProperties", "minProperties"],
      type: "object",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        const op =
          keyword === "maxProperties"
            ? codegen_1.operators.GT
            : codegen_1.operators.LT;
        cxt.fail$data(
          (0, codegen_1._)`Object.keys(${data}).length ${op} ${schemaCode}`
        );
      },
    };
    exports2.default = def;
  },
});

// node_modules/@near-js/accounts/node_modules/ajv/dist/vocabularies/validation/required.js
var require_required = __commonJS({
  "node_modules/@near-js/accounts/node_modules/ajv/dist/vocabularies/validation/required.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: ({ params: { missingProperty } }) =>
        (0, codegen_1.str)`must have required property '${missingProperty}'`,
      params: ({ params: { missingProperty } }) =>
        (0, codegen_1._)`{missingProperty: ${missingProperty}}`,
    };
    var def = {
      keyword: "required",
      type: "object",
      schemaType: "array",
      $data: true,
      error,
      code(cxt) {
        const { gen, schema, schemaCode, data, $data, it } = cxt;
        const { opts } = it;
        if (!$data && schema.length === 0) return;
        const useLoop = schema.length >= opts.loopRequired;
        if (it.allErrors) allErrorsMode();
        else exitOnErrorMode();
        if (opts.strictRequired) {
          const props = cxt.parentSchema.properties;
          const { definedProperties } = cxt.it;
          for (const requiredKey of schema) {
            if (
              (props === null || props === void 0
                ? void 0
                : props[requiredKey]) === void 0 &&
              !definedProperties.has(requiredKey)
            ) {
              const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
              const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
              (0, util_1.checkStrictMode)(it, msg, it.opts.strictRequired);
            }
          }
        }
        function allErrorsMode() {
          if (useLoop || $data) {
            cxt.block$data(codegen_1.nil, loopAllRequired);
          } else {
            for (const prop of schema) {
              (0, code_1.checkReportMissingProp)(cxt, prop);
            }
          }
        }
        function exitOnErrorMode() {
          const missing = gen.let("missing");
          if (useLoop || $data) {
            const valid = gen.let("valid", true);
            cxt.block$data(valid, () => loopUntilMissing(missing, valid));
            cxt.ok(valid);
          } else {
            gen.if((0, code_1.checkMissingProp)(cxt, schema, missing));
            (0, code_1.reportMissingProp)(cxt, missing);
            gen.else();
          }
        }
        function loopAllRequired() {
          gen.forOf("prop", schemaCode, (prop) => {
            cxt.setParams({ missingProperty: prop });
            gen.if(
              (0, code_1.noPropertyInData)(gen, data, prop, opts.ownProperties),
              () => cxt.error()
            );
          });
        }
        function loopUntilMissing(missing, valid) {
          cxt.setParams({ missingProperty: missing });
          gen.forOf(
            missing,
            schemaCode,
            () => {
              gen.assign(
                valid,
                (0, code_1.propertyInData)(
                  gen,
                  data,
                  missing,
                  opts.ownProperties
                )
              );
              gen.if((0, codegen_1.not)(valid), () => {
                cxt.error();
                gen.break();
              });
            },
            codegen_1.nil
          );
        }
      },
    };
    exports2.default = def;
  },
});

// node_modules/@near-js/accounts/node_modules/ajv/dist/vocabularies/validation/limitItems.js
var require_limitItems = __commonJS({
  "node_modules/@near-js/accounts/node_modules/ajv/dist/vocabularies/validation/limitItems.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message({ keyword, schemaCode }) {
        const comp = keyword === "maxItems" ? "more" : "fewer";
        return (0,
        codegen_1.str)`must NOT have ${comp} than ${schemaCode} items`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`,
    };
    var def = {
      keyword: ["maxItems", "minItems"],
      type: "array",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        const op =
          keyword === "maxItems"
            ? codegen_1.operators.GT
            : codegen_1.operators.LT;
        cxt.fail$data((0, codegen_1._)`${data}.length ${op} ${schemaCode}`);
      },
    };
    exports2.default = def;
  },
});

// node_modules/@near-js/accounts/node_modules/ajv/dist/runtime/equal.js
var require_equal = __commonJS({
  "node_modules/@near-js/accounts/node_modules/ajv/dist/runtime/equal.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var equal = require_fast_deep_equal();
    equal.code = 'require("ajv/dist/runtime/equal").default';
    exports2.default = equal;
  },
});

// node_modules/@near-js/accounts/node_modules/ajv/dist/vocabularies/validation/uniqueItems.js
var require_uniqueItems = __commonJS({
  "node_modules/@near-js/accounts/node_modules/ajv/dist/vocabularies/validation/uniqueItems.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var dataType_1 = require_dataType();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var equal_1 = require_equal();
    var error = {
      message: ({ params: { i, j } }) =>
        (0,
        codegen_1.str)`must NOT have duplicate items (items ## ${j} and ${i} are identical)`,
      params: ({ params: { i, j } }) => (0, codegen_1._)`{i: ${i}, j: ${j}}`,
    };
    var def = {
      keyword: "uniqueItems",
      type: "array",
      schemaType: "boolean",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schema, parentSchema, schemaCode, it } = cxt;
        if (!$data && !schema) return;
        const valid = gen.let("valid");
        const itemTypes = parentSchema.items
          ? (0, dataType_1.getSchemaTypes)(parentSchema.items)
          : [];
        cxt.block$data(
          valid,
          validateUniqueItems,
          (0, codegen_1._)`${schemaCode} === false`
        );
        cxt.ok(valid);
        function validateUniqueItems() {
          const i = gen.let("i", (0, codegen_1._)`${data}.length`);
          const j = gen.let("j");
          cxt.setParams({ i, j });
          gen.assign(valid, true);
          gen.if((0, codegen_1._)`${i} > 1`, () =>
            (canOptimize() ? loopN : loopN2)(i, j)
          );
        }
        function canOptimize() {
          return (
            itemTypes.length > 0 &&
            !itemTypes.some((t) => t === "object" || t === "array")
          );
        }
        function loopN(i, j) {
          const item = gen.name("item");
          const wrongType = (0, dataType_1.checkDataTypes)(
            itemTypes,
            item,
            it.opts.strictNumbers,
            dataType_1.DataType.Wrong
          );
          const indices = gen.const("indices", (0, codegen_1._)`{}`);
          gen.for((0, codegen_1._)`;${i}--;`, () => {
            gen.let(item, (0, codegen_1._)`${data}[${i}]`);
            gen.if(wrongType, (0, codegen_1._)`continue`);
            if (itemTypes.length > 1)
              gen.if(
                (0, codegen_1._)`typeof ${item} == "string"`,
                (0, codegen_1._)`${item} += "_"`
              );
            gen
              .if(
                (0, codegen_1._)`typeof ${indices}[${item}] == "number"`,
                () => {
                  gen.assign(j, (0, codegen_1._)`${indices}[${item}]`);
                  cxt.error();
                  gen.assign(valid, false).break();
                }
              )
              .code((0, codegen_1._)`${indices}[${item}] = ${i}`);
          });
        }
        function loopN2(i, j) {
          const eql = (0, util_1.useFunc)(gen, equal_1.default);
          const outer = gen.name("outer");
          gen.label(outer).for((0, codegen_1._)`;${i}--;`, () =>
            gen.for((0, codegen_1._)`${j} = ${i}; ${j}--;`, () =>
              gen.if(
                (0, codegen_1._)`${eql}(${data}[${i}], ${data}[${j}])`,
                () => {
                  cxt.error();
                  gen.assign(valid, false).break(outer);
                }
              )
            )
          );
        }
      },
    };
    exports2.default = def;
  },
});

// node_modules/@near-js/accounts/node_modules/ajv/dist/vocabularies/validation/const.js
var require_const = __commonJS({
  "node_modules/@near-js/accounts/node_modules/ajv/dist/vocabularies/validation/const.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var equal_1 = require_equal();
    var error = {
      message: "must be equal to constant",
      params: ({ schemaCode }) =>
        (0, codegen_1._)`{allowedValue: ${schemaCode}}`,
    };
    var def = {
      keyword: "const",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schemaCode, schema } = cxt;
        if ($data || (schema && typeof schema == "object")) {
          cxt.fail$data(
            (0, codegen_1._)`!${(0, util_1.useFunc)(
              gen,
              equal_1.default
            )}(${data}, ${schemaCode})`
          );
        } else {
          cxt.fail((0, codegen_1._)`${schema} !== ${data}`);
        }
      },
    };
    exports2.default = def;
  },
});

// node_modules/@near-js/accounts/node_modules/ajv/dist/vocabularies/validation/enum.js
var require_enum = __commonJS({
  "node_modules/@near-js/accounts/node_modules/ajv/dist/vocabularies/validation/enum.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var equal_1 = require_equal();
    var error = {
      message: "must be equal to one of the allowed values",
      params: ({ schemaCode }) =>
        (0, codegen_1._)`{allowedValues: ${schemaCode}}`,
    };
    var def = {
      keyword: "enum",
      schemaType: "array",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schema, schemaCode, it } = cxt;
        if (!$data && schema.length === 0)
          throw new Error("enum must have non-empty array");
        const useLoop = schema.length >= it.opts.loopEnum;
        let eql;
        const getEql = () =>
          eql !== null && eql !== void 0
            ? eql
            : (eql = (0, util_1.useFunc)(gen, equal_1.default));
        let valid;
        if (useLoop || $data) {
          valid = gen.let("valid");
          cxt.block$data(valid, loopEnum);
        } else {
          if (!Array.isArray(schema))
            throw new Error("ajv implementation error");
          const vSchema = gen.const("vSchema", schemaCode);
          valid = (0, codegen_1.or)(
            ...schema.map((_x, i) => equalCode(vSchema, i))
          );
        }
        cxt.pass(valid);
        function loopEnum() {
          gen.assign(valid, false);
          gen.forOf("v", schemaCode, (v) =>
            gen.if((0, codegen_1._)`${getEql()}(${data}, ${v})`, () =>
              gen.assign(valid, true).break()
            )
          );
        }
        function equalCode(vSchema, i) {
          const sch = schema[i];
          return typeof sch === "object" && sch !== null
            ? (0, codegen_1._)`${getEql()}(${data}, ${vSchema}[${i}])`
            : (0, codegen_1._)`${data} === ${sch}`;
        }
      },
    };
    exports2.default = def;
  },
});

// node_modules/@near-js/accounts/node_modules/ajv/dist/vocabularies/validation/index.js
var require_validation = __commonJS({
  "node_modules/@near-js/accounts/node_modules/ajv/dist/vocabularies/validation/index.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var limitNumber_1 = require_limitNumber();
    var multipleOf_1 = require_multipleOf();
    var limitLength_1 = require_limitLength();
    var pattern_1 = require_pattern();
    var limitProperties_1 = require_limitProperties();
    var required_1 = require_required();
    var limitItems_1 = require_limitItems();
    var uniqueItems_1 = require_uniqueItems();
    var const_1 = require_const();
    var enum_1 = require_enum();
    var validation = [
      // number
      limitNumber_1.default,
      multipleOf_1.default,
      // string
      limitLength_1.default,
      pattern_1.default,
      // object
      limitProperties_1.default,
      required_1.default,
      // array
      limitItems_1.default,
      uniqueItems_1.default,
      // any
      { keyword: "type", schemaType: ["string", "array"] },
      { keyword: "nullable", schemaType: "boolean" },
      const_1.default,
      enum_1.default,
    ];
    exports2.default = validation;
  },
});

// node_modules/@near-js/accounts/node_modules/ajv/dist/vocabularies/applicator/additionalItems.js
var require_additionalItems = __commonJS({
  "node_modules/@near-js/accounts/node_modules/ajv/dist/vocabularies/applicator/additionalItems.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateAdditionalItems = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: ({ params: { len } }) =>
        (0, codegen_1.str)`must NOT have more than ${len} items`,
      params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`,
    };
    var def = {
      keyword: "additionalItems",
      type: "array",
      schemaType: ["boolean", "object"],
      before: "uniqueItems",
      error,
      code(cxt) {
        const { parentSchema, it } = cxt;
        const { items } = parentSchema;
        if (!Array.isArray(items)) {
          (0, util_1.checkStrictMode)(
            it,
            '"additionalItems" is ignored when "items" is not an array of schemas'
          );
          return;
        }
        validateAdditionalItems(cxt, items);
      },
    };
    function validateAdditionalItems(cxt, items) {
      const { gen, schema, data, keyword, it } = cxt;
      it.items = true;
      const len = gen.const("len", (0, codegen_1._)`${data}.length`);
      if (schema === false) {
        cxt.setParams({ len: items.length });
        cxt.pass((0, codegen_1._)`${len} <= ${items.length}`);
      } else if (
        typeof schema == "object" &&
        !(0, util_1.alwaysValidSchema)(it, schema)
      ) {
        const valid = gen.var(
          "valid",
          (0, codegen_1._)`${len} <= ${items.length}`
        );
        gen.if((0, codegen_1.not)(valid), () => validateItems(valid));
        cxt.ok(valid);
      }
      function validateItems(valid) {
        gen.forRange("i", items.length, len, (i) => {
          cxt.subschema(
            { keyword, dataProp: i, dataPropType: util_1.Type.Num },
            valid
          );
          if (!it.allErrors)
            gen.if((0, codegen_1.not)(valid), () => gen.break());
        });
      }
    }
    exports2.validateAdditionalItems = validateAdditionalItems;
    exports2.default = def;
  },
});

// node_modules/@near-js/accounts/node_modules/ajv/dist/vocabularies/applicator/items.js
var require_items = __commonJS({
  "node_modules/@near-js/accounts/node_modules/ajv/dist/vocabularies/applicator/items.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateTuple = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var code_1 = require_code2();
    var def = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "array", "boolean"],
      before: "uniqueItems",
      code(cxt) {
        const { schema, it } = cxt;
        if (Array.isArray(schema))
          return validateTuple(cxt, "additionalItems", schema);
        it.items = true;
        if ((0, util_1.alwaysValidSchema)(it, schema)) return;
        cxt.ok((0, code_1.validateArray)(cxt));
      },
    };
    function validateTuple(cxt, extraItems, schArr = cxt.schema) {
      const { gen, parentSchema, data, keyword, it } = cxt;
      checkStrictTuple(parentSchema);
      if (it.opts.unevaluated && schArr.length && it.items !== true) {
        it.items = util_1.mergeEvaluated.items(gen, schArr.length, it.items);
      }
      const valid = gen.name("valid");
      const len = gen.const("len", (0, codegen_1._)`${data}.length`);
      schArr.forEach((sch, i) => {
        if ((0, util_1.alwaysValidSchema)(it, sch)) return;
        gen.if((0, codegen_1._)`${len} > ${i}`, () =>
          cxt.subschema(
            {
              keyword,
              schemaProp: i,
              dataProp: i,
            },
            valid
          )
        );
        cxt.ok(valid);
      });
      function checkStrictTuple(sch) {
        const { opts, errSchemaPath } = it;
        const l = schArr.length;
        const fullTuple =
          l === sch.minItems &&
          (l === sch.maxItems || sch[extraItems] === false);
        if (opts.strictTuples && !fullTuple) {
          const msg = `"${keyword}" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
          (0, util_1.checkStrictMode)(it, msg, opts.strictTuples);
        }
      }
    }
    exports2.validateTuple = validateTuple;
    exports2.default = def;
  },
});

// node_modules/@near-js/accounts/node_modules/ajv/dist/vocabularies/applicator/prefixItems.js
var require_prefixItems = __commonJS({
  "node_modules/@near-js/accounts/node_modules/ajv/dist/vocabularies/applicator/prefixItems.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var items_1 = require_items();
    var def = {
      keyword: "prefixItems",
      type: "array",
      schemaType: ["array"],
      before: "uniqueItems",
      code: (cxt) => (0, items_1.validateTuple)(cxt, "items"),
    };
    exports2.default = def;
  },
});

// node_modules/@near-js/accounts/node_modules/ajv/dist/vocabularies/applicator/items2020.js
var require_items2020 = __commonJS({
  "node_modules/@near-js/accounts/node_modules/ajv/dist/vocabularies/applicator/items2020.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var code_1 = require_code2();
    var additionalItems_1 = require_additionalItems();
    var error = {
      message: ({ params: { len } }) =>
        (0, codegen_1.str)`must NOT have more than ${len} items`,
      params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`,
    };
    var def = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      error,
      code(cxt) {
        const { schema, parentSchema, it } = cxt;
        const { prefixItems } = parentSchema;
        it.items = true;
        if ((0, util_1.alwaysValidSchema)(it, schema)) return;
        if (prefixItems)
          (0, additionalItems_1.validateAdditionalItems)(cxt, prefixItems);
        else cxt.ok((0, code_1.validateArray)(cxt));
      },
    };
    exports2.default = def;
  },
});

// node_modules/@near-js/accounts/node_modules/ajv/dist/vocabularies/applicator/contains.js
var require_contains = __commonJS({
  "node_modules/@near-js/accounts/node_modules/ajv/dist/vocabularies/applicator/contains.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: ({ params: { min, max } }) =>
        max === void 0
          ? (0, codegen_1.str)`must contain at least ${min} valid item(s)`
          : (0,
            codegen_1.str)`must contain at least ${min} and no more than ${max} valid item(s)`,
      params: ({ params: { min, max } }) =>
        max === void 0
          ? (0, codegen_1._)`{minContains: ${min}}`
          : (0, codegen_1._)`{minContains: ${min}, maxContains: ${max}}`,
    };
    var def = {
      keyword: "contains",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema, parentSchema, data, it } = cxt;
        let min;
        let max;
        const { minContains, maxContains } = parentSchema;
        if (it.opts.next) {
          min = minContains === void 0 ? 1 : minContains;
          max = maxContains;
        } else {
          min = 1;
        }
        const len = gen.const("len", (0, codegen_1._)`${data}.length`);
        cxt.setParams({ min, max });
        if (max === void 0 && min === 0) {
          (0, util_1.checkStrictMode)(
            it,
            `"minContains" == 0 without "maxContains": "contains" keyword ignored`
          );
          return;
        }
        if (max !== void 0 && min > max) {
          (0, util_1.checkStrictMode)(
            it,
            `"minContains" > "maxContains" is always invalid`
          );
          cxt.fail();
          return;
        }
        if ((0, util_1.alwaysValidSchema)(it, schema)) {
          let cond = (0, codegen_1._)`${len} >= ${min}`;
          if (max !== void 0)
            cond = (0, codegen_1._)`${cond} && ${len} <= ${max}`;
          cxt.pass(cond);
          return;
        }
        it.items = true;
        const valid = gen.name("valid");
        if (max === void 0 && min === 1) {
          validateItems(valid, () => gen.if(valid, () => gen.break()));
        } else if (min === 0) {
          gen.let(valid, true);
          if (max !== void 0)
            gen.if(
              (0, codegen_1._)`${data}.length > 0`,
              validateItemsWithCount
            );
        } else {
          gen.let(valid, false);
          validateItemsWithCount();
        }
        cxt.result(valid, () => cxt.reset());
        function validateItemsWithCount() {
          const schValid = gen.name("_valid");
          const count = gen.let("count", 0);
          validateItems(schValid, () =>
            gen.if(schValid, () => checkLimits(count))
          );
        }
        function validateItems(_valid, block) {
          gen.forRange("i", 0, len, (i) => {
            cxt.subschema(
              {
                keyword: "contains",
                dataProp: i,
                dataPropType: util_1.Type.Num,
                compositeRule: true,
              },
              _valid
            );
            block();
          });
        }
        function checkLimits(count) {
          gen.code((0, codegen_1._)`${count}++`);
          if (max === void 0) {
            gen.if((0, codegen_1._)`${count} >= ${min}`, () =>
              gen.assign(valid, true).break()
            );
          } else {
            gen.if((0, codegen_1._)`${count} > ${max}`, () =>
              gen.assign(valid, false).break()
            );
            if (min === 1) gen.assign(valid, true);
            else
              gen.if((0, codegen_1._)`${count} >= ${min}`, () =>
                gen.assign(valid, true)
              );
          }
        }
      },
    };
    exports2.default = def;
  },
});

// node_modules/@near-js/accounts/node_modules/ajv/dist/vocabularies/applicator/dependencies.js
var require_dependencies = __commonJS({
  "node_modules/@near-js/accounts/node_modules/ajv/dist/vocabularies/applicator/dependencies.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateSchemaDeps =
      exports2.validatePropertyDeps =
      exports2.error =
        void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var code_1 = require_code2();
    exports2.error = {
      message: ({ params: { property, depsCount, deps } }) => {
        const property_ies = depsCount === 1 ? "property" : "properties";
        return (0,
        codegen_1.str)`must have ${property_ies} ${deps} when property ${property} is present`;
      },
      params: ({
        params: { property, depsCount, deps, missingProperty },
      }) => (0, codegen_1._)`{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`,
      // TODO change to reference
    };
    var def = {
      keyword: "dependencies",
      type: "object",
      schemaType: "object",
      error: exports2.error,
      code(cxt) {
        const [propDeps, schDeps] = splitDependencies(cxt);
        validatePropertyDeps(cxt, propDeps);
        validateSchemaDeps(cxt, schDeps);
      },
    };
    function splitDependencies({ schema }) {
      const propertyDeps = {};
      const schemaDeps = {};
      for (const key in schema) {
        if (key === "__proto__") continue;
        const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;
        deps[key] = schema[key];
      }
      return [propertyDeps, schemaDeps];
    }
    function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
      const { gen, data, it } = cxt;
      if (Object.keys(propertyDeps).length === 0) return;
      const missing = gen.let("missing");
      for (const prop in propertyDeps) {
        const deps = propertyDeps[prop];
        if (deps.length === 0) continue;
        const hasProperty = (0, code_1.propertyInData)(
          gen,
          data,
          prop,
          it.opts.ownProperties
        );
        cxt.setParams({
          property: prop,
          depsCount: deps.length,
          deps: deps.join(", "),
        });
        if (it.allErrors) {
          gen.if(hasProperty, () => {
            for (const depProp of deps) {
              (0, code_1.checkReportMissingProp)(cxt, depProp);
            }
          });
        } else {
          gen.if(
            (0, codegen_1._)`${hasProperty} && (${(0, code_1.checkMissingProp)(
              cxt,
              deps,
              missing
            )})`
          );
          (0, code_1.reportMissingProp)(cxt, missing);
          gen.else();
        }
      }
    }
    exports2.validatePropertyDeps = validatePropertyDeps;
    function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
      const { gen, data, keyword, it } = cxt;
      const valid = gen.name("valid");
      for (const prop in schemaDeps) {
        if ((0, util_1.alwaysValidSchema)(it, schemaDeps[prop])) continue;
        gen.if(
          (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties),
          () => {
            const schCxt = cxt.subschema({ keyword, schemaProp: prop }, valid);
            cxt.mergeValidEvaluated(schCxt, valid);
          },
          () => gen.var(valid, true)
          // TODO var
        );
        cxt.ok(valid);
      }
    }
    exports2.validateSchemaDeps = validateSchemaDeps;
    exports2.default = def;
  },
});

// node_modules/@near-js/accounts/node_modules/ajv/dist/vocabularies/applicator/propertyNames.js
var require_propertyNames = __commonJS({
  "node_modules/@near-js/accounts/node_modules/ajv/dist/vocabularies/applicator/propertyNames.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: "property name must be valid",
      params: ({ params }) =>
        (0, codegen_1._)`{propertyName: ${params.propertyName}}`,
    };
    var def = {
      keyword: "propertyNames",
      type: "object",
      schemaType: ["object", "boolean"],
      error,
      code(cxt) {
        const { gen, schema, data, it } = cxt;
        if ((0, util_1.alwaysValidSchema)(it, schema)) return;
        const valid = gen.name("valid");
        gen.forIn("key", data, (key) => {
          cxt.setParams({ propertyName: key });
          cxt.subschema(
            {
              keyword: "propertyNames",
              data: key,
              dataTypes: ["string"],
              propertyName: key,
              compositeRule: true,
            },
            valid
          );
          gen.if((0, codegen_1.not)(valid), () => {
            cxt.error(true);
            if (!it.allErrors) gen.break();
          });
        });
        cxt.ok(valid);
      },
    };
    exports2.default = def;
  },
});

// node_modules/@near-js/accounts/node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js
var require_additionalProperties = __commonJS({
  "node_modules/@near-js/accounts/node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var util_1 = require_util();
    var error = {
      message: "must NOT have additional properties",
      params: ({ params }) =>
        (0, codegen_1._)`{additionalProperty: ${params.additionalProperty}}`,
    };
    var def = {
      keyword: "additionalProperties",
      type: ["object"],
      schemaType: ["boolean", "object"],
      allowUndefined: true,
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema, parentSchema, data, errsCount, it } = cxt;
        if (!errsCount) throw new Error("ajv implementation error");
        const { allErrors, opts } = it;
        it.props = true;
        if (
          opts.removeAdditional !== "all" &&
          (0, util_1.alwaysValidSchema)(it, schema)
        )
          return;
        const props = (0, code_1.allSchemaProperties)(parentSchema.properties);
        const patProps = (0, code_1.allSchemaProperties)(
          parentSchema.patternProperties
        );
        checkAdditionalProperties();
        cxt.ok((0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
        function checkAdditionalProperties() {
          gen.forIn("key", data, (key) => {
            if (!props.length && !patProps.length) additionalPropertyCode(key);
            else gen.if(isAdditional(key), () => additionalPropertyCode(key));
          });
        }
        function isAdditional(key) {
          let definedProp;
          if (props.length > 8) {
            const propsSchema = (0, util_1.schemaRefOrVal)(
              it,
              parentSchema.properties,
              "properties"
            );
            definedProp = (0, code_1.isOwnProperty)(gen, propsSchema, key);
          } else if (props.length) {
            definedProp = (0, codegen_1.or)(
              ...props.map((p) => (0, codegen_1._)`${key} === ${p}`)
            );
          } else {
            definedProp = codegen_1.nil;
          }
          if (patProps.length) {
            definedProp = (0, codegen_1.or)(
              definedProp,
              ...patProps.map(
                (p) =>
                  (0, codegen_1._)`${(0, code_1.usePattern)(
                    cxt,
                    p
                  )}.test(${key})`
              )
            );
          }
          return (0, codegen_1.not)(definedProp);
        }
        function deleteAdditional(key) {
          gen.code((0, codegen_1._)`delete ${data}[${key}]`);
        }
        function additionalPropertyCode(key) {
          if (
            opts.removeAdditional === "all" ||
            (opts.removeAdditional && schema === false)
          ) {
            deleteAdditional(key);
            return;
          }
          if (schema === false) {
            cxt.setParams({ additionalProperty: key });
            cxt.error();
            if (!allErrors) gen.break();
            return;
          }
          if (
            typeof schema == "object" &&
            !(0, util_1.alwaysValidSchema)(it, schema)
          ) {
            const valid = gen.name("valid");
            if (opts.removeAdditional === "failing") {
              applyAdditionalSchema(key, valid, false);
              gen.if((0, codegen_1.not)(valid), () => {
                cxt.reset();
                deleteAdditional(key);
              });
            } else {
              applyAdditionalSchema(key, valid);
              if (!allErrors)
                gen.if((0, codegen_1.not)(valid), () => gen.break());
            }
          }
        }
        function applyAdditionalSchema(key, valid, errors) {
          const subschema = {
            keyword: "additionalProperties",
            dataProp: key,
            dataPropType: util_1.Type.Str,
          };
          if (errors === false) {
            Object.assign(subschema, {
              compositeRule: true,
              createErrors: false,
              allErrors: false,
            });
          }
          cxt.subschema(subschema, valid);
        }
      },
    };
    exports2.default = def;
  },
});

// node_modules/@near-js/accounts/node_modules/ajv/dist/vocabularies/applicator/properties.js
var require_properties = __commonJS({
  "node_modules/@near-js/accounts/node_modules/ajv/dist/vocabularies/applicator/properties.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var validate_1 = require_validate();
    var code_1 = require_code2();
    var util_1 = require_util();
    var additionalProperties_1 = require_additionalProperties();
    var def = {
      keyword: "properties",
      type: "object",
      schemaType: "object",
      code(cxt) {
        const { gen, schema, parentSchema, data, it } = cxt;
        if (
          it.opts.removeAdditional === "all" &&
          parentSchema.additionalProperties === void 0
        ) {
          additionalProperties_1.default.code(
            new validate_1.KeywordCxt(
              it,
              additionalProperties_1.default,
              "additionalProperties"
            )
          );
        }
        const allProps = (0, code_1.allSchemaProperties)(schema);
        for (const prop of allProps) {
          it.definedProperties.add(prop);
        }
        if (it.opts.unevaluated && allProps.length && it.props !== true) {
          it.props = util_1.mergeEvaluated.props(
            gen,
            (0, util_1.toHash)(allProps),
            it.props
          );
        }
        const properties = allProps.filter(
          (p) => !(0, util_1.alwaysValidSchema)(it, schema[p])
        );
        if (properties.length === 0) return;
        const valid = gen.name("valid");
        for (const prop of properties) {
          if (hasDefault(prop)) {
            applyPropertySchema(prop);
          } else {
            gen.if(
              (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties)
            );
            applyPropertySchema(prop);
            if (!it.allErrors) gen.else().var(valid, true);
            gen.endIf();
          }
          cxt.it.definedProperties.add(prop);
          cxt.ok(valid);
        }
        function hasDefault(prop) {
          return (
            it.opts.useDefaults &&
            !it.compositeRule &&
            schema[prop].default !== void 0
          );
        }
        function applyPropertySchema(prop) {
          cxt.subschema(
            {
              keyword: "properties",
              schemaProp: prop,
              dataProp: prop,
            },
            valid
          );
        }
      },
    };
    exports2.default = def;
  },
});

// node_modules/@near-js/accounts/node_modules/ajv/dist/vocabularies/applicator/patternProperties.js
var require_patternProperties = __commonJS({
  "node_modules/@near-js/accounts/node_modules/ajv/dist/vocabularies/applicator/patternProperties.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var util_2 = require_util();
    var def = {
      keyword: "patternProperties",
      type: "object",
      schemaType: "object",
      code(cxt) {
        const { gen, schema, data, parentSchema, it } = cxt;
        const { opts } = it;
        const patterns = (0, code_1.allSchemaProperties)(schema);
        const alwaysValidPatterns = patterns.filter((p) =>
          (0, util_1.alwaysValidSchema)(it, schema[p])
        );
        if (
          patterns.length === 0 ||
          (alwaysValidPatterns.length === patterns.length &&
            (!it.opts.unevaluated || it.props === true))
        ) {
          return;
        }
        const checkProperties =
          opts.strictSchema &&
          !opts.allowMatchingProperties &&
          parentSchema.properties;
        const valid = gen.name("valid");
        if (it.props !== true && !(it.props instanceof codegen_1.Name)) {
          it.props = (0, util_2.evaluatedPropsToName)(gen, it.props);
        }
        const { props } = it;
        validatePatternProperties();
        function validatePatternProperties() {
          for (const pat of patterns) {
            if (checkProperties) checkMatchingProperties(pat);
            if (it.allErrors) {
              validateProperties(pat);
            } else {
              gen.var(valid, true);
              validateProperties(pat);
              gen.if(valid);
            }
          }
        }
        function checkMatchingProperties(pat) {
          for (const prop in checkProperties) {
            if (new RegExp(pat).test(prop)) {
              (0, util_1.checkStrictMode)(
                it,
                `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`
              );
            }
          }
        }
        function validateProperties(pat) {
          gen.forIn("key", data, (key) => {
            gen.if(
              (0, codegen_1._)`${(0, code_1.usePattern)(
                cxt,
                pat
              )}.test(${key})`,
              () => {
                const alwaysValid = alwaysValidPatterns.includes(pat);
                if (!alwaysValid) {
                  cxt.subschema(
                    {
                      keyword: "patternProperties",
                      schemaProp: pat,
                      dataProp: key,
                      dataPropType: util_2.Type.Str,
                    },
                    valid
                  );
                }
                if (it.opts.unevaluated && props !== true) {
                  gen.assign((0, codegen_1._)`${props}[${key}]`, true);
                } else if (!alwaysValid && !it.allErrors) {
                  gen.if((0, codegen_1.not)(valid), () => gen.break());
                }
              }
            );
          });
        }
      },
    };
    exports2.default = def;
  },
});

// node_modules/@near-js/accounts/node_modules/ajv/dist/vocabularies/applicator/not.js
var require_not = __commonJS({
  "node_modules/@near-js/accounts/node_modules/ajv/dist/vocabularies/applicator/not.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var util_1 = require_util();
    var def = {
      keyword: "not",
      schemaType: ["object", "boolean"],
      trackErrors: true,
      code(cxt) {
        const { gen, schema, it } = cxt;
        if ((0, util_1.alwaysValidSchema)(it, schema)) {
          cxt.fail();
          return;
        }
        const valid = gen.name("valid");
        cxt.subschema(
          {
            keyword: "not",
            compositeRule: true,
            createErrors: false,
            allErrors: false,
          },
          valid
        );
        cxt.failResult(
          valid,
          () => cxt.reset(),
          () => cxt.error()
        );
      },
      error: { message: "must NOT be valid" },
    };
    exports2.default = def;
  },
});

// node_modules/@near-js/accounts/node_modules/ajv/dist/vocabularies/applicator/anyOf.js
var require_anyOf = __commonJS({
  "node_modules/@near-js/accounts/node_modules/ajv/dist/vocabularies/applicator/anyOf.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var code_1 = require_code2();
    var def = {
      keyword: "anyOf",
      schemaType: "array",
      trackErrors: true,
      code: code_1.validateUnion,
      error: { message: "must match a schema in anyOf" },
    };
    exports2.default = def;
  },
});

// node_modules/@near-js/accounts/node_modules/ajv/dist/vocabularies/applicator/oneOf.js
var require_oneOf = __commonJS({
  "node_modules/@near-js/accounts/node_modules/ajv/dist/vocabularies/applicator/oneOf.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: "must match exactly one schema in oneOf",
      params: ({ params }) =>
        (0, codegen_1._)`{passingSchemas: ${params.passing}}`,
    };
    var def = {
      keyword: "oneOf",
      schemaType: "array",
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema, parentSchema, it } = cxt;
        if (!Array.isArray(schema)) throw new Error("ajv implementation error");
        if (it.opts.discriminator && parentSchema.discriminator) return;
        const schArr = schema;
        const valid = gen.let("valid", false);
        const passing = gen.let("passing", null);
        const schValid = gen.name("_valid");
        cxt.setParams({ passing });
        gen.block(validateOneOf);
        cxt.result(
          valid,
          () => cxt.reset(),
          () => cxt.error(true)
        );
        function validateOneOf() {
          schArr.forEach((sch, i) => {
            let schCxt;
            if ((0, util_1.alwaysValidSchema)(it, sch)) {
              gen.var(schValid, true);
            } else {
              schCxt = cxt.subschema(
                {
                  keyword: "oneOf",
                  schemaProp: i,
                  compositeRule: true,
                },
                schValid
              );
            }
            if (i > 0) {
              gen
                .if((0, codegen_1._)`${schValid} && ${valid}`)
                .assign(valid, false)
                .assign(passing, (0, codegen_1._)`[${passing}, ${i}]`)
                .else();
            }
            gen.if(schValid, () => {
              gen.assign(valid, true);
              gen.assign(passing, i);
              if (schCxt) cxt.mergeEvaluated(schCxt, codegen_1.Name);
            });
          });
        }
      },
    };
    exports2.default = def;
  },
});

// node_modules/@near-js/accounts/node_modules/ajv/dist/vocabularies/applicator/allOf.js
var require_allOf = __commonJS({
  "node_modules/@near-js/accounts/node_modules/ajv/dist/vocabularies/applicator/allOf.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var util_1 = require_util();
    var def = {
      keyword: "allOf",
      schemaType: "array",
      code(cxt) {
        const { gen, schema, it } = cxt;
        if (!Array.isArray(schema)) throw new Error("ajv implementation error");
        const valid = gen.name("valid");
        schema.forEach((sch, i) => {
          if ((0, util_1.alwaysValidSchema)(it, sch)) return;
          const schCxt = cxt.subschema(
            { keyword: "allOf", schemaProp: i },
            valid
          );
          cxt.ok(valid);
          cxt.mergeEvaluated(schCxt);
        });
      },
    };
    exports2.default = def;
  },
});

// node_modules/@near-js/accounts/node_modules/ajv/dist/vocabularies/applicator/if.js
var require_if = __commonJS({
  "node_modules/@near-js/accounts/node_modules/ajv/dist/vocabularies/applicator/if.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: ({ params }) =>
        (0, codegen_1.str)`must match "${params.ifClause}" schema`,
      params: ({ params }) =>
        (0, codegen_1._)`{failingKeyword: ${params.ifClause}}`,
    };
    var def = {
      keyword: "if",
      schemaType: ["object", "boolean"],
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, parentSchema, it } = cxt;
        if (parentSchema.then === void 0 && parentSchema.else === void 0) {
          (0, util_1.checkStrictMode)(
            it,
            '"if" without "then" and "else" is ignored'
          );
        }
        const hasThen = hasSchema(it, "then");
        const hasElse = hasSchema(it, "else");
        if (!hasThen && !hasElse) return;
        const valid = gen.let("valid", true);
        const schValid = gen.name("_valid");
        validateIf();
        cxt.reset();
        if (hasThen && hasElse) {
          const ifClause = gen.let("ifClause");
          cxt.setParams({ ifClause });
          gen.if(
            schValid,
            validateClause("then", ifClause),
            validateClause("else", ifClause)
          );
        } else if (hasThen) {
          gen.if(schValid, validateClause("then"));
        } else {
          gen.if((0, codegen_1.not)(schValid), validateClause("else"));
        }
        cxt.pass(valid, () => cxt.error(true));
        function validateIf() {
          const schCxt = cxt.subschema(
            {
              keyword: "if",
              compositeRule: true,
              createErrors: false,
              allErrors: false,
            },
            schValid
          );
          cxt.mergeEvaluated(schCxt);
        }
        function validateClause(keyword, ifClause) {
          return () => {
            const schCxt = cxt.subschema({ keyword }, schValid);
            gen.assign(valid, schValid);
            cxt.mergeValidEvaluated(schCxt, valid);
            if (ifClause) gen.assign(ifClause, (0, codegen_1._)`${keyword}`);
            else cxt.setParams({ ifClause: keyword });
          };
        }
      },
    };
    function hasSchema(it, keyword) {
      const schema = it.schema[keyword];
      return schema !== void 0 && !(0, util_1.alwaysValidSchema)(it, schema);
    }
    exports2.default = def;
  },
});

// node_modules/@near-js/accounts/node_modules/ajv/dist/vocabularies/applicator/thenElse.js
var require_thenElse = __commonJS({
  "node_modules/@near-js/accounts/node_modules/ajv/dist/vocabularies/applicator/thenElse.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var util_1 = require_util();
    var def = {
      keyword: ["then", "else"],
      schemaType: ["object", "boolean"],
      code({ keyword, parentSchema, it }) {
        if (parentSchema.if === void 0)
          (0, util_1.checkStrictMode)(
            it,
            `"${keyword}" without "if" is ignored`
          );
      },
    };
    exports2.default = def;
  },
});

// node_modules/@near-js/accounts/node_modules/ajv/dist/vocabularies/applicator/index.js
var require_applicator = __commonJS({
  "node_modules/@near-js/accounts/node_modules/ajv/dist/vocabularies/applicator/index.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var additionalItems_1 = require_additionalItems();
    var prefixItems_1 = require_prefixItems();
    var items_1 = require_items();
    var items2020_1 = require_items2020();
    var contains_1 = require_contains();
    var dependencies_1 = require_dependencies();
    var propertyNames_1 = require_propertyNames();
    var additionalProperties_1 = require_additionalProperties();
    var properties_1 = require_properties();
    var patternProperties_1 = require_patternProperties();
    var not_1 = require_not();
    var anyOf_1 = require_anyOf();
    var oneOf_1 = require_oneOf();
    var allOf_1 = require_allOf();
    var if_1 = require_if();
    var thenElse_1 = require_thenElse();
    function getApplicator(draft2020 = false) {
      const applicator = [
        // any
        not_1.default,
        anyOf_1.default,
        oneOf_1.default,
        allOf_1.default,
        if_1.default,
        thenElse_1.default,
        // object
        propertyNames_1.default,
        additionalProperties_1.default,
        dependencies_1.default,
        properties_1.default,
        patternProperties_1.default,
      ];
      if (draft2020)
        applicator.push(prefixItems_1.default, items2020_1.default);
      else applicator.push(additionalItems_1.default, items_1.default);
      applicator.push(contains_1.default);
      return applicator;
    }
    exports2.default = getApplicator;
  },
});

// node_modules/@near-js/accounts/node_modules/ajv/dist/vocabularies/format/format.js
var require_format3 = __commonJS({
  "node_modules/@near-js/accounts/node_modules/ajv/dist/vocabularies/format/format.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message: ({ schemaCode }) =>
        (0, codegen_1.str)`must match format "${schemaCode}"`,
      params: ({ schemaCode }) => (0, codegen_1._)`{format: ${schemaCode}}`,
    };
    var def = {
      keyword: "format",
      type: ["number", "string"],
      schemaType: "string",
      $data: true,
      error,
      code(cxt, ruleType) {
        const { gen, data, $data, schema, schemaCode, it } = cxt;
        const { opts, errSchemaPath, schemaEnv, self: self2 } = it;
        if (!opts.validateFormats) return;
        if ($data) validate$DataFormat();
        else validateFormat();
        function validate$DataFormat() {
          const fmts = gen.scopeValue("formats", {
            ref: self2.formats,
            code: opts.code.formats,
          });
          const fDef = gen.const(
            "fDef",
            (0, codegen_1._)`${fmts}[${schemaCode}]`
          );
          const fType = gen.let("fType");
          const format = gen.let("format");
          gen.if(
            (0,
            codegen_1._)`typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`,
            () =>
              gen
                .assign(fType, (0, codegen_1._)`${fDef}.type || "string"`)
                .assign(format, (0, codegen_1._)`${fDef}.validate`),
            () =>
              gen.assign(fType, (0, codegen_1._)`"string"`).assign(format, fDef)
          );
          cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()));
          function unknownFmt() {
            if (opts.strictSchema === false) return codegen_1.nil;
            return (0, codegen_1._)`${schemaCode} && !${format}`;
          }
          function invalidFmt() {
            const callFormat = schemaEnv.$async
              ? (0,
                codegen_1._)`(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))`
              : (0, codegen_1._)`${format}(${data})`;
            const validData = (0,
            codegen_1._)`(typeof ${format} == "function" ? ${callFormat} : ${format}.test(${data}))`;
            return (0,
            codegen_1._)`${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`;
          }
        }
        function validateFormat() {
          const formatDef = self2.formats[schema];
          if (!formatDef) {
            unknownFormat();
            return;
          }
          if (formatDef === true) return;
          const [fmtType, format, fmtRef] = getFormat(formatDef);
          if (fmtType === ruleType) cxt.pass(validCondition());
          function unknownFormat() {
            if (opts.strictSchema === false) {
              self2.logger.warn(unknownMsg());
              return;
            }
            throw new Error(unknownMsg());
            function unknownMsg() {
              return `unknown format "${schema}" ignored in schema at path "${errSchemaPath}"`;
            }
          }
          function getFormat(fmtDef) {
            const code =
              fmtDef instanceof RegExp
                ? (0, codegen_1.regexpCode)(fmtDef)
                : opts.code.formats
                ? (0, codegen_1._)`${opts.code.formats}${(0,
                  codegen_1.getProperty)(schema)}`
                : void 0;
            const fmt = gen.scopeValue("formats", {
              key: schema,
              ref: fmtDef,
              code,
            });
            if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
              return [
                fmtDef.type || "string",
                fmtDef.validate,
                (0, codegen_1._)`${fmt}.validate`,
              ];
            }
            return ["string", fmtDef, fmt];
          }
          function validCondition() {
            if (
              typeof formatDef == "object" &&
              !(formatDef instanceof RegExp) &&
              formatDef.async
            ) {
              if (!schemaEnv.$async)
                throw new Error("async format in sync schema");
              return (0, codegen_1._)`await ${fmtRef}(${data})`;
            }
            return typeof format == "function"
              ? (0, codegen_1._)`${fmtRef}(${data})`
              : (0, codegen_1._)`${fmtRef}.test(${data})`;
          }
        }
      },
    };
    exports2.default = def;
  },
});

// node_modules/@near-js/accounts/node_modules/ajv/dist/vocabularies/format/index.js
var require_format4 = __commonJS({
  "node_modules/@near-js/accounts/node_modules/ajv/dist/vocabularies/format/index.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var format_1 = require_format3();
    var format = [format_1.default];
    exports2.default = format;
  },
});

// node_modules/@near-js/accounts/node_modules/ajv/dist/vocabularies/metadata.js
var require_metadata = __commonJS({
  "node_modules/@near-js/accounts/node_modules/ajv/dist/vocabularies/metadata.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.contentVocabulary = exports2.metadataVocabulary = void 0;
    exports2.metadataVocabulary = [
      "title",
      "description",
      "default",
      "deprecated",
      "readOnly",
      "writeOnly",
      "examples",
    ];
    exports2.contentVocabulary = [
      "contentMediaType",
      "contentEncoding",
      "contentSchema",
    ];
  },
});

// node_modules/@near-js/accounts/node_modules/ajv/dist/vocabularies/draft7.js
var require_draft7 = __commonJS({
  "node_modules/@near-js/accounts/node_modules/ajv/dist/vocabularies/draft7.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var core_1 = require_core2();
    var validation_1 = require_validation();
    var applicator_1 = require_applicator();
    var format_1 = require_format4();
    var metadata_1 = require_metadata();
    var draft7Vocabularies = [
      core_1.default,
      validation_1.default,
      (0, applicator_1.default)(),
      format_1.default,
      metadata_1.metadataVocabulary,
      metadata_1.contentVocabulary,
    ];
    exports2.default = draft7Vocabularies;
  },
});

// node_modules/@near-js/accounts/node_modules/ajv/dist/vocabularies/discriminator/types.js
var require_types2 = __commonJS({
  "node_modules/@near-js/accounts/node_modules/ajv/dist/vocabularies/discriminator/types.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DiscrError = void 0;
    (function (DiscrError2) {
      DiscrError2["Tag"] = "tag";
      DiscrError2["Mapping"] = "mapping";
    })(exports2.DiscrError || (exports2.DiscrError = {}));
  },
});

// node_modules/@near-js/accounts/node_modules/ajv/dist/vocabularies/discriminator/index.js
var require_discriminator = __commonJS({
  "node_modules/@near-js/accounts/node_modules/ajv/dist/vocabularies/discriminator/index.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var types_1 = require_types2();
    var compile_1 = require_compile();
    var util_1 = require_util();
    var error = {
      message: ({ params: { discrError, tagName } }) =>
        discrError === types_1.DiscrError.Tag
          ? `tag "${tagName}" must be string`
          : `value of tag "${tagName}" must be in oneOf`,
      params: ({ params: { discrError, tag, tagName } }) =>
        (0,
        codegen_1._)`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`,
    };
    var def = {
      keyword: "discriminator",
      type: "object",
      schemaType: "object",
      error,
      code(cxt) {
        const { gen, data, schema, parentSchema, it } = cxt;
        const { oneOf } = parentSchema;
        if (!it.opts.discriminator) {
          throw new Error("discriminator: requires discriminator option");
        }
        const tagName = schema.propertyName;
        if (typeof tagName != "string")
          throw new Error("discriminator: requires propertyName");
        if (schema.mapping)
          throw new Error("discriminator: mapping is not supported");
        if (!oneOf) throw new Error("discriminator: requires oneOf keyword");
        const valid = gen.let("valid", false);
        const tag = gen.const(
          "tag",
          (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(tagName)}`
        );
        gen.if(
          (0, codegen_1._)`typeof ${tag} == "string"`,
          () => validateMapping(),
          () =>
            cxt.error(false, {
              discrError: types_1.DiscrError.Tag,
              tag,
              tagName,
            })
        );
        cxt.ok(valid);
        function validateMapping() {
          const mapping = getMapping();
          gen.if(false);
          for (const tagValue in mapping) {
            gen.elseIf((0, codegen_1._)`${tag} === ${tagValue}`);
            gen.assign(valid, applyTagSchema(mapping[tagValue]));
          }
          gen.else();
          cxt.error(false, {
            discrError: types_1.DiscrError.Mapping,
            tag,
            tagName,
          });
          gen.endIf();
        }
        function applyTagSchema(schemaProp) {
          const _valid = gen.name("valid");
          const schCxt = cxt.subschema(
            { keyword: "oneOf", schemaProp },
            _valid
          );
          cxt.mergeEvaluated(schCxt, codegen_1.Name);
          return _valid;
        }
        function getMapping() {
          var _a;
          const oneOfMapping = {};
          const topRequired = hasRequired(parentSchema);
          let tagRequired = true;
          for (let i = 0; i < oneOf.length; i++) {
            let sch = oneOf[i];
            if (
              (sch === null || sch === void 0 ? void 0 : sch.$ref) &&
              !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)
            ) {
              sch = compile_1.resolveRef.call(
                it.self,
                it.schemaEnv.root,
                it.baseId,
                sch === null || sch === void 0 ? void 0 : sch.$ref
              );
              if (sch instanceof compile_1.SchemaEnv) sch = sch.schema;
            }
            const propSch =
              (_a =
                sch === null || sch === void 0 ? void 0 : sch.properties) ===
                null || _a === void 0
                ? void 0
                : _a[tagName];
            if (typeof propSch != "object") {
              throw new Error(
                `discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`
              );
            }
            tagRequired = tagRequired && (topRequired || hasRequired(sch));
            addMappings(propSch, i);
          }
          if (!tagRequired)
            throw new Error(`discriminator: "${tagName}" must be required`);
          return oneOfMapping;
          function hasRequired({ required }) {
            return Array.isArray(required) && required.includes(tagName);
          }
          function addMappings(sch, i) {
            if (sch.const) {
              addMapping(sch.const, i);
            } else if (sch.enum) {
              for (const tagValue of sch.enum) {
                addMapping(tagValue, i);
              }
            } else {
              throw new Error(
                `discriminator: "properties/${tagName}" must have "const" or "enum"`
              );
            }
          }
          function addMapping(tagValue, i) {
            if (typeof tagValue != "string" || tagValue in oneOfMapping) {
              throw new Error(
                `discriminator: "${tagName}" values must be unique strings`
              );
            }
            oneOfMapping[tagValue] = i;
          }
        }
      },
    };
    exports2.default = def;
  },
});

// node_modules/@near-js/accounts/node_modules/ajv/dist/refs/json-schema-draft-07.json
var require_json_schema_draft_07 = __commonJS({
  "node_modules/@near-js/accounts/node_modules/ajv/dist/refs/json-schema-draft-07.json"(
    exports2,
    module2
  ) {
    module2.exports = {
      $schema: "http://json-schema.org/draft-07/schema#",
      $id: "http://json-schema.org/draft-07/schema#",
      title: "Core schema meta-schema",
      definitions: {
        schemaArray: {
          type: "array",
          minItems: 1,
          items: { $ref: "#" },
        },
        nonNegativeInteger: {
          type: "integer",
          minimum: 0,
        },
        nonNegativeIntegerDefault0: {
          allOf: [{ $ref: "#/definitions/nonNegativeInteger" }, { default: 0 }],
        },
        simpleTypes: {
          enum: [
            "array",
            "boolean",
            "integer",
            "null",
            "number",
            "object",
            "string",
          ],
        },
        stringArray: {
          type: "array",
          items: { type: "string" },
          uniqueItems: true,
          default: [],
        },
      },
      type: ["object", "boolean"],
      properties: {
        $id: {
          type: "string",
          format: "uri-reference",
        },
        $schema: {
          type: "string",
          format: "uri",
        },
        $ref: {
          type: "string",
          format: "uri-reference",
        },
        $comment: {
          type: "string",
        },
        title: {
          type: "string",
        },
        description: {
          type: "string",
        },
        default: true,
        readOnly: {
          type: "boolean",
          default: false,
        },
        examples: {
          type: "array",
          items: true,
        },
        multipleOf: {
          type: "number",
          exclusiveMinimum: 0,
        },
        maximum: {
          type: "number",
        },
        exclusiveMaximum: {
          type: "number",
        },
        minimum: {
          type: "number",
        },
        exclusiveMinimum: {
          type: "number",
        },
        maxLength: { $ref: "#/definitions/nonNegativeInteger" },
        minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        pattern: {
          type: "string",
          format: "regex",
        },
        additionalItems: { $ref: "#" },
        items: {
          anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }],
          default: true,
        },
        maxItems: { $ref: "#/definitions/nonNegativeInteger" },
        minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        uniqueItems: {
          type: "boolean",
          default: false,
        },
        contains: { $ref: "#" },
        maxProperties: { $ref: "#/definitions/nonNegativeInteger" },
        minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        required: { $ref: "#/definitions/stringArray" },
        additionalProperties: { $ref: "#" },
        definitions: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {},
        },
        properties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {},
        },
        patternProperties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          propertyNames: { format: "regex" },
          default: {},
        },
        dependencies: {
          type: "object",
          additionalProperties: {
            anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }],
          },
        },
        propertyNames: { $ref: "#" },
        const: true,
        enum: {
          type: "array",
          items: true,
          minItems: 1,
          uniqueItems: true,
        },
        type: {
          anyOf: [
            { $ref: "#/definitions/simpleTypes" },
            {
              type: "array",
              items: { $ref: "#/definitions/simpleTypes" },
              minItems: 1,
              uniqueItems: true,
            },
          ],
        },
        format: { type: "string" },
        contentMediaType: { type: "string" },
        contentEncoding: { type: "string" },
        if: { $ref: "#" },
        then: { $ref: "#" },
        else: { $ref: "#" },
        allOf: { $ref: "#/definitions/schemaArray" },
        anyOf: { $ref: "#/definitions/schemaArray" },
        oneOf: { $ref: "#/definitions/schemaArray" },
        not: { $ref: "#" },
      },
      default: true,
    };
  },
});

// node_modules/@near-js/accounts/node_modules/ajv/dist/ajv.js
var require_ajv = __commonJS({
  "node_modules/@near-js/accounts/node_modules/ajv/dist/ajv.js"(
    exports2,
    module2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MissingRefError =
      exports2.ValidationError =
      exports2.CodeGen =
      exports2.Name =
      exports2.nil =
      exports2.stringify =
      exports2.str =
      exports2._ =
      exports2.KeywordCxt =
        void 0;
    var core_1 = require_core();
    var draft7_1 = require_draft7();
    var discriminator_1 = require_discriminator();
    var draft7MetaSchema = require_json_schema_draft_07();
    var META_SUPPORT_DATA = ["/properties"];
    var META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
    var Ajv = class extends core_1.default {
      _addVocabularies() {
        super._addVocabularies();
        draft7_1.default.forEach((v) => this.addVocabulary(v));
        if (this.opts.discriminator) this.addKeyword(discriminator_1.default);
      }
      _addDefaultMetaSchema() {
        super._addDefaultMetaSchema();
        if (!this.opts.meta) return;
        const metaSchema = this.opts.$data
          ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA)
          : draft7MetaSchema;
        this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);
        this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
      }
      defaultMeta() {
        return (this.opts.defaultMeta =
          super.defaultMeta() ||
          (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0));
      }
    };
    module2.exports = exports2 = Ajv;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = Ajv;
    var validate_1 = require_validate();
    Object.defineProperty(exports2, "KeywordCxt", {
      enumerable: true,
      get: function () {
        return validate_1.KeywordCxt;
      },
    });
    var codegen_1 = require_codegen();
    Object.defineProperty(exports2, "_", {
      enumerable: true,
      get: function () {
        return codegen_1._;
      },
    });
    Object.defineProperty(exports2, "str", {
      enumerable: true,
      get: function () {
        return codegen_1.str;
      },
    });
    Object.defineProperty(exports2, "stringify", {
      enumerable: true,
      get: function () {
        return codegen_1.stringify;
      },
    });
    Object.defineProperty(exports2, "nil", {
      enumerable: true,
      get: function () {
        return codegen_1.nil;
      },
    });
    Object.defineProperty(exports2, "Name", {
      enumerable: true,
      get: function () {
        return codegen_1.Name;
      },
    });
    Object.defineProperty(exports2, "CodeGen", {
      enumerable: true,
      get: function () {
        return codegen_1.CodeGen;
      },
    });
    var validation_error_1 = require_validation_error();
    Object.defineProperty(exports2, "ValidationError", {
      enumerable: true,
      get: function () {
        return validation_error_1.default;
      },
    });
    var ref_error_1 = require_ref_error();
    Object.defineProperty(exports2, "MissingRefError", {
      enumerable: true,
      get: function () {
        return ref_error_1.default;
      },
    });
  },
});

// node_modules/ajv-formats/dist/formats.js
var require_formats = __commonJS({
  "node_modules/ajv-formats/dist/formats.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.formatNames = exports2.fastFormats = exports2.fullFormats = void 0;
    function fmtDef(validate, compare) {
      return { validate, compare };
    }
    exports2.fullFormats = {
      // date: http://tools.ietf.org/html/rfc3339#section-5.6
      date: fmtDef(date, compareDate),
      // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
      time: fmtDef(time, compareTime),
      "date-time": fmtDef(date_time, compareDateTime),
      // duration: https://tools.ietf.org/html/rfc3339#appendix-A
      duration:
        /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
      uri,
      "uri-reference":
        /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
      // uri-template: https://tools.ietf.org/html/rfc6570
      "uri-template":
        /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
      // For the source: https://gist.github.com/dperini/729294
      // For test cases: https://mathiasbynens.be/demo/url-regex
      url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
      email:
        /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
      hostname:
        /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
      // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
      ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
      ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
      regex,
      // uuid: http://tools.ietf.org/html/rfc4122
      uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
      // JSON-pointer: https://tools.ietf.org/html/rfc6901
      // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
      "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
      "json-pointer-uri-fragment":
        /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
      // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
      "relative-json-pointer":
        /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
      // the following formats are used by the openapi specification: https://spec.openapis.org/oas/v3.0.0#data-types
      // byte: https://github.com/miguelmota/is-base64
      byte,
      // signed 32 bit integer
      int32: { type: "number", validate: validateInt32 },
      // signed 64 bit integer
      int64: { type: "number", validate: validateInt64 },
      // C-type float
      float: { type: "number", validate: validateNumber },
      // C-type double
      double: { type: "number", validate: validateNumber },
      // hint to the UI to hide input strings
      password: true,
      // unchecked string payload
      binary: true,
    };
    exports2.fastFormats = {
      ...exports2.fullFormats,
      date: fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, compareDate),
      time: fmtDef(
        /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i,
        compareTime
      ),
      "date-time": fmtDef(
        /^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i,
        compareDateTime
      ),
      // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
      uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
      "uri-reference":
        /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
      // email (sources from jsen validator):
      // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
      // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'wilful violation')
      email:
        /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,
    };
    exports2.formatNames = Object.keys(exports2.fullFormats);
    function isLeapYear(year) {
      return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
    }
    var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
    var DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    function date(str) {
      const matches = DATE.exec(str);
      if (!matches) return false;
      const year = +matches[1];
      const month = +matches[2];
      const day = +matches[3];
      return (
        month >= 1 &&
        month <= 12 &&
        day >= 1 &&
        day <= (month === 2 && isLeapYear(year) ? 29 : DAYS[month])
      );
    }
    function compareDate(d1, d2) {
      if (!(d1 && d2)) return void 0;
      if (d1 > d2) return 1;
      if (d1 < d2) return -1;
      return 0;
    }
    var TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i;
    function time(str, withTimeZone) {
      const matches = TIME.exec(str);
      if (!matches) return false;
      const hour = +matches[1];
      const minute = +matches[2];
      const second = +matches[3];
      const timeZone = matches[5];
      return (
        ((hour <= 23 && minute <= 59 && second <= 59) ||
          (hour === 23 && minute === 59 && second === 60)) &&
        (!withTimeZone || timeZone !== "")
      );
    }
    function compareTime(t1, t2) {
      if (!(t1 && t2)) return void 0;
      const a1 = TIME.exec(t1);
      const a2 = TIME.exec(t2);
      if (!(a1 && a2)) return void 0;
      t1 = a1[1] + a1[2] + a1[3] + (a1[4] || "");
      t2 = a2[1] + a2[2] + a2[3] + (a2[4] || "");
      if (t1 > t2) return 1;
      if (t1 < t2) return -1;
      return 0;
    }
    var DATE_TIME_SEPARATOR = /t|\s/i;
    function date_time(str) {
      const dateTime = str.split(DATE_TIME_SEPARATOR);
      return (
        dateTime.length === 2 && date(dateTime[0]) && time(dateTime[1], true)
      );
    }
    function compareDateTime(dt1, dt2) {
      if (!(dt1 && dt2)) return void 0;
      const [d1, t1] = dt1.split(DATE_TIME_SEPARATOR);
      const [d2, t2] = dt2.split(DATE_TIME_SEPARATOR);
      const res = compareDate(d1, d2);
      if (res === void 0) return void 0;
      return res || compareTime(t1, t2);
    }
    var NOT_URI_FRAGMENT = /\/|:/;
    var URI =
      /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
    function uri(str) {
      return NOT_URI_FRAGMENT.test(str) && URI.test(str);
    }
    var BYTE =
      /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
    function byte(str) {
      BYTE.lastIndex = 0;
      return BYTE.test(str);
    }
    var MIN_INT32 = -(2 ** 31);
    var MAX_INT32 = 2 ** 31 - 1;
    function validateInt32(value) {
      return (
        Number.isInteger(value) && value <= MAX_INT32 && value >= MIN_INT32
      );
    }
    function validateInt64(value) {
      return Number.isInteger(value);
    }
    function validateNumber() {
      return true;
    }
    var Z_ANCHOR = /[^\\]\\Z/;
    function regex(str) {
      if (Z_ANCHOR.test(str)) return false;
      try {
        new RegExp(str);
        return true;
      } catch (e) {
        return false;
      }
    }
  },
});

// node_modules/ajv-formats/node_modules/ajv/dist/compile/codegen/code.js
var require_code3 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/compile/codegen/code.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.regexpCode =
      exports2.getEsmExportName =
      exports2.getProperty =
      exports2.safeStringify =
      exports2.stringify =
      exports2.strConcat =
      exports2.addCodeArg =
      exports2.str =
      exports2._ =
      exports2.nil =
      exports2._Code =
      exports2.Name =
      exports2.IDENTIFIER =
      exports2._CodeOrName =
        void 0;
    var _CodeOrName = class {};
    exports2._CodeOrName = _CodeOrName;
    exports2.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
    var Name = class extends _CodeOrName {
      constructor(s) {
        super();
        if (!exports2.IDENTIFIER.test(s))
          throw new Error("CodeGen: name must be a valid identifier");
        this.str = s;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        return false;
      }
      get names() {
        return { [this.str]: 1 };
      }
    };
    exports2.Name = Name;
    var _Code = class extends _CodeOrName {
      constructor(code) {
        super();
        this._items = typeof code === "string" ? [code] : code;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        if (this._items.length > 1) return false;
        const item = this._items[0];
        return item === "" || item === '""';
      }
      get str() {
        var _a;
        return (_a = this._str) !== null && _a !== void 0
          ? _a
          : (this._str = this._items.reduce((s, c) => `${s}${c}`, ""));
      }
      get names() {
        var _a;
        return (_a = this._names) !== null && _a !== void 0
          ? _a
          : (this._names = this._items.reduce((names, c) => {
              if (c instanceof Name) names[c.str] = (names[c.str] || 0) + 1;
              return names;
            }, {}));
      }
    };
    exports2._Code = _Code;
    exports2.nil = new _Code("");
    function _(strs, ...args) {
      const code = [strs[0]];
      let i = 0;
      while (i < args.length) {
        addCodeArg(code, args[i]);
        code.push(strs[++i]);
      }
      return new _Code(code);
    }
    exports2._ = _;
    var plus = new _Code("+");
    function str(strs, ...args) {
      const expr = [safeStringify(strs[0])];
      let i = 0;
      while (i < args.length) {
        expr.push(plus);
        addCodeArg(expr, args[i]);
        expr.push(plus, safeStringify(strs[++i]));
      }
      optimize(expr);
      return new _Code(expr);
    }
    exports2.str = str;
    function addCodeArg(code, arg) {
      if (arg instanceof _Code) code.push(...arg._items);
      else if (arg instanceof Name) code.push(arg);
      else code.push(interpolate(arg));
    }
    exports2.addCodeArg = addCodeArg;
    function optimize(expr) {
      let i = 1;
      while (i < expr.length - 1) {
        if (expr[i] === plus) {
          const res = mergeExprItems(expr[i - 1], expr[i + 1]);
          if (res !== void 0) {
            expr.splice(i - 1, 3, res);
            continue;
          }
          expr[i++] = "+";
        }
        i++;
      }
    }
    function mergeExprItems(a, b) {
      if (b === '""') return a;
      if (a === '""') return b;
      if (typeof a == "string") {
        if (b instanceof Name || a[a.length - 1] !== '"') return;
        if (typeof b != "string") return `${a.slice(0, -1)}${b}"`;
        if (b[0] === '"') return a.slice(0, -1) + b.slice(1);
        return;
      }
      if (typeof b == "string" && b[0] === '"' && !(a instanceof Name))
        return `"${a}${b.slice(1)}`;
      return;
    }
    function strConcat(c1, c2) {
      return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`;
    }
    exports2.strConcat = strConcat;
    function interpolate(x) {
      return typeof x == "number" || typeof x == "boolean" || x === null
        ? x
        : safeStringify(Array.isArray(x) ? x.join(",") : x);
    }
    function stringify(x) {
      return new _Code(safeStringify(x));
    }
    exports2.stringify = stringify;
    function safeStringify(x) {
      return JSON.stringify(x)
        .replace(/\u2028/g, "\\u2028")
        .replace(/\u2029/g, "\\u2029");
    }
    exports2.safeStringify = safeStringify;
    function getProperty(key) {
      return typeof key == "string" && exports2.IDENTIFIER.test(key)
        ? new _Code(`.${key}`)
        : _`[${key}]`;
    }
    exports2.getProperty = getProperty;
    function getEsmExportName(key) {
      if (typeof key == "string" && exports2.IDENTIFIER.test(key)) {
        return new _Code(`${key}`);
      }
      throw new Error(
        `CodeGen: invalid export name: ${key}, use explicit $id name mapping`
      );
    }
    exports2.getEsmExportName = getEsmExportName;
    function regexpCode(rx) {
      return new _Code(rx.toString());
    }
    exports2.regexpCode = regexpCode;
  },
});

// node_modules/ajv-formats/node_modules/ajv/dist/compile/codegen/scope.js
var require_scope2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/compile/codegen/scope.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ValueScope =
      exports2.ValueScopeName =
      exports2.Scope =
      exports2.varKinds =
      exports2.UsedValueState =
        void 0;
    var code_1 = require_code3();
    var ValueError = class extends Error {
      constructor(name) {
        super(`CodeGen: "code" for ${name} not defined`);
        this.value = name.value;
      }
    };
    var UsedValueState;
    (function (UsedValueState2) {
      UsedValueState2[(UsedValueState2["Started"] = 0)] = "Started";
      UsedValueState2[(UsedValueState2["Completed"] = 1)] = "Completed";
    })(
      (UsedValueState =
        exports2.UsedValueState || (exports2.UsedValueState = {}))
    );
    exports2.varKinds = {
      const: new code_1.Name("const"),
      let: new code_1.Name("let"),
      var: new code_1.Name("var"),
    };
    var Scope = class {
      constructor({ prefixes, parent } = {}) {
        this._names = {};
        this._prefixes = prefixes;
        this._parent = parent;
      }
      toName(nameOrPrefix) {
        return nameOrPrefix instanceof code_1.Name
          ? nameOrPrefix
          : this.name(nameOrPrefix);
      }
      name(prefix) {
        return new code_1.Name(this._newName(prefix));
      }
      _newName(prefix) {
        const ng = this._names[prefix] || this._nameGroup(prefix);
        return `${prefix}${ng.index++}`;
      }
      _nameGroup(prefix) {
        var _a, _b;
        if (
          ((_b =
            (_a = this._parent) === null || _a === void 0
              ? void 0
              : _a._prefixes) === null || _b === void 0
            ? void 0
            : _b.has(prefix)) ||
          (this._prefixes && !this._prefixes.has(prefix))
        ) {
          throw new Error(
            `CodeGen: prefix "${prefix}" is not allowed in this scope`
          );
        }
        return (this._names[prefix] = { prefix, index: 0 });
      }
    };
    exports2.Scope = Scope;
    var ValueScopeName = class extends code_1.Name {
      constructor(prefix, nameStr) {
        super(nameStr);
        this.prefix = prefix;
      }
      setValue(value, { property, itemIndex }) {
        this.value = value;
        this.scopePath = (0, code_1._)`.${new code_1.Name(
          property
        )}[${itemIndex}]`;
      }
    };
    exports2.ValueScopeName = ValueScopeName;
    var line = (0, code_1._)`\n`;
    var ValueScope = class extends Scope {
      constructor(opts) {
        super(opts);
        this._values = {};
        this._scope = opts.scope;
        this.opts = { ...opts, _n: opts.lines ? line : code_1.nil };
      }
      get() {
        return this._scope;
      }
      name(prefix) {
        return new ValueScopeName(prefix, this._newName(prefix));
      }
      value(nameOrPrefix, value) {
        var _a;
        if (value.ref === void 0)
          throw new Error("CodeGen: ref must be passed in value");
        const name = this.toName(nameOrPrefix);
        const { prefix } = name;
        const valueKey =
          (_a = value.key) !== null && _a !== void 0 ? _a : value.ref;
        let vs = this._values[prefix];
        if (vs) {
          const _name = vs.get(valueKey);
          if (_name) return _name;
        } else {
          vs = this._values[prefix] = /* @__PURE__ */ new Map();
        }
        vs.set(valueKey, name);
        const s = this._scope[prefix] || (this._scope[prefix] = []);
        const itemIndex = s.length;
        s[itemIndex] = value.ref;
        name.setValue(value, { property: prefix, itemIndex });
        return name;
      }
      getValue(prefix, keyOrRef) {
        const vs = this._values[prefix];
        if (!vs) return;
        return vs.get(keyOrRef);
      }
      scopeRefs(scopeName, values = this._values) {
        return this._reduceValues(values, (name) => {
          if (name.scopePath === void 0)
            throw new Error(`CodeGen: name "${name}" has no value`);
          return (0, code_1._)`${scopeName}${name.scopePath}`;
        });
      }
      scopeCode(values = this._values, usedValues, getCode) {
        return this._reduceValues(
          values,
          (name) => {
            if (name.value === void 0)
              throw new Error(`CodeGen: name "${name}" has no value`);
            return name.value.code;
          },
          usedValues,
          getCode
        );
      }
      _reduceValues(values, valueCode, usedValues = {}, getCode) {
        let code = code_1.nil;
        for (const prefix in values) {
          const vs = values[prefix];
          if (!vs) continue;
          const nameSet = (usedValues[prefix] =
            usedValues[prefix] || /* @__PURE__ */ new Map());
          vs.forEach((name) => {
            if (nameSet.has(name)) return;
            nameSet.set(name, UsedValueState.Started);
            let c = valueCode(name);
            if (c) {
              const def = this.opts.es5
                ? exports2.varKinds.var
                : exports2.varKinds.const;
              code = (0,
              code_1._)`${code}${def} ${name} = ${c};${this.opts._n}`;
            } else if (
              (c =
                getCode === null || getCode === void 0 ? void 0 : getCode(name))
            ) {
              code = (0, code_1._)`${code}${c}${this.opts._n}`;
            } else {
              throw new ValueError(name);
            }
            nameSet.set(name, UsedValueState.Completed);
          });
        }
        return code;
      }
    };
    exports2.ValueScope = ValueScope;
  },
});

// node_modules/ajv-formats/node_modules/ajv/dist/compile/codegen/index.js
var require_codegen2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/compile/codegen/index.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.or =
      exports2.and =
      exports2.not =
      exports2.CodeGen =
      exports2.operators =
      exports2.varKinds =
      exports2.ValueScopeName =
      exports2.ValueScope =
      exports2.Scope =
      exports2.Name =
      exports2.regexpCode =
      exports2.stringify =
      exports2.getProperty =
      exports2.nil =
      exports2.strConcat =
      exports2.str =
      exports2._ =
        void 0;
    var code_1 = require_code3();
    var scope_1 = require_scope2();
    var code_2 = require_code3();
    Object.defineProperty(exports2, "_", {
      enumerable: true,
      get: function () {
        return code_2._;
      },
    });
    Object.defineProperty(exports2, "str", {
      enumerable: true,
      get: function () {
        return code_2.str;
      },
    });
    Object.defineProperty(exports2, "strConcat", {
      enumerable: true,
      get: function () {
        return code_2.strConcat;
      },
    });
    Object.defineProperty(exports2, "nil", {
      enumerable: true,
      get: function () {
        return code_2.nil;
      },
    });
    Object.defineProperty(exports2, "getProperty", {
      enumerable: true,
      get: function () {
        return code_2.getProperty;
      },
    });
    Object.defineProperty(exports2, "stringify", {
      enumerable: true,
      get: function () {
        return code_2.stringify;
      },
    });
    Object.defineProperty(exports2, "regexpCode", {
      enumerable: true,
      get: function () {
        return code_2.regexpCode;
      },
    });
    Object.defineProperty(exports2, "Name", {
      enumerable: true,
      get: function () {
        return code_2.Name;
      },
    });
    var scope_2 = require_scope2();
    Object.defineProperty(exports2, "Scope", {
      enumerable: true,
      get: function () {
        return scope_2.Scope;
      },
    });
    Object.defineProperty(exports2, "ValueScope", {
      enumerable: true,
      get: function () {
        return scope_2.ValueScope;
      },
    });
    Object.defineProperty(exports2, "ValueScopeName", {
      enumerable: true,
      get: function () {
        return scope_2.ValueScopeName;
      },
    });
    Object.defineProperty(exports2, "varKinds", {
      enumerable: true,
      get: function () {
        return scope_2.varKinds;
      },
    });
    exports2.operators = {
      GT: new code_1._Code(">"),
      GTE: new code_1._Code(">="),
      LT: new code_1._Code("<"),
      LTE: new code_1._Code("<="),
      EQ: new code_1._Code("==="),
      NEQ: new code_1._Code("!=="),
      NOT: new code_1._Code("!"),
      OR: new code_1._Code("||"),
      AND: new code_1._Code("&&"),
      ADD: new code_1._Code("+"),
    };
    var Node = class {
      optimizeNodes() {
        return this;
      }
      optimizeNames(_names, _constants) {
        return this;
      }
    };
    var Def = class extends Node {
      constructor(varKind, name, rhs) {
        super();
        this.varKind = varKind;
        this.name = name;
        this.rhs = rhs;
      }
      render({ es5, _n }) {
        const varKind = es5 ? scope_1.varKinds.var : this.varKind;
        const rhs = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
        return `${varKind} ${this.name}${rhs};` + _n;
      }
      optimizeNames(names, constants) {
        if (!names[this.name.str]) return;
        if (this.rhs) this.rhs = optimizeExpr(this.rhs, names, constants);
        return this;
      }
      get names() {
        return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};
      }
    };
    var Assign = class extends Node {
      constructor(lhs, rhs, sideEffects) {
        super();
        this.lhs = lhs;
        this.rhs = rhs;
        this.sideEffects = sideEffects;
      }
      render({ _n }) {
        return `${this.lhs} = ${this.rhs};` + _n;
      }
      optimizeNames(names, constants) {
        if (
          this.lhs instanceof code_1.Name &&
          !names[this.lhs.str] &&
          !this.sideEffects
        )
          return;
        this.rhs = optimizeExpr(this.rhs, names, constants);
        return this;
      }
      get names() {
        const names =
          this.lhs instanceof code_1.Name ? {} : { ...this.lhs.names };
        return addExprNames(names, this.rhs);
      }
    };
    var AssignOp = class extends Assign {
      constructor(lhs, op, rhs, sideEffects) {
        super(lhs, rhs, sideEffects);
        this.op = op;
      }
      render({ _n }) {
        return `${this.lhs} ${this.op}= ${this.rhs};` + _n;
      }
    };
    var Label = class extends Node {
      constructor(label) {
        super();
        this.label = label;
        this.names = {};
      }
      render({ _n }) {
        return `${this.label}:` + _n;
      }
    };
    var Break = class extends Node {
      constructor(label) {
        super();
        this.label = label;
        this.names = {};
      }
      render({ _n }) {
        const label = this.label ? ` ${this.label}` : "";
        return `break${label};` + _n;
      }
    };
    var Throw = class extends Node {
      constructor(error) {
        super();
        this.error = error;
      }
      render({ _n }) {
        return `throw ${this.error};` + _n;
      }
      get names() {
        return this.error.names;
      }
    };
    var AnyCode = class extends Node {
      constructor(code) {
        super();
        this.code = code;
      }
      render({ _n }) {
        return `${this.code};` + _n;
      }
      optimizeNodes() {
        return `${this.code}` ? this : void 0;
      }
      optimizeNames(names, constants) {
        this.code = optimizeExpr(this.code, names, constants);
        return this;
      }
      get names() {
        return this.code instanceof code_1._CodeOrName ? this.code.names : {};
      }
    };
    var ParentNode = class extends Node {
      constructor(nodes = []) {
        super();
        this.nodes = nodes;
      }
      render(opts) {
        return this.nodes.reduce((code, n) => code + n.render(opts), "");
      }
      optimizeNodes() {
        const { nodes } = this;
        let i = nodes.length;
        while (i--) {
          const n = nodes[i].optimizeNodes();
          if (Array.isArray(n)) nodes.splice(i, 1, ...n);
          else if (n) nodes[i] = n;
          else nodes.splice(i, 1);
        }
        return nodes.length > 0 ? this : void 0;
      }
      optimizeNames(names, constants) {
        const { nodes } = this;
        let i = nodes.length;
        while (i--) {
          const n = nodes[i];
          if (n.optimizeNames(names, constants)) continue;
          subtractNames(names, n.names);
          nodes.splice(i, 1);
        }
        return nodes.length > 0 ? this : void 0;
      }
      get names() {
        return this.nodes.reduce((names, n) => addNames(names, n.names), {});
      }
    };
    var BlockNode = class extends ParentNode {
      render(opts) {
        return "{" + opts._n + super.render(opts) + "}" + opts._n;
      }
    };
    var Root = class extends ParentNode {};
    var Else = class extends BlockNode {};
    Else.kind = "else";
    var If = class _If extends BlockNode {
      constructor(condition, nodes) {
        super(nodes);
        this.condition = condition;
      }
      render(opts) {
        let code = `if(${this.condition})` + super.render(opts);
        if (this.else) code += "else " + this.else.render(opts);
        return code;
      }
      optimizeNodes() {
        super.optimizeNodes();
        const cond = this.condition;
        if (cond === true) return this.nodes;
        let e = this.else;
        if (e) {
          const ns = e.optimizeNodes();
          e = this.else = Array.isArray(ns) ? new Else(ns) : ns;
        }
        if (e) {
          if (cond === false) return e instanceof _If ? e : e.nodes;
          if (this.nodes.length) return this;
          return new _If(not(cond), e instanceof _If ? [e] : e.nodes);
        }
        if (cond === false || !this.nodes.length) return void 0;
        return this;
      }
      optimizeNames(names, constants) {
        var _a;
        this.else =
          (_a = this.else) === null || _a === void 0
            ? void 0
            : _a.optimizeNames(names, constants);
        if (!(super.optimizeNames(names, constants) || this.else)) return;
        this.condition = optimizeExpr(this.condition, names, constants);
        return this;
      }
      get names() {
        const names = super.names;
        addExprNames(names, this.condition);
        if (this.else) addNames(names, this.else.names);
        return names;
      }
    };
    If.kind = "if";
    var For = class extends BlockNode {};
    For.kind = "for";
    var ForLoop = class extends For {
      constructor(iteration) {
        super();
        this.iteration = iteration;
      }
      render(opts) {
        return `for(${this.iteration})` + super.render(opts);
      }
      optimizeNames(names, constants) {
        if (!super.optimizeNames(names, constants)) return;
        this.iteration = optimizeExpr(this.iteration, names, constants);
        return this;
      }
      get names() {
        return addNames(super.names, this.iteration.names);
      }
    };
    var ForRange = class extends For {
      constructor(varKind, name, from, to) {
        super();
        this.varKind = varKind;
        this.name = name;
        this.from = from;
        this.to = to;
      }
      render(opts) {
        const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;
        const { name, from, to } = this;
        return (
          `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` +
          super.render(opts)
        );
      }
      get names() {
        const names = addExprNames(super.names, this.from);
        return addExprNames(names, this.to);
      }
    };
    var ForIter = class extends For {
      constructor(loop, varKind, name, iterable) {
        super();
        this.loop = loop;
        this.varKind = varKind;
        this.name = name;
        this.iterable = iterable;
      }
      render(opts) {
        return (
          `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` +
          super.render(opts)
        );
      }
      optimizeNames(names, constants) {
        if (!super.optimizeNames(names, constants)) return;
        this.iterable = optimizeExpr(this.iterable, names, constants);
        return this;
      }
      get names() {
        return addNames(super.names, this.iterable.names);
      }
    };
    var Func = class extends BlockNode {
      constructor(name, args, async) {
        super();
        this.name = name;
        this.args = args;
        this.async = async;
      }
      render(opts) {
        const _async = this.async ? "async " : "";
        return (
          `${_async}function ${this.name}(${this.args})` + super.render(opts)
        );
      }
    };
    Func.kind = "func";
    var Return = class extends ParentNode {
      render(opts) {
        return "return " + super.render(opts);
      }
    };
    Return.kind = "return";
    var Try = class extends BlockNode {
      render(opts) {
        let code = "try" + super.render(opts);
        if (this.catch) code += this.catch.render(opts);
        if (this.finally) code += this.finally.render(opts);
        return code;
      }
      optimizeNodes() {
        var _a, _b;
        super.optimizeNodes();
        (_a = this.catch) === null || _a === void 0
          ? void 0
          : _a.optimizeNodes();
        (_b = this.finally) === null || _b === void 0
          ? void 0
          : _b.optimizeNodes();
        return this;
      }
      optimizeNames(names, constants) {
        var _a, _b;
        super.optimizeNames(names, constants);
        (_a = this.catch) === null || _a === void 0
          ? void 0
          : _a.optimizeNames(names, constants);
        (_b = this.finally) === null || _b === void 0
          ? void 0
          : _b.optimizeNames(names, constants);
        return this;
      }
      get names() {
        const names = super.names;
        if (this.catch) addNames(names, this.catch.names);
        if (this.finally) addNames(names, this.finally.names);
        return names;
      }
    };
    var Catch = class extends BlockNode {
      constructor(error) {
        super();
        this.error = error;
      }
      render(opts) {
        return `catch(${this.error})` + super.render(opts);
      }
    };
    Catch.kind = "catch";
    var Finally = class extends BlockNode {
      render(opts) {
        return "finally" + super.render(opts);
      }
    };
    Finally.kind = "finally";
    var CodeGen = class {
      constructor(extScope, opts = {}) {
        this._values = {};
        this._blockStarts = [];
        this._constants = {};
        this.opts = { ...opts, _n: opts.lines ? "\n" : "" };
        this._extScope = extScope;
        this._scope = new scope_1.Scope({ parent: extScope });
        this._nodes = [new Root()];
      }
      toString() {
        return this._root.render(this.opts);
      }
      // returns unique name in the internal scope
      name(prefix) {
        return this._scope.name(prefix);
      }
      // reserves unique name in the external scope
      scopeName(prefix) {
        return this._extScope.name(prefix);
      }
      // reserves unique name in the external scope and assigns value to it
      scopeValue(prefixOrName, value) {
        const name = this._extScope.value(prefixOrName, value);
        const vs =
          this._values[name.prefix] ||
          (this._values[name.prefix] = /* @__PURE__ */ new Set());
        vs.add(name);
        return name;
      }
      getScopeValue(prefix, keyOrRef) {
        return this._extScope.getValue(prefix, keyOrRef);
      }
      // return code that assigns values in the external scope to the names that are used internally
      // (same names that were returned by gen.scopeName or gen.scopeValue)
      scopeRefs(scopeName) {
        return this._extScope.scopeRefs(scopeName, this._values);
      }
      scopeCode() {
        return this._extScope.scopeCode(this._values);
      }
      _def(varKind, nameOrPrefix, rhs, constant) {
        const name = this._scope.toName(nameOrPrefix);
        if (rhs !== void 0 && constant) this._constants[name.str] = rhs;
        this._leafNode(new Def(varKind, name, rhs));
        return name;
      }
      // `const` declaration (`var` in es5 mode)
      const(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
      }
      // `let` declaration with optional assignment (`var` in es5 mode)
      let(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
      }
      // `var` declaration with optional assignment
      var(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
      }
      // assignment code
      assign(lhs, rhs, sideEffects) {
        return this._leafNode(new Assign(lhs, rhs, sideEffects));
      }
      // `+=` code
      add(lhs, rhs) {
        return this._leafNode(new AssignOp(lhs, exports2.operators.ADD, rhs));
      }
      // appends passed SafeExpr to code or executes Block
      code(c) {
        if (typeof c == "function") c();
        else if (c !== code_1.nil) this._leafNode(new AnyCode(c));
        return this;
      }
      // returns code for object literal for the passed argument list of key-value pairs
      object(...keyValues) {
        const code = ["{"];
        for (const [key, value] of keyValues) {
          if (code.length > 1) code.push(",");
          code.push(key);
          if (key !== value || this.opts.es5) {
            code.push(":");
            (0, code_1.addCodeArg)(code, value);
          }
        }
        code.push("}");
        return new code_1._Code(code);
      }
      // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
      if(condition, thenBody, elseBody) {
        this._blockNode(new If(condition));
        if (thenBody && elseBody) {
          this.code(thenBody).else().code(elseBody).endIf();
        } else if (thenBody) {
          this.code(thenBody).endIf();
        } else if (elseBody) {
          throw new Error('CodeGen: "else" body without "then" body');
        }
        return this;
      }
      // `else if` clause - invalid without `if` or after `else` clauses
      elseIf(condition) {
        return this._elseNode(new If(condition));
      }
      // `else` clause - only valid after `if` or `else if` clauses
      else() {
        return this._elseNode(new Else());
      }
      // end `if` statement (needed if gen.if was used only with condition)
      endIf() {
        return this._endBlockNode(If, Else);
      }
      _for(node, forBody) {
        this._blockNode(node);
        if (forBody) this.code(forBody).endFor();
        return this;
      }
      // a generic `for` clause (or statement if `forBody` is passed)
      for(iteration, forBody) {
        return this._for(new ForLoop(iteration), forBody);
      }
      // `for` statement for a range of values
      forRange(
        nameOrPrefix,
        from,
        to,
        forBody,
        varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let
      ) {
        const name = this._scope.toName(nameOrPrefix);
        return this._for(new ForRange(varKind, name, from, to), () =>
          forBody(name)
        );
      }
      // `for-of` statement (in es5 mode replace with a normal for loop)
      forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
        const name = this._scope.toName(nameOrPrefix);
        if (this.opts.es5) {
          const arr =
            iterable instanceof code_1.Name
              ? iterable
              : this.var("_arr", iterable);
          return this.forRange("_i", 0, (0, code_1._)`${arr}.length`, (i) => {
            this.var(name, (0, code_1._)`${arr}[${i}]`);
            forBody(name);
          });
        }
        return this._for(new ForIter("of", varKind, name, iterable), () =>
          forBody(name)
        );
      }
      // `for-in` statement.
      // With option `ownProperties` replaced with a `for-of` loop for object keys
      forIn(
        nameOrPrefix,
        obj,
        forBody,
        varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const
      ) {
        if (this.opts.ownProperties) {
          return this.forOf(
            nameOrPrefix,
            (0, code_1._)`Object.keys(${obj})`,
            forBody
          );
        }
        const name = this._scope.toName(nameOrPrefix);
        return this._for(new ForIter("in", varKind, name, obj), () =>
          forBody(name)
        );
      }
      // end `for` loop
      endFor() {
        return this._endBlockNode(For);
      }
      // `label` statement
      label(label) {
        return this._leafNode(new Label(label));
      }
      // `break` statement
      break(label) {
        return this._leafNode(new Break(label));
      }
      // `return` statement
      return(value) {
        const node = new Return();
        this._blockNode(node);
        this.code(value);
        if (node.nodes.length !== 1)
          throw new Error('CodeGen: "return" should have one node');
        return this._endBlockNode(Return);
      }
      // `try` statement
      try(tryBody, catchCode, finallyCode) {
        if (!catchCode && !finallyCode)
          throw new Error('CodeGen: "try" without "catch" and "finally"');
        const node = new Try();
        this._blockNode(node);
        this.code(tryBody);
        if (catchCode) {
          const error = this.name("e");
          this._currNode = node.catch = new Catch(error);
          catchCode(error);
        }
        if (finallyCode) {
          this._currNode = node.finally = new Finally();
          this.code(finallyCode);
        }
        return this._endBlockNode(Catch, Finally);
      }
      // `throw` statement
      throw(error) {
        return this._leafNode(new Throw(error));
      }
      // start self-balancing block
      block(body, nodeCount) {
        this._blockStarts.push(this._nodes.length);
        if (body) this.code(body).endBlock(nodeCount);
        return this;
      }
      // end the current self-balancing block
      endBlock(nodeCount) {
        const len = this._blockStarts.pop();
        if (len === void 0)
          throw new Error("CodeGen: not in self-balancing block");
        const toClose = this._nodes.length - len;
        if (toClose < 0 || (nodeCount !== void 0 && toClose !== nodeCount)) {
          throw new Error(
            `CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`
          );
        }
        this._nodes.length = len;
        return this;
      }
      // `function` heading (or definition if funcBody is passed)
      func(name, args = code_1.nil, async, funcBody) {
        this._blockNode(new Func(name, args, async));
        if (funcBody) this.code(funcBody).endFunc();
        return this;
      }
      // end function definition
      endFunc() {
        return this._endBlockNode(Func);
      }
      optimize(n = 1) {
        while (n-- > 0) {
          this._root.optimizeNodes();
          this._root.optimizeNames(this._root.names, this._constants);
        }
      }
      _leafNode(node) {
        this._currNode.nodes.push(node);
        return this;
      }
      _blockNode(node) {
        this._currNode.nodes.push(node);
        this._nodes.push(node);
      }
      _endBlockNode(N1, N2) {
        const n = this._currNode;
        if (n instanceof N1 || (N2 && n instanceof N2)) {
          this._nodes.pop();
          return this;
        }
        throw new Error(
          `CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`
        );
      }
      _elseNode(node) {
        const n = this._currNode;
        if (!(n instanceof If)) {
          throw new Error('CodeGen: "else" without "if"');
        }
        this._currNode = n.else = node;
        return this;
      }
      get _root() {
        return this._nodes[0];
      }
      get _currNode() {
        const ns = this._nodes;
        return ns[ns.length - 1];
      }
      set _currNode(node) {
        const ns = this._nodes;
        ns[ns.length - 1] = node;
      }
    };
    exports2.CodeGen = CodeGen;
    function addNames(names, from) {
      for (const n in from) names[n] = (names[n] || 0) + (from[n] || 0);
      return names;
    }
    function addExprNames(names, from) {
      return from instanceof code_1._CodeOrName
        ? addNames(names, from.names)
        : names;
    }
    function optimizeExpr(expr, names, constants) {
      if (expr instanceof code_1.Name) return replaceName(expr);
      if (!canOptimize(expr)) return expr;
      return new code_1._Code(
        expr._items.reduce((items, c) => {
          if (c instanceof code_1.Name) c = replaceName(c);
          if (c instanceof code_1._Code) items.push(...c._items);
          else items.push(c);
          return items;
        }, [])
      );
      function replaceName(n) {
        const c = constants[n.str];
        if (c === void 0 || names[n.str] !== 1) return n;
        delete names[n.str];
        return c;
      }
      function canOptimize(e) {
        return (
          e instanceof code_1._Code &&
          e._items.some(
            (c) =>
              c instanceof code_1.Name &&
              names[c.str] === 1 &&
              constants[c.str] !== void 0
          )
        );
      }
    }
    function subtractNames(names, from) {
      for (const n in from) names[n] = (names[n] || 0) - (from[n] || 0);
    }
    function not(x) {
      return typeof x == "boolean" || typeof x == "number" || x === null
        ? !x
        : (0, code_1._)`!${par(x)}`;
    }
    exports2.not = not;
    var andCode = mappend(exports2.operators.AND);
    function and(...args) {
      return args.reduce(andCode);
    }
    exports2.and = and;
    var orCode = mappend(exports2.operators.OR);
    function or(...args) {
      return args.reduce(orCode);
    }
    exports2.or = or;
    function mappend(op) {
      return (x, y) =>
        x === code_1.nil
          ? y
          : y === code_1.nil
          ? x
          : (0, code_1._)`${par(x)} ${op} ${par(y)}`;
    }
    function par(x) {
      return x instanceof code_1.Name ? x : (0, code_1._)`(${x})`;
    }
  },
});

// node_modules/ajv-formats/node_modules/ajv/dist/compile/util.js
var require_util2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/compile/util.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.checkStrictMode =
      exports2.getErrorPath =
      exports2.Type =
      exports2.useFunc =
      exports2.setEvaluated =
      exports2.evaluatedPropsToName =
      exports2.mergeEvaluated =
      exports2.eachItem =
      exports2.unescapeJsonPointer =
      exports2.escapeJsonPointer =
      exports2.escapeFragment =
      exports2.unescapeFragment =
      exports2.schemaRefOrVal =
      exports2.schemaHasRulesButRef =
      exports2.schemaHasRules =
      exports2.checkUnknownRules =
      exports2.alwaysValidSchema =
      exports2.toHash =
        void 0;
    var codegen_1 = require_codegen2();
    var code_1 = require_code3();
    function toHash(arr) {
      const hash = {};
      for (const item of arr) hash[item] = true;
      return hash;
    }
    exports2.toHash = toHash;
    function alwaysValidSchema(it, schema) {
      if (typeof schema == "boolean") return schema;
      if (Object.keys(schema).length === 0) return true;
      checkUnknownRules(it, schema);
      return !schemaHasRules(schema, it.self.RULES.all);
    }
    exports2.alwaysValidSchema = alwaysValidSchema;
    function checkUnknownRules(it, schema = it.schema) {
      const { opts, self: self2 } = it;
      if (!opts.strictSchema) return;
      if (typeof schema === "boolean") return;
      const rules = self2.RULES.keywords;
      for (const key in schema) {
        if (!rules[key]) checkStrictMode(it, `unknown keyword: "${key}"`);
      }
    }
    exports2.checkUnknownRules = checkUnknownRules;
    function schemaHasRules(schema, rules) {
      if (typeof schema == "boolean") return !schema;
      for (const key in schema) if (rules[key]) return true;
      return false;
    }
    exports2.schemaHasRules = schemaHasRules;
    function schemaHasRulesButRef(schema, RULES) {
      if (typeof schema == "boolean") return !schema;
      for (const key in schema)
        if (key !== "$ref" && RULES.all[key]) return true;
      return false;
    }
    exports2.schemaHasRulesButRef = schemaHasRulesButRef;
    function schemaRefOrVal(
      { topSchemaRef, schemaPath },
      schema,
      keyword,
      $data
    ) {
      if (!$data) {
        if (typeof schema == "number" || typeof schema == "boolean")
          return schema;
        if (typeof schema == "string") return (0, codegen_1._)`${schema}`;
      }
      return (0, codegen_1._)`${topSchemaRef}${schemaPath}${(0,
      codegen_1.getProperty)(keyword)}`;
    }
    exports2.schemaRefOrVal = schemaRefOrVal;
    function unescapeFragment(str) {
      return unescapeJsonPointer(decodeURIComponent(str));
    }
    exports2.unescapeFragment = unescapeFragment;
    function escapeFragment(str) {
      return encodeURIComponent(escapeJsonPointer(str));
    }
    exports2.escapeFragment = escapeFragment;
    function escapeJsonPointer(str) {
      if (typeof str == "number") return `${str}`;
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
    exports2.escapeJsonPointer = escapeJsonPointer;
    function unescapeJsonPointer(str) {
      return str.replace(/~1/g, "/").replace(/~0/g, "~");
    }
    exports2.unescapeJsonPointer = unescapeJsonPointer;
    function eachItem(xs, f) {
      if (Array.isArray(xs)) {
        for (const x of xs) f(x);
      } else {
        f(xs);
      }
    }
    exports2.eachItem = eachItem;
    function makeMergeEvaluated({
      mergeNames,
      mergeToName,
      mergeValues,
      resultToName,
    }) {
      return (gen, from, to, toName) => {
        const res =
          to === void 0
            ? from
            : to instanceof codegen_1.Name
            ? (from instanceof codegen_1.Name
                ? mergeNames(gen, from, to)
                : mergeToName(gen, from, to),
              to)
            : from instanceof codegen_1.Name
            ? (mergeToName(gen, to, from), from)
            : mergeValues(from, to);
        return toName === codegen_1.Name && !(res instanceof codegen_1.Name)
          ? resultToName(gen, res)
          : res;
      };
    }
    exports2.mergeEvaluated = {
      props: makeMergeEvaluated({
        mergeNames: (gen, from, to) =>
          gen.if(
            (0, codegen_1._)`${to} !== true && ${from} !== undefined`,
            () => {
              gen.if(
                (0, codegen_1._)`${from} === true`,
                () => gen.assign(to, true),
                () =>
                  gen
                    .assign(to, (0, codegen_1._)`${to} || {}`)
                    .code((0, codegen_1._)`Object.assign(${to}, ${from})`)
              );
            }
          ),
        mergeToName: (gen, from, to) =>
          gen.if((0, codegen_1._)`${to} !== true`, () => {
            if (from === true) {
              gen.assign(to, true);
            } else {
              gen.assign(to, (0, codegen_1._)`${to} || {}`);
              setEvaluated(gen, to, from);
            }
          }),
        mergeValues: (from, to) => (from === true ? true : { ...from, ...to }),
        resultToName: evaluatedPropsToName,
      }),
      items: makeMergeEvaluated({
        mergeNames: (gen, from, to) =>
          gen.if(
            (0, codegen_1._)`${to} !== true && ${from} !== undefined`,
            () =>
              gen.assign(
                to,
                (0,
                codegen_1._)`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`
              )
          ),
        mergeToName: (gen, from, to) =>
          gen.if((0, codegen_1._)`${to} !== true`, () =>
            gen.assign(
              to,
              from === true
                ? true
                : (0, codegen_1._)`${to} > ${from} ? ${to} : ${from}`
            )
          ),
        mergeValues: (from, to) => (from === true ? true : Math.max(from, to)),
        resultToName: (gen, items) => gen.var("items", items),
      }),
    };
    function evaluatedPropsToName(gen, ps) {
      if (ps === true) return gen.var("props", true);
      const props = gen.var("props", (0, codegen_1._)`{}`);
      if (ps !== void 0) setEvaluated(gen, props, ps);
      return props;
    }
    exports2.evaluatedPropsToName = evaluatedPropsToName;
    function setEvaluated(gen, props, ps) {
      Object.keys(ps).forEach((p) =>
        gen.assign(
          (0, codegen_1._)`${props}${(0, codegen_1.getProperty)(p)}`,
          true
        )
      );
    }
    exports2.setEvaluated = setEvaluated;
    var snippets = {};
    function useFunc(gen, f) {
      return gen.scopeValue("func", {
        ref: f,
        code: snippets[f.code] || (snippets[f.code] = new code_1._Code(f.code)),
      });
    }
    exports2.useFunc = useFunc;
    var Type;
    (function (Type2) {
      Type2[(Type2["Num"] = 0)] = "Num";
      Type2[(Type2["Str"] = 1)] = "Str";
    })((Type = exports2.Type || (exports2.Type = {})));
    function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
      if (dataProp instanceof codegen_1.Name) {
        const isNumber = dataPropType === Type.Num;
        return jsPropertySyntax
          ? isNumber
            ? (0, codegen_1._)`"[" + ${dataProp} + "]"`
            : (0, codegen_1._)`"['" + ${dataProp} + "']"`
          : isNumber
          ? (0, codegen_1._)`"/" + ${dataProp}`
          : (0,
            codegen_1._)`"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
      }
      return jsPropertySyntax
        ? (0, codegen_1.getProperty)(dataProp).toString()
        : "/" + escapeJsonPointer(dataProp);
    }
    exports2.getErrorPath = getErrorPath;
    function checkStrictMode(it, msg, mode = it.opts.strictSchema) {
      if (!mode) return;
      msg = `strict mode: ${msg}`;
      if (mode === true) throw new Error(msg);
      it.self.logger.warn(msg);
    }
    exports2.checkStrictMode = checkStrictMode;
  },
});

// node_modules/ajv-formats/node_modules/ajv/dist/compile/names.js
var require_names2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/compile/names.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen2();
    var names = {
      // validation function arguments
      data: new codegen_1.Name("data"),
      // args passed from referencing schema
      valCxt: new codegen_1.Name("valCxt"),
      instancePath: new codegen_1.Name("instancePath"),
      parentData: new codegen_1.Name("parentData"),
      parentDataProperty: new codegen_1.Name("parentDataProperty"),
      rootData: new codegen_1.Name("rootData"),
      dynamicAnchors: new codegen_1.Name("dynamicAnchors"),
      // function scoped variables
      vErrors: new codegen_1.Name("vErrors"),
      errors: new codegen_1.Name("errors"),
      this: new codegen_1.Name("this"),
      // "globals"
      self: new codegen_1.Name("self"),
      scope: new codegen_1.Name("scope"),
      // JTD serialize/parse name for JSON string and position
      json: new codegen_1.Name("json"),
      jsonPos: new codegen_1.Name("jsonPos"),
      jsonLen: new codegen_1.Name("jsonLen"),
      jsonPart: new codegen_1.Name("jsonPart"),
    };
    exports2.default = names;
  },
});

// node_modules/ajv-formats/node_modules/ajv/dist/compile/errors.js
var require_errors5 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/compile/errors.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.extendErrors =
      exports2.resetErrorsCount =
      exports2.reportExtraError =
      exports2.reportError =
      exports2.keyword$DataError =
      exports2.keywordError =
        void 0;
    var codegen_1 = require_codegen2();
    var util_1 = require_util2();
    var names_1 = require_names2();
    exports2.keywordError = {
      message: ({ keyword }) =>
        (0, codegen_1.str)`must pass "${keyword}" keyword validation`,
    };
    exports2.keyword$DataError = {
      message: ({ keyword, schemaType }) =>
        schemaType
          ? (0,
            codegen_1.str)`"${keyword}" keyword must be ${schemaType} ($data)`
          : (0, codegen_1.str)`"${keyword}" keyword is invalid ($data)`,
    };
    function reportError(
      cxt,
      error = exports2.keywordError,
      errorPaths,
      overrideAllErrors
    ) {
      const { it } = cxt;
      const { gen, compositeRule, allErrors } = it;
      const errObj = errorObjectCode(cxt, error, errorPaths);
      if (
        overrideAllErrors !== null && overrideAllErrors !== void 0
          ? overrideAllErrors
          : compositeRule || allErrors
      ) {
        addError(gen, errObj);
      } else {
        returnErrors(it, (0, codegen_1._)`[${errObj}]`);
      }
    }
    exports2.reportError = reportError;
    function reportExtraError(cxt, error = exports2.keywordError, errorPaths) {
      const { it } = cxt;
      const { gen, compositeRule, allErrors } = it;
      const errObj = errorObjectCode(cxt, error, errorPaths);
      addError(gen, errObj);
      if (!(compositeRule || allErrors)) {
        returnErrors(it, names_1.default.vErrors);
      }
    }
    exports2.reportExtraError = reportExtraError;
    function resetErrorsCount(gen, errsCount) {
      gen.assign(names_1.default.errors, errsCount);
      gen.if((0, codegen_1._)`${names_1.default.vErrors} !== null`, () =>
        gen.if(
          errsCount,
          () =>
            gen.assign(
              (0, codegen_1._)`${names_1.default.vErrors}.length`,
              errsCount
            ),
          () => gen.assign(names_1.default.vErrors, null)
        )
      );
    }
    exports2.resetErrorsCount = resetErrorsCount;
    function extendErrors({ gen, keyword, schemaValue, data, errsCount, it }) {
      if (errsCount === void 0) throw new Error("ajv implementation error");
      const err = gen.name("err");
      gen.forRange("i", errsCount, names_1.default.errors, (i) => {
        gen.const(err, (0, codegen_1._)`${names_1.default.vErrors}[${i}]`);
        gen.if((0, codegen_1._)`${err}.instancePath === undefined`, () =>
          gen.assign(
            (0, codegen_1._)`${err}.instancePath`,
            (0, codegen_1.strConcat)(names_1.default.instancePath, it.errorPath)
          )
        );
        gen.assign(
          (0, codegen_1._)`${err}.schemaPath`,
          (0, codegen_1.str)`${it.errSchemaPath}/${keyword}`
        );
        if (it.opts.verbose) {
          gen.assign((0, codegen_1._)`${err}.schema`, schemaValue);
          gen.assign((0, codegen_1._)`${err}.data`, data);
        }
      });
    }
    exports2.extendErrors = extendErrors;
    function addError(gen, errObj) {
      const err = gen.const("err", errObj);
      gen.if(
        (0, codegen_1._)`${names_1.default.vErrors} === null`,
        () => gen.assign(names_1.default.vErrors, (0, codegen_1._)`[${err}]`),
        (0, codegen_1._)`${names_1.default.vErrors}.push(${err})`
      );
      gen.code((0, codegen_1._)`${names_1.default.errors}++`);
    }
    function returnErrors(it, errs) {
      const { gen, validateName, schemaEnv } = it;
      if (schemaEnv.$async) {
        gen.throw((0, codegen_1._)`new ${it.ValidationError}(${errs})`);
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, errs);
        gen.return(false);
      }
    }
    var E = {
      keyword: new codegen_1.Name("keyword"),
      schemaPath: new codegen_1.Name("schemaPath"),
      params: new codegen_1.Name("params"),
      propertyName: new codegen_1.Name("propertyName"),
      message: new codegen_1.Name("message"),
      schema: new codegen_1.Name("schema"),
      parentSchema: new codegen_1.Name("parentSchema"),
    };
    function errorObjectCode(cxt, error, errorPaths) {
      const { createErrors } = cxt.it;
      if (createErrors === false) return (0, codegen_1._)`{}`;
      return errorObject(cxt, error, errorPaths);
    }
    function errorObject(cxt, error, errorPaths = {}) {
      const { gen, it } = cxt;
      const keyValues = [
        errorInstancePath(it, errorPaths),
        errorSchemaPath(cxt, errorPaths),
      ];
      extraErrorProps(cxt, error, keyValues);
      return gen.object(...keyValues);
    }
    function errorInstancePath({ errorPath }, { instancePath }) {
      const instPath = instancePath
        ? (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(
            instancePath,
            util_1.Type.Str
          )}`
        : errorPath;
      return [
        names_1.default.instancePath,
        (0, codegen_1.strConcat)(names_1.default.instancePath, instPath),
      ];
    }
    function errorSchemaPath(
      { keyword, it: { errSchemaPath } },
      { schemaPath, parentSchema }
    ) {
      let schPath = parentSchema
        ? errSchemaPath
        : (0, codegen_1.str)`${errSchemaPath}/${keyword}`;
      if (schemaPath) {
        schPath = (0, codegen_1.str)`${schPath}${(0, util_1.getErrorPath)(
          schemaPath,
          util_1.Type.Str
        )}`;
      }
      return [E.schemaPath, schPath];
    }
    function extraErrorProps(cxt, { params, message }, keyValues) {
      const { keyword, data, schemaValue, it } = cxt;
      const { opts, propertyName, topSchemaRef, schemaPath } = it;
      keyValues.push(
        [E.keyword, keyword],
        [
          E.params,
          typeof params == "function"
            ? params(cxt)
            : params || (0, codegen_1._)`{}`,
        ]
      );
      if (opts.messages) {
        keyValues.push([
          E.message,
          typeof message == "function" ? message(cxt) : message,
        ]);
      }
      if (opts.verbose) {
        keyValues.push(
          [E.schema, schemaValue],
          [E.parentSchema, (0, codegen_1._)`${topSchemaRef}${schemaPath}`],
          [names_1.default.data, data]
        );
      }
      if (propertyName) keyValues.push([E.propertyName, propertyName]);
    }
  },
});

// node_modules/ajv-formats/node_modules/ajv/dist/compile/validate/boolSchema.js
var require_boolSchema2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/compile/validate/boolSchema.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.boolOrEmptySchema = exports2.topBoolOrEmptySchema = void 0;
    var errors_1 = require_errors5();
    var codegen_1 = require_codegen2();
    var names_1 = require_names2();
    var boolError = {
      message: "boolean schema is false",
    };
    function topBoolOrEmptySchema(it) {
      const { gen, schema, validateName } = it;
      if (schema === false) {
        falseSchemaError(it, false);
      } else if (typeof schema == "object" && schema.$async === true) {
        gen.return(names_1.default.data);
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, null);
        gen.return(true);
      }
    }
    exports2.topBoolOrEmptySchema = topBoolOrEmptySchema;
    function boolOrEmptySchema(it, valid) {
      const { gen, schema } = it;
      if (schema === false) {
        gen.var(valid, false);
        falseSchemaError(it);
      } else {
        gen.var(valid, true);
      }
    }
    exports2.boolOrEmptySchema = boolOrEmptySchema;
    function falseSchemaError(it, overrideAllErrors) {
      const { gen, data } = it;
      const cxt = {
        gen,
        keyword: "false schema",
        data,
        schema: false,
        schemaCode: false,
        schemaValue: false,
        params: {},
        it,
      };
      (0, errors_1.reportError)(cxt, boolError, void 0, overrideAllErrors);
    }
  },
});

// node_modules/ajv-formats/node_modules/ajv/dist/compile/rules.js
var require_rules2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/compile/rules.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getRules = exports2.isJSONType = void 0;
    var _jsonTypes = [
      "string",
      "number",
      "integer",
      "boolean",
      "null",
      "object",
      "array",
    ];
    var jsonTypes = new Set(_jsonTypes);
    function isJSONType(x) {
      return typeof x == "string" && jsonTypes.has(x);
    }
    exports2.isJSONType = isJSONType;
    function getRules() {
      const groups = {
        number: { type: "number", rules: [] },
        string: { type: "string", rules: [] },
        array: { type: "array", rules: [] },
        object: { type: "object", rules: [] },
      };
      return {
        types: { ...groups, integer: true, boolean: true, null: true },
        rules: [
          { rules: [] },
          groups.number,
          groups.string,
          groups.array,
          groups.object,
        ],
        post: { rules: [] },
        all: {},
        keywords: {},
      };
    }
    exports2.getRules = getRules;
  },
});

// node_modules/ajv-formats/node_modules/ajv/dist/compile/validate/applicability.js
var require_applicability2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/compile/validate/applicability.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.shouldUseRule =
      exports2.shouldUseGroup =
      exports2.schemaHasRulesForType =
        void 0;
    function schemaHasRulesForType({ schema, self: self2 }, type) {
      const group = self2.RULES.types[type];
      return group && group !== true && shouldUseGroup(schema, group);
    }
    exports2.schemaHasRulesForType = schemaHasRulesForType;
    function shouldUseGroup(schema, group) {
      return group.rules.some((rule) => shouldUseRule(schema, rule));
    }
    exports2.shouldUseGroup = shouldUseGroup;
    function shouldUseRule(schema, rule) {
      var _a;
      return (
        schema[rule.keyword] !== void 0 ||
        ((_a = rule.definition.implements) === null || _a === void 0
          ? void 0
          : _a.some((kwd) => schema[kwd] !== void 0))
      );
    }
    exports2.shouldUseRule = shouldUseRule;
  },
});

// node_modules/ajv-formats/node_modules/ajv/dist/compile/validate/dataType.js
var require_dataType2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/compile/validate/dataType.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.reportTypeError =
      exports2.checkDataTypes =
      exports2.checkDataType =
      exports2.coerceAndCheckDataType =
      exports2.getJSONTypes =
      exports2.getSchemaTypes =
      exports2.DataType =
        void 0;
    var rules_1 = require_rules2();
    var applicability_1 = require_applicability2();
    var errors_1 = require_errors5();
    var codegen_1 = require_codegen2();
    var util_1 = require_util2();
    var DataType;
    (function (DataType2) {
      DataType2[(DataType2["Correct"] = 0)] = "Correct";
      DataType2[(DataType2["Wrong"] = 1)] = "Wrong";
    })((DataType = exports2.DataType || (exports2.DataType = {})));
    function getSchemaTypes(schema) {
      const types = getJSONTypes(schema.type);
      const hasNull = types.includes("null");
      if (hasNull) {
        if (schema.nullable === false)
          throw new Error("type: null contradicts nullable: false");
      } else {
        if (!types.length && schema.nullable !== void 0) {
          throw new Error('"nullable" cannot be used without "type"');
        }
        if (schema.nullable === true) types.push("null");
      }
      return types;
    }
    exports2.getSchemaTypes = getSchemaTypes;
    function getJSONTypes(ts) {
      const types = Array.isArray(ts) ? ts : ts ? [ts] : [];
      if (types.every(rules_1.isJSONType)) return types;
      throw new Error(
        "type must be JSONType or JSONType[]: " + types.join(",")
      );
    }
    exports2.getJSONTypes = getJSONTypes;
    function coerceAndCheckDataType(it, types) {
      const { gen, data, opts } = it;
      const coerceTo = coerceToTypes(types, opts.coerceTypes);
      const checkTypes =
        types.length > 0 &&
        !(
          coerceTo.length === 0 &&
          types.length === 1 &&
          (0, applicability_1.schemaHasRulesForType)(it, types[0])
        );
      if (checkTypes) {
        const wrongType = checkDataTypes(
          types,
          data,
          opts.strictNumbers,
          DataType.Wrong
        );
        gen.if(wrongType, () => {
          if (coerceTo.length) coerceData(it, types, coerceTo);
          else reportTypeError(it);
        });
      }
      return checkTypes;
    }
    exports2.coerceAndCheckDataType = coerceAndCheckDataType;
    var COERCIBLE = /* @__PURE__ */ new Set([
      "string",
      "number",
      "integer",
      "boolean",
      "null",
    ]);
    function coerceToTypes(types, coerceTypes) {
      return coerceTypes
        ? types.filter(
            (t) =>
              COERCIBLE.has(t) || (coerceTypes === "array" && t === "array")
          )
        : [];
    }
    function coerceData(it, types, coerceTo) {
      const { gen, data, opts } = it;
      const dataType = gen.let("dataType", (0, codegen_1._)`typeof ${data}`);
      const coerced = gen.let("coerced", (0, codegen_1._)`undefined`);
      if (opts.coerceTypes === "array") {
        gen.if(
          (0,
          codegen_1._)`${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`,
          () =>
            gen
              .assign(data, (0, codegen_1._)`${data}[0]`)
              .assign(dataType, (0, codegen_1._)`typeof ${data}`)
              .if(checkDataTypes(types, data, opts.strictNumbers), () =>
                gen.assign(coerced, data)
              )
        );
      }
      gen.if((0, codegen_1._)`${coerced} !== undefined`);
      for (const t of coerceTo) {
        if (
          COERCIBLE.has(t) ||
          (t === "array" && opts.coerceTypes === "array")
        ) {
          coerceSpecificType(t);
        }
      }
      gen.else();
      reportTypeError(it);
      gen.endIf();
      gen.if((0, codegen_1._)`${coerced} !== undefined`, () => {
        gen.assign(data, coerced);
        assignParentData(it, coerced);
      });
      function coerceSpecificType(t) {
        switch (t) {
          case "string":
            gen
              .elseIf(
                (0,
                codegen_1._)`${dataType} == "number" || ${dataType} == "boolean"`
              )
              .assign(coerced, (0, codegen_1._)`"" + ${data}`)
              .elseIf((0, codegen_1._)`${data} === null`)
              .assign(coerced, (0, codegen_1._)`""`);
            return;
          case "number":
            gen
              .elseIf(
                (0, codegen_1._)`${dataType} == "boolean" || ${data} === null
              || (${dataType} == "string" && ${data} && ${data} == +${data})`
              )
              .assign(coerced, (0, codegen_1._)`+${data}`);
            return;
          case "integer":
            gen
              .elseIf(
                (0, codegen_1._)`${dataType} === "boolean" || ${data} === null
              || (${dataType} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`
              )
              .assign(coerced, (0, codegen_1._)`+${data}`);
            return;
          case "boolean":
            gen
              .elseIf(
                (0,
                codegen_1._)`${data} === "false" || ${data} === 0 || ${data} === null`
              )
              .assign(coerced, false)
              .elseIf((0, codegen_1._)`${data} === "true" || ${data} === 1`)
              .assign(coerced, true);
            return;
          case "null":
            gen.elseIf(
              (0,
              codegen_1._)`${data} === "" || ${data} === 0 || ${data} === false`
            );
            gen.assign(coerced, null);
            return;
          case "array":
            gen
              .elseIf(
                (0,
                codegen_1._)`${dataType} === "string" || ${dataType} === "number"
              || ${dataType} === "boolean" || ${data} === null`
              )
              .assign(coerced, (0, codegen_1._)`[${data}]`);
        }
      }
    }
    function assignParentData({ gen, parentData, parentDataProperty }, expr) {
      gen.if((0, codegen_1._)`${parentData} !== undefined`, () =>
        gen.assign((0, codegen_1._)`${parentData}[${parentDataProperty}]`, expr)
      );
    }
    function checkDataType(
      dataType,
      data,
      strictNums,
      correct = DataType.Correct
    ) {
      const EQ =
        correct === DataType.Correct
          ? codegen_1.operators.EQ
          : codegen_1.operators.NEQ;
      let cond;
      switch (dataType) {
        case "null":
          return (0, codegen_1._)`${data} ${EQ} null`;
        case "array":
          cond = (0, codegen_1._)`Array.isArray(${data})`;
          break;
        case "object":
          cond = (0,
          codegen_1._)`${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
          break;
        case "integer":
          cond = numCond((0, codegen_1._)`!(${data} % 1) && !isNaN(${data})`);
          break;
        case "number":
          cond = numCond();
          break;
        default:
          return (0, codegen_1._)`typeof ${data} ${EQ} ${dataType}`;
      }
      return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);
      function numCond(_cond = codegen_1.nil) {
        return (0, codegen_1.and)(
          (0, codegen_1._)`typeof ${data} == "number"`,
          _cond,
          strictNums ? (0, codegen_1._)`isFinite(${data})` : codegen_1.nil
        );
      }
    }
    exports2.checkDataType = checkDataType;
    function checkDataTypes(dataTypes, data, strictNums, correct) {
      if (dataTypes.length === 1) {
        return checkDataType(dataTypes[0], data, strictNums, correct);
      }
      let cond;
      const types = (0, util_1.toHash)(dataTypes);
      if (types.array && types.object) {
        const notObj = (0, codegen_1._)`typeof ${data} != "object"`;
        cond = types.null ? notObj : (0, codegen_1._)`!${data} || ${notObj}`;
        delete types.null;
        delete types.array;
        delete types.object;
      } else {
        cond = codegen_1.nil;
      }
      if (types.number) delete types.integer;
      for (const t in types)
        cond = (0, codegen_1.and)(
          cond,
          checkDataType(t, data, strictNums, correct)
        );
      return cond;
    }
    exports2.checkDataTypes = checkDataTypes;
    var typeError = {
      message: ({ schema }) => `must be ${schema}`,
      params: ({ schema, schemaValue }) =>
        typeof schema == "string"
          ? (0, codegen_1._)`{type: ${schema}}`
          : (0, codegen_1._)`{type: ${schemaValue}}`,
    };
    function reportTypeError(it) {
      const cxt = getTypeErrorContext(it);
      (0, errors_1.reportError)(cxt, typeError);
    }
    exports2.reportTypeError = reportTypeError;
    function getTypeErrorContext(it) {
      const { gen, data, schema } = it;
      const schemaCode = (0, util_1.schemaRefOrVal)(it, schema, "type");
      return {
        gen,
        keyword: "type",
        data,
        schema: schema.type,
        schemaCode,
        schemaValue: schemaCode,
        parentSchema: schema,
        params: {},
        it,
      };
    }
  },
});

// node_modules/ajv-formats/node_modules/ajv/dist/compile/validate/defaults.js
var require_defaults2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/compile/validate/defaults.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.assignDefaults = void 0;
    var codegen_1 = require_codegen2();
    var util_1 = require_util2();
    function assignDefaults(it, ty) {
      const { properties, items } = it.schema;
      if (ty === "object" && properties) {
        for (const key in properties) {
          assignDefault(it, key, properties[key].default);
        }
      } else if (ty === "array" && Array.isArray(items)) {
        items.forEach((sch, i) => assignDefault(it, i, sch.default));
      }
    }
    exports2.assignDefaults = assignDefaults;
    function assignDefault(it, prop, defaultValue) {
      const { gen, compositeRule, data, opts } = it;
      if (defaultValue === void 0) return;
      const childData = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(
        prop
      )}`;
      if (compositeRule) {
        (0, util_1.checkStrictMode)(it, `default is ignored for: ${childData}`);
        return;
      }
      let condition = (0, codegen_1._)`${childData} === undefined`;
      if (opts.useDefaults === "empty") {
        condition = (0,
        codegen_1._)`${condition} || ${childData} === null || ${childData} === ""`;
      }
      gen.if(
        condition,
        (0, codegen_1._)`${childData} = ${(0, codegen_1.stringify)(
          defaultValue
        )}`
      );
    }
  },
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/code.js
var require_code4 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/code.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateUnion =
      exports2.validateArray =
      exports2.usePattern =
      exports2.callValidateCode =
      exports2.schemaProperties =
      exports2.allSchemaProperties =
      exports2.noPropertyInData =
      exports2.propertyInData =
      exports2.isOwnProperty =
      exports2.hasPropFunc =
      exports2.reportMissingProp =
      exports2.checkMissingProp =
      exports2.checkReportMissingProp =
        void 0;
    var codegen_1 = require_codegen2();
    var util_1 = require_util2();
    var names_1 = require_names2();
    var util_2 = require_util2();
    function checkReportMissingProp(cxt, prop) {
      const { gen, data, it } = cxt;
      gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {
        cxt.setParams({ missingProperty: (0, codegen_1._)`${prop}` }, true);
        cxt.error();
      });
    }
    exports2.checkReportMissingProp = checkReportMissingProp;
    function checkMissingProp(
      { gen, data, it: { opts } },
      properties,
      missing
    ) {
      return (0, codegen_1.or)(
        ...properties.map((prop) =>
          (0, codegen_1.and)(
            noPropertyInData(gen, data, prop, opts.ownProperties),
            (0, codegen_1._)`${missing} = ${prop}`
          )
        )
      );
    }
    exports2.checkMissingProp = checkMissingProp;
    function reportMissingProp(cxt, missing) {
      cxt.setParams({ missingProperty: missing }, true);
      cxt.error();
    }
    exports2.reportMissingProp = reportMissingProp;
    function hasPropFunc(gen) {
      return gen.scopeValue("func", {
        // eslint-disable-next-line @typescript-eslint/unbound-method
        ref: Object.prototype.hasOwnProperty,
        code: (0, codegen_1._)`Object.prototype.hasOwnProperty`,
      });
    }
    exports2.hasPropFunc = hasPropFunc;
    function isOwnProperty(gen, data, property) {
      return (0, codegen_1._)`${hasPropFunc(gen)}.call(${data}, ${property})`;
    }
    exports2.isOwnProperty = isOwnProperty;
    function propertyInData(gen, data, property, ownProperties) {
      const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(
        property
      )} !== undefined`;
      return ownProperties
        ? (0, codegen_1._)`${cond} && ${isOwnProperty(gen, data, property)}`
        : cond;
    }
    exports2.propertyInData = propertyInData;
    function noPropertyInData(gen, data, property, ownProperties) {
      const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(
        property
      )} === undefined`;
      return ownProperties
        ? (0, codegen_1.or)(
            cond,
            (0, codegen_1.not)(isOwnProperty(gen, data, property))
          )
        : cond;
    }
    exports2.noPropertyInData = noPropertyInData;
    function allSchemaProperties(schemaMap) {
      return schemaMap
        ? Object.keys(schemaMap).filter((p) => p !== "__proto__")
        : [];
    }
    exports2.allSchemaProperties = allSchemaProperties;
    function schemaProperties(it, schemaMap) {
      return allSchemaProperties(schemaMap).filter(
        (p) => !(0, util_1.alwaysValidSchema)(it, schemaMap[p])
      );
    }
    exports2.schemaProperties = schemaProperties;
    function callValidateCode(
      {
        schemaCode,
        data,
        it: { gen, topSchemaRef, schemaPath, errorPath },
        it,
      },
      func,
      context,
      passSchema
    ) {
      const dataAndSchema = passSchema
        ? (0, codegen_1._)`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}`
        : data;
      const valCxt = [
        [
          names_1.default.instancePath,
          (0, codegen_1.strConcat)(names_1.default.instancePath, errorPath),
        ],
        [names_1.default.parentData, it.parentData],
        [names_1.default.parentDataProperty, it.parentDataProperty],
        [names_1.default.rootData, names_1.default.rootData],
      ];
      if (it.opts.dynamicRef)
        valCxt.push([
          names_1.default.dynamicAnchors,
          names_1.default.dynamicAnchors,
        ]);
      const args = (0, codegen_1._)`${dataAndSchema}, ${gen.object(...valCxt)}`;
      return context !== codegen_1.nil
        ? (0, codegen_1._)`${func}.call(${context}, ${args})`
        : (0, codegen_1._)`${func}(${args})`;
    }
    exports2.callValidateCode = callValidateCode;
    var newRegExp = (0, codegen_1._)`new RegExp`;
    function usePattern({ gen, it: { opts } }, pattern) {
      const u = opts.unicodeRegExp ? "u" : "";
      const { regExp } = opts.code;
      const rx = regExp(pattern, u);
      return gen.scopeValue("pattern", {
        key: rx.toString(),
        ref: rx,
        code: (0, codegen_1._)`${
          regExp.code === "new RegExp"
            ? newRegExp
            : (0, util_2.useFunc)(gen, regExp)
        }(${pattern}, ${u})`,
      });
    }
    exports2.usePattern = usePattern;
    function validateArray(cxt) {
      const { gen, data, keyword, it } = cxt;
      const valid = gen.name("valid");
      if (it.allErrors) {
        const validArr = gen.let("valid", true);
        validateItems(() => gen.assign(validArr, false));
        return validArr;
      }
      gen.var(valid, true);
      validateItems(() => gen.break());
      return valid;
      function validateItems(notValid) {
        const len = gen.const("len", (0, codegen_1._)`${data}.length`);
        gen.forRange("i", 0, len, (i) => {
          cxt.subschema(
            {
              keyword,
              dataProp: i,
              dataPropType: util_1.Type.Num,
            },
            valid
          );
          gen.if((0, codegen_1.not)(valid), notValid);
        });
      }
    }
    exports2.validateArray = validateArray;
    function validateUnion(cxt) {
      const { gen, schema, keyword, it } = cxt;
      if (!Array.isArray(schema)) throw new Error("ajv implementation error");
      const alwaysValid = schema.some((sch) =>
        (0, util_1.alwaysValidSchema)(it, sch)
      );
      if (alwaysValid && !it.opts.unevaluated) return;
      const valid = gen.let("valid", false);
      const schValid = gen.name("_valid");
      gen.block(() =>
        schema.forEach((_sch, i) => {
          const schCxt = cxt.subschema(
            {
              keyword,
              schemaProp: i,
              compositeRule: true,
            },
            schValid
          );
          gen.assign(valid, (0, codegen_1._)`${valid} || ${schValid}`);
          const merged = cxt.mergeValidEvaluated(schCxt, schValid);
          if (!merged) gen.if((0, codegen_1.not)(valid));
        })
      );
      cxt.result(
        valid,
        () => cxt.reset(),
        () => cxt.error(true)
      );
    }
    exports2.validateUnion = validateUnion;
  },
});

// node_modules/ajv-formats/node_modules/ajv/dist/compile/validate/keyword.js
var require_keyword2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/compile/validate/keyword.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateKeywordUsage =
      exports2.validSchemaType =
      exports2.funcKeywordCode =
      exports2.macroKeywordCode =
        void 0;
    var codegen_1 = require_codegen2();
    var names_1 = require_names2();
    var code_1 = require_code4();
    var errors_1 = require_errors5();
    function macroKeywordCode(cxt, def) {
      const { gen, keyword, schema, parentSchema, it } = cxt;
      const macroSchema = def.macro.call(it.self, schema, parentSchema, it);
      const schemaRef = useKeyword(gen, keyword, macroSchema);
      if (it.opts.validateSchema !== false)
        it.self.validateSchema(macroSchema, true);
      const valid = gen.name("valid");
      cxt.subschema(
        {
          schema: macroSchema,
          schemaPath: codegen_1.nil,
          errSchemaPath: `${it.errSchemaPath}/${keyword}`,
          topSchemaRef: schemaRef,
          compositeRule: true,
        },
        valid
      );
      cxt.pass(valid, () => cxt.error(true));
    }
    exports2.macroKeywordCode = macroKeywordCode;
    function funcKeywordCode(cxt, def) {
      var _a;
      const { gen, keyword, schema, parentSchema, $data, it } = cxt;
      checkAsyncKeyword(it, def);
      const validate =
        !$data && def.compile
          ? def.compile.call(it.self, schema, parentSchema, it)
          : def.validate;
      const validateRef = useKeyword(gen, keyword, validate);
      const valid = gen.let("valid");
      cxt.block$data(valid, validateKeyword);
      cxt.ok((_a = def.valid) !== null && _a !== void 0 ? _a : valid);
      function validateKeyword() {
        if (def.errors === false) {
          assignValid();
          if (def.modifying) modifyData(cxt);
          reportErrs(() => cxt.error());
        } else {
          const ruleErrs = def.async ? validateAsync() : validateSync();
          if (def.modifying) modifyData(cxt);
          reportErrs(() => addErrs(cxt, ruleErrs));
        }
      }
      function validateAsync() {
        const ruleErrs = gen.let("ruleErrs", null);
        gen.try(
          () => assignValid((0, codegen_1._)`await `),
          (e) =>
            gen.assign(valid, false).if(
              (0, codegen_1._)`${e} instanceof ${it.ValidationError}`,
              () => gen.assign(ruleErrs, (0, codegen_1._)`${e}.errors`),
              () => gen.throw(e)
            )
        );
        return ruleErrs;
      }
      function validateSync() {
        const validateErrs = (0, codegen_1._)`${validateRef}.errors`;
        gen.assign(validateErrs, null);
        assignValid(codegen_1.nil);
        return validateErrs;
      }
      function assignValid(
        _await = def.async ? (0, codegen_1._)`await ` : codegen_1.nil
      ) {
        const passCxt = it.opts.passContext
          ? names_1.default.this
          : names_1.default.self;
        const passSchema = !(
          ("compile" in def && !$data) ||
          def.schema === false
        );
        gen.assign(
          valid,
          (0, codegen_1._)`${_await}${(0, code_1.callValidateCode)(
            cxt,
            validateRef,
            passCxt,
            passSchema
          )}`,
          def.modifying
        );
      }
      function reportErrs(errors) {
        var _a2;
        gen.if(
          (0, codegen_1.not)(
            (_a2 = def.valid) !== null && _a2 !== void 0 ? _a2 : valid
          ),
          errors
        );
      }
    }
    exports2.funcKeywordCode = funcKeywordCode;
    function modifyData(cxt) {
      const { gen, data, it } = cxt;
      gen.if(it.parentData, () =>
        gen.assign(
          data,
          (0, codegen_1._)`${it.parentData}[${it.parentDataProperty}]`
        )
      );
    }
    function addErrs(cxt, errs) {
      const { gen } = cxt;
      gen.if(
        (0, codegen_1._)`Array.isArray(${errs})`,
        () => {
          gen
            .assign(
              names_1.default.vErrors,
              (0,
              codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`
            )
            .assign(
              names_1.default.errors,
              (0, codegen_1._)`${names_1.default.vErrors}.length`
            );
          (0, errors_1.extendErrors)(cxt);
        },
        () => cxt.error()
      );
    }
    function checkAsyncKeyword({ schemaEnv }, def) {
      if (def.async && !schemaEnv.$async)
        throw new Error("async keyword in sync schema");
    }
    function useKeyword(gen, keyword, result) {
      if (result === void 0)
        throw new Error(`keyword "${keyword}" failed to compile`);
      return gen.scopeValue(
        "keyword",
        typeof result == "function"
          ? { ref: result }
          : { ref: result, code: (0, codegen_1.stringify)(result) }
      );
    }
    function validSchemaType(schema, schemaType, allowUndefined = false) {
      return (
        !schemaType.length ||
        schemaType.some((st) =>
          st === "array"
            ? Array.isArray(schema)
            : st === "object"
            ? schema && typeof schema == "object" && !Array.isArray(schema)
            : typeof schema == st ||
              (allowUndefined && typeof schema == "undefined")
        )
      );
    }
    exports2.validSchemaType = validSchemaType;
    function validateKeywordUsage(
      { schema, opts, self: self2, errSchemaPath },
      def,
      keyword
    ) {
      if (
        Array.isArray(def.keyword)
          ? !def.keyword.includes(keyword)
          : def.keyword !== keyword
      ) {
        throw new Error("ajv implementation error");
      }
      const deps = def.dependencies;
      if (
        deps === null || deps === void 0
          ? void 0
          : deps.some(
              (kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd)
            )
      ) {
        throw new Error(
          `parent schema must have dependencies of ${keyword}: ${deps.join(
            ","
          )}`
        );
      }
      if (def.validateSchema) {
        const valid = def.validateSchema(schema[keyword]);
        if (!valid) {
          const msg =
            `keyword "${keyword}" value is invalid at path "${errSchemaPath}": ` +
            self2.errorsText(def.validateSchema.errors);
          if (opts.validateSchema === "log") self2.logger.error(msg);
          else throw new Error(msg);
        }
      }
    }
    exports2.validateKeywordUsage = validateKeywordUsage;
  },
});

// node_modules/ajv-formats/node_modules/ajv/dist/compile/validate/subschema.js
var require_subschema2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/compile/validate/subschema.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.extendSubschemaMode =
      exports2.extendSubschemaData =
      exports2.getSubschema =
        void 0;
    var codegen_1 = require_codegen2();
    var util_1 = require_util2();
    function getSubschema(
      it,
      { keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }
    ) {
      if (keyword !== void 0 && schema !== void 0) {
        throw new Error('both "keyword" and "schema" passed, only one allowed');
      }
      if (keyword !== void 0) {
        const sch = it.schema[keyword];
        return schemaProp === void 0
          ? {
              schema: sch,
              schemaPath: (0, codegen_1._)`${it.schemaPath}${(0,
              codegen_1.getProperty)(keyword)}`,
              errSchemaPath: `${it.errSchemaPath}/${keyword}`,
            }
          : {
              schema: sch[schemaProp],
              schemaPath: (0, codegen_1._)`${it.schemaPath}${(0,
              codegen_1.getProperty)(keyword)}${(0, codegen_1.getProperty)(
                schemaProp
              )}`,
              errSchemaPath: `${it.errSchemaPath}/${keyword}/${(0,
              util_1.escapeFragment)(schemaProp)}`,
            };
      }
      if (schema !== void 0) {
        if (
          schemaPath === void 0 ||
          errSchemaPath === void 0 ||
          topSchemaRef === void 0
        ) {
          throw new Error(
            '"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"'
          );
        }
        return {
          schema,
          schemaPath,
          topSchemaRef,
          errSchemaPath,
        };
      }
      throw new Error('either "keyword" or "schema" must be passed');
    }
    exports2.getSubschema = getSubschema;
    function extendSubschemaData(
      subschema,
      it,
      { dataProp, dataPropType: dpType, data, dataTypes, propertyName }
    ) {
      if (data !== void 0 && dataProp !== void 0) {
        throw new Error('both "data" and "dataProp" passed, only one allowed');
      }
      const { gen } = it;
      if (dataProp !== void 0) {
        const { errorPath, dataPathArr, opts } = it;
        const nextData = gen.let(
          "data",
          (0, codegen_1._)`${it.data}${(0, codegen_1.getProperty)(dataProp)}`,
          true
        );
        dataContextProps(nextData);
        subschema.errorPath = (0, codegen_1.str)`${errorPath}${(0,
        util_1.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;
        subschema.parentDataProperty = (0, codegen_1._)`${dataProp}`;
        subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty];
      }
      if (data !== void 0) {
        const nextData =
          data instanceof codegen_1.Name ? data : gen.let("data", data, true);
        dataContextProps(nextData);
        if (propertyName !== void 0) subschema.propertyName = propertyName;
      }
      if (dataTypes) subschema.dataTypes = dataTypes;
      function dataContextProps(_nextData) {
        subschema.data = _nextData;
        subschema.dataLevel = it.dataLevel + 1;
        subschema.dataTypes = [];
        it.definedProperties = /* @__PURE__ */ new Set();
        subschema.parentData = it.data;
        subschema.dataNames = [...it.dataNames, _nextData];
      }
    }
    exports2.extendSubschemaData = extendSubschemaData;
    function extendSubschemaMode(
      subschema,
      { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }
    ) {
      if (compositeRule !== void 0) subschema.compositeRule = compositeRule;
      if (createErrors !== void 0) subschema.createErrors = createErrors;
      if (allErrors !== void 0) subschema.allErrors = allErrors;
      subschema.jtdDiscriminator = jtdDiscriminator;
      subschema.jtdMetadata = jtdMetadata;
    }
    exports2.extendSubschemaMode = extendSubschemaMode;
  },
});

// node_modules/ajv-formats/node_modules/json-schema-traverse/index.js
var require_json_schema_traverse2 = __commonJS({
  "node_modules/ajv-formats/node_modules/json-schema-traverse/index.js"(
    exports2,
    module2
  ) {
    var traverse = (module2.exports = function (schema, opts, cb) {
      if (typeof opts == "function") {
        cb = opts;
        opts = {};
      }
      cb = opts.cb || cb;
      var pre = typeof cb == "function" ? cb : cb.pre || function () {};
      var post = cb.post || function () {};
      _traverse(opts, pre, post, schema, "", schema);
    });
    traverse.keywords = {
      additionalItems: true,
      items: true,
      contains: true,
      additionalProperties: true,
      propertyNames: true,
      not: true,
      if: true,
      then: true,
      else: true,
    };
    traverse.arrayKeywords = {
      items: true,
      allOf: true,
      anyOf: true,
      oneOf: true,
    };
    traverse.propsKeywords = {
      $defs: true,
      definitions: true,
      properties: true,
      patternProperties: true,
      dependencies: true,
    };
    traverse.skipKeywords = {
      default: true,
      enum: true,
      const: true,
      required: true,
      maximum: true,
      minimum: true,
      exclusiveMaximum: true,
      exclusiveMinimum: true,
      multipleOf: true,
      maxLength: true,
      minLength: true,
      pattern: true,
      format: true,
      maxItems: true,
      minItems: true,
      uniqueItems: true,
      maxProperties: true,
      minProperties: true,
    };
    function _traverse(
      opts,
      pre,
      post,
      schema,
      jsonPtr,
      rootSchema,
      parentJsonPtr,
      parentKeyword,
      parentSchema,
      keyIndex
    ) {
      if (schema && typeof schema == "object" && !Array.isArray(schema)) {
        pre(
          schema,
          jsonPtr,
          rootSchema,
          parentJsonPtr,
          parentKeyword,
          parentSchema,
          keyIndex
        );
        for (var key in schema) {
          var sch = schema[key];
          if (Array.isArray(sch)) {
            if (key in traverse.arrayKeywords) {
              for (var i = 0; i < sch.length; i++)
                _traverse(
                  opts,
                  pre,
                  post,
                  sch[i],
                  jsonPtr + "/" + key + "/" + i,
                  rootSchema,
                  jsonPtr,
                  key,
                  schema,
                  i
                );
            }
          } else if (key in traverse.propsKeywords) {
            if (sch && typeof sch == "object") {
              for (var prop in sch)
                _traverse(
                  opts,
                  pre,
                  post,
                  sch[prop],
                  jsonPtr + "/" + key + "/" + escapeJsonPtr(prop),
                  rootSchema,
                  jsonPtr,
                  key,
                  schema,
                  prop
                );
            }
          } else if (
            key in traverse.keywords ||
            (opts.allKeys && !(key in traverse.skipKeywords))
          ) {
            _traverse(
              opts,
              pre,
              post,
              sch,
              jsonPtr + "/" + key,
              rootSchema,
              jsonPtr,
              key,
              schema
            );
          }
        }
        post(
          schema,
          jsonPtr,
          rootSchema,
          parentJsonPtr,
          parentKeyword,
          parentSchema,
          keyIndex
        );
      }
    }
    function escapeJsonPtr(str) {
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
  },
});

// node_modules/ajv-formats/node_modules/ajv/dist/compile/resolve.js
var require_resolve2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/compile/resolve.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getSchemaRefs =
      exports2.resolveUrl =
      exports2.normalizeId =
      exports2._getFullPath =
      exports2.getFullPath =
      exports2.inlineRef =
        void 0;
    var util_1 = require_util2();
    var equal = require_fast_deep_equal();
    var traverse = require_json_schema_traverse2();
    var SIMPLE_INLINED = /* @__PURE__ */ new Set([
      "type",
      "format",
      "pattern",
      "maxLength",
      "minLength",
      "maxProperties",
      "minProperties",
      "maxItems",
      "minItems",
      "maximum",
      "minimum",
      "uniqueItems",
      "multipleOf",
      "required",
      "enum",
      "const",
    ]);
    function inlineRef(schema, limit = true) {
      if (typeof schema == "boolean") return true;
      if (limit === true) return !hasRef(schema);
      if (!limit) return false;
      return countKeys(schema) <= limit;
    }
    exports2.inlineRef = inlineRef;
    var REF_KEYWORDS = /* @__PURE__ */ new Set([
      "$ref",
      "$recursiveRef",
      "$recursiveAnchor",
      "$dynamicRef",
      "$dynamicAnchor",
    ]);
    function hasRef(schema) {
      for (const key in schema) {
        if (REF_KEYWORDS.has(key)) return true;
        const sch = schema[key];
        if (Array.isArray(sch) && sch.some(hasRef)) return true;
        if (typeof sch == "object" && hasRef(sch)) return true;
      }
      return false;
    }
    function countKeys(schema) {
      let count = 0;
      for (const key in schema) {
        if (key === "$ref") return Infinity;
        count++;
        if (SIMPLE_INLINED.has(key)) continue;
        if (typeof schema[key] == "object") {
          (0, util_1.eachItem)(schema[key], (sch) => (count += countKeys(sch)));
        }
        if (count === Infinity) return Infinity;
      }
      return count;
    }
    function getFullPath(resolver, id = "", normalize) {
      if (normalize !== false) id = normalizeId(id);
      const p = resolver.parse(id);
      return _getFullPath(resolver, p);
    }
    exports2.getFullPath = getFullPath;
    function _getFullPath(resolver, p) {
      const serialized = resolver.serialize(p);
      return serialized.split("#")[0] + "#";
    }
    exports2._getFullPath = _getFullPath;
    var TRAILING_SLASH_HASH = /#\/?$/;
    function normalizeId(id) {
      return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
    }
    exports2.normalizeId = normalizeId;
    function resolveUrl(resolver, baseId, id) {
      id = normalizeId(id);
      return resolver.resolve(baseId, id);
    }
    exports2.resolveUrl = resolveUrl;
    var ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
    function getSchemaRefs(schema, baseId) {
      if (typeof schema == "boolean") return {};
      const { schemaId, uriResolver } = this.opts;
      const schId = normalizeId(schema[schemaId] || baseId);
      const baseIds = { "": schId };
      const pathPrefix = getFullPath(uriResolver, schId, false);
      const localRefs = {};
      const schemaRefs = /* @__PURE__ */ new Set();
      traverse(schema, { allKeys: true }, (sch, jsonPtr, _, parentJsonPtr) => {
        if (parentJsonPtr === void 0) return;
        const fullPath = pathPrefix + jsonPtr;
        let baseId2 = baseIds[parentJsonPtr];
        if (typeof sch[schemaId] == "string")
          baseId2 = addRef.call(this, sch[schemaId]);
        addAnchor.call(this, sch.$anchor);
        addAnchor.call(this, sch.$dynamicAnchor);
        baseIds[jsonPtr] = baseId2;
        function addRef(ref) {
          const _resolve = this.opts.uriResolver.resolve;
          ref = normalizeId(baseId2 ? _resolve(baseId2, ref) : ref);
          if (schemaRefs.has(ref)) throw ambiguos(ref);
          schemaRefs.add(ref);
          let schOrRef = this.refs[ref];
          if (typeof schOrRef == "string") schOrRef = this.refs[schOrRef];
          if (typeof schOrRef == "object") {
            checkAmbiguosRef(sch, schOrRef.schema, ref);
          } else if (ref !== normalizeId(fullPath)) {
            if (ref[0] === "#") {
              checkAmbiguosRef(sch, localRefs[ref], ref);
              localRefs[ref] = sch;
            } else {
              this.refs[ref] = fullPath;
            }
          }
          return ref;
        }
        function addAnchor(anchor) {
          if (typeof anchor == "string") {
            if (!ANCHOR.test(anchor))
              throw new Error(`invalid anchor "${anchor}"`);
            addRef.call(this, `#${anchor}`);
          }
        }
      });
      return localRefs;
      function checkAmbiguosRef(sch1, sch2, ref) {
        if (sch2 !== void 0 && !equal(sch1, sch2)) throw ambiguos(ref);
      }
      function ambiguos(ref) {
        return new Error(`reference "${ref}" resolves to more than one schema`);
      }
    }
    exports2.getSchemaRefs = getSchemaRefs;
  },
});

// node_modules/ajv-formats/node_modules/ajv/dist/compile/validate/index.js
var require_validate2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/compile/validate/index.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getData =
      exports2.KeywordCxt =
      exports2.validateFunctionCode =
        void 0;
    var boolSchema_1 = require_boolSchema2();
    var dataType_1 = require_dataType2();
    var applicability_1 = require_applicability2();
    var dataType_2 = require_dataType2();
    var defaults_1 = require_defaults2();
    var keyword_1 = require_keyword2();
    var subschema_1 = require_subschema2();
    var codegen_1 = require_codegen2();
    var names_1 = require_names2();
    var resolve_1 = require_resolve2();
    var util_1 = require_util2();
    var errors_1 = require_errors5();
    function validateFunctionCode(it) {
      if (isSchemaObj(it)) {
        checkKeywords(it);
        if (schemaCxtHasRules(it)) {
          topSchemaObjCode(it);
          return;
        }
      }
      validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));
    }
    exports2.validateFunctionCode = validateFunctionCode;
    function validateFunction(
      { gen, validateName, schema, schemaEnv, opts },
      body
    ) {
      if (opts.code.es5) {
        gen.func(
          validateName,
          (0, codegen_1._)`${names_1.default.data}, ${names_1.default.valCxt}`,
          schemaEnv.$async,
          () => {
            gen.code(
              (0, codegen_1._)`"use strict"; ${funcSourceUrl(schema, opts)}`
            );
            destructureValCxtES5(gen, opts);
            gen.code(body);
          }
        );
      } else {
        gen.func(
          validateName,
          (0, codegen_1._)`${names_1.default.data}, ${destructureValCxt(opts)}`,
          schemaEnv.$async,
          () => gen.code(funcSourceUrl(schema, opts)).code(body)
        );
      }
    }
    function destructureValCxt(opts) {
      return (0, codegen_1._)`{${names_1.default.instancePath}="", ${
        names_1.default.parentData
      }, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${
        names_1.default.data
      }${
        opts.dynamicRef
          ? (0, codegen_1._)`, ${names_1.default.dynamicAnchors}={}`
          : codegen_1.nil
      }}={}`;
    }
    function destructureValCxtES5(gen, opts) {
      gen.if(
        names_1.default.valCxt,
        () => {
          gen.var(
            names_1.default.instancePath,
            (0,
            codegen_1._)`${names_1.default.valCxt}.${names_1.default.instancePath}`
          );
          gen.var(
            names_1.default.parentData,
            (0,
            codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentData}`
          );
          gen.var(
            names_1.default.parentDataProperty,
            (0,
            codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentDataProperty}`
          );
          gen.var(
            names_1.default.rootData,
            (0,
            codegen_1._)`${names_1.default.valCxt}.${names_1.default.rootData}`
          );
          if (opts.dynamicRef)
            gen.var(
              names_1.default.dynamicAnchors,
              (0,
              codegen_1._)`${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`
            );
        },
        () => {
          gen.var(names_1.default.instancePath, (0, codegen_1._)`""`);
          gen.var(names_1.default.parentData, (0, codegen_1._)`undefined`);
          gen.var(
            names_1.default.parentDataProperty,
            (0, codegen_1._)`undefined`
          );
          gen.var(names_1.default.rootData, names_1.default.data);
          if (opts.dynamicRef)
            gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`{}`);
        }
      );
    }
    function topSchemaObjCode(it) {
      const { schema, opts, gen } = it;
      validateFunction(it, () => {
        if (opts.$comment && schema.$comment) commentKeyword(it);
        checkNoDefault(it);
        gen.let(names_1.default.vErrors, null);
        gen.let(names_1.default.errors, 0);
        if (opts.unevaluated) resetEvaluated(it);
        typeAndKeywords(it);
        returnResults(it);
      });
      return;
    }
    function resetEvaluated(it) {
      const { gen, validateName } = it;
      it.evaluated = gen.const(
        "evaluated",
        (0, codegen_1._)`${validateName}.evaluated`
      );
      gen.if((0, codegen_1._)`${it.evaluated}.dynamicProps`, () =>
        gen.assign(
          (0, codegen_1._)`${it.evaluated}.props`,
          (0, codegen_1._)`undefined`
        )
      );
      gen.if((0, codegen_1._)`${it.evaluated}.dynamicItems`, () =>
        gen.assign(
          (0, codegen_1._)`${it.evaluated}.items`,
          (0, codegen_1._)`undefined`
        )
      );
    }
    function funcSourceUrl(schema, opts) {
      const schId = typeof schema == "object" && schema[opts.schemaId];
      return schId && (opts.code.source || opts.code.process)
        ? (0, codegen_1._)`/*# sourceURL=${schId} */`
        : codegen_1.nil;
    }
    function subschemaCode(it, valid) {
      if (isSchemaObj(it)) {
        checkKeywords(it);
        if (schemaCxtHasRules(it)) {
          subSchemaObjCode(it, valid);
          return;
        }
      }
      (0, boolSchema_1.boolOrEmptySchema)(it, valid);
    }
    function schemaCxtHasRules({ schema, self: self2 }) {
      if (typeof schema == "boolean") return !schema;
      for (const key in schema) if (self2.RULES.all[key]) return true;
      return false;
    }
    function isSchemaObj(it) {
      return typeof it.schema != "boolean";
    }
    function subSchemaObjCode(it, valid) {
      const { schema, gen, opts } = it;
      if (opts.$comment && schema.$comment) commentKeyword(it);
      updateContext(it);
      checkAsyncSchema(it);
      const errsCount = gen.const("_errs", names_1.default.errors);
      typeAndKeywords(it, errsCount);
      gen.var(
        valid,
        (0, codegen_1._)`${errsCount} === ${names_1.default.errors}`
      );
    }
    function checkKeywords(it) {
      (0, util_1.checkUnknownRules)(it);
      checkRefsAndKeywords(it);
    }
    function typeAndKeywords(it, errsCount) {
      if (it.opts.jtd) return schemaKeywords(it, [], false, errsCount);
      const types = (0, dataType_1.getSchemaTypes)(it.schema);
      const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it, types);
      schemaKeywords(it, types, !checkedTypes, errsCount);
    }
    function checkRefsAndKeywords(it) {
      const { schema, errSchemaPath, opts, self: self2 } = it;
      if (
        schema.$ref &&
        opts.ignoreKeywordsWithRef &&
        (0, util_1.schemaHasRulesButRef)(schema, self2.RULES)
      ) {
        self2.logger.warn(
          `$ref: keywords ignored in schema at path "${errSchemaPath}"`
        );
      }
    }
    function checkNoDefault(it) {
      const { schema, opts } = it;
      if (schema.default !== void 0 && opts.useDefaults && opts.strictSchema) {
        (0, util_1.checkStrictMode)(
          it,
          "default is ignored in the schema root"
        );
      }
    }
    function updateContext(it) {
      const schId = it.schema[it.opts.schemaId];
      if (schId)
        it.baseId = (0, resolve_1.resolveUrl)(
          it.opts.uriResolver,
          it.baseId,
          schId
        );
    }
    function checkAsyncSchema(it) {
      if (it.schema.$async && !it.schemaEnv.$async)
        throw new Error("async schema in sync schema");
    }
    function commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {
      const msg = schema.$comment;
      if (opts.$comment === true) {
        gen.code((0, codegen_1._)`${names_1.default.self}.logger.log(${msg})`);
      } else if (typeof opts.$comment == "function") {
        const schemaPath = (0, codegen_1.str)`${errSchemaPath}/$comment`;
        const rootName = gen.scopeValue("root", { ref: schemaEnv.root });
        gen.code(
          (0,
          codegen_1._)`${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`
        );
      }
    }
    function returnResults(it) {
      const { gen, schemaEnv, validateName, ValidationError, opts } = it;
      if (schemaEnv.$async) {
        gen.if(
          (0, codegen_1._)`${names_1.default.errors} === 0`,
          () => gen.return(names_1.default.data),
          () =>
            gen.throw(
              (0,
              codegen_1._)`new ${ValidationError}(${names_1.default.vErrors})`
            )
        );
      } else {
        gen.assign(
          (0, codegen_1._)`${validateName}.errors`,
          names_1.default.vErrors
        );
        if (opts.unevaluated) assignEvaluated(it);
        gen.return((0, codegen_1._)`${names_1.default.errors} === 0`);
      }
    }
    function assignEvaluated({ gen, evaluated, props, items }) {
      if (props instanceof codegen_1.Name)
        gen.assign((0, codegen_1._)`${evaluated}.props`, props);
      if (items instanceof codegen_1.Name)
        gen.assign((0, codegen_1._)`${evaluated}.items`, items);
    }
    function schemaKeywords(it, types, typeErrors, errsCount) {
      const { gen, schema, data, allErrors, opts, self: self2 } = it;
      const { RULES } = self2;
      if (
        schema.$ref &&
        (opts.ignoreKeywordsWithRef ||
          !(0, util_1.schemaHasRulesButRef)(schema, RULES))
      ) {
        gen.block(() => keywordCode(it, "$ref", RULES.all.$ref.definition));
        return;
      }
      if (!opts.jtd) checkStrictTypes(it, types);
      gen.block(() => {
        for (const group of RULES.rules) groupKeywords(group);
        groupKeywords(RULES.post);
      });
      function groupKeywords(group) {
        if (!(0, applicability_1.shouldUseGroup)(schema, group)) return;
        if (group.type) {
          gen.if(
            (0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers)
          );
          iterateKeywords(it, group);
          if (types.length === 1 && types[0] === group.type && typeErrors) {
            gen.else();
            (0, dataType_2.reportTypeError)(it);
          }
          gen.endIf();
        } else {
          iterateKeywords(it, group);
        }
        if (!allErrors)
          gen.if(
            (0, codegen_1._)`${names_1.default.errors} === ${errsCount || 0}`
          );
      }
    }
    function iterateKeywords(it, group) {
      const {
        gen,
        schema,
        opts: { useDefaults },
      } = it;
      if (useDefaults) (0, defaults_1.assignDefaults)(it, group.type);
      gen.block(() => {
        for (const rule of group.rules) {
          if ((0, applicability_1.shouldUseRule)(schema, rule)) {
            keywordCode(it, rule.keyword, rule.definition, group.type);
          }
        }
      });
    }
    function checkStrictTypes(it, types) {
      if (it.schemaEnv.meta || !it.opts.strictTypes) return;
      checkContextTypes(it, types);
      if (!it.opts.allowUnionTypes) checkMultipleTypes(it, types);
      checkKeywordTypes(it, it.dataTypes);
    }
    function checkContextTypes(it, types) {
      if (!types.length) return;
      if (!it.dataTypes.length) {
        it.dataTypes = types;
        return;
      }
      types.forEach((t) => {
        if (!includesType(it.dataTypes, t)) {
          strictTypesError(
            it,
            `type "${t}" not allowed by context "${it.dataTypes.join(",")}"`
          );
        }
      });
      narrowSchemaTypes(it, types);
    }
    function checkMultipleTypes(it, ts) {
      if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) {
        strictTypesError(it, "use allowUnionTypes to allow union type keyword");
      }
    }
    function checkKeywordTypes(it, ts) {
      const rules = it.self.RULES.all;
      for (const keyword in rules) {
        const rule = rules[keyword];
        if (
          typeof rule == "object" &&
          (0, applicability_1.shouldUseRule)(it.schema, rule)
        ) {
          const { type } = rule.definition;
          if (type.length && !type.some((t) => hasApplicableType(ts, t))) {
            strictTypesError(
              it,
              `missing type "${type.join(",")}" for keyword "${keyword}"`
            );
          }
        }
      }
    }
    function hasApplicableType(schTs, kwdT) {
      return (
        schTs.includes(kwdT) || (kwdT === "number" && schTs.includes("integer"))
      );
    }
    function includesType(ts, t) {
      return ts.includes(t) || (t === "integer" && ts.includes("number"));
    }
    function narrowSchemaTypes(it, withTypes) {
      const ts = [];
      for (const t of it.dataTypes) {
        if (includesType(withTypes, t)) ts.push(t);
        else if (withTypes.includes("integer") && t === "number")
          ts.push("integer");
      }
      it.dataTypes = ts;
    }
    function strictTypesError(it, msg) {
      const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
      msg += ` at "${schemaPath}" (strictTypes)`;
      (0, util_1.checkStrictMode)(it, msg, it.opts.strictTypes);
    }
    var KeywordCxt = class {
      constructor(it, def, keyword) {
        (0, keyword_1.validateKeywordUsage)(it, def, keyword);
        this.gen = it.gen;
        this.allErrors = it.allErrors;
        this.keyword = keyword;
        this.data = it.data;
        this.schema = it.schema[keyword];
        this.$data =
          def.$data && it.opts.$data && this.schema && this.schema.$data;
        this.schemaValue = (0, util_1.schemaRefOrVal)(
          it,
          this.schema,
          keyword,
          this.$data
        );
        this.schemaType = def.schemaType;
        this.parentSchema = it.schema;
        this.params = {};
        this.it = it;
        this.def = def;
        if (this.$data) {
          this.schemaCode = it.gen.const("vSchema", getData(this.$data, it));
        } else {
          this.schemaCode = this.schemaValue;
          if (
            !(0, keyword_1.validSchemaType)(
              this.schema,
              def.schemaType,
              def.allowUndefined
            )
          ) {
            throw new Error(
              `${keyword} value must be ${JSON.stringify(def.schemaType)}`
            );
          }
        }
        if ("code" in def ? def.trackErrors : def.errors !== false) {
          this.errsCount = it.gen.const("_errs", names_1.default.errors);
        }
      }
      result(condition, successAction, failAction) {
        this.failResult(
          (0, codegen_1.not)(condition),
          successAction,
          failAction
        );
      }
      failResult(condition, successAction, failAction) {
        this.gen.if(condition);
        if (failAction) failAction();
        else this.error();
        if (successAction) {
          this.gen.else();
          successAction();
          if (this.allErrors) this.gen.endIf();
        } else {
          if (this.allErrors) this.gen.endIf();
          else this.gen.else();
        }
      }
      pass(condition, failAction) {
        this.failResult((0, codegen_1.not)(condition), void 0, failAction);
      }
      fail(condition) {
        if (condition === void 0) {
          this.error();
          if (!this.allErrors) this.gen.if(false);
          return;
        }
        this.gen.if(condition);
        this.error();
        if (this.allErrors) this.gen.endIf();
        else this.gen.else();
      }
      fail$data(condition) {
        if (!this.$data) return this.fail(condition);
        const { schemaCode } = this;
        this.fail(
          (0, codegen_1._)`${schemaCode} !== undefined && (${(0, codegen_1.or)(
            this.invalid$data(),
            condition
          )})`
        );
      }
      error(append, errorParams, errorPaths) {
        if (errorParams) {
          this.setParams(errorParams);
          this._error(append, errorPaths);
          this.setParams({});
          return;
        }
        this._error(append, errorPaths);
      }
      _error(append, errorPaths) {
        (append ? errors_1.reportExtraError : errors_1.reportError)(
          this,
          this.def.error,
          errorPaths
        );
      }
      $dataError() {
        (0, errors_1.reportError)(
          this,
          this.def.$dataError || errors_1.keyword$DataError
        );
      }
      reset() {
        if (this.errsCount === void 0)
          throw new Error('add "trackErrors" to keyword definition');
        (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);
      }
      ok(cond) {
        if (!this.allErrors) this.gen.if(cond);
      }
      setParams(obj, assign) {
        if (assign) Object.assign(this.params, obj);
        else this.params = obj;
      }
      block$data(valid, codeBlock, $dataValid = codegen_1.nil) {
        this.gen.block(() => {
          this.check$data(valid, $dataValid);
          codeBlock();
        });
      }
      check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {
        if (!this.$data) return;
        const { gen, schemaCode, schemaType, def } = this;
        gen.if(
          (0, codegen_1.or)(
            (0, codegen_1._)`${schemaCode} === undefined`,
            $dataValid
          )
        );
        if (valid !== codegen_1.nil) gen.assign(valid, true);
        if (schemaType.length || def.validateSchema) {
          gen.elseIf(this.invalid$data());
          this.$dataError();
          if (valid !== codegen_1.nil) gen.assign(valid, false);
        }
        gen.else();
      }
      invalid$data() {
        const { gen, schemaCode, schemaType, def, it } = this;
        return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());
        function wrong$DataType() {
          if (schemaType.length) {
            if (!(schemaCode instanceof codegen_1.Name))
              throw new Error("ajv implementation error");
            const st = Array.isArray(schemaType) ? schemaType : [schemaType];
            return (0, codegen_1._)`${(0, dataType_2.checkDataTypes)(
              st,
              schemaCode,
              it.opts.strictNumbers,
              dataType_2.DataType.Wrong
            )}`;
          }
          return codegen_1.nil;
        }
        function invalid$DataSchema() {
          if (def.validateSchema) {
            const validateSchemaRef = gen.scopeValue("validate$data", {
              ref: def.validateSchema,
            });
            return (0, codegen_1._)`!${validateSchemaRef}(${schemaCode})`;
          }
          return codegen_1.nil;
        }
      }
      subschema(appl, valid) {
        const subschema = (0, subschema_1.getSubschema)(this.it, appl);
        (0, subschema_1.extendSubschemaData)(subschema, this.it, appl);
        (0, subschema_1.extendSubschemaMode)(subschema, appl);
        const nextContext = {
          ...this.it,
          ...subschema,
          items: void 0,
          props: void 0,
        };
        subschemaCode(nextContext, valid);
        return nextContext;
      }
      mergeEvaluated(schemaCxt, toName) {
        const { it, gen } = this;
        if (!it.opts.unevaluated) return;
        if (it.props !== true && schemaCxt.props !== void 0) {
          it.props = util_1.mergeEvaluated.props(
            gen,
            schemaCxt.props,
            it.props,
            toName
          );
        }
        if (it.items !== true && schemaCxt.items !== void 0) {
          it.items = util_1.mergeEvaluated.items(
            gen,
            schemaCxt.items,
            it.items,
            toName
          );
        }
      }
      mergeValidEvaluated(schemaCxt, valid) {
        const { it, gen } = this;
        if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {
          gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));
          return true;
        }
      }
    };
    exports2.KeywordCxt = KeywordCxt;
    function keywordCode(it, keyword, def, ruleType) {
      const cxt = new KeywordCxt(it, def, keyword);
      if ("code" in def) {
        def.code(cxt, ruleType);
      } else if (cxt.$data && def.validate) {
        (0, keyword_1.funcKeywordCode)(cxt, def);
      } else if ("macro" in def) {
        (0, keyword_1.macroKeywordCode)(cxt, def);
      } else if (def.compile || def.validate) {
        (0, keyword_1.funcKeywordCode)(cxt, def);
      }
    }
    var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
    var RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
    function getData($data, { dataLevel, dataNames, dataPathArr }) {
      let jsonPointer;
      let data;
      if ($data === "") return names_1.default.rootData;
      if ($data[0] === "/") {
        if (!JSON_POINTER.test($data))
          throw new Error(`Invalid JSON-pointer: ${$data}`);
        jsonPointer = $data;
        data = names_1.default.rootData;
      } else {
        const matches = RELATIVE_JSON_POINTER.exec($data);
        if (!matches) throw new Error(`Invalid JSON-pointer: ${$data}`);
        const up = +matches[1];
        jsonPointer = matches[2];
        if (jsonPointer === "#") {
          if (up >= dataLevel) throw new Error(errorMsg("property/index", up));
          return dataPathArr[dataLevel - up];
        }
        if (up > dataLevel) throw new Error(errorMsg("data", up));
        data = dataNames[dataLevel - up];
        if (!jsonPointer) return data;
      }
      let expr = data;
      const segments = jsonPointer.split("/");
      for (const segment of segments) {
        if (segment) {
          data = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(
            (0, util_1.unescapeJsonPointer)(segment)
          )}`;
          expr = (0, codegen_1._)`${expr} && ${data}`;
        }
      }
      return expr;
      function errorMsg(pointerType, up) {
        return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
      }
    }
    exports2.getData = getData;
  },
});

// node_modules/ajv-formats/node_modules/ajv/dist/runtime/validation_error.js
var require_validation_error2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/runtime/validation_error.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var ValidationError = class extends Error {
      constructor(errors) {
        super("validation failed");
        this.errors = errors;
        this.ajv = this.validation = true;
      }
    };
    exports2.default = ValidationError;
  },
});

// node_modules/ajv-formats/node_modules/ajv/dist/compile/ref_error.js
var require_ref_error2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/compile/ref_error.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var resolve_1 = require_resolve2();
    var MissingRefError = class extends Error {
      constructor(resolver, baseId, ref, msg) {
        super(msg || `can't resolve reference ${ref} from id ${baseId}`);
        this.missingRef = (0, resolve_1.resolveUrl)(resolver, baseId, ref);
        this.missingSchema = (0, resolve_1.normalizeId)(
          (0, resolve_1.getFullPath)(resolver, this.missingRef)
        );
      }
    };
    exports2.default = MissingRefError;
  },
});

// node_modules/ajv-formats/node_modules/ajv/dist/compile/index.js
var require_compile2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/compile/index.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resolveSchema =
      exports2.getCompilingSchema =
      exports2.resolveRef =
      exports2.compileSchema =
      exports2.SchemaEnv =
        void 0;
    var codegen_1 = require_codegen2();
    var validation_error_1 = require_validation_error2();
    var names_1 = require_names2();
    var resolve_1 = require_resolve2();
    var util_1 = require_util2();
    var validate_1 = require_validate2();
    var SchemaEnv = class {
      constructor(env) {
        var _a;
        this.refs = {};
        this.dynamicAnchors = {};
        let schema;
        if (typeof env.schema == "object") schema = env.schema;
        this.schema = env.schema;
        this.schemaId = env.schemaId;
        this.root = env.root || this;
        this.baseId =
          (_a = env.baseId) !== null && _a !== void 0
            ? _a
            : (0, resolve_1.normalizeId)(
                schema === null || schema === void 0
                  ? void 0
                  : schema[env.schemaId || "$id"]
              );
        this.schemaPath = env.schemaPath;
        this.localRefs = env.localRefs;
        this.meta = env.meta;
        this.$async =
          schema === null || schema === void 0 ? void 0 : schema.$async;
        this.refs = {};
      }
    };
    exports2.SchemaEnv = SchemaEnv;
    function compileSchema(sch) {
      const _sch = getCompilingSchema.call(this, sch);
      if (_sch) return _sch;
      const rootId = (0, resolve_1.getFullPath)(
        this.opts.uriResolver,
        sch.root.baseId
      );
      const { es5, lines } = this.opts.code;
      const { ownProperties } = this.opts;
      const gen = new codegen_1.CodeGen(this.scope, {
        es5,
        lines,
        ownProperties,
      });
      let _ValidationError;
      if (sch.$async) {
        _ValidationError = gen.scopeValue("Error", {
          ref: validation_error_1.default,
          code: (0,
          codegen_1._)`require("ajv/dist/runtime/validation_error").default`,
        });
      }
      const validateName = gen.scopeName("validate");
      sch.validateName = validateName;
      const schemaCxt = {
        gen,
        allErrors: this.opts.allErrors,
        data: names_1.default.data,
        parentData: names_1.default.parentData,
        parentDataProperty: names_1.default.parentDataProperty,
        dataNames: [names_1.default.data],
        dataPathArr: [codegen_1.nil],
        dataLevel: 0,
        dataTypes: [],
        definedProperties: /* @__PURE__ */ new Set(),
        topSchemaRef: gen.scopeValue(
          "schema",
          this.opts.code.source === true
            ? { ref: sch.schema, code: (0, codegen_1.stringify)(sch.schema) }
            : { ref: sch.schema }
        ),
        validateName,
        ValidationError: _ValidationError,
        schema: sch.schema,
        schemaEnv: sch,
        rootId,
        baseId: sch.baseId || rootId,
        schemaPath: codegen_1.nil,
        errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
        errorPath: (0, codegen_1._)`""`,
        opts: this.opts,
        self: this,
      };
      let sourceCode;
      try {
        this._compilations.add(sch);
        (0, validate_1.validateFunctionCode)(schemaCxt);
        gen.optimize(this.opts.code.optimize);
        const validateCode = gen.toString();
        sourceCode = `${gen.scopeRefs(
          names_1.default.scope
        )}return ${validateCode}`;
        if (this.opts.code.process)
          sourceCode = this.opts.code.process(sourceCode, sch);
        const makeValidate = new Function(
          `${names_1.default.self}`,
          `${names_1.default.scope}`,
          sourceCode
        );
        const validate = makeValidate(this, this.scope.get());
        this.scope.value(validateName, { ref: validate });
        validate.errors = null;
        validate.schema = sch.schema;
        validate.schemaEnv = sch;
        if (sch.$async) validate.$async = true;
        if (this.opts.code.source === true) {
          validate.source = {
            validateName,
            validateCode,
            scopeValues: gen._values,
          };
        }
        if (this.opts.unevaluated) {
          const { props, items } = schemaCxt;
          validate.evaluated = {
            props: props instanceof codegen_1.Name ? void 0 : props,
            items: items instanceof codegen_1.Name ? void 0 : items,
            dynamicProps: props instanceof codegen_1.Name,
            dynamicItems: items instanceof codegen_1.Name,
          };
          if (validate.source)
            validate.source.evaluated = (0, codegen_1.stringify)(
              validate.evaluated
            );
        }
        sch.validate = validate;
        return sch;
      } catch (e) {
        delete sch.validate;
        delete sch.validateName;
        if (sourceCode)
          this.logger.error(
            "Error compiling schema, function code:",
            sourceCode
          );
        throw e;
      } finally {
        this._compilations.delete(sch);
      }
    }
    exports2.compileSchema = compileSchema;
    function resolveRef(root2, baseId, ref) {
      var _a;
      ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref);
      const schOrFunc = root2.refs[ref];
      if (schOrFunc) return schOrFunc;
      let _sch = resolve.call(this, root2, ref);
      if (_sch === void 0) {
        const schema =
          (_a = root2.localRefs) === null || _a === void 0 ? void 0 : _a[ref];
        const { schemaId } = this.opts;
        if (schema)
          _sch = new SchemaEnv({ schema, schemaId, root: root2, baseId });
      }
      if (_sch === void 0) return;
      return (root2.refs[ref] = inlineOrCompile.call(this, _sch));
    }
    exports2.resolveRef = resolveRef;
    function inlineOrCompile(sch) {
      if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs))
        return sch.schema;
      return sch.validate ? sch : compileSchema.call(this, sch);
    }
    function getCompilingSchema(schEnv) {
      for (const sch of this._compilations) {
        if (sameSchemaEnv(sch, schEnv)) return sch;
      }
    }
    exports2.getCompilingSchema = getCompilingSchema;
    function sameSchemaEnv(s1, s2) {
      return (
        s1.schema === s2.schema &&
        s1.root === s2.root &&
        s1.baseId === s2.baseId
      );
    }
    function resolve(root2, ref) {
      let sch;
      while (typeof (sch = this.refs[ref]) == "string") ref = sch;
      return sch || this.schemas[ref] || resolveSchema.call(this, root2, ref);
    }
    function resolveSchema(root2, ref) {
      const p = this.opts.uriResolver.parse(ref);
      const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p);
      let baseId = (0, resolve_1.getFullPath)(
        this.opts.uriResolver,
        root2.baseId,
        void 0
      );
      if (Object.keys(root2.schema).length > 0 && refPath === baseId) {
        return getJsonPointer.call(this, p, root2);
      }
      const id = (0, resolve_1.normalizeId)(refPath);
      const schOrRef = this.refs[id] || this.schemas[id];
      if (typeof schOrRef == "string") {
        const sch = resolveSchema.call(this, root2, schOrRef);
        if (
          typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !==
          "object"
        )
          return;
        return getJsonPointer.call(this, p, sch);
      }
      if (
        typeof (schOrRef === null || schOrRef === void 0
          ? void 0
          : schOrRef.schema) !== "object"
      )
        return;
      if (!schOrRef.validate) compileSchema.call(this, schOrRef);
      if (id === (0, resolve_1.normalizeId)(ref)) {
        const { schema } = schOrRef;
        const { schemaId } = this.opts;
        const schId = schema[schemaId];
        if (schId)
          baseId = (0, resolve_1.resolveUrl)(
            this.opts.uriResolver,
            baseId,
            schId
          );
        return new SchemaEnv({ schema, schemaId, root: root2, baseId });
      }
      return getJsonPointer.call(this, p, schOrRef);
    }
    exports2.resolveSchema = resolveSchema;
    var PREVENT_SCOPE_CHANGE = /* @__PURE__ */ new Set([
      "properties",
      "patternProperties",
      "enum",
      "dependencies",
      "definitions",
    ]);
    function getJsonPointer(parsedRef, { baseId, schema, root: root2 }) {
      var _a;
      if (
        ((_a = parsedRef.fragment) === null || _a === void 0
          ? void 0
          : _a[0]) !== "/"
      )
        return;
      for (const part of parsedRef.fragment.slice(1).split("/")) {
        if (typeof schema === "boolean") return;
        const partSchema = schema[(0, util_1.unescapeFragment)(part)];
        if (partSchema === void 0) return;
        schema = partSchema;
        const schId = typeof schema === "object" && schema[this.opts.schemaId];
        if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {
          baseId = (0, resolve_1.resolveUrl)(
            this.opts.uriResolver,
            baseId,
            schId
          );
        }
      }
      let env;
      if (
        typeof schema != "boolean" &&
        schema.$ref &&
        !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)
      ) {
        const $ref = (0, resolve_1.resolveUrl)(
          this.opts.uriResolver,
          baseId,
          schema.$ref
        );
        env = resolveSchema.call(this, root2, $ref);
      }
      const { schemaId } = this.opts;
      env = env || new SchemaEnv({ schema, schemaId, root: root2, baseId });
      if (env.schema !== env.root.schema) return env;
      return void 0;
    }
  },
});

// node_modules/ajv-formats/node_modules/ajv/dist/refs/data.json
var require_data2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/refs/data.json"(
    exports2,
    module2
  ) {
    module2.exports = {
      $id: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
      description:
        "Meta-schema for $data reference (JSON AnySchema extension proposal)",
      type: "object",
      required: ["$data"],
      properties: {
        $data: {
          type: "string",
          anyOf: [
            { format: "relative-json-pointer" },
            { format: "json-pointer" },
          ],
        },
      },
      additionalProperties: false,
    };
  },
});

// node_modules/ajv-formats/node_modules/ajv/dist/runtime/uri.js
var require_uri2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/runtime/uri.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var uri = require_uri_all();
    uri.code = 'require("ajv/dist/runtime/uri").default';
    exports2.default = uri;
  },
});

// node_modules/ajv-formats/node_modules/ajv/dist/core.js
var require_core3 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/core.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CodeGen =
      exports2.Name =
      exports2.nil =
      exports2.stringify =
      exports2.str =
      exports2._ =
      exports2.KeywordCxt =
        void 0;
    var validate_1 = require_validate2();
    Object.defineProperty(exports2, "KeywordCxt", {
      enumerable: true,
      get: function () {
        return validate_1.KeywordCxt;
      },
    });
    var codegen_1 = require_codegen2();
    Object.defineProperty(exports2, "_", {
      enumerable: true,
      get: function () {
        return codegen_1._;
      },
    });
    Object.defineProperty(exports2, "str", {
      enumerable: true,
      get: function () {
        return codegen_1.str;
      },
    });
    Object.defineProperty(exports2, "stringify", {
      enumerable: true,
      get: function () {
        return codegen_1.stringify;
      },
    });
    Object.defineProperty(exports2, "nil", {
      enumerable: true,
      get: function () {
        return codegen_1.nil;
      },
    });
    Object.defineProperty(exports2, "Name", {
      enumerable: true,
      get: function () {
        return codegen_1.Name;
      },
    });
    Object.defineProperty(exports2, "CodeGen", {
      enumerable: true,
      get: function () {
        return codegen_1.CodeGen;
      },
    });
    var validation_error_1 = require_validation_error2();
    var ref_error_1 = require_ref_error2();
    var rules_1 = require_rules2();
    var compile_1 = require_compile2();
    var codegen_2 = require_codegen2();
    var resolve_1 = require_resolve2();
    var dataType_1 = require_dataType2();
    var util_1 = require_util2();
    var $dataRefSchema = require_data2();
    var uri_1 = require_uri2();
    var defaultRegExp = (str, flags) => new RegExp(str, flags);
    defaultRegExp.code = "new RegExp";
    var META_IGNORE_OPTIONS = [
      "removeAdditional",
      "useDefaults",
      "coerceTypes",
    ];
    var EXT_SCOPE_NAMES = /* @__PURE__ */ new Set([
      "validate",
      "serialize",
      "parse",
      "wrapper",
      "root",
      "schema",
      "keyword",
      "pattern",
      "formats",
      "validate$data",
      "func",
      "obj",
      "Error",
    ]);
    var removedOptions = {
      errorDataPath: "",
      format: "`validateFormats: false` can be used instead.",
      nullable: '"nullable" keyword is supported by default.',
      jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
      extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
      missingRefs:
        "Pass empty schema with $id that should be ignored to ajv.addSchema.",
      processCode:
        "Use option `code: {process: (code, schemaEnv: object) => string}`",
      sourceCode: "Use option `code: {source: true}`",
      strictDefaults: "It is default now, see option `strict`.",
      strictKeywords: "It is default now, see option `strict`.",
      uniqueItems: '"uniqueItems" keyword is always validated.',
      unknownFormats:
        "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
      cache: "Map is used as cache, schema object as key.",
      serialize: "Map is used as cache, schema object as key.",
      ajvErrors: "It is default now.",
    };
    var deprecatedOptions = {
      ignoreKeywordsWithRef: "",
      jsPropertySyntax: "",
      unicode:
        '"minLength"/"maxLength" account for unicode characters by default.',
    };
    var MAX_EXPRESSION = 200;
    function requiredOptions(o) {
      var _a,
        _b,
        _c,
        _d,
        _e,
        _f,
        _g,
        _h,
        _j,
        _k,
        _l,
        _m,
        _o,
        _p,
        _q,
        _r,
        _s,
        _t,
        _u,
        _v,
        _w,
        _x,
        _y,
        _z,
        _0;
      const s = o.strict;
      const _optz =
        (_a = o.code) === null || _a === void 0 ? void 0 : _a.optimize;
      const optimize = _optz === true || _optz === void 0 ? 1 : _optz || 0;
      const regExp =
        (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !==
          null && _c !== void 0
          ? _c
          : defaultRegExp;
      const uriResolver =
        (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;
      return {
        strictSchema:
          (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !==
            null && _f !== void 0
            ? _f
            : true,
        strictNumbers:
          (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !==
            null && _h !== void 0
            ? _h
            : true,
        strictTypes:
          (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !==
            null && _k !== void 0
            ? _k
            : "log",
        strictTuples:
          (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !==
            null && _m !== void 0
            ? _m
            : "log",
        strictRequired:
          (_p = (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s) !==
            null && _p !== void 0
            ? _p
            : false,
        code: o.code ? { ...o.code, optimize, regExp } : { optimize, regExp },
        loopRequired:
          (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,
        loopEnum:
          (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,
        meta: (_s = o.meta) !== null && _s !== void 0 ? _s : true,
        messages: (_t = o.messages) !== null && _t !== void 0 ? _t : true,
        inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : true,
        schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : "$id",
        addUsedSchema:
          (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,
        validateSchema:
          (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,
        validateFormats:
          (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,
        unicodeRegExp:
          (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,
        int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,
        uriResolver,
      };
    }
    var Ajv = class {
      constructor(opts = {}) {
        this.schemas = {};
        this.refs = {};
        this.formats = {};
        this._compilations = /* @__PURE__ */ new Set();
        this._loading = {};
        this._cache = /* @__PURE__ */ new Map();
        opts = this.opts = { ...opts, ...requiredOptions(opts) };
        const { es5, lines } = this.opts.code;
        this.scope = new codegen_2.ValueScope({
          scope: {},
          prefixes: EXT_SCOPE_NAMES,
          es5,
          lines,
        });
        this.logger = getLogger(opts.logger);
        const formatOpt = opts.validateFormats;
        opts.validateFormats = false;
        this.RULES = (0, rules_1.getRules)();
        checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
        checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
        this._metaOpts = getMetaSchemaOptions.call(this);
        if (opts.formats) addInitialFormats.call(this);
        this._addVocabularies();
        this._addDefaultMetaSchema();
        if (opts.keywords) addInitialKeywords.call(this, opts.keywords);
        if (typeof opts.meta == "object") this.addMetaSchema(opts.meta);
        addInitialSchemas.call(this);
        opts.validateFormats = formatOpt;
      }
      _addVocabularies() {
        this.addKeyword("$async");
      }
      _addDefaultMetaSchema() {
        const { $data, meta, schemaId } = this.opts;
        let _dataRefSchema = $dataRefSchema;
        if (schemaId === "id") {
          _dataRefSchema = { ...$dataRefSchema };
          _dataRefSchema.id = _dataRefSchema.$id;
          delete _dataRefSchema.$id;
        }
        if (meta && $data)
          this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
      }
      defaultMeta() {
        const { meta, schemaId } = this.opts;
        return (this.opts.defaultMeta =
          typeof meta == "object" ? meta[schemaId] || meta : void 0);
      }
      validate(schemaKeyRef, data) {
        let v;
        if (typeof schemaKeyRef == "string") {
          v = this.getSchema(schemaKeyRef);
          if (!v)
            throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
        } else {
          v = this.compile(schemaKeyRef);
        }
        const valid = v(data);
        if (!("$async" in v)) this.errors = v.errors;
        return valid;
      }
      compile(schema, _meta) {
        const sch = this._addSchema(schema, _meta);
        return sch.validate || this._compileSchemaEnv(sch);
      }
      compileAsync(schema, meta) {
        if (typeof this.opts.loadSchema != "function") {
          throw new Error("options.loadSchema should be a function");
        }
        const { loadSchema } = this.opts;
        return runCompileAsync.call(this, schema, meta);
        async function runCompileAsync(_schema, _meta) {
          await loadMetaSchema.call(this, _schema.$schema);
          const sch = this._addSchema(_schema, _meta);
          return sch.validate || _compileAsync.call(this, sch);
        }
        async function loadMetaSchema($ref) {
          if ($ref && !this.getSchema($ref)) {
            await runCompileAsync.call(this, { $ref }, true);
          }
        }
        async function _compileAsync(sch) {
          try {
            return this._compileSchemaEnv(sch);
          } catch (e) {
            if (!(e instanceof ref_error_1.default)) throw e;
            checkLoaded.call(this, e);
            await loadMissingSchema.call(this, e.missingSchema);
            return _compileAsync.call(this, sch);
          }
        }
        function checkLoaded({ missingSchema: ref, missingRef }) {
          if (this.refs[ref]) {
            throw new Error(
              `AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`
            );
          }
        }
        async function loadMissingSchema(ref) {
          const _schema = await _loadSchema.call(this, ref);
          if (!this.refs[ref]) await loadMetaSchema.call(this, _schema.$schema);
          if (!this.refs[ref]) this.addSchema(_schema, ref, meta);
        }
        async function _loadSchema(ref) {
          const p = this._loading[ref];
          if (p) return p;
          try {
            return await (this._loading[ref] = loadSchema(ref));
          } finally {
            delete this._loading[ref];
          }
        }
      }
      // Adds schema to the instance
      addSchema(
        schema,
        key,
        _meta,
        _validateSchema = this.opts.validateSchema
      ) {
        if (Array.isArray(schema)) {
          for (const sch of schema)
            this.addSchema(sch, void 0, _meta, _validateSchema);
          return this;
        }
        let id;
        if (typeof schema === "object") {
          const { schemaId } = this.opts;
          id = schema[schemaId];
          if (id !== void 0 && typeof id != "string") {
            throw new Error(`schema ${schemaId} must be string`);
          }
        }
        key = (0, resolve_1.normalizeId)(key || id);
        this._checkUnique(key);
        this.schemas[key] = this._addSchema(
          schema,
          _meta,
          key,
          _validateSchema,
          true
        );
        return this;
      }
      // Add schema that will be used to validate other schemas
      // options in META_IGNORE_OPTIONS are alway set to false
      addMetaSchema(schema, key, _validateSchema = this.opts.validateSchema) {
        this.addSchema(schema, key, true, _validateSchema);
        return this;
      }
      //  Validate schema against its meta-schema
      validateSchema(schema, throwOrLogError) {
        if (typeof schema == "boolean") return true;
        let $schema;
        $schema = schema.$schema;
        if ($schema !== void 0 && typeof $schema != "string") {
          throw new Error("$schema must be a string");
        }
        $schema = $schema || this.opts.defaultMeta || this.defaultMeta();
        if (!$schema) {
          this.logger.warn("meta-schema not available");
          this.errors = null;
          return true;
        }
        const valid = this.validate($schema, schema);
        if (!valid && throwOrLogError) {
          const message = "schema is invalid: " + this.errorsText();
          if (this.opts.validateSchema === "log") this.logger.error(message);
          else throw new Error(message);
        }
        return valid;
      }
      // Get compiled schema by `key` or `ref`.
      // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
      getSchema(keyRef) {
        let sch;
        while (typeof (sch = getSchEnv.call(this, keyRef)) == "string")
          keyRef = sch;
        if (sch === void 0) {
          const { schemaId } = this.opts;
          const root2 = new compile_1.SchemaEnv({ schema: {}, schemaId });
          sch = compile_1.resolveSchema.call(this, root2, keyRef);
          if (!sch) return;
          this.refs[keyRef] = sch;
        }
        return sch.validate || this._compileSchemaEnv(sch);
      }
      // Remove cached schema(s).
      // If no parameter is passed all schemas but meta-schemas are removed.
      // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
      // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
      removeSchema(schemaKeyRef) {
        if (schemaKeyRef instanceof RegExp) {
          this._removeAllSchemas(this.schemas, schemaKeyRef);
          this._removeAllSchemas(this.refs, schemaKeyRef);
          return this;
        }
        switch (typeof schemaKeyRef) {
          case "undefined":
            this._removeAllSchemas(this.schemas);
            this._removeAllSchemas(this.refs);
            this._cache.clear();
            return this;
          case "string": {
            const sch = getSchEnv.call(this, schemaKeyRef);
            if (typeof sch == "object") this._cache.delete(sch.schema);
            delete this.schemas[schemaKeyRef];
            delete this.refs[schemaKeyRef];
            return this;
          }
          case "object": {
            const cacheKey = schemaKeyRef;
            this._cache.delete(cacheKey);
            let id = schemaKeyRef[this.opts.schemaId];
            if (id) {
              id = (0, resolve_1.normalizeId)(id);
              delete this.schemas[id];
              delete this.refs[id];
            }
            return this;
          }
          default:
            throw new Error("ajv.removeSchema: invalid parameter");
        }
      }
      // add "vocabulary" - a collection of keywords
      addVocabulary(definitions) {
        for (const def of definitions) this.addKeyword(def);
        return this;
      }
      addKeyword(kwdOrDef, def) {
        let keyword;
        if (typeof kwdOrDef == "string") {
          keyword = kwdOrDef;
          if (typeof def == "object") {
            this.logger.warn(
              "these parameters are deprecated, see docs for addKeyword"
            );
            def.keyword = keyword;
          }
        } else if (typeof kwdOrDef == "object" && def === void 0) {
          def = kwdOrDef;
          keyword = def.keyword;
          if (Array.isArray(keyword) && !keyword.length) {
            throw new Error(
              "addKeywords: keyword must be string or non-empty array"
            );
          }
        } else {
          throw new Error("invalid addKeywords parameters");
        }
        checkKeyword.call(this, keyword, def);
        if (!def) {
          (0, util_1.eachItem)(keyword, (kwd) => addRule.call(this, kwd));
          return this;
        }
        keywordMetaschema.call(this, def);
        const definition = {
          ...def,
          type: (0, dataType_1.getJSONTypes)(def.type),
          schemaType: (0, dataType_1.getJSONTypes)(def.schemaType),
        };
        (0, util_1.eachItem)(
          keyword,
          definition.type.length === 0
            ? (k) => addRule.call(this, k, definition)
            : (k) =>
                definition.type.forEach((t) =>
                  addRule.call(this, k, definition, t)
                )
        );
        return this;
      }
      getKeyword(keyword) {
        const rule = this.RULES.all[keyword];
        return typeof rule == "object" ? rule.definition : !!rule;
      }
      // Remove keyword
      removeKeyword(keyword) {
        const { RULES } = this;
        delete RULES.keywords[keyword];
        delete RULES.all[keyword];
        for (const group of RULES.rules) {
          const i = group.rules.findIndex((rule) => rule.keyword === keyword);
          if (i >= 0) group.rules.splice(i, 1);
        }
        return this;
      }
      // Add format
      addFormat(name, format) {
        if (typeof format == "string") format = new RegExp(format);
        this.formats[name] = format;
        return this;
      }
      errorsText(
        errors = this.errors,
        { separator = ", ", dataVar = "data" } = {}
      ) {
        if (!errors || errors.length === 0) return "No errors";
        return errors
          .map((e) => `${dataVar}${e.instancePath} ${e.message}`)
          .reduce((text, msg) => text + separator + msg);
      }
      $dataMetaSchema(metaSchema, keywordsJsonPointers) {
        const rules = this.RULES.all;
        metaSchema = JSON.parse(JSON.stringify(metaSchema));
        for (const jsonPointer of keywordsJsonPointers) {
          const segments = jsonPointer.split("/").slice(1);
          let keywords = metaSchema;
          for (const seg of segments) keywords = keywords[seg];
          for (const key in rules) {
            const rule = rules[key];
            if (typeof rule != "object") continue;
            const { $data } = rule.definition;
            const schema = keywords[key];
            if ($data && schema) keywords[key] = schemaOrData(schema);
          }
        }
        return metaSchema;
      }
      _removeAllSchemas(schemas, regex) {
        for (const keyRef in schemas) {
          const sch = schemas[keyRef];
          if (!regex || regex.test(keyRef)) {
            if (typeof sch == "string") {
              delete schemas[keyRef];
            } else if (sch && !sch.meta) {
              this._cache.delete(sch.schema);
              delete schemas[keyRef];
            }
          }
        }
      }
      _addSchema(
        schema,
        meta,
        baseId,
        validateSchema = this.opts.validateSchema,
        addSchema = this.opts.addUsedSchema
      ) {
        let id;
        const { schemaId } = this.opts;
        if (typeof schema == "object") {
          id = schema[schemaId];
        } else {
          if (this.opts.jtd) throw new Error("schema must be object");
          else if (typeof schema != "boolean")
            throw new Error("schema must be object or boolean");
        }
        let sch = this._cache.get(schema);
        if (sch !== void 0) return sch;
        baseId = (0, resolve_1.normalizeId)(id || baseId);
        const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);
        sch = new compile_1.SchemaEnv({
          schema,
          schemaId,
          meta,
          baseId,
          localRefs,
        });
        this._cache.set(sch.schema, sch);
        if (addSchema && !baseId.startsWith("#")) {
          if (baseId) this._checkUnique(baseId);
          this.refs[baseId] = sch;
        }
        if (validateSchema) this.validateSchema(schema, true);
        return sch;
      }
      _checkUnique(id) {
        if (this.schemas[id] || this.refs[id]) {
          throw new Error(`schema with key or id "${id}" already exists`);
        }
      }
      _compileSchemaEnv(sch) {
        if (sch.meta) this._compileMetaSchema(sch);
        else compile_1.compileSchema.call(this, sch);
        if (!sch.validate) throw new Error("ajv implementation error");
        return sch.validate;
      }
      _compileMetaSchema(sch) {
        const currentOpts = this.opts;
        this.opts = this._metaOpts;
        try {
          compile_1.compileSchema.call(this, sch);
        } finally {
          this.opts = currentOpts;
        }
      }
    };
    exports2.default = Ajv;
    Ajv.ValidationError = validation_error_1.default;
    Ajv.MissingRefError = ref_error_1.default;
    function checkOptions(checkOpts, options, msg, log = "error") {
      for (const key in checkOpts) {
        const opt = key;
        if (opt in options)
          this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);
      }
    }
    function getSchEnv(keyRef) {
      keyRef = (0, resolve_1.normalizeId)(keyRef);
      return this.schemas[keyRef] || this.refs[keyRef];
    }
    function addInitialSchemas() {
      const optsSchemas = this.opts.schemas;
      if (!optsSchemas) return;
      if (Array.isArray(optsSchemas)) this.addSchema(optsSchemas);
      else for (const key in optsSchemas) this.addSchema(optsSchemas[key], key);
    }
    function addInitialFormats() {
      for (const name in this.opts.formats) {
        const format = this.opts.formats[name];
        if (format) this.addFormat(name, format);
      }
    }
    function addInitialKeywords(defs) {
      if (Array.isArray(defs)) {
        this.addVocabulary(defs);
        return;
      }
      this.logger.warn("keywords option as map is deprecated, pass array");
      for (const keyword in defs) {
        const def = defs[keyword];
        if (!def.keyword) def.keyword = keyword;
        this.addKeyword(def);
      }
    }
    function getMetaSchemaOptions() {
      const metaOpts = { ...this.opts };
      for (const opt of META_IGNORE_OPTIONS) delete metaOpts[opt];
      return metaOpts;
    }
    var noLogs = { log() {}, warn() {}, error() {} };
    function getLogger(logger) {
      if (logger === false) return noLogs;
      if (logger === void 0) return console;
      if (logger.log && logger.warn && logger.error) return logger;
      throw new Error("logger must implement log, warn and error methods");
    }
    var KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
    function checkKeyword(keyword, def) {
      const { RULES } = this;
      (0, util_1.eachItem)(keyword, (kwd) => {
        if (RULES.keywords[kwd])
          throw new Error(`Keyword ${kwd} is already defined`);
        if (!KEYWORD_NAME.test(kwd))
          throw new Error(`Keyword ${kwd} has invalid name`);
      });
      if (!def) return;
      if (def.$data && !("code" in def || "validate" in def)) {
        throw new Error(
          '$data keyword must have "code" or "validate" function'
        );
      }
    }
    function addRule(keyword, definition, dataType) {
      var _a;
      const post =
        definition === null || definition === void 0 ? void 0 : definition.post;
      if (dataType && post)
        throw new Error('keyword with "post" flag cannot have "type"');
      const { RULES } = this;
      let ruleGroup = post
        ? RULES.post
        : RULES.rules.find(({ type: t }) => t === dataType);
      if (!ruleGroup) {
        ruleGroup = { type: dataType, rules: [] };
        RULES.rules.push(ruleGroup);
      }
      RULES.keywords[keyword] = true;
      if (!definition) return;
      const rule = {
        keyword,
        definition: {
          ...definition,
          type: (0, dataType_1.getJSONTypes)(definition.type),
          schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType),
        },
      };
      if (definition.before)
        addBeforeRule.call(this, ruleGroup, rule, definition.before);
      else ruleGroup.rules.push(rule);
      RULES.all[keyword] = rule;
      (_a = definition.implements) === null || _a === void 0
        ? void 0
        : _a.forEach((kwd) => this.addKeyword(kwd));
    }
    function addBeforeRule(ruleGroup, rule, before) {
      const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
      if (i >= 0) {
        ruleGroup.rules.splice(i, 0, rule);
      } else {
        ruleGroup.rules.push(rule);
        this.logger.warn(`rule ${before} is not defined`);
      }
    }
    function keywordMetaschema(def) {
      let { metaSchema } = def;
      if (metaSchema === void 0) return;
      if (def.$data && this.opts.$data) metaSchema = schemaOrData(metaSchema);
      def.validateSchema = this.compile(metaSchema, true);
    }
    var $dataRef = {
      $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
    };
    function schemaOrData(schema) {
      return { anyOf: [schema, $dataRef] };
    }
  },
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/core/id.js
var require_id2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/core/id.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var def = {
      keyword: "id",
      code() {
        throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
      },
    };
    exports2.default = def;
  },
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/core/ref.js
var require_ref2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/core/ref.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.callRef = exports2.getValidate = void 0;
    var ref_error_1 = require_ref_error2();
    var code_1 = require_code4();
    var codegen_1 = require_codegen2();
    var names_1 = require_names2();
    var compile_1 = require_compile2();
    var util_1 = require_util2();
    var def = {
      keyword: "$ref",
      schemaType: "string",
      code(cxt) {
        const { gen, schema: $ref, it } = cxt;
        const { baseId, schemaEnv: env, validateName, opts, self: self2 } = it;
        const { root: root2 } = env;
        if (($ref === "#" || $ref === "#/") && baseId === root2.baseId)
          return callRootRef();
        const schOrEnv = compile_1.resolveRef.call(self2, root2, baseId, $ref);
        if (schOrEnv === void 0)
          throw new ref_error_1.default(it.opts.uriResolver, baseId, $ref);
        if (schOrEnv instanceof compile_1.SchemaEnv)
          return callValidate(schOrEnv);
        return inlineRefSchema(schOrEnv);
        function callRootRef() {
          if (env === root2) return callRef(cxt, validateName, env, env.$async);
          const rootName = gen.scopeValue("root", { ref: root2 });
          return callRef(
            cxt,
            (0, codegen_1._)`${rootName}.validate`,
            root2,
            root2.$async
          );
        }
        function callValidate(sch) {
          const v = getValidate(cxt, sch);
          callRef(cxt, v, sch, sch.$async);
        }
        function inlineRefSchema(sch) {
          const schName = gen.scopeValue(
            "schema",
            opts.code.source === true
              ? { ref: sch, code: (0, codegen_1.stringify)(sch) }
              : { ref: sch }
          );
          const valid = gen.name("valid");
          const schCxt = cxt.subschema(
            {
              schema: sch,
              dataTypes: [],
              schemaPath: codegen_1.nil,
              topSchemaRef: schName,
              errSchemaPath: $ref,
            },
            valid
          );
          cxt.mergeEvaluated(schCxt);
          cxt.ok(valid);
        }
      },
    };
    function getValidate(cxt, sch) {
      const { gen } = cxt;
      return sch.validate
        ? gen.scopeValue("validate", { ref: sch.validate })
        : (0, codegen_1._)`${gen.scopeValue("wrapper", { ref: sch })}.validate`;
    }
    exports2.getValidate = getValidate;
    function callRef(cxt, v, sch, $async) {
      const { gen, it } = cxt;
      const { allErrors, schemaEnv: env, opts } = it;
      const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;
      if ($async) callAsyncRef();
      else callSyncRef();
      function callAsyncRef() {
        if (!env.$async)
          throw new Error("async schema referenced by sync schema");
        const valid = gen.let("valid");
        gen.try(
          () => {
            gen.code(
              (0, codegen_1._)`await ${(0, code_1.callValidateCode)(
                cxt,
                v,
                passCxt
              )}`
            );
            addEvaluatedFrom(v);
            if (!allErrors) gen.assign(valid, true);
          },
          (e) => {
            gen.if(
              (0, codegen_1._)`!(${e} instanceof ${it.ValidationError})`,
              () => gen.throw(e)
            );
            addErrorsFrom(e);
            if (!allErrors) gen.assign(valid, false);
          }
        );
        cxt.ok(valid);
      }
      function callSyncRef() {
        cxt.result(
          (0, code_1.callValidateCode)(cxt, v, passCxt),
          () => addEvaluatedFrom(v),
          () => addErrorsFrom(v)
        );
      }
      function addErrorsFrom(source) {
        const errs = (0, codegen_1._)`${source}.errors`;
        gen.assign(
          names_1.default.vErrors,
          (0,
          codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`
        );
        gen.assign(
          names_1.default.errors,
          (0, codegen_1._)`${names_1.default.vErrors}.length`
        );
      }
      function addEvaluatedFrom(source) {
        var _a;
        if (!it.opts.unevaluated) return;
        const schEvaluated =
          (_a = sch === null || sch === void 0 ? void 0 : sch.validate) ===
            null || _a === void 0
            ? void 0
            : _a.evaluated;
        if (it.props !== true) {
          if (schEvaluated && !schEvaluated.dynamicProps) {
            if (schEvaluated.props !== void 0) {
              it.props = util_1.mergeEvaluated.props(
                gen,
                schEvaluated.props,
                it.props
              );
            }
          } else {
            const props = gen.var(
              "props",
              (0, codegen_1._)`${source}.evaluated.props`
            );
            it.props = util_1.mergeEvaluated.props(
              gen,
              props,
              it.props,
              codegen_1.Name
            );
          }
        }
        if (it.items !== true) {
          if (schEvaluated && !schEvaluated.dynamicItems) {
            if (schEvaluated.items !== void 0) {
              it.items = util_1.mergeEvaluated.items(
                gen,
                schEvaluated.items,
                it.items
              );
            }
          } else {
            const items = gen.var(
              "items",
              (0, codegen_1._)`${source}.evaluated.items`
            );
            it.items = util_1.mergeEvaluated.items(
              gen,
              items,
              it.items,
              codegen_1.Name
            );
          }
        }
      }
    }
    exports2.callRef = callRef;
    exports2.default = def;
  },
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/core/index.js
var require_core4 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/core/index.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var id_1 = require_id2();
    var ref_1 = require_ref2();
    var core = [
      "$schema",
      "$id",
      "$defs",
      "$vocabulary",
      { keyword: "$comment" },
      "definitions",
      id_1.default,
      ref_1.default,
    ];
    exports2.default = core;
  },
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/limitNumber.js
var require_limitNumber2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/limitNumber.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen2();
    var ops = codegen_1.operators;
    var KWDs = {
      maximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
      minimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
      exclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
      exclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE },
    };
    var error = {
      message: ({ keyword, schemaCode }) =>
        (0, codegen_1.str)`must be ${KWDs[keyword].okStr} ${schemaCode}`,
      params: ({ keyword, schemaCode }) =>
        (0,
        codegen_1._)`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`,
    };
    var def = {
      keyword: Object.keys(KWDs),
      type: "number",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        cxt.fail$data(
          (0,
          codegen_1._)`${data} ${KWDs[keyword].fail} ${schemaCode} || isNaN(${data})`
        );
      },
    };
    exports2.default = def;
  },
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/multipleOf.js
var require_multipleOf2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/multipleOf.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen2();
    var error = {
      message: ({ schemaCode }) =>
        (0, codegen_1.str)`must be multiple of ${schemaCode}`,
      params: ({ schemaCode }) => (0, codegen_1._)`{multipleOf: ${schemaCode}}`,
    };
    var def = {
      keyword: "multipleOf",
      type: "number",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, schemaCode, it } = cxt;
        const prec = it.opts.multipleOfPrecision;
        const res = gen.let("res");
        const invalid = prec
          ? (0, codegen_1._)`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}`
          : (0, codegen_1._)`${res} !== parseInt(${res})`;
        cxt.fail$data(
          (0,
          codegen_1._)`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`
        );
      },
    };
    exports2.default = def;
  },
});

// node_modules/ajv-formats/node_modules/ajv/dist/runtime/ucs2length.js
var require_ucs2length2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/runtime/ucs2length.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    function ucs2length(str) {
      const len = str.length;
      let length = 0;
      let pos = 0;
      let value;
      while (pos < len) {
        length++;
        value = str.charCodeAt(pos++);
        if (value >= 55296 && value <= 56319 && pos < len) {
          value = str.charCodeAt(pos);
          if ((value & 64512) === 56320) pos++;
        }
      }
      return length;
    }
    exports2.default = ucs2length;
    ucs2length.code = 'require("ajv/dist/runtime/ucs2length").default';
  },
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/limitLength.js
var require_limitLength2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/limitLength.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen2();
    var util_1 = require_util2();
    var ucs2length_1 = require_ucs2length2();
    var error = {
      message({ keyword, schemaCode }) {
        const comp = keyword === "maxLength" ? "more" : "fewer";
        return (0,
        codegen_1.str)`must NOT have ${comp} than ${schemaCode} characters`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`,
    };
    var def = {
      keyword: ["maxLength", "minLength"],
      type: "string",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode, it } = cxt;
        const op =
          keyword === "maxLength"
            ? codegen_1.operators.GT
            : codegen_1.operators.LT;
        const len =
          it.opts.unicode === false
            ? (0, codegen_1._)`${data}.length`
            : (0, codegen_1._)`${(0, util_1.useFunc)(
                cxt.gen,
                ucs2length_1.default
              )}(${data})`;
        cxt.fail$data((0, codegen_1._)`${len} ${op} ${schemaCode}`);
      },
    };
    exports2.default = def;
  },
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/pattern.js
var require_pattern2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/pattern.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var code_1 = require_code4();
    var codegen_1 = require_codegen2();
    var error = {
      message: ({ schemaCode }) =>
        (0, codegen_1.str)`must match pattern "${schemaCode}"`,
      params: ({ schemaCode }) => (0, codegen_1._)`{pattern: ${schemaCode}}`,
    };
    var def = {
      keyword: "pattern",
      type: "string",
      schemaType: "string",
      $data: true,
      error,
      code(cxt) {
        const { data, $data, schema, schemaCode, it } = cxt;
        const u = it.opts.unicodeRegExp ? "u" : "";
        const regExp = $data
          ? (0, codegen_1._)`(new RegExp(${schemaCode}, ${u}))`
          : (0, code_1.usePattern)(cxt, schema);
        cxt.fail$data((0, codegen_1._)`!${regExp}.test(${data})`);
      },
    };
    exports2.default = def;
  },
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/limitProperties.js
var require_limitProperties2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/limitProperties.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen2();
    var error = {
      message({ keyword, schemaCode }) {
        const comp = keyword === "maxProperties" ? "more" : "fewer";
        return (0,
        codegen_1.str)`must NOT have ${comp} than ${schemaCode} properties`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`,
    };
    var def = {
      keyword: ["maxProperties", "minProperties"],
      type: "object",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        const op =
          keyword === "maxProperties"
            ? codegen_1.operators.GT
            : codegen_1.operators.LT;
        cxt.fail$data(
          (0, codegen_1._)`Object.keys(${data}).length ${op} ${schemaCode}`
        );
      },
    };
    exports2.default = def;
  },
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/required.js
var require_required2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/required.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var code_1 = require_code4();
    var codegen_1 = require_codegen2();
    var util_1 = require_util2();
    var error = {
      message: ({ params: { missingProperty } }) =>
        (0, codegen_1.str)`must have required property '${missingProperty}'`,
      params: ({ params: { missingProperty } }) =>
        (0, codegen_1._)`{missingProperty: ${missingProperty}}`,
    };
    var def = {
      keyword: "required",
      type: "object",
      schemaType: "array",
      $data: true,
      error,
      code(cxt) {
        const { gen, schema, schemaCode, data, $data, it } = cxt;
        const { opts } = it;
        if (!$data && schema.length === 0) return;
        const useLoop = schema.length >= opts.loopRequired;
        if (it.allErrors) allErrorsMode();
        else exitOnErrorMode();
        if (opts.strictRequired) {
          const props = cxt.parentSchema.properties;
          const { definedProperties } = cxt.it;
          for (const requiredKey of schema) {
            if (
              (props === null || props === void 0
                ? void 0
                : props[requiredKey]) === void 0 &&
              !definedProperties.has(requiredKey)
            ) {
              const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
              const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
              (0, util_1.checkStrictMode)(it, msg, it.opts.strictRequired);
            }
          }
        }
        function allErrorsMode() {
          if (useLoop || $data) {
            cxt.block$data(codegen_1.nil, loopAllRequired);
          } else {
            for (const prop of schema) {
              (0, code_1.checkReportMissingProp)(cxt, prop);
            }
          }
        }
        function exitOnErrorMode() {
          const missing = gen.let("missing");
          if (useLoop || $data) {
            const valid = gen.let("valid", true);
            cxt.block$data(valid, () => loopUntilMissing(missing, valid));
            cxt.ok(valid);
          } else {
            gen.if((0, code_1.checkMissingProp)(cxt, schema, missing));
            (0, code_1.reportMissingProp)(cxt, missing);
            gen.else();
          }
        }
        function loopAllRequired() {
          gen.forOf("prop", schemaCode, (prop) => {
            cxt.setParams({ missingProperty: prop });
            gen.if(
              (0, code_1.noPropertyInData)(gen, data, prop, opts.ownProperties),
              () => cxt.error()
            );
          });
        }
        function loopUntilMissing(missing, valid) {
          cxt.setParams({ missingProperty: missing });
          gen.forOf(
            missing,
            schemaCode,
            () => {
              gen.assign(
                valid,
                (0, code_1.propertyInData)(
                  gen,
                  data,
                  missing,
                  opts.ownProperties
                )
              );
              gen.if((0, codegen_1.not)(valid), () => {
                cxt.error();
                gen.break();
              });
            },
            codegen_1.nil
          );
        }
      },
    };
    exports2.default = def;
  },
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/limitItems.js
var require_limitItems2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/limitItems.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen2();
    var error = {
      message({ keyword, schemaCode }) {
        const comp = keyword === "maxItems" ? "more" : "fewer";
        return (0,
        codegen_1.str)`must NOT have ${comp} than ${schemaCode} items`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`,
    };
    var def = {
      keyword: ["maxItems", "minItems"],
      type: "array",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        const op =
          keyword === "maxItems"
            ? codegen_1.operators.GT
            : codegen_1.operators.LT;
        cxt.fail$data((0, codegen_1._)`${data}.length ${op} ${schemaCode}`);
      },
    };
    exports2.default = def;
  },
});

// node_modules/ajv-formats/node_modules/ajv/dist/runtime/equal.js
var require_equal2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/runtime/equal.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var equal = require_fast_deep_equal();
    equal.code = 'require("ajv/dist/runtime/equal").default';
    exports2.default = equal;
  },
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/uniqueItems.js
var require_uniqueItems2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/uniqueItems.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var dataType_1 = require_dataType2();
    var codegen_1 = require_codegen2();
    var util_1 = require_util2();
    var equal_1 = require_equal2();
    var error = {
      message: ({ params: { i, j } }) =>
        (0,
        codegen_1.str)`must NOT have duplicate items (items ## ${j} and ${i} are identical)`,
      params: ({ params: { i, j } }) => (0, codegen_1._)`{i: ${i}, j: ${j}}`,
    };
    var def = {
      keyword: "uniqueItems",
      type: "array",
      schemaType: "boolean",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schema, parentSchema, schemaCode, it } = cxt;
        if (!$data && !schema) return;
        const valid = gen.let("valid");
        const itemTypes = parentSchema.items
          ? (0, dataType_1.getSchemaTypes)(parentSchema.items)
          : [];
        cxt.block$data(
          valid,
          validateUniqueItems,
          (0, codegen_1._)`${schemaCode} === false`
        );
        cxt.ok(valid);
        function validateUniqueItems() {
          const i = gen.let("i", (0, codegen_1._)`${data}.length`);
          const j = gen.let("j");
          cxt.setParams({ i, j });
          gen.assign(valid, true);
          gen.if((0, codegen_1._)`${i} > 1`, () =>
            (canOptimize() ? loopN : loopN2)(i, j)
          );
        }
        function canOptimize() {
          return (
            itemTypes.length > 0 &&
            !itemTypes.some((t) => t === "object" || t === "array")
          );
        }
        function loopN(i, j) {
          const item = gen.name("item");
          const wrongType = (0, dataType_1.checkDataTypes)(
            itemTypes,
            item,
            it.opts.strictNumbers,
            dataType_1.DataType.Wrong
          );
          const indices = gen.const("indices", (0, codegen_1._)`{}`);
          gen.for((0, codegen_1._)`;${i}--;`, () => {
            gen.let(item, (0, codegen_1._)`${data}[${i}]`);
            gen.if(wrongType, (0, codegen_1._)`continue`);
            if (itemTypes.length > 1)
              gen.if(
                (0, codegen_1._)`typeof ${item} == "string"`,
                (0, codegen_1._)`${item} += "_"`
              );
            gen
              .if(
                (0, codegen_1._)`typeof ${indices}[${item}] == "number"`,
                () => {
                  gen.assign(j, (0, codegen_1._)`${indices}[${item}]`);
                  cxt.error();
                  gen.assign(valid, false).break();
                }
              )
              .code((0, codegen_1._)`${indices}[${item}] = ${i}`);
          });
        }
        function loopN2(i, j) {
          const eql = (0, util_1.useFunc)(gen, equal_1.default);
          const outer = gen.name("outer");
          gen.label(outer).for((0, codegen_1._)`;${i}--;`, () =>
            gen.for((0, codegen_1._)`${j} = ${i}; ${j}--;`, () =>
              gen.if(
                (0, codegen_1._)`${eql}(${data}[${i}], ${data}[${j}])`,
                () => {
                  cxt.error();
                  gen.assign(valid, false).break(outer);
                }
              )
            )
          );
        }
      },
    };
    exports2.default = def;
  },
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/const.js
var require_const2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/const.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen2();
    var util_1 = require_util2();
    var equal_1 = require_equal2();
    var error = {
      message: "must be equal to constant",
      params: ({ schemaCode }) =>
        (0, codegen_1._)`{allowedValue: ${schemaCode}}`,
    };
    var def = {
      keyword: "const",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schemaCode, schema } = cxt;
        if ($data || (schema && typeof schema == "object")) {
          cxt.fail$data(
            (0, codegen_1._)`!${(0, util_1.useFunc)(
              gen,
              equal_1.default
            )}(${data}, ${schemaCode})`
          );
        } else {
          cxt.fail((0, codegen_1._)`${schema} !== ${data}`);
        }
      },
    };
    exports2.default = def;
  },
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/enum.js
var require_enum2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/enum.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen2();
    var util_1 = require_util2();
    var equal_1 = require_equal2();
    var error = {
      message: "must be equal to one of the allowed values",
      params: ({ schemaCode }) =>
        (0, codegen_1._)`{allowedValues: ${schemaCode}}`,
    };
    var def = {
      keyword: "enum",
      schemaType: "array",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schema, schemaCode, it } = cxt;
        if (!$data && schema.length === 0)
          throw new Error("enum must have non-empty array");
        const useLoop = schema.length >= it.opts.loopEnum;
        let eql;
        const getEql = () =>
          eql !== null && eql !== void 0
            ? eql
            : (eql = (0, util_1.useFunc)(gen, equal_1.default));
        let valid;
        if (useLoop || $data) {
          valid = gen.let("valid");
          cxt.block$data(valid, loopEnum);
        } else {
          if (!Array.isArray(schema))
            throw new Error("ajv implementation error");
          const vSchema = gen.const("vSchema", schemaCode);
          valid = (0, codegen_1.or)(
            ...schema.map((_x, i) => equalCode(vSchema, i))
          );
        }
        cxt.pass(valid);
        function loopEnum() {
          gen.assign(valid, false);
          gen.forOf("v", schemaCode, (v) =>
            gen.if((0, codegen_1._)`${getEql()}(${data}, ${v})`, () =>
              gen.assign(valid, true).break()
            )
          );
        }
        function equalCode(vSchema, i) {
          const sch = schema[i];
          return typeof sch === "object" && sch !== null
            ? (0, codegen_1._)`${getEql()}(${data}, ${vSchema}[${i}])`
            : (0, codegen_1._)`${data} === ${sch}`;
        }
      },
    };
    exports2.default = def;
  },
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/index.js
var require_validation2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/index.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var limitNumber_1 = require_limitNumber2();
    var multipleOf_1 = require_multipleOf2();
    var limitLength_1 = require_limitLength2();
    var pattern_1 = require_pattern2();
    var limitProperties_1 = require_limitProperties2();
    var required_1 = require_required2();
    var limitItems_1 = require_limitItems2();
    var uniqueItems_1 = require_uniqueItems2();
    var const_1 = require_const2();
    var enum_1 = require_enum2();
    var validation = [
      // number
      limitNumber_1.default,
      multipleOf_1.default,
      // string
      limitLength_1.default,
      pattern_1.default,
      // object
      limitProperties_1.default,
      required_1.default,
      // array
      limitItems_1.default,
      uniqueItems_1.default,
      // any
      { keyword: "type", schemaType: ["string", "array"] },
      { keyword: "nullable", schemaType: "boolean" },
      const_1.default,
      enum_1.default,
    ];
    exports2.default = validation;
  },
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/additionalItems.js
var require_additionalItems2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/additionalItems.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateAdditionalItems = void 0;
    var codegen_1 = require_codegen2();
    var util_1 = require_util2();
    var error = {
      message: ({ params: { len } }) =>
        (0, codegen_1.str)`must NOT have more than ${len} items`,
      params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`,
    };
    var def = {
      keyword: "additionalItems",
      type: "array",
      schemaType: ["boolean", "object"],
      before: "uniqueItems",
      error,
      code(cxt) {
        const { parentSchema, it } = cxt;
        const { items } = parentSchema;
        if (!Array.isArray(items)) {
          (0, util_1.checkStrictMode)(
            it,
            '"additionalItems" is ignored when "items" is not an array of schemas'
          );
          return;
        }
        validateAdditionalItems(cxt, items);
      },
    };
    function validateAdditionalItems(cxt, items) {
      const { gen, schema, data, keyword, it } = cxt;
      it.items = true;
      const len = gen.const("len", (0, codegen_1._)`${data}.length`);
      if (schema === false) {
        cxt.setParams({ len: items.length });
        cxt.pass((0, codegen_1._)`${len} <= ${items.length}`);
      } else if (
        typeof schema == "object" &&
        !(0, util_1.alwaysValidSchema)(it, schema)
      ) {
        const valid = gen.var(
          "valid",
          (0, codegen_1._)`${len} <= ${items.length}`
        );
        gen.if((0, codegen_1.not)(valid), () => validateItems(valid));
        cxt.ok(valid);
      }
      function validateItems(valid) {
        gen.forRange("i", items.length, len, (i) => {
          cxt.subschema(
            { keyword, dataProp: i, dataPropType: util_1.Type.Num },
            valid
          );
          if (!it.allErrors)
            gen.if((0, codegen_1.not)(valid), () => gen.break());
        });
      }
    }
    exports2.validateAdditionalItems = validateAdditionalItems;
    exports2.default = def;
  },
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/items.js
var require_items2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/items.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateTuple = void 0;
    var codegen_1 = require_codegen2();
    var util_1 = require_util2();
    var code_1 = require_code4();
    var def = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "array", "boolean"],
      before: "uniqueItems",
      code(cxt) {
        const { schema, it } = cxt;
        if (Array.isArray(schema))
          return validateTuple(cxt, "additionalItems", schema);
        it.items = true;
        if ((0, util_1.alwaysValidSchema)(it, schema)) return;
        cxt.ok((0, code_1.validateArray)(cxt));
      },
    };
    function validateTuple(cxt, extraItems, schArr = cxt.schema) {
      const { gen, parentSchema, data, keyword, it } = cxt;
      checkStrictTuple(parentSchema);
      if (it.opts.unevaluated && schArr.length && it.items !== true) {
        it.items = util_1.mergeEvaluated.items(gen, schArr.length, it.items);
      }
      const valid = gen.name("valid");
      const len = gen.const("len", (0, codegen_1._)`${data}.length`);
      schArr.forEach((sch, i) => {
        if ((0, util_1.alwaysValidSchema)(it, sch)) return;
        gen.if((0, codegen_1._)`${len} > ${i}`, () =>
          cxt.subschema(
            {
              keyword,
              schemaProp: i,
              dataProp: i,
            },
            valid
          )
        );
        cxt.ok(valid);
      });
      function checkStrictTuple(sch) {
        const { opts, errSchemaPath } = it;
        const l = schArr.length;
        const fullTuple =
          l === sch.minItems &&
          (l === sch.maxItems || sch[extraItems] === false);
        if (opts.strictTuples && !fullTuple) {
          const msg = `"${keyword}" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
          (0, util_1.checkStrictMode)(it, msg, opts.strictTuples);
        }
      }
    }
    exports2.validateTuple = validateTuple;
    exports2.default = def;
  },
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/prefixItems.js
var require_prefixItems2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/prefixItems.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var items_1 = require_items2();
    var def = {
      keyword: "prefixItems",
      type: "array",
      schemaType: ["array"],
      before: "uniqueItems",
      code: (cxt) => (0, items_1.validateTuple)(cxt, "items"),
    };
    exports2.default = def;
  },
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/items2020.js
var require_items20202 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/items2020.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen2();
    var util_1 = require_util2();
    var code_1 = require_code4();
    var additionalItems_1 = require_additionalItems2();
    var error = {
      message: ({ params: { len } }) =>
        (0, codegen_1.str)`must NOT have more than ${len} items`,
      params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`,
    };
    var def = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      error,
      code(cxt) {
        const { schema, parentSchema, it } = cxt;
        const { prefixItems } = parentSchema;
        it.items = true;
        if ((0, util_1.alwaysValidSchema)(it, schema)) return;
        if (prefixItems)
          (0, additionalItems_1.validateAdditionalItems)(cxt, prefixItems);
        else cxt.ok((0, code_1.validateArray)(cxt));
      },
    };
    exports2.default = def;
  },
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/contains.js
var require_contains2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/contains.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen2();
    var util_1 = require_util2();
    var error = {
      message: ({ params: { min, max } }) =>
        max === void 0
          ? (0, codegen_1.str)`must contain at least ${min} valid item(s)`
          : (0,
            codegen_1.str)`must contain at least ${min} and no more than ${max} valid item(s)`,
      params: ({ params: { min, max } }) =>
        max === void 0
          ? (0, codegen_1._)`{minContains: ${min}}`
          : (0, codegen_1._)`{minContains: ${min}, maxContains: ${max}}`,
    };
    var def = {
      keyword: "contains",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema, parentSchema, data, it } = cxt;
        let min;
        let max;
        const { minContains, maxContains } = parentSchema;
        if (it.opts.next) {
          min = minContains === void 0 ? 1 : minContains;
          max = maxContains;
        } else {
          min = 1;
        }
        const len = gen.const("len", (0, codegen_1._)`${data}.length`);
        cxt.setParams({ min, max });
        if (max === void 0 && min === 0) {
          (0, util_1.checkStrictMode)(
            it,
            `"minContains" == 0 without "maxContains": "contains" keyword ignored`
          );
          return;
        }
        if (max !== void 0 && min > max) {
          (0, util_1.checkStrictMode)(
            it,
            `"minContains" > "maxContains" is always invalid`
          );
          cxt.fail();
          return;
        }
        if ((0, util_1.alwaysValidSchema)(it, schema)) {
          let cond = (0, codegen_1._)`${len} >= ${min}`;
          if (max !== void 0)
            cond = (0, codegen_1._)`${cond} && ${len} <= ${max}`;
          cxt.pass(cond);
          return;
        }
        it.items = true;
        const valid = gen.name("valid");
        if (max === void 0 && min === 1) {
          validateItems(valid, () => gen.if(valid, () => gen.break()));
        } else if (min === 0) {
          gen.let(valid, true);
          if (max !== void 0)
            gen.if(
              (0, codegen_1._)`${data}.length > 0`,
              validateItemsWithCount
            );
        } else {
          gen.let(valid, false);
          validateItemsWithCount();
        }
        cxt.result(valid, () => cxt.reset());
        function validateItemsWithCount() {
          const schValid = gen.name("_valid");
          const count = gen.let("count", 0);
          validateItems(schValid, () =>
            gen.if(schValid, () => checkLimits(count))
          );
        }
        function validateItems(_valid, block) {
          gen.forRange("i", 0, len, (i) => {
            cxt.subschema(
              {
                keyword: "contains",
                dataProp: i,
                dataPropType: util_1.Type.Num,
                compositeRule: true,
              },
              _valid
            );
            block();
          });
        }
        function checkLimits(count) {
          gen.code((0, codegen_1._)`${count}++`);
          if (max === void 0) {
            gen.if((0, codegen_1._)`${count} >= ${min}`, () =>
              gen.assign(valid, true).break()
            );
          } else {
            gen.if((0, codegen_1._)`${count} > ${max}`, () =>
              gen.assign(valid, false).break()
            );
            if (min === 1) gen.assign(valid, true);
            else
              gen.if((0, codegen_1._)`${count} >= ${min}`, () =>
                gen.assign(valid, true)
              );
          }
        }
      },
    };
    exports2.default = def;
  },
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/dependencies.js
var require_dependencies2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/dependencies.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateSchemaDeps =
      exports2.validatePropertyDeps =
      exports2.error =
        void 0;
    var codegen_1 = require_codegen2();
    var util_1 = require_util2();
    var code_1 = require_code4();
    exports2.error = {
      message: ({ params: { property, depsCount, deps } }) => {
        const property_ies = depsCount === 1 ? "property" : "properties";
        return (0,
        codegen_1.str)`must have ${property_ies} ${deps} when property ${property} is present`;
      },
      params: ({
        params: { property, depsCount, deps, missingProperty },
      }) => (0, codegen_1._)`{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`,
      // TODO change to reference
    };
    var def = {
      keyword: "dependencies",
      type: "object",
      schemaType: "object",
      error: exports2.error,
      code(cxt) {
        const [propDeps, schDeps] = splitDependencies(cxt);
        validatePropertyDeps(cxt, propDeps);
        validateSchemaDeps(cxt, schDeps);
      },
    };
    function splitDependencies({ schema }) {
      const propertyDeps = {};
      const schemaDeps = {};
      for (const key in schema) {
        if (key === "__proto__") continue;
        const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;
        deps[key] = schema[key];
      }
      return [propertyDeps, schemaDeps];
    }
    function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
      const { gen, data, it } = cxt;
      if (Object.keys(propertyDeps).length === 0) return;
      const missing = gen.let("missing");
      for (const prop in propertyDeps) {
        const deps = propertyDeps[prop];
        if (deps.length === 0) continue;
        const hasProperty = (0, code_1.propertyInData)(
          gen,
          data,
          prop,
          it.opts.ownProperties
        );
        cxt.setParams({
          property: prop,
          depsCount: deps.length,
          deps: deps.join(", "),
        });
        if (it.allErrors) {
          gen.if(hasProperty, () => {
            for (const depProp of deps) {
              (0, code_1.checkReportMissingProp)(cxt, depProp);
            }
          });
        } else {
          gen.if(
            (0, codegen_1._)`${hasProperty} && (${(0, code_1.checkMissingProp)(
              cxt,
              deps,
              missing
            )})`
          );
          (0, code_1.reportMissingProp)(cxt, missing);
          gen.else();
        }
      }
    }
    exports2.validatePropertyDeps = validatePropertyDeps;
    function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
      const { gen, data, keyword, it } = cxt;
      const valid = gen.name("valid");
      for (const prop in schemaDeps) {
        if ((0, util_1.alwaysValidSchema)(it, schemaDeps[prop])) continue;
        gen.if(
          (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties),
          () => {
            const schCxt = cxt.subschema({ keyword, schemaProp: prop }, valid);
            cxt.mergeValidEvaluated(schCxt, valid);
          },
          () => gen.var(valid, true)
          // TODO var
        );
        cxt.ok(valid);
      }
    }
    exports2.validateSchemaDeps = validateSchemaDeps;
    exports2.default = def;
  },
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/propertyNames.js
var require_propertyNames2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/propertyNames.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen2();
    var util_1 = require_util2();
    var error = {
      message: "property name must be valid",
      params: ({ params }) =>
        (0, codegen_1._)`{propertyName: ${params.propertyName}}`,
    };
    var def = {
      keyword: "propertyNames",
      type: "object",
      schemaType: ["object", "boolean"],
      error,
      code(cxt) {
        const { gen, schema, data, it } = cxt;
        if ((0, util_1.alwaysValidSchema)(it, schema)) return;
        const valid = gen.name("valid");
        gen.forIn("key", data, (key) => {
          cxt.setParams({ propertyName: key });
          cxt.subschema(
            {
              keyword: "propertyNames",
              data: key,
              dataTypes: ["string"],
              propertyName: key,
              compositeRule: true,
            },
            valid
          );
          gen.if((0, codegen_1.not)(valid), () => {
            cxt.error(true);
            if (!it.allErrors) gen.break();
          });
        });
        cxt.ok(valid);
      },
    };
    exports2.default = def;
  },
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js
var require_additionalProperties2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var code_1 = require_code4();
    var codegen_1 = require_codegen2();
    var names_1 = require_names2();
    var util_1 = require_util2();
    var error = {
      message: "must NOT have additional properties",
      params: ({ params }) =>
        (0, codegen_1._)`{additionalProperty: ${params.additionalProperty}}`,
    };
    var def = {
      keyword: "additionalProperties",
      type: ["object"],
      schemaType: ["boolean", "object"],
      allowUndefined: true,
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema, parentSchema, data, errsCount, it } = cxt;
        if (!errsCount) throw new Error("ajv implementation error");
        const { allErrors, opts } = it;
        it.props = true;
        if (
          opts.removeAdditional !== "all" &&
          (0, util_1.alwaysValidSchema)(it, schema)
        )
          return;
        const props = (0, code_1.allSchemaProperties)(parentSchema.properties);
        const patProps = (0, code_1.allSchemaProperties)(
          parentSchema.patternProperties
        );
        checkAdditionalProperties();
        cxt.ok((0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
        function checkAdditionalProperties() {
          gen.forIn("key", data, (key) => {
            if (!props.length && !patProps.length) additionalPropertyCode(key);
            else gen.if(isAdditional(key), () => additionalPropertyCode(key));
          });
        }
        function isAdditional(key) {
          let definedProp;
          if (props.length > 8) {
            const propsSchema = (0, util_1.schemaRefOrVal)(
              it,
              parentSchema.properties,
              "properties"
            );
            definedProp = (0, code_1.isOwnProperty)(gen, propsSchema, key);
          } else if (props.length) {
            definedProp = (0, codegen_1.or)(
              ...props.map((p) => (0, codegen_1._)`${key} === ${p}`)
            );
          } else {
            definedProp = codegen_1.nil;
          }
          if (patProps.length) {
            definedProp = (0, codegen_1.or)(
              definedProp,
              ...patProps.map(
                (p) =>
                  (0, codegen_1._)`${(0, code_1.usePattern)(
                    cxt,
                    p
                  )}.test(${key})`
              )
            );
          }
          return (0, codegen_1.not)(definedProp);
        }
        function deleteAdditional(key) {
          gen.code((0, codegen_1._)`delete ${data}[${key}]`);
        }
        function additionalPropertyCode(key) {
          if (
            opts.removeAdditional === "all" ||
            (opts.removeAdditional && schema === false)
          ) {
            deleteAdditional(key);
            return;
          }
          if (schema === false) {
            cxt.setParams({ additionalProperty: key });
            cxt.error();
            if (!allErrors) gen.break();
            return;
          }
          if (
            typeof schema == "object" &&
            !(0, util_1.alwaysValidSchema)(it, schema)
          ) {
            const valid = gen.name("valid");
            if (opts.removeAdditional === "failing") {
              applyAdditionalSchema(key, valid, false);
              gen.if((0, codegen_1.not)(valid), () => {
                cxt.reset();
                deleteAdditional(key);
              });
            } else {
              applyAdditionalSchema(key, valid);
              if (!allErrors)
                gen.if((0, codegen_1.not)(valid), () => gen.break());
            }
          }
        }
        function applyAdditionalSchema(key, valid, errors) {
          const subschema = {
            keyword: "additionalProperties",
            dataProp: key,
            dataPropType: util_1.Type.Str,
          };
          if (errors === false) {
            Object.assign(subschema, {
              compositeRule: true,
              createErrors: false,
              allErrors: false,
            });
          }
          cxt.subschema(subschema, valid);
        }
      },
    };
    exports2.default = def;
  },
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/properties.js
var require_properties2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/properties.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var validate_1 = require_validate2();
    var code_1 = require_code4();
    var util_1 = require_util2();
    var additionalProperties_1 = require_additionalProperties2();
    var def = {
      keyword: "properties",
      type: "object",
      schemaType: "object",
      code(cxt) {
        const { gen, schema, parentSchema, data, it } = cxt;
        if (
          it.opts.removeAdditional === "all" &&
          parentSchema.additionalProperties === void 0
        ) {
          additionalProperties_1.default.code(
            new validate_1.KeywordCxt(
              it,
              additionalProperties_1.default,
              "additionalProperties"
            )
          );
        }
        const allProps = (0, code_1.allSchemaProperties)(schema);
        for (const prop of allProps) {
          it.definedProperties.add(prop);
        }
        if (it.opts.unevaluated && allProps.length && it.props !== true) {
          it.props = util_1.mergeEvaluated.props(
            gen,
            (0, util_1.toHash)(allProps),
            it.props
          );
        }
        const properties = allProps.filter(
          (p) => !(0, util_1.alwaysValidSchema)(it, schema[p])
        );
        if (properties.length === 0) return;
        const valid = gen.name("valid");
        for (const prop of properties) {
          if (hasDefault(prop)) {
            applyPropertySchema(prop);
          } else {
            gen.if(
              (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties)
            );
            applyPropertySchema(prop);
            if (!it.allErrors) gen.else().var(valid, true);
            gen.endIf();
          }
          cxt.it.definedProperties.add(prop);
          cxt.ok(valid);
        }
        function hasDefault(prop) {
          return (
            it.opts.useDefaults &&
            !it.compositeRule &&
            schema[prop].default !== void 0
          );
        }
        function applyPropertySchema(prop) {
          cxt.subschema(
            {
              keyword: "properties",
              schemaProp: prop,
              dataProp: prop,
            },
            valid
          );
        }
      },
    };
    exports2.default = def;
  },
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/patternProperties.js
var require_patternProperties2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/patternProperties.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var code_1 = require_code4();
    var codegen_1 = require_codegen2();
    var util_1 = require_util2();
    var util_2 = require_util2();
    var def = {
      keyword: "patternProperties",
      type: "object",
      schemaType: "object",
      code(cxt) {
        const { gen, schema, data, parentSchema, it } = cxt;
        const { opts } = it;
        const patterns = (0, code_1.allSchemaProperties)(schema);
        const alwaysValidPatterns = patterns.filter((p) =>
          (0, util_1.alwaysValidSchema)(it, schema[p])
        );
        if (
          patterns.length === 0 ||
          (alwaysValidPatterns.length === patterns.length &&
            (!it.opts.unevaluated || it.props === true))
        ) {
          return;
        }
        const checkProperties =
          opts.strictSchema &&
          !opts.allowMatchingProperties &&
          parentSchema.properties;
        const valid = gen.name("valid");
        if (it.props !== true && !(it.props instanceof codegen_1.Name)) {
          it.props = (0, util_2.evaluatedPropsToName)(gen, it.props);
        }
        const { props } = it;
        validatePatternProperties();
        function validatePatternProperties() {
          for (const pat of patterns) {
            if (checkProperties) checkMatchingProperties(pat);
            if (it.allErrors) {
              validateProperties(pat);
            } else {
              gen.var(valid, true);
              validateProperties(pat);
              gen.if(valid);
            }
          }
        }
        function checkMatchingProperties(pat) {
          for (const prop in checkProperties) {
            if (new RegExp(pat).test(prop)) {
              (0, util_1.checkStrictMode)(
                it,
                `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`
              );
            }
          }
        }
        function validateProperties(pat) {
          gen.forIn("key", data, (key) => {
            gen.if(
              (0, codegen_1._)`${(0, code_1.usePattern)(
                cxt,
                pat
              )}.test(${key})`,
              () => {
                const alwaysValid = alwaysValidPatterns.includes(pat);
                if (!alwaysValid) {
                  cxt.subschema(
                    {
                      keyword: "patternProperties",
                      schemaProp: pat,
                      dataProp: key,
                      dataPropType: util_2.Type.Str,
                    },
                    valid
                  );
                }
                if (it.opts.unevaluated && props !== true) {
                  gen.assign((0, codegen_1._)`${props}[${key}]`, true);
                } else if (!alwaysValid && !it.allErrors) {
                  gen.if((0, codegen_1.not)(valid), () => gen.break());
                }
              }
            );
          });
        }
      },
    };
    exports2.default = def;
  },
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/not.js
var require_not2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/not.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var util_1 = require_util2();
    var def = {
      keyword: "not",
      schemaType: ["object", "boolean"],
      trackErrors: true,
      code(cxt) {
        const { gen, schema, it } = cxt;
        if ((0, util_1.alwaysValidSchema)(it, schema)) {
          cxt.fail();
          return;
        }
        const valid = gen.name("valid");
        cxt.subschema(
          {
            keyword: "not",
            compositeRule: true,
            createErrors: false,
            allErrors: false,
          },
          valid
        );
        cxt.failResult(
          valid,
          () => cxt.reset(),
          () => cxt.error()
        );
      },
      error: { message: "must NOT be valid" },
    };
    exports2.default = def;
  },
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/anyOf.js
var require_anyOf2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/anyOf.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var code_1 = require_code4();
    var def = {
      keyword: "anyOf",
      schemaType: "array",
      trackErrors: true,
      code: code_1.validateUnion,
      error: { message: "must match a schema in anyOf" },
    };
    exports2.default = def;
  },
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/oneOf.js
var require_oneOf2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/oneOf.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen2();
    var util_1 = require_util2();
    var error = {
      message: "must match exactly one schema in oneOf",
      params: ({ params }) =>
        (0, codegen_1._)`{passingSchemas: ${params.passing}}`,
    };
    var def = {
      keyword: "oneOf",
      schemaType: "array",
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema, parentSchema, it } = cxt;
        if (!Array.isArray(schema)) throw new Error("ajv implementation error");
        if (it.opts.discriminator && parentSchema.discriminator) return;
        const schArr = schema;
        const valid = gen.let("valid", false);
        const passing = gen.let("passing", null);
        const schValid = gen.name("_valid");
        cxt.setParams({ passing });
        gen.block(validateOneOf);
        cxt.result(
          valid,
          () => cxt.reset(),
          () => cxt.error(true)
        );
        function validateOneOf() {
          schArr.forEach((sch, i) => {
            let schCxt;
            if ((0, util_1.alwaysValidSchema)(it, sch)) {
              gen.var(schValid, true);
            } else {
              schCxt = cxt.subschema(
                {
                  keyword: "oneOf",
                  schemaProp: i,
                  compositeRule: true,
                },
                schValid
              );
            }
            if (i > 0) {
              gen
                .if((0, codegen_1._)`${schValid} && ${valid}`)
                .assign(valid, false)
                .assign(passing, (0, codegen_1._)`[${passing}, ${i}]`)
                .else();
            }
            gen.if(schValid, () => {
              gen.assign(valid, true);
              gen.assign(passing, i);
              if (schCxt) cxt.mergeEvaluated(schCxt, codegen_1.Name);
            });
          });
        }
      },
    };
    exports2.default = def;
  },
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/allOf.js
var require_allOf2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/allOf.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var util_1 = require_util2();
    var def = {
      keyword: "allOf",
      schemaType: "array",
      code(cxt) {
        const { gen, schema, it } = cxt;
        if (!Array.isArray(schema)) throw new Error("ajv implementation error");
        const valid = gen.name("valid");
        schema.forEach((sch, i) => {
          if ((0, util_1.alwaysValidSchema)(it, sch)) return;
          const schCxt = cxt.subschema(
            { keyword: "allOf", schemaProp: i },
            valid
          );
          cxt.ok(valid);
          cxt.mergeEvaluated(schCxt);
        });
      },
    };
    exports2.default = def;
  },
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/if.js
var require_if2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/if.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen2();
    var util_1 = require_util2();
    var error = {
      message: ({ params }) =>
        (0, codegen_1.str)`must match "${params.ifClause}" schema`,
      params: ({ params }) =>
        (0, codegen_1._)`{failingKeyword: ${params.ifClause}}`,
    };
    var def = {
      keyword: "if",
      schemaType: ["object", "boolean"],
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, parentSchema, it } = cxt;
        if (parentSchema.then === void 0 && parentSchema.else === void 0) {
          (0, util_1.checkStrictMode)(
            it,
            '"if" without "then" and "else" is ignored'
          );
        }
        const hasThen = hasSchema(it, "then");
        const hasElse = hasSchema(it, "else");
        if (!hasThen && !hasElse) return;
        const valid = gen.let("valid", true);
        const schValid = gen.name("_valid");
        validateIf();
        cxt.reset();
        if (hasThen && hasElse) {
          const ifClause = gen.let("ifClause");
          cxt.setParams({ ifClause });
          gen.if(
            schValid,
            validateClause("then", ifClause),
            validateClause("else", ifClause)
          );
        } else if (hasThen) {
          gen.if(schValid, validateClause("then"));
        } else {
          gen.if((0, codegen_1.not)(schValid), validateClause("else"));
        }
        cxt.pass(valid, () => cxt.error(true));
        function validateIf() {
          const schCxt = cxt.subschema(
            {
              keyword: "if",
              compositeRule: true,
              createErrors: false,
              allErrors: false,
            },
            schValid
          );
          cxt.mergeEvaluated(schCxt);
        }
        function validateClause(keyword, ifClause) {
          return () => {
            const schCxt = cxt.subschema({ keyword }, schValid);
            gen.assign(valid, schValid);
            cxt.mergeValidEvaluated(schCxt, valid);
            if (ifClause) gen.assign(ifClause, (0, codegen_1._)`${keyword}`);
            else cxt.setParams({ ifClause: keyword });
          };
        }
      },
    };
    function hasSchema(it, keyword) {
      const schema = it.schema[keyword];
      return schema !== void 0 && !(0, util_1.alwaysValidSchema)(it, schema);
    }
    exports2.default = def;
  },
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/thenElse.js
var require_thenElse2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/thenElse.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var util_1 = require_util2();
    var def = {
      keyword: ["then", "else"],
      schemaType: ["object", "boolean"],
      code({ keyword, parentSchema, it }) {
        if (parentSchema.if === void 0)
          (0, util_1.checkStrictMode)(
            it,
            `"${keyword}" without "if" is ignored`
          );
      },
    };
    exports2.default = def;
  },
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/index.js
var require_applicator2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/index.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var additionalItems_1 = require_additionalItems2();
    var prefixItems_1 = require_prefixItems2();
    var items_1 = require_items2();
    var items2020_1 = require_items20202();
    var contains_1 = require_contains2();
    var dependencies_1 = require_dependencies2();
    var propertyNames_1 = require_propertyNames2();
    var additionalProperties_1 = require_additionalProperties2();
    var properties_1 = require_properties2();
    var patternProperties_1 = require_patternProperties2();
    var not_1 = require_not2();
    var anyOf_1 = require_anyOf2();
    var oneOf_1 = require_oneOf2();
    var allOf_1 = require_allOf2();
    var if_1 = require_if2();
    var thenElse_1 = require_thenElse2();
    function getApplicator(draft2020 = false) {
      const applicator = [
        // any
        not_1.default,
        anyOf_1.default,
        oneOf_1.default,
        allOf_1.default,
        if_1.default,
        thenElse_1.default,
        // object
        propertyNames_1.default,
        additionalProperties_1.default,
        dependencies_1.default,
        properties_1.default,
        patternProperties_1.default,
      ];
      if (draft2020)
        applicator.push(prefixItems_1.default, items2020_1.default);
      else applicator.push(additionalItems_1.default, items_1.default);
      applicator.push(contains_1.default);
      return applicator;
    }
    exports2.default = getApplicator;
  },
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/format/format.js
var require_format5 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/format/format.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen2();
    var error = {
      message: ({ schemaCode }) =>
        (0, codegen_1.str)`must match format "${schemaCode}"`,
      params: ({ schemaCode }) => (0, codegen_1._)`{format: ${schemaCode}}`,
    };
    var def = {
      keyword: "format",
      type: ["number", "string"],
      schemaType: "string",
      $data: true,
      error,
      code(cxt, ruleType) {
        const { gen, data, $data, schema, schemaCode, it } = cxt;
        const { opts, errSchemaPath, schemaEnv, self: self2 } = it;
        if (!opts.validateFormats) return;
        if ($data) validate$DataFormat();
        else validateFormat();
        function validate$DataFormat() {
          const fmts = gen.scopeValue("formats", {
            ref: self2.formats,
            code: opts.code.formats,
          });
          const fDef = gen.const(
            "fDef",
            (0, codegen_1._)`${fmts}[${schemaCode}]`
          );
          const fType = gen.let("fType");
          const format = gen.let("format");
          gen.if(
            (0,
            codegen_1._)`typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`,
            () =>
              gen
                .assign(fType, (0, codegen_1._)`${fDef}.type || "string"`)
                .assign(format, (0, codegen_1._)`${fDef}.validate`),
            () =>
              gen.assign(fType, (0, codegen_1._)`"string"`).assign(format, fDef)
          );
          cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()));
          function unknownFmt() {
            if (opts.strictSchema === false) return codegen_1.nil;
            return (0, codegen_1._)`${schemaCode} && !${format}`;
          }
          function invalidFmt() {
            const callFormat = schemaEnv.$async
              ? (0,
                codegen_1._)`(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))`
              : (0, codegen_1._)`${format}(${data})`;
            const validData = (0,
            codegen_1._)`(typeof ${format} == "function" ? ${callFormat} : ${format}.test(${data}))`;
            return (0,
            codegen_1._)`${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`;
          }
        }
        function validateFormat() {
          const formatDef = self2.formats[schema];
          if (!formatDef) {
            unknownFormat();
            return;
          }
          if (formatDef === true) return;
          const [fmtType, format, fmtRef] = getFormat(formatDef);
          if (fmtType === ruleType) cxt.pass(validCondition());
          function unknownFormat() {
            if (opts.strictSchema === false) {
              self2.logger.warn(unknownMsg());
              return;
            }
            throw new Error(unknownMsg());
            function unknownMsg() {
              return `unknown format "${schema}" ignored in schema at path "${errSchemaPath}"`;
            }
          }
          function getFormat(fmtDef) {
            const code =
              fmtDef instanceof RegExp
                ? (0, codegen_1.regexpCode)(fmtDef)
                : opts.code.formats
                ? (0, codegen_1._)`${opts.code.formats}${(0,
                  codegen_1.getProperty)(schema)}`
                : void 0;
            const fmt = gen.scopeValue("formats", {
              key: schema,
              ref: fmtDef,
              code,
            });
            if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
              return [
                fmtDef.type || "string",
                fmtDef.validate,
                (0, codegen_1._)`${fmt}.validate`,
              ];
            }
            return ["string", fmtDef, fmt];
          }
          function validCondition() {
            if (
              typeof formatDef == "object" &&
              !(formatDef instanceof RegExp) &&
              formatDef.async
            ) {
              if (!schemaEnv.$async)
                throw new Error("async format in sync schema");
              return (0, codegen_1._)`await ${fmtRef}(${data})`;
            }
            return typeof format == "function"
              ? (0, codegen_1._)`${fmtRef}(${data})`
              : (0, codegen_1._)`${fmtRef}.test(${data})`;
          }
        }
      },
    };
    exports2.default = def;
  },
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/format/index.js
var require_format6 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/format/index.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var format_1 = require_format5();
    var format = [format_1.default];
    exports2.default = format;
  },
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/metadata.js
var require_metadata2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/metadata.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.contentVocabulary = exports2.metadataVocabulary = void 0;
    exports2.metadataVocabulary = [
      "title",
      "description",
      "default",
      "deprecated",
      "readOnly",
      "writeOnly",
      "examples",
    ];
    exports2.contentVocabulary = [
      "contentMediaType",
      "contentEncoding",
      "contentSchema",
    ];
  },
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/draft7.js
var require_draft72 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/draft7.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var core_1 = require_core4();
    var validation_1 = require_validation2();
    var applicator_1 = require_applicator2();
    var format_1 = require_format6();
    var metadata_1 = require_metadata2();
    var draft7Vocabularies = [
      core_1.default,
      validation_1.default,
      (0, applicator_1.default)(),
      format_1.default,
      metadata_1.metadataVocabulary,
      metadata_1.contentVocabulary,
    ];
    exports2.default = draft7Vocabularies;
  },
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/discriminator/types.js
var require_types3 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/discriminator/types.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DiscrError = void 0;
    (function (DiscrError2) {
      DiscrError2["Tag"] = "tag";
      DiscrError2["Mapping"] = "mapping";
    })(exports2.DiscrError || (exports2.DiscrError = {}));
  },
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/discriminator/index.js
var require_discriminator2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/discriminator/index.js"(
    exports2
  ) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen2();
    var types_1 = require_types3();
    var compile_1 = require_compile2();
    var util_1 = require_util2();
    var error = {
      message: ({ params: { discrError, tagName } }) =>
        discrError === types_1.DiscrError.Tag
          ? `tag "${tagName}" must be string`
          : `value of tag "${tagName}" must be in oneOf`,
      params: ({ params: { discrError, tag, tagName } }) =>
        (0,
        codegen_1._)`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`,
    };
    var def = {
      keyword: "discriminator",
      type: "object",
      schemaType: "object",
      error,
      code(cxt) {
        const { gen, data, schema, parentSchema, it } = cxt;
        const { oneOf } = parentSchema;
        if (!it.opts.discriminator) {
          throw new Error("discriminator: requires discriminator option");
        }
        const tagName = schema.propertyName;
        if (typeof tagName != "string")
          throw new Error("discriminator: requires propertyName");
        if (schema.mapping)
          throw new Error("discriminator: mapping is not supported");
        if (!oneOf) throw new Error("discriminator: requires oneOf keyword");
        const valid = gen.let("valid", false);
        const tag = gen.const(
          "tag",
          (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(tagName)}`
        );
        gen.if(
          (0, codegen_1._)`typeof ${tag} == "string"`,
          () => validateMapping(),
          () =>
            cxt.error(false, {
              discrError: types_1.DiscrError.Tag,
              tag,
              tagName,
            })
        );
        cxt.ok(valid);
        function validateMapping() {
          const mapping = getMapping();
          gen.if(false);
          for (const tagValue in mapping) {
            gen.elseIf((0, codegen_1._)`${tag} === ${tagValue}`);
            gen.assign(valid, applyTagSchema(mapping[tagValue]));
          }
          gen.else();
          cxt.error(false, {
            discrError: types_1.DiscrError.Mapping,
            tag,
            tagName,
          });
          gen.endIf();
        }
        function applyTagSchema(schemaProp) {
          const _valid = gen.name("valid");
          const schCxt = cxt.subschema(
            { keyword: "oneOf", schemaProp },
            _valid
          );
          cxt.mergeEvaluated(schCxt, codegen_1.Name);
          return _valid;
        }
        function getMapping() {
          var _a;
          const oneOfMapping = {};
          const topRequired = hasRequired(parentSchema);
          let tagRequired = true;
          for (let i = 0; i < oneOf.length; i++) {
            let sch = oneOf[i];
            if (
              (sch === null || sch === void 0 ? void 0 : sch.$ref) &&
              !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)
            ) {
              sch = compile_1.resolveRef.call(
                it.self,
                it.schemaEnv.root,
                it.baseId,
                sch === null || sch === void 0 ? void 0 : sch.$ref
              );
              if (sch instanceof compile_1.SchemaEnv) sch = sch.schema;
            }
            const propSch =
              (_a =
                sch === null || sch === void 0 ? void 0 : sch.properties) ===
                null || _a === void 0
                ? void 0
                : _a[tagName];
            if (typeof propSch != "object") {
              throw new Error(
                `discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`
              );
            }
            tagRequired = tagRequired && (topRequired || hasRequired(sch));
            addMappings(propSch, i);
          }
          if (!tagRequired)
            throw new Error(`discriminator: "${tagName}" must be required`);
          return oneOfMapping;
          function hasRequired({ required }) {
            return Array.isArray(required) && required.includes(tagName);
          }
          function addMappings(sch, i) {
            if (sch.const) {
              addMapping(sch.const, i);
            } else if (sch.enum) {
              for (const tagValue of sch.enum) {
                addMapping(tagValue, i);
              }
            } else {
              throw new Error(
                `discriminator: "properties/${tagName}" must have "const" or "enum"`
              );
            }
          }
          function addMapping(tagValue, i) {
            if (typeof tagValue != "string" || tagValue in oneOfMapping) {
              throw new Error(
                `discriminator: "${tagName}" values must be unique strings`
              );
            }
            oneOfMapping[tagValue] = i;
          }
        }
      },
    };
    exports2.default = def;
  },
});

// node_modules/ajv-formats/node_modules/ajv/dist/refs/json-schema-draft-07.json
var require_json_schema_draft_072 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/refs/json-schema-draft-07.json"(
    exports2,
    module2
  ) {
    module2.exports = {
      $schema: "http://json-schema.org/draft-07/schema#",
      $id: "http://json-schema.org/draft-07/schema#",
      title: "Core schema meta-schema",
      definitions: {
        schemaArray: {
          type: "array",
          minItems: 1,
          items: { $ref: "#" },
        },
        nonNegativeInteger: {
          type: "integer",
          minimum: 0,
        },
        nonNegativeIntegerDefault0: {
          allOf: [{ $ref: "#/definitions/nonNegativeInteger" }, { default: 0 }],
        },
        simpleTypes: {
          enum: [
            "array",
            "boolean",
            "integer",
            "null",
            "number",
            "object",
            "string",
          ],
        },
        stringArray: {
          type: "array",
          items: { type: "string" },
          uniqueItems: true,
          default: [],
        },
      },
      type: ["object", "boolean"],
      properties: {
        $id: {
          type: "string",
          format: "uri-reference",
        },
        $schema: {
          type: "string",
          format: "uri",
        },
        $ref: {
          type: "string",
          format: "uri-reference",
        },
        $comment: {
          type: "string",
        },
        title: {
          type: "string",
        },
        description: {
          type: "string",
        },
        default: true,
        readOnly: {
          type: "boolean",
          default: false,
        },
        examples: {
          type: "array",
          items: true,
        },
        multipleOf: {
          type: "number",
          exclusiveMinimum: 0,
        },
        maximum: {
          type: "number",
        },
        exclusiveMaximum: {
          type: "number",
        },
        minimum: {
          type: "number",
        },
        exclusiveMinimum: {
          type: "number",
        },
        maxLength: { $ref: "#/definitions/nonNegativeInteger" },
        minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        pattern: {
          type: "string",
          format: "regex",
        },
        additionalItems: { $ref: "#" },
        items: {
          anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }],
          default: true,
        },
        maxItems: { $ref: "#/definitions/nonNegativeInteger" },
        minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        uniqueItems: {
          type: "boolean",
          default: false,
        },
        contains: { $ref: "#" },
        maxProperties: { $ref: "#/definitions/nonNegativeInteger" },
        minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        required: { $ref: "#/definitions/stringArray" },
        additionalProperties: { $ref: "#" },
        definitions: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {},
        },
        properties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {},
        },
        patternProperties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          propertyNames: { format: "regex" },
          default: {},
        },
        dependencies: {
          type: "object",
          additionalProperties: {
            anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }],
          },
        },
        propertyNames: { $ref: "#" },
        const: true,
        enum: {
          type: "array",
          items: true,
          minItems: 1,
          uniqueItems: true,
        },
        type: {
          anyOf: [
            { $ref: "#/definitions/simpleTypes" },
            {
              type: "array",
              items: { $ref: "#/definitions/simpleTypes" },
              minItems: 1,
              uniqueItems: true,
            },
          ],
        },
        format: { type: "string" },
        contentMediaType: { type: "string" },
        contentEncoding: { type: "string" },
        if: { $ref: "#" },
        then: { $ref: "#" },
        else: { $ref: "#" },
        allOf: { $ref: "#/definitions/schemaArray" },
        anyOf: { $ref: "#/definitions/schemaArray" },
        oneOf: { $ref: "#/definitions/schemaArray" },
        not: { $ref: "#" },
      },
      default: true,
    };
  },
});

// node_modules/ajv-formats/node_modules/ajv/dist/ajv.js
var require_ajv2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/ajv.js"(exports2, module2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MissingRefError =
      exports2.ValidationError =
      exports2.CodeGen =
      exports2.Name =
      exports2.nil =
      exports2.stringify =
      exports2.str =
      exports2._ =
      exports2.KeywordCxt =
        void 0;
    var core_1 = require_core3();
    var draft7_1 = require_draft72();
    var discriminator_1 = require_discriminator2();
    var draft7MetaSchema = require_json_schema_draft_072();
    var META_SUPPORT_DATA = ["/properties"];
    var META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
    var Ajv = class extends core_1.default {
      _addVocabularies() {
        super._addVocabularies();
        draft7_1.default.forEach((v) => this.addVocabulary(v));
        if (this.opts.discriminator) this.addKeyword(discriminator_1.default);
      }
      _addDefaultMetaSchema() {
        super._addDefaultMetaSchema();
        if (!this.opts.meta) return;
        const metaSchema = this.opts.$data
          ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA)
          : draft7MetaSchema;
        this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);
        this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
      }
      defaultMeta() {
        return (this.opts.defaultMeta =
          super.defaultMeta() ||
          (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0));
      }
    };
    module2.exports = exports2 = Ajv;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = Ajv;
    var validate_1 = require_validate2();
    Object.defineProperty(exports2, "KeywordCxt", {
      enumerable: true,
      get: function () {
        return validate_1.KeywordCxt;
      },
    });
    var codegen_1 = require_codegen2();
    Object.defineProperty(exports2, "_", {
      enumerable: true,
      get: function () {
        return codegen_1._;
      },
    });
    Object.defineProperty(exports2, "str", {
      enumerable: true,
      get: function () {
        return codegen_1.str;
      },
    });
    Object.defineProperty(exports2, "stringify", {
      enumerable: true,
      get: function () {
        return codegen_1.stringify;
      },
    });
    Object.defineProperty(exports2, "nil", {
      enumerable: true,
      get: function () {
        return codegen_1.nil;
      },
    });
    Object.defineProperty(exports2, "Name", {
      enumerable: true,
      get: function () {
        return codegen_1.Name;
      },
    });
    Object.defineProperty(exports2, "CodeGen", {
      enumerable: true,
      get: function () {
        return codegen_1.CodeGen;
      },
    });
    var validation_error_1 = require_validation_error2();
    Object.defineProperty(exports2, "ValidationError", {
      enumerable: true,
      get: function () {
        return validation_error_1.default;
      },
    });
    var ref_error_1 = require_ref_error2();
    Object.defineProperty(exports2, "MissingRefError", {
      enumerable: true,
      get: function () {
        return ref_error_1.default;
      },
    });
  },
});

// node_modules/ajv-formats/dist/limit.js
var require_limit = __commonJS({
  "node_modules/ajv-formats/dist/limit.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.formatLimitDefinition = void 0;
    var ajv_1 = require_ajv2();
    var codegen_1 = require_codegen2();
    var ops = codegen_1.operators;
    var KWDs = {
      formatMaximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
      formatMinimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
      formatExclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
      formatExclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE },
    };
    var error = {
      message: ({ keyword, schemaCode }) =>
        codegen_1.str`should be ${KWDs[keyword].okStr} ${schemaCode}`,
      params: ({ keyword, schemaCode }) =>
        codegen_1._`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`,
    };
    exports2.formatLimitDefinition = {
      keyword: Object.keys(KWDs),
      type: "string",
      schemaType: "string",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, schemaCode, keyword, it } = cxt;
        const { opts, self: self2 } = it;
        if (!opts.validateFormats) return;
        const fCxt = new ajv_1.KeywordCxt(
          it,
          self2.RULES.all.format.definition,
          "format"
        );
        if (fCxt.$data) validate$DataFormat();
        else validateFormat();
        function validate$DataFormat() {
          const fmts = gen.scopeValue("formats", {
            ref: self2.formats,
            code: opts.code.formats,
          });
          const fmt = gen.const(
            "fmt",
            codegen_1._`${fmts}[${fCxt.schemaCode}]`
          );
          cxt.fail$data(
            codegen_1.or(
              codegen_1._`typeof ${fmt} != "object"`,
              codegen_1._`${fmt} instanceof RegExp`,
              codegen_1._`typeof ${fmt}.compare != "function"`,
              compareCode(fmt)
            )
          );
        }
        function validateFormat() {
          const format = fCxt.schema;
          const fmtDef = self2.formats[format];
          if (!fmtDef || fmtDef === true) return;
          if (
            typeof fmtDef != "object" ||
            fmtDef instanceof RegExp ||
            typeof fmtDef.compare != "function"
          ) {
            throw new Error(
              `"${keyword}": format "${format}" does not define "compare" function`
            );
          }
          const fmt = gen.scopeValue("formats", {
            key: format,
            ref: fmtDef,
            code: opts.code.formats
              ? codegen_1._`${opts.code.formats}${codegen_1.getProperty(
                  format
                )}`
              : void 0,
          });
          cxt.fail$data(compareCode(fmt));
        }
        function compareCode(fmt) {
          return codegen_1._`${fmt}.compare(${data}, ${schemaCode}) ${KWDs[keyword].fail} 0`;
        }
      },
      dependencies: ["format"],
    };
    var formatLimitPlugin = (ajv) => {
      ajv.addKeyword(exports2.formatLimitDefinition);
      return ajv;
    };
    exports2.default = formatLimitPlugin;
  },
});

// node_modules/ajv-formats/dist/index.js
var require_dist = __commonJS({
  "node_modules/ajv-formats/dist/index.js"(exports2, module2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var formats_1 = require_formats();
    var limit_1 = require_limit();
    var codegen_1 = require_codegen2();
    var fullName = new codegen_1.Name("fullFormats");
    var fastName = new codegen_1.Name("fastFormats");
    var formatsPlugin = (ajv, opts = { keywords: true }) => {
      if (Array.isArray(opts)) {
        addFormats(ajv, opts, formats_1.fullFormats, fullName);
        return ajv;
      }
      const [formats, exportName] =
        opts.mode === "fast"
          ? [formats_1.fastFormats, fastName]
          : [formats_1.fullFormats, fullName];
      const list = opts.formats || formats_1.formatNames;
      addFormats(ajv, list, formats, exportName);
      if (opts.keywords) limit_1.default(ajv);
      return ajv;
    };
    formatsPlugin.get = (name, mode = "full") => {
      const formats =
        mode === "fast" ? formats_1.fastFormats : formats_1.fullFormats;
      const f = formats[name];
      if (!f) throw new Error(`Unknown format "${name}"`);
      return f;
    };
    function addFormats(ajv, list, fs, exportName) {
      var _a;
      var _b;
      (_a = (_b = ajv.opts.code).formats) !== null && _a !== void 0
        ? _a
        : (_b.formats = codegen_1._`require("ajv-formats/dist/formats").${exportName}`);
      for (const f of list) ajv.addFormat(f, fs[f]);
    }
    module2.exports = exports2 = formatsPlugin;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = formatsPlugin;
  },
});

// node_modules/near-abi/lib/index.js
var require_lib10 = __commonJS({
  "node_modules/near-abi/lib/index.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AbiSerializationType =
      exports2.AbiFunctionModifier =
      exports2.AbiFunctionKind =
      exports2.SCHEMA_VERSION =
        void 0;
    exports2.SCHEMA_VERSION = "0.3.0";
    (function (AbiFunctionKind2) {
      AbiFunctionKind2["View"] = "view";
      AbiFunctionKind2["Call"] = "call";
    })(exports2.AbiFunctionKind || (exports2.AbiFunctionKind = {}));
    (function (AbiFunctionModifier2) {
      AbiFunctionModifier2["Init"] = "init";
      AbiFunctionModifier2["Private"] = "private";
      AbiFunctionModifier2["Payable"] = "payable";
    })(exports2.AbiFunctionModifier || (exports2.AbiFunctionModifier = {}));
    (function (AbiSerializationType2) {
      AbiSerializationType2["Json"] = "json";
      AbiSerializationType2["Borsh"] = "borsh";
    })(exports2.AbiSerializationType || (exports2.AbiSerializationType = {}));
  },
});

// node_modules/@near-js/accounts/lib/errors.js
var require_errors6 = __commonJS({
  "node_modules/@near-js/accounts/lib/errors.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ConflictingOptions =
      exports2.ArgumentSchemaError =
      exports2.UnknownArgumentError =
      exports2.UnsupportedSerializationError =
        void 0;
    var UnsupportedSerializationError = class extends Error {
      constructor(methodName, serializationType) {
        super(
          `Contract method '${methodName}' is using an unsupported serialization type ${serializationType}`
        );
      }
    };
    exports2.UnsupportedSerializationError = UnsupportedSerializationError;
    var UnknownArgumentError = class extends Error {
      constructor(actualArgName, expectedArgNames) {
        super(
          `Unrecognized argument '${actualArgName}', expected '${JSON.stringify(
            expectedArgNames
          )}'`
        );
      }
    };
    exports2.UnknownArgumentError = UnknownArgumentError;
    var ArgumentSchemaError = class extends Error {
      constructor(argName, errors) {
        super(
          `Argument '${argName}' does not conform to the specified ABI schema: '${JSON.stringify(
            errors
          )}'`
        );
      }
    };
    exports2.ArgumentSchemaError = ArgumentSchemaError;
    var ConflictingOptions = class extends Error {
      constructor() {
        super(
          "Conflicting contract method options have been passed. You can either specify ABI or a list of view/call methods."
        );
      }
    };
    exports2.ConflictingOptions = ConflictingOptions;
  },
});

// node_modules/@near-js/accounts/lib/contract.js
var require_contract = __commonJS({
  "node_modules/@near-js/accounts/lib/contract.js"(exports2) {
    var __awaiter =
      (exports2 && exports2.__awaiter) ||
      function (thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P
            ? value
            : new P(function (resolve) {
                resolve(value);
              });
        }
        return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done
              ? resolve(result.value)
              : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
    var __importDefault =
      (exports2 && exports2.__importDefault) ||
      function (mod) {
        return mod && mod.__esModule ? mod : { default: mod };
      };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Contract = void 0;
    var utils_1 = require_lib6();
    var types_1 = require_lib2();
    var ajv_1 = __importDefault(require_ajv());
    var ajv_formats_1 = __importDefault(require_dist());
    var bn_js_1 = __importDefault(require_bn());
    var depd_1 = __importDefault(require_browser$1());
    var near_abi_1 = require_lib10();
    var errors_1 = require_errors6();
    function nameFunction(name, body) {
      return {
        [name](...args) {
          return body(...args);
        },
      }[name];
    }
    function validateArguments(args, abiFunction, ajv, abiRoot) {
      var _a;
      if (!isObject(args)) return;
      if (
        abiFunction.params &&
        abiFunction.params.serialization_type !==
          near_abi_1.AbiSerializationType.Json
      ) {
        throw new errors_1.UnsupportedSerializationError(
          abiFunction.name,
          abiFunction.params.serialization_type
        );
      }
      if (
        abiFunction.result &&
        abiFunction.result.serialization_type !==
          near_abi_1.AbiSerializationType.Json
      ) {
        throw new errors_1.UnsupportedSerializationError(
          abiFunction.name,
          abiFunction.result.serialization_type
        );
      }
      const params =
        ((_a = abiFunction.params) === null || _a === void 0
          ? void 0
          : _a.args) || [];
      for (const p of params) {
        const arg = args[p.name];
        const typeSchema = p.type_schema;
        typeSchema.definitions = abiRoot.body.root_schema.definitions;
        const validate = ajv.compile(typeSchema);
        if (!validate(arg)) {
          throw new errors_1.ArgumentSchemaError(p.name, validate.errors);
        }
      }
      for (const argName of Object.keys(args)) {
        const param = params.find((p) => p.name === argName);
        if (!param) {
          throw new errors_1.UnknownArgumentError(
            argName,
            params.map((p) => p.name)
          );
        }
      }
    }
    function createAjv() {
      const ajv = new ajv_1.default({
        strictSchema: false,
        formats: {
          uint32: true,
          uint64: true,
        },
      });
      (0, ajv_formats_1.default)(ajv);
      return ajv;
    }
    var isUint8Array = (x) =>
      x && x.byteLength !== void 0 && x.byteLength === x.length;
    var isObject = (x) =>
      Object.prototype.toString.call(x) === "[object Object]";
    var Contract = class {
      /**
       * @param account NEAR account to sign change method transactions
       * @param contractId NEAR account id where the contract is deployed
       * @param options NEAR smart contract methods that your application will use. These will be available as `contract.methodName`
       */
      constructor(account, contractId, options) {
        this.account = account;
        this.contractId = contractId;
        const { viewMethods = [], changeMethods = [], abi: abiRoot } = options;
        let viewMethodsWithAbi = viewMethods.map((name) => ({
          name,
          abi: null,
        }));
        let changeMethodsWithAbi = changeMethods.map((name) => ({
          name,
          abi: null,
        }));
        if (abiRoot) {
          if (
            viewMethodsWithAbi.length > 0 ||
            changeMethodsWithAbi.length > 0
          ) {
            throw new errors_1.ConflictingOptions();
          }
          viewMethodsWithAbi = abiRoot.body.functions
            .filter((m) => m.kind === near_abi_1.AbiFunctionKind.View)
            .map((m) => ({ name: m.name, abi: m }));
          changeMethodsWithAbi = abiRoot.body.functions
            .filter(
              (methodAbi) => methodAbi.kind === near_abi_1.AbiFunctionKind.Call
            )
            .map((methodAbi) => ({ name: methodAbi.name, abi: methodAbi }));
        }
        const ajv = createAjv();
        viewMethodsWithAbi.forEach(({ name, abi }) => {
          Object.defineProperty(this, name, {
            writable: false,
            enumerable: true,
            value: nameFunction(name, (args = {}, options2 = {}, ...ignored) =>
              __awaiter(this, void 0, void 0, function* () {
                if (
                  ignored.length ||
                  !(isObject(args) || isUint8Array(args)) ||
                  !isObject(options2)
                ) {
                  throw new types_1.PositionalArgsError();
                }
                if (abi) {
                  validateArguments(args, abi, ajv, abiRoot);
                }
                return this.account.viewFunction(
                  Object.assign(
                    { contractId: this.contractId, methodName: name, args },
                    options2
                  )
                );
              })
            ),
          });
        });
        changeMethodsWithAbi.forEach(({ name, abi }) => {
          Object.defineProperty(this, name, {
            writable: false,
            enumerable: true,
            value: nameFunction(name, (...args) =>
              __awaiter(this, void 0, void 0, function* () {
                if (
                  args.length &&
                  (args.length > 3 ||
                    !(isObject(args[0]) || isUint8Array(args[0])))
                ) {
                  throw new types_1.PositionalArgsError();
                }
                if (args.length > 1 || !(args[0] && args[0].args)) {
                  const deprecate = (0, depd_1.default)(
                    "contract.methodName(args, gas, amount)"
                  );
                  deprecate(
                    "use `contract.methodName({ args, gas?, amount?, callbackUrl?, meta? })` instead"
                  );
                  args[0] = {
                    args: args[0],
                    gas: args[1],
                    amount: args[2],
                  };
                }
                if (abi) {
                  validateArguments(args[0].args, abi, ajv, abiRoot);
                }
                return this._changeMethod(
                  Object.assign({ methodName: name }, args[0])
                );
              })
            ),
          });
        });
      }
      _changeMethod({ args, methodName, gas, amount, meta, callbackUrl }) {
        return __awaiter(this, void 0, void 0, function* () {
          validateBNLike({ gas, amount });
          const rawResult = yield this.account.functionCall({
            contractId: this.contractId,
            methodName,
            args,
            gas,
            attachedDeposit: amount,
            walletMeta: meta,
            walletCallbackUrl: callbackUrl,
          });
          return (0, utils_1.getTransactionLastResult)(rawResult);
        });
      }
    };
    exports2.Contract = Contract;
    function validateBNLike(argMap) {
      const bnLike = "number, decimal string or BN";
      for (const argName of Object.keys(argMap)) {
        const argValue = argMap[argName];
        if (argValue && !bn_js_1.default.isBN(argValue) && isNaN(argValue)) {
          throw new types_1.ArgumentTypeError(argName, bnLike, argValue);
        }
      }
    }
  },
});

// node_modules/@near-js/accounts/lib/index.js
var require_lib11 = __commonJS({
  "node_modules/@near-js/accounts/lib/index.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MultisigStateStatus =
      exports2.MultisigDeleteRequestRejectionError =
      exports2.UnsupportedSerializationError =
      exports2.UnknownArgumentError =
      exports2.ConflictingOptions =
      exports2.ArgumentSchemaError =
      exports2.Contract =
      exports2.MULTISIG_CONFIRM_METHODS =
      exports2.MULTISIG_CHANGE_METHODS =
      exports2.MULTISIG_DEPOSIT =
      exports2.MULTISIG_GAS =
      exports2.MULTISIG_ALLOWANCE =
      exports2.MULTISIG_STORAGE_KEY =
      exports2.Connection =
      exports2.AccountMultisig =
      exports2.UrlAccountCreator =
      exports2.LocalAccountCreator =
      exports2.AccountCreator =
      exports2.Account2FA =
      exports2.Account =
        void 0;
    var account_1 = require_account();
    Object.defineProperty(exports2, "Account", {
      enumerable: true,
      get: function () {
        return account_1.Account;
      },
    });
    var account_2fa_1 = require_account_2fa();
    Object.defineProperty(exports2, "Account2FA", {
      enumerable: true,
      get: function () {
        return account_2fa_1.Account2FA;
      },
    });
    var account_creator_1 = require_account_creator();
    Object.defineProperty(exports2, "AccountCreator", {
      enumerable: true,
      get: function () {
        return account_creator_1.AccountCreator;
      },
    });
    Object.defineProperty(exports2, "LocalAccountCreator", {
      enumerable: true,
      get: function () {
        return account_creator_1.LocalAccountCreator;
      },
    });
    Object.defineProperty(exports2, "UrlAccountCreator", {
      enumerable: true,
      get: function () {
        return account_creator_1.UrlAccountCreator;
      },
    });
    var account_multisig_1 = require_account_multisig();
    Object.defineProperty(exports2, "AccountMultisig", {
      enumerable: true,
      get: function () {
        return account_multisig_1.AccountMultisig;
      },
    });
    var connection_1 = require_connection();
    Object.defineProperty(exports2, "Connection", {
      enumerable: true,
      get: function () {
        return connection_1.Connection;
      },
    });
    var constants_1 = require_constants3();
    Object.defineProperty(exports2, "MULTISIG_STORAGE_KEY", {
      enumerable: true,
      get: function () {
        return constants_1.MULTISIG_STORAGE_KEY;
      },
    });
    Object.defineProperty(exports2, "MULTISIG_ALLOWANCE", {
      enumerable: true,
      get: function () {
        return constants_1.MULTISIG_ALLOWANCE;
      },
    });
    Object.defineProperty(exports2, "MULTISIG_GAS", {
      enumerable: true,
      get: function () {
        return constants_1.MULTISIG_GAS;
      },
    });
    Object.defineProperty(exports2, "MULTISIG_DEPOSIT", {
      enumerable: true,
      get: function () {
        return constants_1.MULTISIG_DEPOSIT;
      },
    });
    Object.defineProperty(exports2, "MULTISIG_CHANGE_METHODS", {
      enumerable: true,
      get: function () {
        return constants_1.MULTISIG_CHANGE_METHODS;
      },
    });
    Object.defineProperty(exports2, "MULTISIG_CONFIRM_METHODS", {
      enumerable: true,
      get: function () {
        return constants_1.MULTISIG_CONFIRM_METHODS;
      },
    });
    var contract_1 = require_contract();
    Object.defineProperty(exports2, "Contract", {
      enumerable: true,
      get: function () {
        return contract_1.Contract;
      },
    });
    var errors_1 = require_errors6();
    Object.defineProperty(exports2, "ArgumentSchemaError", {
      enumerable: true,
      get: function () {
        return errors_1.ArgumentSchemaError;
      },
    });
    Object.defineProperty(exports2, "ConflictingOptions", {
      enumerable: true,
      get: function () {
        return errors_1.ConflictingOptions;
      },
    });
    Object.defineProperty(exports2, "UnknownArgumentError", {
      enumerable: true,
      get: function () {
        return errors_1.UnknownArgumentError;
      },
    });
    Object.defineProperty(exports2, "UnsupportedSerializationError", {
      enumerable: true,
      get: function () {
        return errors_1.UnsupportedSerializationError;
      },
    });
    var types_1 = require_types();
    Object.defineProperty(exports2, "MultisigDeleteRequestRejectionError", {
      enumerable: true,
      get: function () {
        return types_1.MultisigDeleteRequestRejectionError;
      },
    });
    Object.defineProperty(exports2, "MultisigStateStatus", {
      enumerable: true,
      get: function () {
        return types_1.MultisigStateStatus;
      },
    });
  },
});

// node_modules/near-api-js/lib/utils/errors.js
var require_errors7 = __commonJS({
  "node_modules/near-api-js/lib/utils/errors.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.logWarning =
      exports2.TypedError =
      exports2.PositionalArgsError =
      exports2.ErrorContext =
      exports2.ArgumentTypeError =
      exports2.UnsupportedSerializationError =
      exports2.UnknownArgumentError =
      exports2.ConflictingOptions =
      exports2.ArgumentSchemaError =
        void 0;
    var accounts_1 = require_lib11();
    Object.defineProperty(exports2, "ArgumentSchemaError", {
      enumerable: true,
      get: function () {
        return accounts_1.ArgumentSchemaError;
      },
    });
    Object.defineProperty(exports2, "ConflictingOptions", {
      enumerable: true,
      get: function () {
        return accounts_1.ConflictingOptions;
      },
    });
    Object.defineProperty(exports2, "UnknownArgumentError", {
      enumerable: true,
      get: function () {
        return accounts_1.UnknownArgumentError;
      },
    });
    Object.defineProperty(exports2, "UnsupportedSerializationError", {
      enumerable: true,
      get: function () {
        return accounts_1.UnsupportedSerializationError;
      },
    });
    var types_1 = require_lib2();
    Object.defineProperty(exports2, "ArgumentTypeError", {
      enumerable: true,
      get: function () {
        return types_1.ArgumentTypeError;
      },
    });
    Object.defineProperty(exports2, "ErrorContext", {
      enumerable: true,
      get: function () {
        return types_1.ErrorContext;
      },
    });
    Object.defineProperty(exports2, "PositionalArgsError", {
      enumerable: true,
      get: function () {
        return types_1.PositionalArgsError;
      },
    });
    Object.defineProperty(exports2, "TypedError", {
      enumerable: true,
      get: function () {
        return types_1.TypedError;
      },
    });
    var utils_1 = require_lib6();
    Object.defineProperty(exports2, "logWarning", {
      enumerable: true,
      get: function () {
        return utils_1.logWarning;
      },
    });
  },
});

// node_modules/near-api-js/lib/utils/index.js
var require_utils$1 = __commonJS({
  "node_modules/near-api-js/lib/utils/index.js"(exports2) {
    var __createBinding =
      (exports2 && exports2.__createBinding) ||
      (Object.create
        ? function (o, m, k, k2) {
            if (k2 === void 0) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);
            if (
              !desc ||
              ("get" in desc
                ? !m.__esModule
                : desc.writable || desc.configurable)
            ) {
              desc = {
                enumerable: true,
                get: function () {
                  return m[k];
                },
              };
            }
            Object.defineProperty(o, k2, desc);
          }
        : function (o, m, k, k2) {
            if (k2 === void 0) k2 = k;
            o[k2] = m[k];
          });
    var __setModuleDefault =
      (exports2 && exports2.__setModuleDefault) ||
      (Object.create
        ? function (o, v) {
            Object.defineProperty(o, "default", { enumerable: true, value: v });
          }
        : function (o, v) {
            o["default"] = v;
          });
    var __importStar =
      (exports2 && exports2.__importStar) ||
      function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.logWarning =
      exports2.rpc_errors =
      exports2.KeyPairEd25519 =
      exports2.KeyPair =
      exports2.PublicKey =
      exports2.format =
      exports2.enums =
      exports2.web =
      exports2.serialize =
      exports2.key_pair =
        void 0;
    var key_pair = __importStar(require_key_pair2());
    exports2.key_pair = key_pair;
    var serialize = __importStar(require_serialize());
    exports2.serialize = serialize;
    var web = __importStar(require_web());
    exports2.web = web;
    var enums = __importStar(require_enums());
    exports2.enums = enums;
    var format = __importStar(require_format2());
    exports2.format = format;
    var rpc_errors = __importStar(require_rpc_errors2());
    exports2.rpc_errors = rpc_errors;
    var key_pair_1 = require_key_pair2();
    Object.defineProperty(exports2, "PublicKey", {
      enumerable: true,
      get: function () {
        return key_pair_1.PublicKey;
      },
    });
    Object.defineProperty(exports2, "KeyPair", {
      enumerable: true,
      get: function () {
        return key_pair_1.KeyPair;
      },
    });
    Object.defineProperty(exports2, "KeyPairEd25519", {
      enumerable: true,
      get: function () {
        return key_pair_1.KeyPairEd25519;
      },
    });
    var errors_1 = require_errors7();
    Object.defineProperty(exports2, "logWarning", {
      enumerable: true,
      get: function () {
        return errors_1.logWarning;
      },
    });
  },
});

// node_modules/near-api-js/lib/transaction.js
var require_transaction = __commonJS({
  "node_modules/near-api-js/lib/transaction.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.transfer =
      exports2.stake =
      exports2.functionCallAccessKey =
      exports2.functionCall =
      exports2.fullAccessKey =
      exports2.deployContract =
      exports2.deleteKey =
      exports2.deleteAccount =
      exports2.createAccount =
      exports2.addKey =
      exports2.encodeDelegateAction =
      exports2.encodeSignedDelegate =
      exports2.Transaction =
      exports2.SignedTransaction =
      exports2.Signature =
      exports2.signTransaction =
      exports2.createTransaction =
      exports2.SCHEMA =
      exports2.Transfer =
      exports2.Stake =
      exports2.FunctionCallPermission =
      exports2.FunctionCall =
      exports2.FullAccessPermission =
      exports2.DeployContract =
      exports2.DeleteKey =
      exports2.DeleteAccount =
      exports2.CreateAccount =
      exports2.AddKey =
      exports2.AccessKeyPermission =
      exports2.AccessKey =
      exports2.Action =
      exports2.stringifyJsonOrBytes =
        void 0;
    var transactions_1 = require_lib7();
    Object.defineProperty(exports2, "stringifyJsonOrBytes", {
      enumerable: true,
      get: function () {
        return transactions_1.stringifyJsonOrBytes;
      },
    });
    Object.defineProperty(exports2, "Action", {
      enumerable: true,
      get: function () {
        return transactions_1.Action;
      },
    });
    Object.defineProperty(exports2, "AccessKey", {
      enumerable: true,
      get: function () {
        return transactions_1.AccessKey;
      },
    });
    Object.defineProperty(exports2, "AccessKeyPermission", {
      enumerable: true,
      get: function () {
        return transactions_1.AccessKeyPermission;
      },
    });
    Object.defineProperty(exports2, "AddKey", {
      enumerable: true,
      get: function () {
        return transactions_1.AddKey;
      },
    });
    Object.defineProperty(exports2, "CreateAccount", {
      enumerable: true,
      get: function () {
        return transactions_1.CreateAccount;
      },
    });
    Object.defineProperty(exports2, "DeleteAccount", {
      enumerable: true,
      get: function () {
        return transactions_1.DeleteAccount;
      },
    });
    Object.defineProperty(exports2, "DeleteKey", {
      enumerable: true,
      get: function () {
        return transactions_1.DeleteKey;
      },
    });
    Object.defineProperty(exports2, "DeployContract", {
      enumerable: true,
      get: function () {
        return transactions_1.DeployContract;
      },
    });
    Object.defineProperty(exports2, "FullAccessPermission", {
      enumerable: true,
      get: function () {
        return transactions_1.FullAccessPermission;
      },
    });
    Object.defineProperty(exports2, "FunctionCall", {
      enumerable: true,
      get: function () {
        return transactions_1.FunctionCall;
      },
    });
    Object.defineProperty(exports2, "FunctionCallPermission", {
      enumerable: true,
      get: function () {
        return transactions_1.FunctionCallPermission;
      },
    });
    Object.defineProperty(exports2, "Stake", {
      enumerable: true,
      get: function () {
        return transactions_1.Stake;
      },
    });
    Object.defineProperty(exports2, "Transfer", {
      enumerable: true,
      get: function () {
        return transactions_1.Transfer;
      },
    });
    Object.defineProperty(exports2, "SCHEMA", {
      enumerable: true,
      get: function () {
        return transactions_1.SCHEMA;
      },
    });
    Object.defineProperty(exports2, "createTransaction", {
      enumerable: true,
      get: function () {
        return transactions_1.createTransaction;
      },
    });
    Object.defineProperty(exports2, "signTransaction", {
      enumerable: true,
      get: function () {
        return transactions_1.signTransaction;
      },
    });
    Object.defineProperty(exports2, "Signature", {
      enumerable: true,
      get: function () {
        return transactions_1.Signature;
      },
    });
    Object.defineProperty(exports2, "SignedTransaction", {
      enumerable: true,
      get: function () {
        return transactions_1.SignedTransaction;
      },
    });
    Object.defineProperty(exports2, "Transaction", {
      enumerable: true,
      get: function () {
        return transactions_1.Transaction;
      },
    });
    Object.defineProperty(exports2, "encodeSignedDelegate", {
      enumerable: true,
      get: function () {
        return transactions_1.encodeSignedDelegate;
      },
    });
    Object.defineProperty(exports2, "encodeDelegateAction", {
      enumerable: true,
      get: function () {
        return transactions_1.encodeDelegateAction;
      },
    });
    var transactions_2 = require_lib7();
    var addKey = (publicKey, accessKey) =>
      transactions_2.actionCreators.addKey(publicKey, accessKey);
    exports2.addKey = addKey;
    var createAccount = () => transactions_2.actionCreators.createAccount();
    exports2.createAccount = createAccount;
    var deleteAccount = (beneficiaryId) =>
      transactions_2.actionCreators.deleteAccount(beneficiaryId);
    exports2.deleteAccount = deleteAccount;
    var deleteKey = (publicKey) =>
      transactions_2.actionCreators.deleteKey(publicKey);
    exports2.deleteKey = deleteKey;
    var deployContract = (code) =>
      transactions_2.actionCreators.deployContract(code);
    exports2.deployContract = deployContract;
    var fullAccessKey = () => transactions_2.actionCreators.fullAccessKey();
    exports2.fullAccessKey = fullAccessKey;
    var functionCall = (
      methodName,
      args,
      gas,
      deposit,
      stringify,
      jsContract
    ) =>
      transactions_2.actionCreators.functionCall(
        methodName,
        args,
        gas,
        deposit,
        stringify,
        jsContract
      );
    exports2.functionCall = functionCall;
    var functionCallAccessKey = (receiverId, methodNames, allowance) =>
      transactions_2.actionCreators.functionCallAccessKey(
        receiverId,
        methodNames,
        allowance
      );
    exports2.functionCallAccessKey = functionCallAccessKey;
    var stake = (stake2, publicKey) =>
      transactions_2.actionCreators.stake(stake2, publicKey);
    exports2.stake = stake;
    var transfer = (deposit) => transactions_2.actionCreators.transfer(deposit);
    exports2.transfer = transfer;
  },
});

// node_modules/near-api-js/lib/validators.js
var require_validators2 = __commonJS({
  "node_modules/near-api-js/lib/validators.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.findSeatPrice = exports2.diffEpochValidators = void 0;
    var utils_1 = require_lib6();
    Object.defineProperty(exports2, "diffEpochValidators", {
      enumerable: true,
      get: function () {
        return utils_1.diffEpochValidators;
      },
    });
    Object.defineProperty(exports2, "findSeatPrice", {
      enumerable: true,
      get: function () {
        return utils_1.findSeatPrice;
      },
    });
  },
});

// node_modules/near-api-js/lib/account.js
var require_account2 = __commonJS({
  "node_modules/near-api-js/lib/account.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Account = void 0;
    var accounts_1 = require_lib11();
    Object.defineProperty(exports2, "Account", {
      enumerable: true,
      get: function () {
        return accounts_1.Account;
      },
    });
  },
});

// node_modules/near-api-js/lib/account_multisig.js
var require_account_multisig2 = __commonJS({
  "node_modules/near-api-js/lib/account_multisig.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MultisigStateStatus =
      exports2.MultisigDeleteRequestRejectionError =
      exports2.MULTISIG_CONFIRM_METHODS =
      exports2.MULTISIG_CHANGE_METHODS =
      exports2.MULTISIG_DEPOSIT =
      exports2.MULTISIG_GAS =
      exports2.MULTISIG_ALLOWANCE =
      exports2.MULTISIG_STORAGE_KEY =
      exports2.AccountMultisig =
      exports2.Account2FA =
        void 0;
    var accounts_1 = require_lib11();
    Object.defineProperty(exports2, "Account2FA", {
      enumerable: true,
      get: function () {
        return accounts_1.Account2FA;
      },
    });
    Object.defineProperty(exports2, "AccountMultisig", {
      enumerable: true,
      get: function () {
        return accounts_1.AccountMultisig;
      },
    });
    Object.defineProperty(exports2, "MULTISIG_STORAGE_KEY", {
      enumerable: true,
      get: function () {
        return accounts_1.MULTISIG_STORAGE_KEY;
      },
    });
    Object.defineProperty(exports2, "MULTISIG_ALLOWANCE", {
      enumerable: true,
      get: function () {
        return accounts_1.MULTISIG_ALLOWANCE;
      },
    });
    Object.defineProperty(exports2, "MULTISIG_GAS", {
      enumerable: true,
      get: function () {
        return accounts_1.MULTISIG_GAS;
      },
    });
    Object.defineProperty(exports2, "MULTISIG_DEPOSIT", {
      enumerable: true,
      get: function () {
        return accounts_1.MULTISIG_DEPOSIT;
      },
    });
    Object.defineProperty(exports2, "MULTISIG_CHANGE_METHODS", {
      enumerable: true,
      get: function () {
        return accounts_1.MULTISIG_CHANGE_METHODS;
      },
    });
    Object.defineProperty(exports2, "MULTISIG_CONFIRM_METHODS", {
      enumerable: true,
      get: function () {
        return accounts_1.MULTISIG_CONFIRM_METHODS;
      },
    });
    Object.defineProperty(exports2, "MultisigDeleteRequestRejectionError", {
      enumerable: true,
      get: function () {
        return accounts_1.MultisigDeleteRequestRejectionError;
      },
    });
    Object.defineProperty(exports2, "MultisigStateStatus", {
      enumerable: true,
      get: function () {
        return accounts_1.MultisigStateStatus;
      },
    });
  },
});

// node_modules/near-api-js/lib/account_creator.js
var require_account_creator2 = __commonJS({
  "node_modules/near-api-js/lib/account_creator.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UrlAccountCreator =
      exports2.LocalAccountCreator =
      exports2.AccountCreator =
        void 0;
    var accounts_1 = require_lib11();
    Object.defineProperty(exports2, "AccountCreator", {
      enumerable: true,
      get: function () {
        return accounts_1.AccountCreator;
      },
    });
    Object.defineProperty(exports2, "LocalAccountCreator", {
      enumerable: true,
      get: function () {
        return accounts_1.LocalAccountCreator;
      },
    });
    Object.defineProperty(exports2, "UrlAccountCreator", {
      enumerable: true,
      get: function () {
        return accounts_1.UrlAccountCreator;
      },
    });
  },
});

// node_modules/near-api-js/lib/connection.js
var require_connection2 = __commonJS({
  "node_modules/near-api-js/lib/connection.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Connection = void 0;
    var accounts_1 = require_lib11();
    Object.defineProperty(exports2, "Connection", {
      enumerable: true,
      get: function () {
        return accounts_1.Connection;
      },
    });
  },
});

// node_modules/near-api-js/lib/signer.js
var require_signer2 = __commonJS({
  "node_modules/near-api-js/lib/signer.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Signer = exports2.InMemorySigner = void 0;
    var signers_1 = require_lib9();
    Object.defineProperty(exports2, "InMemorySigner", {
      enumerable: true,
      get: function () {
        return signers_1.InMemorySigner;
      },
    });
    Object.defineProperty(exports2, "Signer", {
      enumerable: true,
      get: function () {
        return signers_1.Signer;
      },
    });
  },
});

// node_modules/near-api-js/lib/contract.js
var require_contract2 = __commonJS({
  "node_modules/near-api-js/lib/contract.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Contract = void 0;
    var accounts_1 = require_lib11();
    Object.defineProperty(exports2, "Contract", {
      enumerable: true,
      get: function () {
        return accounts_1.Contract;
      },
    });
  },
});

// node_modules/@near-js/wallet-account/lib/near.js
var require_near = __commonJS({
  "node_modules/@near-js/wallet-account/lib/near.js"(exports2) {
    var __awaiter =
      (exports2 && exports2.__awaiter) ||
      function (thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P
            ? value
            : new P(function (resolve) {
                resolve(value);
              });
        }
        return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done
              ? resolve(result.value)
              : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
    var __importDefault =
      (exports2 && exports2.__importDefault) ||
      function (mod) {
        return mod && mod.__esModule ? mod : { default: mod };
      };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Near = void 0;
    var accounts_1 = require_lib11();
    var bn_js_1 = __importDefault(require_bn());
    var Near = class {
      constructor(config) {
        var _a;
        this.config = config;
        this.connection = accounts_1.Connection.fromConfig({
          networkId: config.networkId,
          provider: {
            type: "JsonRpcProvider",
            args: { url: config.nodeUrl, headers: config.headers },
          },
          signer: config.signer || {
            type: "InMemorySigner",
            keyStore:
              config.keyStore ||
              ((_a = config.deps) === null || _a === void 0
                ? void 0
                : _a.keyStore),
          },
          jsvmAccountId: config.jsvmAccountId || `jsvm.${config.networkId}`,
        });
        if (config.masterAccount) {
          const initialBalance = config.initialBalance
            ? new bn_js_1.default(config.initialBalance)
            : new bn_js_1.default("500000000000000000000000000");
          this.accountCreator = new accounts_1.LocalAccountCreator(
            new accounts_1.Account(this.connection, config.masterAccount),
            initialBalance
          );
        } else if (config.helperUrl) {
          this.accountCreator = new accounts_1.UrlAccountCreator(
            this.connection,
            config.helperUrl
          );
        } else {
          this.accountCreator = null;
        }
      }
      /**
       * @param accountId near accountId used to interact with the network.
       */
      account(accountId) {
        return __awaiter(this, void 0, void 0, function* () {
          const account = new accounts_1.Account(this.connection, accountId);
          return account;
        });
      }
      /**
       * Create an account using the {@link account_creator!AccountCreator}. Either:
       * * using a masterAccount with {@link account_creator!LocalAccountCreator}
       * * using the helperUrl with {@link account_creator!UrlAccountCreator}
       * @see {@link NearConfig.masterAccount} and {@link NearConfig.helperUrl}
       *
       * @param accountId
       * @param publicKey
       */
      createAccount(accountId, publicKey) {
        return __awaiter(this, void 0, void 0, function* () {
          if (!this.accountCreator) {
            throw new Error(
              "Must specify account creator, either via masterAccount or helperUrl configuration settings."
            );
          }
          yield this.accountCreator.createAccount(accountId, publicKey);
          return new accounts_1.Account(this.connection, accountId);
        });
      }
    };
    exports2.Near = Near;
  },
});

// node_modules/@near-js/wallet-account/lib/wallet_account.js
var require_wallet_account = __commonJS({
  "node_modules/@near-js/wallet-account/lib/wallet_account.js"(exports2) {
    var __awaiter =
      (exports2 && exports2.__awaiter) ||
      function (thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P
            ? value
            : new P(function (resolve) {
                resolve(value);
              });
        }
        return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done
              ? resolve(result.value)
              : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
    var __importDefault =
      (exports2 && exports2.__importDefault) ||
      function (mod) {
        return mod && mod.__esModule ? mod : { default: mod };
      };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ConnectedWalletAccount = exports2.WalletConnection = void 0;
    var accounts_1 = require_lib11();
    var crypto_1 = require_lib3();
    var transactions_1 = require_lib7();
    var bn_js_1 = __importDefault(require_bn());
    var borsh_1 = require_lib();
    var LOGIN_WALLET_URL_SUFFIX = "/login/";
    var MULTISIG_HAS_METHOD = "add_request_and_confirm";
    var LOCAL_STORAGE_KEY_SUFFIX = "_wallet_auth_key";
    var PENDING_ACCESS_KEY_PREFIX = "pending_key";
    var WalletConnection = class {
      constructor(near, appKeyPrefix) {
        if (typeof appKeyPrefix !== "string") {
          throw new Error(
            "Please define a clear appKeyPrefix for this WalletConnection instance as the second argument to the constructor"
          );
        }
        if (typeof window === "undefined") {
          return new Proxy(this, {
            get(target, property) {
              if (property === "isSignedIn") {
                return () => false;
              }
              if (property === "getAccountId") {
                return () => "";
              }
              if (target[property] && typeof target[property] === "function") {
                return () => {
                  throw new Error(
                    "No window found in context, please ensure you are using WalletConnection on the browser"
                  );
                };
              }
              return target[property];
            },
          });
        }
        this._near = near;
        const authDataKey = appKeyPrefix + LOCAL_STORAGE_KEY_SUFFIX;
        const authData = JSON.parse(window.localStorage.getItem(authDataKey));
        this._networkId = near.config.networkId;
        this._walletBaseUrl = near.config.walletUrl;
        appKeyPrefix = appKeyPrefix || near.config.contractName || "default";
        this._keyStore = near.connection.signer.keyStore;
        this._authData = authData || { allKeys: [] };
        this._authDataKey = authDataKey;
        if (!this.isSignedIn()) {
          this._completeSignInPromise = this._completeSignInWithAccessKey();
        }
      }
      /**
       * Returns true, if this WalletConnection is authorized with the wallet.
       * @example
       * ```js
       * const wallet = new WalletConnection(near, 'my-app');
       * wallet.isSignedIn();
       * ```
       */
      isSignedIn() {
        return !!this._authData.accountId;
      }
      /**
       * Returns promise of completing signing in after redirecting from wallet
       * @example
       * ```js
       * // on login callback page
       * const wallet = new WalletConnection(near, 'my-app');
       * wallet.isSignedIn(); // false
       * await wallet.isSignedInAsync(); // true
       * ```
       */
      isSignedInAsync() {
        return __awaiter(this, void 0, void 0, function* () {
          if (!this._completeSignInPromise) {
            return this.isSignedIn();
          }
          yield this._completeSignInPromise;
          return this.isSignedIn();
        });
      }
      /**
       * Returns authorized Account ID.
       * @example
       * ```js
       * const wallet = new WalletConnection(near, 'my-app');
       * wallet.getAccountId();
       * ```
       */
      getAccountId() {
        return this._authData.accountId || "";
      }
      /**
       * Redirects current page to the wallet authentication page.
       * @param options An optional options object
       * @param options.contractId The NEAR account where the contract is deployed
       * @param options.successUrl URL to redirect upon success. Default: current url
       * @param options.failureUrl URL to redirect upon failure. Default: current url
       *
       * @example
       * ```js
       * const wallet = new WalletConnection(near, 'my-app');
       * // redirects to the NEAR Wallet
       * wallet.requestSignIn({ contractId: 'account-with-deploy-contract.near' });
       * ```
       */
      requestSignIn({ contractId, methodNames, successUrl, failureUrl }) {
        return __awaiter(this, void 0, void 0, function* () {
          const currentUrl = new URL(window.location.href);
          const newUrl = new URL(this._walletBaseUrl + LOGIN_WALLET_URL_SUFFIX);
          newUrl.searchParams.set("success_url", successUrl || currentUrl.href);
          newUrl.searchParams.set("failure_url", failureUrl || currentUrl.href);
          if (contractId) {
            const contractAccount = yield this._near.account(contractId);
            yield contractAccount.state();
            newUrl.searchParams.set("contract_id", contractId);
            const accessKey = crypto_1.KeyPair.fromRandom("ed25519");
            newUrl.searchParams.set(
              "public_key",
              accessKey.getPublicKey().toString()
            );
            yield this._keyStore.setKey(
              this._networkId,
              PENDING_ACCESS_KEY_PREFIX + accessKey.getPublicKey(),
              accessKey
            );
          }
          if (methodNames) {
            methodNames.forEach((methodName) => {
              newUrl.searchParams.append("methodNames", methodName);
            });
          }
          window.location.assign(newUrl.toString());
        });
      }
      /**
       * Requests the user to quickly sign for a transaction or batch of transactions by redirecting to the NEAR wallet.
       */
      requestSignTransactions({ transactions, meta, callbackUrl }) {
        return __awaiter(this, void 0, void 0, function* () {
          const currentUrl = new URL(window.location.href);
          const newUrl = new URL("sign", this._walletBaseUrl);
          newUrl.searchParams.set(
            "transactions",
            transactions
              .map((transaction) =>
                (0, borsh_1.serialize)(transactions_1.SCHEMA, transaction)
              )
              .map((serialized) => Buffer.from(serialized).toString("base64"))
              .join(",")
          );
          newUrl.searchParams.set(
            "callbackUrl",
            callbackUrl || currentUrl.href
          );
          if (meta) newUrl.searchParams.set("meta", meta);
          window.location.assign(newUrl.toString());
        });
      }
      /**
       * @hidden
       * Complete sign in for a given account id and public key. To be invoked by the app when getting a callback from the wallet.
       */
      _completeSignInWithAccessKey() {
        return __awaiter(this, void 0, void 0, function* () {
          const currentUrl = new URL(window.location.href);
          const publicKey = currentUrl.searchParams.get("public_key") || "";
          const allKeys = (currentUrl.searchParams.get("all_keys") || "").split(
            ","
          );
          const accountId = currentUrl.searchParams.get("account_id") || "";
          if (accountId) {
            const authData = {
              accountId,
              allKeys,
            };
            window.localStorage.setItem(
              this._authDataKey,
              JSON.stringify(authData)
            );
            if (publicKey) {
              yield this._moveKeyFromTempToPermanent(accountId, publicKey);
            }
            this._authData = authData;
          }
          currentUrl.searchParams.delete("public_key");
          currentUrl.searchParams.delete("all_keys");
          currentUrl.searchParams.delete("account_id");
          currentUrl.searchParams.delete("meta");
          currentUrl.searchParams.delete("transactionHashes");
          window.history.replaceState(
            {},
            document.title,
            currentUrl.toString()
          );
        });
      }
      /**
       * @hidden
       * @param accountId The NEAR account owning the given public key
       * @param publicKey The public key being set to the key store
       */
      _moveKeyFromTempToPermanent(accountId, publicKey) {
        return __awaiter(this, void 0, void 0, function* () {
          const keyPair = yield this._keyStore.getKey(
            this._networkId,
            PENDING_ACCESS_KEY_PREFIX + publicKey
          );
          yield this._keyStore.setKey(this._networkId, accountId, keyPair);
          yield this._keyStore.removeKey(
            this._networkId,
            PENDING_ACCESS_KEY_PREFIX + publicKey
          );
        });
      }
      /**
       * Sign out from the current account
       * @example
       * walletConnection.signOut();
       */
      signOut() {
        this._authData = {};
        window.localStorage.removeItem(this._authDataKey);
      }
      /**
       * Returns the current connected wallet account
       */
      account() {
        if (!this._connectedAccount) {
          this._connectedAccount = new ConnectedWalletAccount(
            this,
            this._near.connection,
            this._authData.accountId
          );
        }
        return this._connectedAccount;
      }
    };
    exports2.WalletConnection = WalletConnection;
    var ConnectedWalletAccount = class extends accounts_1.Account {
      constructor(walletConnection, connection, accountId) {
        super(connection, accountId);
        this.walletConnection = walletConnection;
      }
      // Overriding Account methods
      /**
       * Sign a transaction by redirecting to the NEAR Wallet
       * @see {@link WalletConnection.requestSignTransactions}
       */
      signAndSendTransaction({
        receiverId,
        actions,
        walletMeta,
        walletCallbackUrl = window.location.href,
      }) {
        const _super = Object.create(null, {
          signAndSendTransaction: { get: () => super.signAndSendTransaction },
        });
        return __awaiter(this, void 0, void 0, function* () {
          const localKey = yield this.connection.signer.getPublicKey(
            this.accountId,
            this.connection.networkId
          );
          let accessKey = yield this.accessKeyForTransaction(
            receiverId,
            actions,
            localKey
          );
          if (!accessKey) {
            throw new Error(
              `Cannot find matching key for transaction sent to ${receiverId}`
            );
          }
          if (localKey && localKey.toString() === accessKey.public_key) {
            try {
              return yield _super.signAndSendTransaction.call(this, {
                receiverId,
                actions,
              });
            } catch (e) {
              if (e.type === "NotEnoughAllowance") {
                accessKey = yield this.accessKeyForTransaction(
                  receiverId,
                  actions
                );
              } else {
                throw e;
              }
            }
          }
          const block = yield this.connection.provider.block({
            finality: "final",
          });
          const blockHash = (0, borsh_1.baseDecode)(block.header.hash);
          const publicKey = crypto_1.PublicKey.from(accessKey.public_key);
          const nonce = accessKey.access_key.nonce.add(new bn_js_1.default(1));
          const transaction = (0, transactions_1.createTransaction)(
            this.accountId,
            publicKey,
            receiverId,
            nonce,
            actions,
            blockHash
          );
          yield this.walletConnection.requestSignTransactions({
            transactions: [transaction],
            meta: walletMeta,
            callbackUrl: walletCallbackUrl,
          });
          return new Promise((resolve, reject) => {
            setTimeout(() => {
              reject(new Error("Failed to redirect to sign transaction"));
            }, 1e3);
          });
        });
      }
      /**
       * Check if given access key allows the function call or method attempted in transaction
       * @param accessKey Array of \{access_key: AccessKey, public_key: PublicKey\} items
       * @param receiverId The NEAR account attempting to have access
       * @param actions The action(s) needed to be checked for access
       */
      accessKeyMatchesTransaction(accessKey, receiverId, actions) {
        return __awaiter(this, void 0, void 0, function* () {
          const {
            access_key: { permission },
          } = accessKey;
          if (permission === "FullAccess") {
            return true;
          }
          if (permission.FunctionCall) {
            const {
              receiver_id: allowedReceiverId,
              method_names: allowedMethods,
            } = permission.FunctionCall;
            if (
              allowedReceiverId === this.accountId &&
              allowedMethods.includes(MULTISIG_HAS_METHOD)
            ) {
              return true;
            }
            if (allowedReceiverId === receiverId) {
              if (actions.length !== 1) {
                return false;
              }
              const [{ functionCall }] = actions;
              return (
                functionCall &&
                (!functionCall.deposit ||
                  functionCall.deposit.toString() === "0") && // TODO: Should support charging amount smaller than allowance?
                (allowedMethods.length === 0 ||
                  allowedMethods.includes(functionCall.methodName))
              );
            }
          }
          return false;
        });
      }
      /**
       * Helper function returning the access key (if it exists) to the receiver that grants the designated permission
       * @param receiverId The NEAR account seeking the access key for a transaction
       * @param actions The action(s) sought to gain access to
       * @param localKey A local public key provided to check for access
       */
      accessKeyForTransaction(receiverId, actions, localKey) {
        return __awaiter(this, void 0, void 0, function* () {
          const accessKeys = yield this.getAccessKeys();
          if (localKey) {
            const accessKey = accessKeys.find(
              (key) => key.public_key.toString() === localKey.toString()
            );
            if (
              accessKey &&
              (yield this.accessKeyMatchesTransaction(
                accessKey,
                receiverId,
                actions
              ))
            ) {
              return accessKey;
            }
          }
          const walletKeys = this.walletConnection._authData.allKeys;
          for (const accessKey of accessKeys) {
            if (
              walletKeys.indexOf(accessKey.public_key) !== -1 &&
              (yield this.accessKeyMatchesTransaction(
                accessKey,
                receiverId,
                actions
              ))
            ) {
              return accessKey;
            }
          }
          return null;
        });
      }
    };
    exports2.ConnectedWalletAccount = ConnectedWalletAccount;
  },
});

// node_modules/@near-js/wallet-account/lib/index.js
var require_lib12 = __commonJS({
  "node_modules/@near-js/wallet-account/lib/index.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WalletConnection =
      exports2.ConnectedWalletAccount =
      exports2.Near =
        void 0;
    var near_1 = require_near();
    Object.defineProperty(exports2, "Near", {
      enumerable: true,
      get: function () {
        return near_1.Near;
      },
    });
    var wallet_account_1 = require_wallet_account();
    Object.defineProperty(exports2, "ConnectedWalletAccount", {
      enumerable: true,
      get: function () {
        return wallet_account_1.ConnectedWalletAccount;
      },
    });
    Object.defineProperty(exports2, "WalletConnection", {
      enumerable: true,
      get: function () {
        return wallet_account_1.WalletConnection;
      },
    });
  },
});

// node_modules/near-api-js/lib/near.js
var require_near2 = __commonJS({
  "node_modules/near-api-js/lib/near.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Near = void 0;
    var wallet_account_1 = require_lib12();
    Object.defineProperty(exports2, "Near", {
      enumerable: true,
      get: function () {
        return wallet_account_1.Near;
      },
    });
  },
});

// node_modules/near-api-js/lib/wallet-account.js
var require_wallet_account2 = __commonJS({
  "node_modules/near-api-js/lib/wallet-account.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WalletConnection = exports2.ConnectedWalletAccount = void 0;
    var wallet_account_1 = require_lib12();
    Object.defineProperty(exports2, "ConnectedWalletAccount", {
      enumerable: true,
      get: function () {
        return wallet_account_1.ConnectedWalletAccount;
      },
    });
    Object.defineProperty(exports2, "WalletConnection", {
      enumerable: true,
      get: function () {
        return wallet_account_1.WalletConnection;
      },
    });
  },
});

// node_modules/near-api-js/lib/common-index.js
var require_common_index = __commonJS({
  "node_modules/near-api-js/lib/common-index.js"(exports2) {
    var __createBinding =
      (exports2 && exports2.__createBinding) ||
      (Object.create
        ? function (o, m, k, k2) {
            if (k2 === void 0) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);
            if (
              !desc ||
              ("get" in desc
                ? !m.__esModule
                : desc.writable || desc.configurable)
            ) {
              desc = {
                enumerable: true,
                get: function () {
                  return m[k];
                },
              };
            }
            Object.defineProperty(o, k2, desc);
          }
        : function (o, m, k, k2) {
            if (k2 === void 0) k2 = k;
            o[k2] = m[k];
          });
    var __setModuleDefault =
      (exports2 && exports2.__setModuleDefault) ||
      (Object.create
        ? function (o, v) {
            Object.defineProperty(o, "default", { enumerable: true, value: v });
          }
        : function (o, v) {
            o["default"] = v;
          });
    var __importStar =
      (exports2 && exports2.__importStar) ||
      function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WalletConnection =
      exports2.ConnectedWalletAccount =
      exports2.Near =
      exports2.KeyPair =
      exports2.Signer =
      exports2.InMemorySigner =
      exports2.Contract =
      exports2.Connection =
      exports2.Account =
      exports2.multisig =
      exports2.validators =
      exports2.transactions =
      exports2.utils =
      exports2.providers =
      exports2.accountCreator =
        void 0;
    var providers = __importStar(require_providers());
    exports2.providers = providers;
    var utils = __importStar(require_utils$1());
    exports2.utils = utils;
    var transactions = __importStar(require_transaction());
    exports2.transactions = transactions;
    var validators = __importStar(require_validators2());
    exports2.validators = validators;
    var account_1 = require_account2();
    Object.defineProperty(exports2, "Account", {
      enumerable: true,
      get: function () {
        return account_1.Account;
      },
    });
    var multisig = __importStar(require_account_multisig2());
    exports2.multisig = multisig;
    var accountCreator = __importStar(require_account_creator2());
    exports2.accountCreator = accountCreator;
    var connection_1 = require_connection2();
    Object.defineProperty(exports2, "Connection", {
      enumerable: true,
      get: function () {
        return connection_1.Connection;
      },
    });
    var signer_1 = require_signer2();
    Object.defineProperty(exports2, "Signer", {
      enumerable: true,
      get: function () {
        return signer_1.Signer;
      },
    });
    Object.defineProperty(exports2, "InMemorySigner", {
      enumerable: true,
      get: function () {
        return signer_1.InMemorySigner;
      },
    });
    var contract_1 = require_contract2();
    Object.defineProperty(exports2, "Contract", {
      enumerable: true,
      get: function () {
        return contract_1.Contract;
      },
    });
    var key_pair_1 = require_key_pair2();
    Object.defineProperty(exports2, "KeyPair", {
      enumerable: true,
      get: function () {
        return key_pair_1.KeyPair;
      },
    });
    var near_1 = require_near2();
    Object.defineProperty(exports2, "Near", {
      enumerable: true,
      get: function () {
        return near_1.Near;
      },
    });
    var wallet_account_1 = require_wallet_account2();
    Object.defineProperty(exports2, "ConnectedWalletAccount", {
      enumerable: true,
      get: function () {
        return wallet_account_1.ConnectedWalletAccount;
      },
    });
    Object.defineProperty(exports2, "WalletConnection", {
      enumerable: true,
      get: function () {
        return wallet_account_1.WalletConnection;
      },
    });
  },
});

// node_modules/near-api-js/lib/browser-connect.js
var require_browser_connect = __commonJS({
  "node_modules/near-api-js/lib/browser-connect.js"(exports2) {
    var __awaiter =
      (exports2 && exports2.__awaiter) ||
      function (thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P
            ? value
            : new P(function (resolve) {
                resolve(value);
              });
        }
        return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done
              ? resolve(result.value)
              : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.connect = void 0;
    var near_1 = require_near2();
    function connect(config) {
      return __awaiter(this, void 0, void 0, function* () {
        return new near_1.Near(config);
      });
    }
    exports2.connect = connect;
  },
});

// node_modules/capability/lib/CapabilityDetector.js
var require_CapabilityDetector = __commonJS({
  "node_modules/capability/lib/CapabilityDetector.js"(exports2, module2) {
    var CapabilityDetector = function () {
      this.tests = {};
      this.cache = {};
    };
    CapabilityDetector.prototype = {
      constructor: CapabilityDetector,
      define: function (name, test) {
        if (typeof name != "string" || !(test instanceof Function))
          throw new Error("Invalid capability definition.");
        if (this.tests[name])
          throw new Error(
            'Duplicated capability definition by "' + name + '".'
          );
        this.tests[name] = test;
      },
      check: function (name) {
        if (!this.test(name))
          throw new Error(
            'The current environment does not support "' +
              name +
              '", therefore we cannot continue.'
          );
      },
      test: function (name) {
        if (this.cache[name] !== void 0) return this.cache[name];
        if (!this.tests[name])
          throw new Error('Unknown capability with name "' + name + '".');
        var test = this.tests[name];
        this.cache[name] = !!test();
        return this.cache[name];
      },
    };
    module2.exports = CapabilityDetector;
  },
});

// node_modules/capability/lib/index.js
var require_lib13 = __commonJS({
  "node_modules/capability/lib/index.js"(exports2, module2) {
    var CapabilityDetector = require_CapabilityDetector();
    var detector = new CapabilityDetector();
    var capability = function (name) {
      return detector.test(name);
    };
    capability.define = function (name, test) {
      detector.define(name, test);
    };
    capability.check = function (name) {
      detector.check(name);
    };
    capability.test = capability;
    module2.exports = capability;
  },
});

// node_modules/capability/lib/definitions.js
var require_definitions = __commonJS({
  "node_modules/capability/lib/definitions.js"() {
    var capability = require_lib13();
    var define2 = capability.define;
    var test = capability.test;
    define2("strict mode", function () {
      return this === void 0;
    });
    define2("arguments.callee.caller", function () {
      try {
        return (
          (function () {
            return arguments.callee.caller;
          })() === arguments.callee
        );
      } catch (strictModeIsEnforced) {
        return false;
      }
    });
    define2("es5", function () {
      return (
        test("Array.prototype.forEach") &&
        test("Array.prototype.map") &&
        test("Function.prototype.bind") &&
        test("Object.create") &&
        test("Object.defineProperties") &&
        test("Object.defineProperty") &&
        test("Object.prototype.hasOwnProperty")
      );
    });
    define2("Array.prototype.forEach", function () {
      return Array.prototype.forEach;
    });
    define2("Array.prototype.map", function () {
      return Array.prototype.map;
    });
    define2("Function.prototype.bind", function () {
      return Function.prototype.bind;
    });
    define2("Object.create", function () {
      return Object.create;
    });
    define2("Object.defineProperties", function () {
      return Object.defineProperties;
    });
    define2("Object.defineProperty", function () {
      return Object.defineProperty;
    });
    define2("Object.prototype.hasOwnProperty", function () {
      return Object.prototype.hasOwnProperty;
    });
    define2("Error.captureStackTrace", function () {
      return Error.captureStackTrace;
    });
    define2("Error.prototype.stack", function () {
      try {
        throw new Error();
      } catch (e) {
        return e.stack || e.stacktrace;
      }
    });
  },
});

// node_modules/capability/index.js
var require_capability = __commonJS({
  "node_modules/capability/index.js"(exports2, module2) {
    require_definitions();
    module2.exports = require_lib13();
  },
});

// node_modules/capability/es5.js
var require_es5 = __commonJS({
  "node_modules/capability/es5.js"() {
    require_capability().check("es5");
  },
});

// node_modules/error-polyfill/lib/prepareStackTrace.js
var require_prepareStackTrace = __commonJS({
  "node_modules/error-polyfill/lib/prepareStackTrace.js"(exports2, module2) {
    var prepareStackTrace = function (throwable, frames, warnings) {
      var string = "";
      string += throwable.name || "Error";
      string += ": " + (throwable.message || "");
      if (warnings instanceof Array)
        for (var warningIndex in warnings) {
          var warning = warnings[warningIndex];
          string += "\n   # " + warning;
        }
      for (var frameIndex in frames) {
        var frame = frames[frameIndex];
        string += "\n   at " + frame.toString();
      }
      return string;
    };
    module2.exports = prepareStackTrace;
  },
});

// node_modules/error-polyfill/lib/v8.js
var require_v8 = __commonJS({
  "node_modules/error-polyfill/lib/v8.js"(exports2, module2) {
    var prepareStackTrace = require_prepareStackTrace();
    module2.exports = function () {
      Error.getStackTrace = function (throwable) {
        return throwable.stack;
      };
      return {
        prepareStackTrace,
      };
    };
  },
});

// node_modules/o3/lib/Class.js
var require_Class = __commonJS({
  "node_modules/o3/lib/Class.js"(exports2, module2) {
    var Class = function () {
      var options = /* @__PURE__ */ Object.create({
        Source: Object,
        config: {},
        buildArgs: [],
      });
      function checkOption(option) {
        var key = "config";
        if (option instanceof Function) key = "Source";
        else if (option instanceof Array) key = "buildArgs";
        else if (option instanceof Object) key = "config";
        else throw new Error("Invalid configuration option.");
        if (options.hasOwnProperty(key))
          throw new Error("Duplicated configuration option: " + key + ".");
        options[key] = option;
      }
      for (var index = 0, length = arguments.length; index < length; ++index)
        checkOption(arguments[index]);
      var Source = options.Source,
        config = options.config,
        buildArgs = options.buildArgs;
      return (Source.extend || Class.extend).call(Source, config, buildArgs);
    };
    Class.factory = function () {
      return function () {
        var instance = this;
        if (instance.build instanceof Function)
          instance.build.apply(instance, arguments);
        if (instance.init instanceof Function)
          instance.init.apply(instance, arguments);
      };
    };
    Class.extend = function (config, buildArgs) {
      var Source = this;
      if (!config) config = {};
      var Subject;
      if (
        config.prototype instanceof Object &&
        config.prototype.constructor !== Object
      )
        Subject = config.prototype.constructor;
      else if (config.factory instanceof Function)
        Subject = config.factory.call(Source);
      Subject = (Source.clone || Class.clone).call(Source, Subject, buildArgs);
      (Subject.merge || Class.merge).call(Subject, config);
      return Subject;
    };
    Class.prototype.extend = function (config, buildArgs) {
      var subject = this;
      var instance = (subject.clone || Class.prototype.clone).apply(
        subject,
        buildArgs
      );
      (instance.merge || Class.prototype.merge).call(instance, config);
      return instance;
    };
    Class.clone = function (Subject, buildArgs) {
      var Source = this;
      if (!(Subject instanceof Function))
        Subject = (Source.factory || Class.factory).call(Source);
      Subject.prototype = (
        Source.prototype.clone || Class.prototype.clone
      ).apply(Source.prototype, buildArgs || []);
      Subject.prototype.constructor = Subject;
      for (var staticProperty in Source)
        if (staticProperty !== "prototype")
          Subject[staticProperty] = Source[staticProperty];
      return Subject;
    };
    Class.prototype.clone = function () {
      var subject = this;
      var instance = Object.create(subject);
      if (instance.build instanceof Function)
        instance.build.apply(instance, arguments);
      return instance;
    };
    Class.merge = function (config) {
      var Subject = this;
      for (var staticProperty in config)
        if (staticProperty !== "prototype")
          Subject[staticProperty] = config[staticProperty];
      if (config.prototype instanceof Object)
        (Subject.prototype.merge || Class.prototype.merge).call(
          Subject.prototype,
          config.prototype
        );
      return Subject;
    };
    Class.prototype.merge = function (config) {
      var subject = this;
      for (var property in config)
        if (property !== "constructor") subject[property] = config[property];
      return subject;
    };
    Class.absorb = function (config) {
      var Subject = this;
      for (var staticProperty in config)
        if (
          staticProperty !== "prototype" &&
          (Subject[staticProperty] === void 0 ||
            Subject[staticProperty] === Function.prototype[staticProperty])
        )
          Subject[staticProperty] = config[staticProperty];
      if (config.prototype instanceof Object)
        (Subject.prototype.absorb || Class.prototype.absorb).call(
          Subject.prototype,
          config.prototype
        );
      return Subject;
    };
    Class.prototype.absorb = function (config) {
      var subject = this;
      for (var property in config)
        if (
          property !== "constructor" &&
          (subject[property] === void 0 ||
            subject[property] === Object.prototype[property])
        )
          subject[property] = config[property];
      return subject;
    };
    Class.getAncestor = function () {
      var Source = this;
      if (Source !== Source.prototype.constructor)
        return Source.prototype.constructor;
    };
    Class.newInstance = function () {
      var Subject = this;
      var instance = Object.create(this.prototype);
      Subject.apply(instance, arguments);
      return instance;
    };
    module2.exports = Class;
  },
});

// node_modules/o3/lib/abstractMethod.js
var require_abstractMethod = __commonJS({
  "node_modules/o3/lib/abstractMethod.js"(exports2, module2) {
    module2.exports = function () {
      throw new Error("Not implemented.");
    };
  },
});

// node_modules/o3/lib/index.js
var require_lib14 = __commonJS({
  "node_modules/o3/lib/index.js"(exports2, module2) {
    module2.exports = {
      Class: require_Class(),
      abstractMethod: require_abstractMethod(),
    };
  },
});

// node_modules/o3/index.js
var require_o3 = __commonJS({
  "node_modules/o3/index.js"(exports2, module2) {
    require_es5();
    module2.exports = require_lib14();
  },
});

// node_modules/u3/lib/cache.js
var require_cache = __commonJS({
  "node_modules/u3/lib/cache.js"(exports2, module2) {
    var cache = function (fn) {
      var called = false,
        store;
      if (!(fn instanceof Function)) {
        called = true;
        store = fn;
        fn = null;
      }
      return function () {
        if (!called) {
          called = true;
          store = fn.apply(this, arguments);
          fn = null;
        }
        return store;
      };
    };
    module2.exports = cache;
  },
});

// node_modules/u3/lib/eachCombination.js
var require_eachCombination = __commonJS({
  "node_modules/u3/lib/eachCombination.js"(exports2, module2) {
    module2.exports = function eachCombination(
      alternativesByDimension,
      callback,
      combination
    ) {
      if (!combination) combination = [];
      if (combination.length < alternativesByDimension.length) {
        var alternatives = alternativesByDimension[combination.length];
        for (var index in alternatives) {
          combination[combination.length] = alternatives[index];
          eachCombination(alternativesByDimension, callback, combination);
          --combination.length;
        }
      } else callback.apply(null, combination);
    };
  },
});

// node_modules/u3/lib/index.js
var require_lib15 = __commonJS({
  "node_modules/u3/lib/index.js"(exports2, module2) {
    module2.exports = {
      cache: require_cache(),
      eachCombination: require_eachCombination(),
    };
  },
});

// node_modules/u3/index.js
var require_u3 = __commonJS({
  "node_modules/u3/index.js"(exports2, module2) {
    module2.exports = require_lib15();
  },
});

// node_modules/error-polyfill/lib/non-v8/FrameStringSource.js
var require_FrameStringSource = __commonJS({
  "node_modules/error-polyfill/lib/non-v8/FrameStringSource.js"(
    exports2,
    module2
  ) {
    var Class = require_o3().Class;
    var abstractMethod = require_o3().abstractMethod;
    var eachCombination = require_u3().eachCombination;
    var cache = require_u3().cache;
    var capability = require_capability();
    var AbstractFrameStringSource = Class(Object, {
      prototype: {
        captureFrameStrings: function (frameShifts) {
          var error = this.createError();
          frameShifts.unshift(this.captureFrameStrings);
          frameShifts.unshift(this.createError);
          var capturedFrameStrings = this.getFrameStrings(error);
          var frameStrings = capturedFrameStrings.slice(frameShifts.length),
            functionValues = [];
          if (capability("arguments.callee.caller")) {
            var capturedFunctionValues = [
              this.createError,
              this.captureFrameStrings,
            ];
            try {
              var aCaller = arguments.callee;
              while ((aCaller = aCaller.caller))
                capturedFunctionValues.push(aCaller);
            } catch (useStrictError) {}
            functionValues = capturedFunctionValues.slice(frameShifts.length);
          }
          return {
            frameStrings,
            functionValues,
          };
        },
        getFrameStrings: function (error) {
          var message = error.message || "";
          var name = error.name || "";
          var stackString = this.getStackString(error);
          if (stackString === void 0) return;
          var stackStringChunks = stackString.split("\n");
          var fromPosition = 0;
          var toPosition = stackStringChunks.length;
          if (this.hasHeader)
            fromPosition +=
              name.split("\n").length + message.split("\n").length - 1;
          if (this.hasFooter) toPosition -= 1;
          return stackStringChunks.slice(fromPosition, toPosition);
        },
        createError: abstractMethod,
        getStackString: abstractMethod,
        hasHeader: void 0,
        hasFooter: void 0,
      },
    });
    var FrameStringSourceCalibrator = Class(Object, {
      prototype: {
        calibrateClass: function (FrameStringSource) {
          return (
            this.calibrateMethods(FrameStringSource) &&
            this.calibrateEnvelope(FrameStringSource)
          );
        },
        calibrateMethods: function (FrameStringSource) {
          try {
            eachCombination(
              [
                [
                  function (message) {
                    return new Error(message);
                  },
                  function (message) {
                    try {
                      throw new Error(message);
                    } catch (error) {
                      return error;
                    }
                  },
                ],
                [
                  function (error) {
                    return error.stack;
                  },
                  function (error) {
                    return error.stacktrace;
                  },
                ],
              ],
              function (createError, getStackString) {
                if (getStackString(createError()))
                  throw {
                    getStackString,
                    createError,
                  };
              }
            );
          } catch (workingImplementation) {
            Class.merge.call(FrameStringSource, {
              prototype: workingImplementation,
            });
            return true;
          }
          return false;
        },
        calibrateEnvelope: function (FrameStringSource) {
          var getStackString = FrameStringSource.prototype.getStackString;
          var createError = FrameStringSource.prototype.createError;
          var calibratorStackString = getStackString(createError("marker"));
          var calibratorFrameStrings = calibratorStackString.split("\n");
          Class.merge.call(FrameStringSource, {
            prototype: {
              hasHeader: /marker/.test(calibratorFrameStrings[0]),
              hasFooter:
                calibratorFrameStrings[calibratorFrameStrings.length - 1] ===
                "",
            },
          });
          return true;
        },
      },
    });
    module2.exports = {
      getClass: cache(function () {
        var FrameStringSource;
        if (FrameStringSource) return FrameStringSource;
        FrameStringSource = Class(AbstractFrameStringSource, {});
        var calibrator = new FrameStringSourceCalibrator();
        if (!calibrator.calibrateClass(FrameStringSource))
          throw new Error(
            "Cannot read Error.prototype.stack in this environment."
          );
        return FrameStringSource;
      }),
      getInstance: cache(function () {
        var FrameStringSource = this.getClass();
        var instance = new FrameStringSource();
        return instance;
      }),
    };
  },
});

// node_modules/error-polyfill/lib/non-v8/Frame.js
var require_Frame = __commonJS({
  "node_modules/error-polyfill/lib/non-v8/Frame.js"(exports2, module2) {
    var Class = require_o3().Class;
    var abstractMethod = require_o3().abstractMethod;
    var Frame = Class(Object, {
      prototype: {
        init: Class.prototype.merge,
        frameString: void 0,
        toString: function () {
          return this.frameString;
        },
        functionValue: void 0,
        getThis: abstractMethod,
        getTypeName: abstractMethod,
        getFunction: function () {
          return this.functionValue;
        },
        getFunctionName: abstractMethod,
        getMethodName: abstractMethod,
        getFileName: abstractMethod,
        getLineNumber: abstractMethod,
        getColumnNumber: abstractMethod,
        getEvalOrigin: abstractMethod,
        isTopLevel: abstractMethod,
        isEval: abstractMethod,
        isNative: abstractMethod,
        isConstructor: abstractMethod,
      },
    });
    module2.exports = Frame;
  },
});

// node_modules/error-polyfill/lib/non-v8/FrameStringParser.js
var require_FrameStringParser = __commonJS({
  "node_modules/error-polyfill/lib/non-v8/FrameStringParser.js"(
    exports2,
    module2
  ) {
    var Class = require_o3().Class;
    var Frame = require_Frame();
    var cache = require_u3().cache;
    var FrameStringParser = Class(Object, {
      prototype: {
        stackParser: null,
        frameParser: null,
        locationParsers: null,
        constructor: function (options) {
          Class.prototype.merge.call(this, options);
        },
        getFrames: function (frameStrings, functionValues) {
          var frames = [];
          for (
            var index = 0, length = frameStrings.length;
            index < length;
            ++index
          )
            frames[index] = this.getFrame(
              frameStrings[index],
              functionValues[index]
            );
          return frames;
        },
        getFrame: function (frameString, functionValue) {
          var config = {
            frameString,
            functionValue,
          };
          return new Frame(config);
        },
      },
    });
    module2.exports = {
      getClass: cache(function () {
        return FrameStringParser;
      }),
      getInstance: cache(function () {
        var FrameStringParser2 = this.getClass();
        var instance = new FrameStringParser2();
        return instance;
      }),
    };
  },
});

// node_modules/error-polyfill/lib/non-v8/index.js
var require_non_v8 = __commonJS({
  "node_modules/error-polyfill/lib/non-v8/index.js"(exports2, module2) {
    var FrameStringSource = require_FrameStringSource();
    var FrameStringParser = require_FrameStringParser();
    var cache = require_u3().cache;
    var prepareStackTrace = require_prepareStackTrace();
    module2.exports = function () {
      Error.captureStackTrace = function captureStackTrace(
        throwable,
        terminator
      ) {
        var warnings;
        var frameShifts = [captureStackTrace];
        if (terminator) {
          frameShifts.push(terminator);
        }
        var captured =
          FrameStringSource.getInstance().captureFrameStrings(frameShifts);
        Object.defineProperties(throwable, {
          stack: {
            configurable: true,
            get: cache(function () {
              var frames = FrameStringParser.getInstance().getFrames(
                captured.frameStrings,
                captured.functionValues
              );
              return (
                Error.prepareStackTrace || prepareStackTrace
              )(throwable, frames, warnings);
            }),
          },
          cachedStack: {
            configurable: true,
            writable: true,
            enumerable: false,
            value: true,
          },
        });
      };
      Error.getStackTrace = function (throwable) {
        if (throwable.cachedStack) return throwable.stack;
        var frameStrings =
            FrameStringSource.getInstance().getFrameStrings(throwable),
          frames = [],
          warnings;
        if (frameStrings)
          frames = FrameStringParser.getInstance().getFrames(frameStrings, []);
        else
          warnings = [
            "The stack is not readable by unthrown errors in this environment.",
          ];
        var stack = (Error.prepareStackTrace || prepareStackTrace)(
          throwable,
          frames,
          warnings
        );
        if (frameStrings)
          try {
            Object.defineProperties(throwable, {
              stack: {
                configurable: true,
                writable: true,
                enumerable: false,
                value: stack,
              },
              cachedStack: {
                configurable: true,
                writable: true,
                enumerable: false,
                value: true,
              },
            });
          } catch (nonConfigurableError) {}
        return stack;
      };
      return {
        prepareStackTrace,
      };
    };
  },
});

// node_modules/error-polyfill/lib/unsupported.js
var require_unsupported = __commonJS({
  "node_modules/error-polyfill/lib/unsupported.js"(exports2, module2) {
    var cache = require_u3().cache;
    var prepareStackTrace = require_prepareStackTrace();
    module2.exports = function () {
      Error.captureStackTrace = function (throwable, terminator) {
        Object.defineProperties(throwable, {
          stack: {
            configurable: true,
            get: cache(function () {
              return (
                Error.prepareStackTrace || prepareStackTrace
              )(throwable, []);
            }),
          },
          cachedStack: {
            configurable: true,
            writable: true,
            enumerable: false,
            value: true,
          },
        });
      };
      Error.getStackTrace = function (throwable) {
        if (throwable.cachedStack) return throwable.stack;
        var stack = (Error.prepareStackTrace || prepareStackTrace)(
          throwable,
          []
        );
        try {
          Object.defineProperties(throwable, {
            stack: {
              configurable: true,
              writable: true,
              enumerable: false,
              value: stack,
            },
            cachedStack: {
              configurable: true,
              writable: true,
              enumerable: false,
              value: true,
            },
          });
        } catch (nonConfigurableError) {}
        return stack;
      };
      return {
        prepareStackTrace,
      };
    };
  },
});

// node_modules/error-polyfill/lib/index.js
var require_lib16 = __commonJS({
  "node_modules/error-polyfill/lib/index.js"(exports2, module2) {
    require_es5();
    var capability = require_capability();
    var polyfill;
    if (capability("Error.captureStackTrace")) polyfill = require_v8();
    else if (capability("Error.prototype.stack")) polyfill = require_non_v8();
    else polyfill = require_unsupported();
    module2.exports = polyfill();
  },
});

// node_modules/error-polyfill/index.js
var require_error_polyfill = __commonJS({
  "node_modules/error-polyfill/index.js"(exports2, module2) {
    module2.exports = require_lib16();
  },
});

// node_modules/near-api-js/lib/browser-index.js
var require_browser_index2 = __commonJS({
  "node_modules/near-api-js/lib/browser-index.js"(exports2) {
    var __createBinding =
      (exports2 && exports2.__createBinding) ||
      (Object.create
        ? function (o, m, k, k2) {
            if (k2 === void 0) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);
            if (
              !desc ||
              ("get" in desc
                ? !m.__esModule
                : desc.writable || desc.configurable)
            ) {
              desc = {
                enumerable: true,
                get: function () {
                  return m[k];
                },
              };
            }
            Object.defineProperty(o, k2, desc);
          }
        : function (o, m, k, k2) {
            if (k2 === void 0) k2 = k;
            o[k2] = m[k];
          });
    var __setModuleDefault =
      (exports2 && exports2.__setModuleDefault) ||
      (Object.create
        ? function (o, v) {
            Object.defineProperty(o, "default", { enumerable: true, value: v });
          }
        : function (o, v) {
            o["default"] = v;
          });
    var __importStar =
      (exports2 && exports2.__importStar) ||
      function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    var __exportStar =
      (exports2 && exports2.__exportStar) ||
      function (m, exports3) {
        for (var p in m)
          if (
            p !== "default" &&
            !Object.prototype.hasOwnProperty.call(exports3, p)
          )
            __createBinding(exports3, m, p);
      };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.keyStores = void 0;
    exports2.keyStores = __importStar(require_browser_index());
    __exportStar(require_common_index(), exports2);
    __exportStar(require_browser_connect(), exports2);
    require_error_polyfill();
  },
});
/*! Bundled license information:

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

mustache/mustache.js:
  (*!
   * mustache.js - Logic-less {{mustache}} templates with JavaScript
   * http://github.com/janl/mustache.js
   *)

depd/lib/browser/index.js:
  (*!
   * depd
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

js-sha256/src/sha256.js:
  (**
   * [js-sha256]{@link https://github.com/emn178/js-sha256}
   *
   * @version 0.9.0
   * @author Chen, Yi-Cyuan [emn178@gmail.com]
   * @copyright Chen, Yi-Cyuan 2014-2017
   * @license MIT
   *)

depd/lib/browser/index.js:
  (*!
   * depd
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

statuses/index.js:
  (*!
   * statuses
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2016 Douglas Christopher Wilson
   * MIT Licensed
   *)

toidentifier/index.js:
  (*!
   * toidentifier
   * Copyright(c) 2016 Douglas Christopher Wilson
   * MIT Licensed
   *)

http-errors/index.js:
  (*!
   * http-errors
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2016 Douglas Christopher Wilson
   * MIT Licensed
   *)

uri-js/dist/es5/uri.all.js:
  (** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js *)
*/

// node_modules/events/events.js
var require_events = __commonJS({
  "node_modules/events/events.js"(exports, module) {
    var R = typeof Reflect === "object" ? Reflect : null;
    var ReflectApply =
      R && typeof R.apply === "function"
        ? R.apply
        : function ReflectApply2(target, receiver, args) {
            return Function.prototype.apply.call(target, receiver, args);
          };
    var ReflectOwnKeys;
    if (R && typeof R.ownKeys === "function") {
      ReflectOwnKeys = R.ownKeys;
    } else if (Object.getOwnPropertySymbols) {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target).concat(
          Object.getOwnPropertySymbols(target)
        );
      };
    } else {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target);
      };
    }
    function ProcessEmitWarning(warning) {
      if (console && console.warn) console.warn(warning);
    }
    var NumberIsNaN =
      Number.isNaN ||
      function NumberIsNaN2(value) {
        return value !== value;
      };
    function EventEmitter2() {
      EventEmitter2.init.call(this);
    }
    module.exports = EventEmitter2;
    module.exports.once = once;
    EventEmitter2.EventEmitter = EventEmitter2;
    EventEmitter2.prototype._events = void 0;
    EventEmitter2.prototype._eventsCount = 0;
    EventEmitter2.prototype._maxListeners = void 0;
    var defaultMaxListeners = 10;
    function checkListener(listener2) {
      if (typeof listener2 !== "function") {
        throw new TypeError(
          'The "listener" argument must be of type Function. Received type ' +
            typeof listener2
        );
      }
    }
    Object.defineProperty(EventEmitter2, "defaultMaxListeners", {
      enumerable: true,
      get: function () {
        return defaultMaxListeners;
      },
      set: function (arg) {
        if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
          throw new RangeError(
            'The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' +
              arg +
              "."
          );
        }
        defaultMaxListeners = arg;
      },
    });
    EventEmitter2.init = function () {
      if (
        this._events === void 0 ||
        this._events === Object.getPrototypeOf(this)._events
      ) {
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter2.prototype.setMaxListeners = function setMaxListeners(n) {
      if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
        throw new RangeError(
          'The value of "n" is out of range. It must be a non-negative number. Received ' +
            n +
            "."
        );
      }
      this._maxListeners = n;
      return this;
    };
    function _getMaxListeners(that) {
      if (that._maxListeners === void 0)
        return EventEmitter2.defaultMaxListeners;
      return that._maxListeners;
    }
    EventEmitter2.prototype.getMaxListeners = function getMaxListeners() {
      return _getMaxListeners(this);
    };
    EventEmitter2.prototype.emit = function emit(type) {
      var args = [];
      for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
      var doError = type === "error";
      var events = this._events;
      if (events !== void 0) doError = doError && events.error === void 0;
      else if (!doError) return false;
      if (doError) {
        var er;
        if (args.length > 0) er = args[0];
        if (er instanceof Error) {
          throw er;
        }
        var err = new Error(
          "Unhandled error." + (er ? " (" + er.message + ")" : "")
        );
        err.context = er;
        throw err;
      }
      var handler = events[type];
      if (handler === void 0) return false;
      if (typeof handler === "function") {
        ReflectApply(handler, this, args);
      } else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i) ReflectApply(listeners[i], this, args);
      }
      return true;
    };
    function _addListener(target, type, listener2, prepend) {
      var m;
      var events;
      var existing;
      checkListener(listener2);
      events = target._events;
      if (events === void 0) {
        events = target._events = /* @__PURE__ */ Object.create(null);
        target._eventsCount = 0;
      } else {
        if (events.newListener !== void 0) {
          target.emit(
            "newListener",
            type,
            listener2.listener ? listener2.listener : listener2
          );
          events = target._events;
        }
        existing = events[type];
      }
      if (existing === void 0) {
        existing = events[type] = listener2;
        ++target._eventsCount;
      } else {
        if (typeof existing === "function") {
          existing = events[type] = prepend
            ? [listener2, existing]
            : [existing, listener2];
        } else if (prepend) {
          existing.unshift(listener2);
        } else {
          existing.push(listener2);
        }
        m = _getMaxListeners(target);
        if (m > 0 && existing.length > m && !existing.warned) {
          existing.warned = true;
          var w = new Error(
            "Possible EventEmitter memory leak detected. " +
              existing.length +
              " " +
              String(type) +
              " listeners added. Use emitter.setMaxListeners() to increase limit"
          );
          w.name = "MaxListenersExceededWarning";
          w.emitter = target;
          w.type = type;
          w.count = existing.length;
          ProcessEmitWarning(w);
        }
      }
      return target;
    }
    EventEmitter2.prototype.addListener = function addListener(
      type,
      listener2
    ) {
      return _addListener(this, type, listener2, false);
    };
    EventEmitter2.prototype.on = EventEmitter2.prototype.addListener;
    EventEmitter2.prototype.prependListener = function prependListener(
      type,
      listener2
    ) {
      return _addListener(this, type, listener2, true);
    };
    function onceWrapper() {
      if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0) return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
      }
    }
    function _onceWrap(target, type, listener2) {
      var state = {
        fired: false,
        wrapFn: void 0,
        target,
        type,
        listener: listener2,
      };
      var wrapped = onceWrapper.bind(state);
      wrapped.listener = listener2;
      state.wrapFn = wrapped;
      return wrapped;
    }
    EventEmitter2.prototype.once = function once2(type, listener2) {
      checkListener(listener2);
      this.on(type, _onceWrap(this, type, listener2));
      return this;
    };
    EventEmitter2.prototype.prependOnceListener = function prependOnceListener(
      type,
      listener2
    ) {
      checkListener(listener2);
      this.prependListener(type, _onceWrap(this, type, listener2));
      return this;
    };
    EventEmitter2.prototype.removeListener = function removeListener(
      type,
      listener2
    ) {
      var list, events, position, i, originalListener;
      checkListener(listener2);
      events = this._events;
      if (events === void 0) return this;
      list = events[type];
      if (list === void 0) return this;
      if (list === listener2 || list.listener === listener2) {
        if (--this._eventsCount === 0)
          this._events = /* @__PURE__ */ Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit("removeListener", type, list.listener || listener2);
        }
      } else if (typeof list !== "function") {
        position = -1;
        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener2 || list[i].listener === listener2) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }
        if (position < 0) return this;
        if (position === 0) list.shift();
        else {
          spliceOne(list, position);
        }
        if (list.length === 1) events[type] = list[0];
        if (events.removeListener !== void 0)
          this.emit("removeListener", type, originalListener || listener2);
      }
      return this;
    };
    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
    EventEmitter2.prototype.removeAllListeners = function removeAllListeners(
      type
    ) {
      var listeners, events, i;
      events = this._events;
      if (events === void 0) return this;
      if (events.removeListener === void 0) {
        if (arguments.length === 0) {
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== void 0) {
          if (--this._eventsCount === 0)
            this._events = /* @__PURE__ */ Object.create(null);
          else delete events[type];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys2 = Object.keys(events);
        var key;
        for (i = 0; i < keys2.length; ++i) {
          key = keys2[i];
          if (key === "removeListener") continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
        return this;
      }
      listeners = events[type];
      if (typeof listeners === "function") {
        this.removeListener(type, listeners);
      } else if (listeners !== void 0) {
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }
      return this;
    };
    function _listeners(target, type, unwrap) {
      var events = target._events;
      if (events === void 0) return [];
      var evlistener = events[type];
      if (evlistener === void 0) return [];
      if (typeof evlistener === "function")
        return unwrap ? [evlistener.listener || evlistener] : [evlistener];
      return unwrap
        ? unwrapListeners(evlistener)
        : arrayClone(evlistener, evlistener.length);
    }
    EventEmitter2.prototype.listeners = function listeners(type) {
      return _listeners(this, type, true);
    };
    EventEmitter2.prototype.rawListeners = function rawListeners(type) {
      return _listeners(this, type, false);
    };
    EventEmitter2.listenerCount = function (emitter, type) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type);
      } else {
        return listenerCount.call(emitter, type);
      }
    };
    EventEmitter2.prototype.listenerCount = listenerCount;
    function listenerCount(type) {
      var events = this._events;
      if (events !== void 0) {
        var evlistener = events[type];
        if (typeof evlistener === "function") {
          return 1;
        } else if (evlistener !== void 0) {
          return evlistener.length;
        }
      }
      return 0;
    }
    EventEmitter2.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
    };
    function arrayClone(arr, n) {
      var copy = new Array(n);
      for (var i = 0; i < n; ++i) copy[i] = arr[i];
      return copy;
    }
    function spliceOne(list, index) {
      for (; index + 1 < list.length; index++) list[index] = list[index + 1];
      list.pop();
    }
    function unwrapListeners(arr) {
      var ret = new Array(arr.length);
      for (var i = 0; i < ret.length; ++i) {
        ret[i] = arr[i].listener || arr[i];
      }
      return ret;
    }
    function once(emitter, name) {
      return new Promise(function (resolve2, reject2) {
        function errorListener(err) {
          emitter.removeListener(name, resolver);
          reject2(err);
        }
        function resolver() {
          if (typeof emitter.removeListener === "function") {
            emitter.removeListener("error", errorListener);
          }
          resolve2([].slice.call(arguments));
        }
        eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
        if (name !== "error") {
          addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
        }
      });
    }
    function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
      if (typeof emitter.on === "function") {
        eventTargetAgnosticAddListener(emitter, "error", handler, flags);
      }
    }
    function eventTargetAgnosticAddListener(emitter, name, listener2, flags) {
      if (typeof emitter.on === "function") {
        if (flags.once) {
          emitter.once(name, listener2);
        } else {
          emitter.on(name, listener2);
        }
      } else if (typeof emitter.addEventListener === "function") {
        emitter.addEventListener(name, function wrapListener(arg) {
          if (flags.once) {
            emitter.removeEventListener(name, wrapListener);
          }
          listener2(arg);
        });
      } else {
        throw new TypeError(
          'The "emitter" argument must be of type EventEmitter. Received type ' +
            typeof emitter
        );
      }
    }
  },
});

// node_modules/@near-wallet-selector/core/index.js
var nearAPI$1 = __toESM(require_browser_index2());
__toESM(require_browser_index2());
var import_events = __toESM(require_events());

// node_modules/rxjs/node_modules/tslib/tslib.es6.mjs
var extendStatics = function (d, b) {
  extendStatics =
    Object.setPrototypeOf ||
    ({ __proto__: [] } instanceof Array &&
      function (d2, b2) {
        d2.__proto__ = b2;
      }) ||
    function (d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
    };
  return extendStatics(d, b);
};
function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError(
      "Class extends value " + String(b) + " is not a constructor or null"
    );
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype =
    b === null ? Object.create(b) : ((__.prototype = b.prototype), new __());
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator,
    m = s && o[s],
    i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function () {
        if (o && i >= o.length) o = void 0;
        return { value: o && o[i++], done: !o };
      },
    };
  throw new TypeError(
    s ? "Object is not iterable." : "Symbol.iterator is not defined."
  );
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o),
    r,
    ar2 = [],
    e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar2.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar2;
}
function __spreadArray(to, from2, pack2) {
  if (pack2 || arguments.length === 2)
    for (var i = 0, l = from2.length, ar2; i < l; i++) {
      if (ar2 || !(i in from2)) {
        if (!ar2) ar2 = Array.prototype.slice.call(from2, 0, i);
        ar2[i] = from2[i];
      }
    }
  return to.concat(ar2 || Array.prototype.slice.call(from2));
}

// node_modules/rxjs/dist/esm5/internal/util/isFunction.js
function isFunction(value) {
  return typeof value === "function";
}

// node_modules/rxjs/dist/esm5/internal/util/createErrorClass.js
function createErrorClass(createImpl) {
  var _super = function (instance) {
    Error.call(instance);
    instance.stack = new Error().stack;
  };
  var ctorFunc = createImpl(_super);
  ctorFunc.prototype = Object.create(Error.prototype);
  ctorFunc.prototype.constructor = ctorFunc;
  return ctorFunc;
}

// node_modules/rxjs/dist/esm5/internal/util/UnsubscriptionError.js
var UnsubscriptionError = createErrorClass(function (_super) {
  return function UnsubscriptionErrorImpl(errors) {
    _super(this);
    this.message = errors
      ? errors.length +
        " errors occurred during unsubscription:\n" +
        errors
          .map(function (err, i) {
            return i + 1 + ") " + err.toString();
          })
          .join("\n  ")
      : "";
    this.name = "UnsubscriptionError";
    this.errors = errors;
  };
});

// node_modules/rxjs/dist/esm5/internal/util/arrRemove.js
function arrRemove(arr, item) {
  if (arr) {
    var index = arr.indexOf(item);
    0 <= index && arr.splice(index, 1);
  }
}

// node_modules/rxjs/dist/esm5/internal/Subscription.js
var Subscription = (function () {
  function Subscription2(initialTeardown) {
    this.initialTeardown = initialTeardown;
    this.closed = false;
    this._parentage = null;
    this._finalizers = null;
  }
  Subscription2.prototype.unsubscribe = function () {
    var e_1, _a, e_2, _b;
    var errors;
    if (!this.closed) {
      this.closed = true;
      var _parentage = this._parentage;
      if (_parentage) {
        this._parentage = null;
        if (Array.isArray(_parentage)) {
          try {
            for (
              var _parentage_1 = __values(_parentage),
                _parentage_1_1 = _parentage_1.next();
              !_parentage_1_1.done;
              _parentage_1_1 = _parentage_1.next()
            ) {
              var parent_1 = _parentage_1_1.value;
              parent_1.remove(this);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (
                _parentage_1_1 &&
                !_parentage_1_1.done &&
                (_a = _parentage_1.return)
              )
                _a.call(_parentage_1);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
        } else {
          _parentage.remove(this);
        }
      }
      var initialFinalizer = this.initialTeardown;
      if (isFunction(initialFinalizer)) {
        try {
          initialFinalizer();
        } catch (e) {
          errors = e instanceof UnsubscriptionError ? e.errors : [e];
        }
      }
      var _finalizers = this._finalizers;
      if (_finalizers) {
        this._finalizers = null;
        try {
          for (
            var _finalizers_1 = __values(_finalizers),
              _finalizers_1_1 = _finalizers_1.next();
            !_finalizers_1_1.done;
            _finalizers_1_1 = _finalizers_1.next()
          ) {
            var finalizer = _finalizers_1_1.value;
            try {
              execFinalizer(finalizer);
            } catch (err) {
              errors = errors !== null && errors !== void 0 ? errors : [];
              if (err instanceof UnsubscriptionError) {
                errors = __spreadArray(
                  __spreadArray([], __read(errors)),
                  __read(err.errors)
                );
              } else {
                errors.push(err);
              }
            }
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (
              _finalizers_1_1 &&
              !_finalizers_1_1.done &&
              (_b = _finalizers_1.return)
            )
              _b.call(_finalizers_1);
          } finally {
            if (e_2) throw e_2.error;
          }
        }
      }
      if (errors) {
        throw new UnsubscriptionError(errors);
      }
    }
  };
  Subscription2.prototype.add = function (teardown) {
    var _a;
    if (teardown && teardown !== this) {
      if (this.closed) {
        execFinalizer(teardown);
      } else {
        if (teardown instanceof Subscription2) {
          if (teardown.closed || teardown._hasParent(this)) {
            return;
          }
          teardown._addParent(this);
        }
        (this._finalizers =
          (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(
          teardown
        );
      }
    }
  };
  Subscription2.prototype._hasParent = function (parent) {
    var _parentage = this._parentage;
    return (
      _parentage === parent ||
      (Array.isArray(_parentage) && _parentage.includes(parent))
    );
  };
  Subscription2.prototype._addParent = function (parent) {
    var _parentage = this._parentage;
    this._parentage = Array.isArray(_parentage)
      ? (_parentage.push(parent), _parentage)
      : _parentage
      ? [_parentage, parent]
      : parent;
  };
  Subscription2.prototype._removeParent = function (parent) {
    var _parentage = this._parentage;
    if (_parentage === parent) {
      this._parentage = null;
    } else if (Array.isArray(_parentage)) {
      arrRemove(_parentage, parent);
    }
  };
  Subscription2.prototype.remove = function (teardown) {
    var _finalizers = this._finalizers;
    _finalizers && arrRemove(_finalizers, teardown);
    if (teardown instanceof Subscription2) {
      teardown._removeParent(this);
    }
  };
  Subscription2.EMPTY = (function () {
    var empty2 = new Subscription2();
    empty2.closed = true;
    return empty2;
  })();
  return Subscription2;
})();
var EMPTY_SUBSCRIPTION = Subscription.EMPTY;
function isSubscription(value) {
  return (
    value instanceof Subscription ||
    (value &&
      "closed" in value &&
      isFunction(value.remove) &&
      isFunction(value.add) &&
      isFunction(value.unsubscribe))
  );
}
function execFinalizer(finalizer) {
  if (isFunction(finalizer)) {
    finalizer();
  } else {
    finalizer.unsubscribe();
  }
}

// node_modules/rxjs/dist/esm5/internal/config.js
var config = {
  onUnhandledError: null,
  onStoppedNotification: null,
  Promise: void 0,
  useDeprecatedSynchronousErrorHandling: false,
  useDeprecatedNextContext: false,
};

// node_modules/rxjs/dist/esm5/internal/scheduler/timeoutProvider.js
var timeoutProvider = {
  setTimeout: function (handler, timeout) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }
    return setTimeout.apply(
      void 0,
      __spreadArray([handler, timeout], __read(args))
    );
  },
  clearTimeout: function (handle) {
    return clearTimeout(handle);
  },
  delegate: void 0,
};

// node_modules/rxjs/dist/esm5/internal/util/reportUnhandledError.js
function reportUnhandledError(err) {
  timeoutProvider.setTimeout(function () {
    {
      throw err;
    }
  });
}

// node_modules/rxjs/dist/esm5/internal/util/noop.js
function noop$2() {}
function errorContext(cb) {
  {
    cb();
  }
}

// node_modules/rxjs/dist/esm5/internal/Subscriber.js
var Subscriber = (function (_super) {
  __extends(Subscriber2, _super);
  function Subscriber2(destination) {
    var _this = _super.call(this) || this;
    _this.isStopped = false;
    if (destination) {
      _this.destination = destination;
      if (isSubscription(destination)) {
        destination.add(_this);
      }
    } else {
      _this.destination = EMPTY_OBSERVER;
    }
    return _this;
  }
  Subscriber2.create = function (next, error, complete) {
    return new SafeSubscriber(next, error, complete);
  };
  Subscriber2.prototype.next = function (value) {
    if (this.isStopped);
    else {
      this._next(value);
    }
  };
  Subscriber2.prototype.error = function (err) {
    if (this.isStopped);
    else {
      this.isStopped = true;
      this._error(err);
    }
  };
  Subscriber2.prototype.complete = function () {
    if (this.isStopped);
    else {
      this.isStopped = true;
      this._complete();
    }
  };
  Subscriber2.prototype.unsubscribe = function () {
    if (!this.closed) {
      this.isStopped = true;
      _super.prototype.unsubscribe.call(this);
      this.destination = null;
    }
  };
  Subscriber2.prototype._next = function (value) {
    this.destination.next(value);
  };
  Subscriber2.prototype._error = function (err) {
    try {
      this.destination.error(err);
    } finally {
      this.unsubscribe();
    }
  };
  Subscriber2.prototype._complete = function () {
    try {
      this.destination.complete();
    } finally {
      this.unsubscribe();
    }
  };
  return Subscriber2;
})(Subscription);
var _bind = Function.prototype.bind;
function bind$8(fn, thisArg) {
  return _bind.call(fn, thisArg);
}
var ConsumerObserver = (function () {
  function ConsumerObserver2(partialObserver) {
    this.partialObserver = partialObserver;
  }
  ConsumerObserver2.prototype.next = function (value) {
    var partialObserver = this.partialObserver;
    if (partialObserver.next) {
      try {
        partialObserver.next(value);
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  ConsumerObserver2.prototype.error = function (err) {
    var partialObserver = this.partialObserver;
    if (partialObserver.error) {
      try {
        partialObserver.error(err);
      } catch (error) {
        handleUnhandledError(error);
      }
    } else {
      handleUnhandledError(err);
    }
  };
  ConsumerObserver2.prototype.complete = function () {
    var partialObserver = this.partialObserver;
    if (partialObserver.complete) {
      try {
        partialObserver.complete();
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  return ConsumerObserver2;
})();
var SafeSubscriber = (function (_super) {
  __extends(SafeSubscriber2, _super);
  function SafeSubscriber2(observerOrNext, error, complete) {
    var _this = _super.call(this) || this;
    var partialObserver;
    if (isFunction(observerOrNext) || !observerOrNext) {
      partialObserver = {
        next:
          observerOrNext !== null && observerOrNext !== void 0
            ? observerOrNext
            : void 0,
        error: error !== null && error !== void 0 ? error : void 0,
        complete: complete !== null && complete !== void 0 ? complete : void 0,
      };
    } else {
      var context_1;
      if (_this && config.useDeprecatedNextContext) {
        context_1 = Object.create(observerOrNext);
        context_1.unsubscribe = function () {
          return _this.unsubscribe();
        };
        partialObserver = {
          next: observerOrNext.next && bind$8(observerOrNext.next, context_1),
          error:
            observerOrNext.error && bind$8(observerOrNext.error, context_1),
          complete:
            observerOrNext.complete &&
            bind$8(observerOrNext.complete, context_1),
        };
      } else {
        partialObserver = observerOrNext;
      }
    }
    _this.destination = new ConsumerObserver(partialObserver);
    return _this;
  }
  return SafeSubscriber2;
})(Subscriber);
function handleUnhandledError(error) {
  {
    reportUnhandledError(error);
  }
}
function defaultErrorHandler(err) {
  throw err;
}
var EMPTY_OBSERVER = {
  closed: true,
  next: noop$2,
  error: defaultErrorHandler,
  complete: noop$2,
};

// node_modules/rxjs/dist/esm5/internal/symbol/observable.js
var observable = (function () {
  return (typeof Symbol === "function" && Symbol.observable) || "@@observable";
})();

// node_modules/rxjs/dist/esm5/internal/util/identity.js
function identity(x) {
  return x;
}

// node_modules/rxjs/dist/esm5/internal/util/pipe.js
function pipeFromArray(fns) {
  if (fns.length === 0) {
    return identity;
  }
  if (fns.length === 1) {
    return fns[0];
  }
  return function piped(input) {
    return fns.reduce(function (prev, fn) {
      return fn(prev);
    }, input);
  };
}

// node_modules/rxjs/dist/esm5/internal/Observable.js
var Observable = (function () {
  function Observable2(subscribe) {
    if (subscribe) {
      this._subscribe = subscribe;
    }
  }
  Observable2.prototype.lift = function (operator) {
    var observable2 = new Observable2();
    observable2.source = this;
    observable2.operator = operator;
    return observable2;
  };
  Observable2.prototype.subscribe = function (observerOrNext, error, complete) {
    var _this = this;
    var subscriber = isSubscriber(observerOrNext)
      ? observerOrNext
      : new SafeSubscriber(observerOrNext, error, complete);
    errorContext(function () {
      var _a = _this,
        operator = _a.operator,
        source = _a.source;
      subscriber.add(
        operator
          ? operator.call(subscriber, source)
          : source
          ? _this._subscribe(subscriber)
          : _this._trySubscribe(subscriber)
      );
    });
    return subscriber;
  };
  Observable2.prototype._trySubscribe = function (sink) {
    try {
      return this._subscribe(sink);
    } catch (err) {
      sink.error(err);
    }
  };
  Observable2.prototype.forEach = function (next, promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function (resolve2, reject2) {
      var subscriber = new SafeSubscriber({
        next: function (value) {
          try {
            next(value);
          } catch (err) {
            reject2(err);
            subscriber.unsubscribe();
          }
        },
        error: reject2,
        complete: resolve2,
      });
      _this.subscribe(subscriber);
    });
  };
  Observable2.prototype._subscribe = function (subscriber) {
    var _a;
    return (_a = this.source) === null || _a === void 0
      ? void 0
      : _a.subscribe(subscriber);
  };
  Observable2.prototype[observable] = function () {
    return this;
  };
  Observable2.prototype.pipe = function () {
    var operations = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      operations[_i] = arguments[_i];
    }
    return pipeFromArray(operations)(this);
  };
  Observable2.prototype.toPromise = function (promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function (resolve2, reject2) {
      var value;
      _this.subscribe(
        function (x) {
          return (value = x);
        },
        function (err) {
          return reject2(err);
        },
        function () {
          return resolve2(value);
        }
      );
    });
  };
  Observable2.create = function (subscribe) {
    return new Observable2(subscribe);
  };
  return Observable2;
})();
function getPromiseCtor(promiseCtor) {
  var _a;
  return (_a =
    promiseCtor !== null && promiseCtor !== void 0
      ? promiseCtor
      : config.Promise) !== null && _a !== void 0
    ? _a
    : Promise;
}
function isObserver(value) {
  return (
    value &&
    isFunction(value.next) &&
    isFunction(value.error) &&
    isFunction(value.complete)
  );
}
function isSubscriber(value) {
  return (
    (value && value instanceof Subscriber) ||
    (isObserver(value) && isSubscription(value))
  );
}

// node_modules/rxjs/dist/esm5/internal/util/lift.js
function hasLift(source) {
  return isFunction(
    source === null || source === void 0 ? void 0 : source.lift
  );
}
function operate(init) {
  return function (source) {
    if (hasLift(source)) {
      return source.lift(function (liftedSource) {
        try {
          return init(liftedSource, this);
        } catch (err) {
          this.error(err);
        }
      });
    }
    throw new TypeError("Unable to lift unknown Observable type");
  };
}

// node_modules/rxjs/dist/esm5/internal/operators/OperatorSubscriber.js
function createOperatorSubscriber(
  destination,
  onNext,
  onComplete,
  onError,
  onFinalize
) {
  return new OperatorSubscriber(
    destination,
    onNext,
    onComplete,
    onError,
    onFinalize
  );
}
var OperatorSubscriber = (function (_super) {
  __extends(OperatorSubscriber2, _super);
  function OperatorSubscriber2(
    destination,
    onNext,
    onComplete,
    onError,
    onFinalize,
    shouldUnsubscribe
  ) {
    var _this = _super.call(this, destination) || this;
    _this.onFinalize = onFinalize;
    _this.shouldUnsubscribe = shouldUnsubscribe;
    _this._next = onNext
      ? function (value) {
          try {
            onNext(value);
          } catch (err) {
            destination.error(err);
          }
        }
      : _super.prototype._next;
    _this._error = onError
      ? function (err) {
          try {
            onError(err);
          } catch (err2) {
            destination.error(err2);
          } finally {
            this.unsubscribe();
          }
        }
      : _super.prototype._error;
    _this._complete = onComplete
      ? function () {
          try {
            onComplete();
          } catch (err) {
            destination.error(err);
          } finally {
            this.unsubscribe();
          }
        }
      : _super.prototype._complete;
    return _this;
  }
  OperatorSubscriber2.prototype.unsubscribe = function () {
    var _a;
    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
      var closed_1 = this.closed;
      _super.prototype.unsubscribe.call(this);
      !closed_1 &&
        ((_a = this.onFinalize) === null || _a === void 0
          ? void 0
          : _a.call(this));
    }
  };
  return OperatorSubscriber2;
})(Subscriber);

// node_modules/rxjs/dist/esm5/internal/util/ObjectUnsubscribedError.js
var ObjectUnsubscribedError = createErrorClass(function (_super) {
  return function ObjectUnsubscribedErrorImpl() {
    _super(this);
    this.name = "ObjectUnsubscribedError";
    this.message = "object unsubscribed";
  };
});

// node_modules/rxjs/dist/esm5/internal/Subject.js
var Subject = (function (_super) {
  __extends(Subject2, _super);
  function Subject2() {
    var _this = _super.call(this) || this;
    _this.closed = false;
    _this.currentObservers = null;
    _this.observers = [];
    _this.isStopped = false;
    _this.hasError = false;
    _this.thrownError = null;
    return _this;
  }
  Subject2.prototype.lift = function (operator) {
    var subject = new AnonymousSubject(this, this);
    subject.operator = operator;
    return subject;
  };
  Subject2.prototype._throwIfClosed = function () {
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    }
  };
  Subject2.prototype.next = function (value) {
    var _this = this;
    errorContext(function () {
      var e_1, _a;
      _this._throwIfClosed();
      if (!_this.isStopped) {
        if (!_this.currentObservers) {
          _this.currentObservers = Array.from(_this.observers);
        }
        try {
          for (
            var _b = __values(_this.currentObservers), _c = _b.next();
            !_c.done;
            _c = _b.next()
          ) {
            var observer = _c.value;
            observer.next(value);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
      }
    });
  };
  Subject2.prototype.error = function (err) {
    var _this = this;
    errorContext(function () {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.hasError = _this.isStopped = true;
        _this.thrownError = err;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().error(err);
        }
      }
    });
  };
  Subject2.prototype.complete = function () {
    var _this = this;
    errorContext(function () {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.isStopped = true;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().complete();
        }
      }
    });
  };
  Subject2.prototype.unsubscribe = function () {
    this.isStopped = this.closed = true;
    this.observers = this.currentObservers = null;
  };
  Object.defineProperty(Subject2.prototype, "observed", {
    get: function () {
      var _a;
      return (
        ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) >
        0
      );
    },
    enumerable: false,
    configurable: true,
  });
  Subject2.prototype._trySubscribe = function (subscriber) {
    this._throwIfClosed();
    return _super.prototype._trySubscribe.call(this, subscriber);
  };
  Subject2.prototype._subscribe = function (subscriber) {
    this._throwIfClosed();
    this._checkFinalizedStatuses(subscriber);
    return this._innerSubscribe(subscriber);
  };
  Subject2.prototype._innerSubscribe = function (subscriber) {
    var _this = this;
    var _a = this,
      hasError = _a.hasError,
      isStopped = _a.isStopped,
      observers = _a.observers;
    if (hasError || isStopped) {
      return EMPTY_SUBSCRIPTION;
    }
    this.currentObservers = null;
    observers.push(subscriber);
    return new Subscription(function () {
      _this.currentObservers = null;
      arrRemove(observers, subscriber);
    });
  };
  Subject2.prototype._checkFinalizedStatuses = function (subscriber) {
    var _a = this,
      hasError = _a.hasError,
      thrownError = _a.thrownError,
      isStopped = _a.isStopped;
    if (hasError) {
      subscriber.error(thrownError);
    } else if (isStopped) {
      subscriber.complete();
    }
  };
  Subject2.prototype.asObservable = function () {
    var observable2 = new Observable();
    observable2.source = this;
    return observable2;
  };
  Subject2.create = function (destination, source) {
    return new AnonymousSubject(destination, source);
  };
  return Subject2;
})(Observable);
var AnonymousSubject = (function (_super) {
  __extends(AnonymousSubject2, _super);
  function AnonymousSubject2(destination, source) {
    var _this = _super.call(this) || this;
    _this.destination = destination;
    _this.source = source;
    return _this;
  }
  AnonymousSubject2.prototype.next = function (value) {
    var _a, _b;
    (_b =
      (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) ===
      null || _b === void 0
      ? void 0
      : _b.call(_a, value);
  };
  AnonymousSubject2.prototype.error = function (err) {
    var _a, _b;
    (_b =
      (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) ===
      null || _b === void 0
      ? void 0
      : _b.call(_a, err);
  };
  AnonymousSubject2.prototype.complete = function () {
    var _a, _b;
    (_b =
      (_a = this.destination) === null || _a === void 0
        ? void 0
        : _a.complete) === null || _b === void 0
      ? void 0
      : _b.call(_a);
  };
  AnonymousSubject2.prototype._subscribe = function (subscriber) {
    var _a, _b;
    return (_b =
      (_a = this.source) === null || _a === void 0
        ? void 0
        : _a.subscribe(subscriber)) !== null && _b !== void 0
      ? _b
      : EMPTY_SUBSCRIPTION;
  };
  return AnonymousSubject2;
})(Subject);

// node_modules/rxjs/dist/esm5/internal/BehaviorSubject.js
var BehaviorSubject = (function (_super) {
  __extends(BehaviorSubject2, _super);
  function BehaviorSubject2(_value) {
    var _this = _super.call(this) || this;
    _this._value = _value;
    return _this;
  }
  Object.defineProperty(BehaviorSubject2.prototype, "value", {
    get: function () {
      return this.getValue();
    },
    enumerable: false,
    configurable: true,
  });
  BehaviorSubject2.prototype._subscribe = function (subscriber) {
    var subscription = _super.prototype._subscribe.call(this, subscriber);
    !subscription.closed && subscriber.next(this._value);
    return subscription;
  };
  BehaviorSubject2.prototype.getValue = function () {
    var _a = this,
      hasError = _a.hasError,
      thrownError = _a.thrownError,
      _value = _a._value;
    if (hasError) {
      throw thrownError;
    }
    this._throwIfClosed();
    return _value;
  };
  BehaviorSubject2.prototype.next = function (value) {
    _super.prototype.next.call(this, (this._value = value));
  };
  return BehaviorSubject2;
})(Subject);

// node_modules/rxjs/dist/esm5/internal/operators/scanInternals.js
function scanInternals(
  accumulator,
  seed,
  hasSeed,
  emitOnNext,
  emitBeforeComplete
) {
  return function (source, subscriber) {
    var hasState = hasSeed;
    var state = seed;
    var index = 0;
    source.subscribe(
      createOperatorSubscriber(
        subscriber,
        function (value) {
          var i = index++;
          state = hasState
            ? accumulator(state, value, i)
            : ((hasState = true), value);
          emitOnNext && subscriber.next(state);
        },
        emitBeforeComplete &&
          function () {
            hasState && subscriber.next(state);
            subscriber.complete();
          }
      )
    );
  };
}

// node_modules/rxjs/dist/esm5/internal/operators/scan.js
function scan(accumulator, seed) {
  return operate(scanInternals(accumulator, seed, arguments.length >= 2, true));
}

// node_modules/@near-wallet-selector/core/index.js
__toESM(require_lib());
__toESM(require_sha256());
function __awaiter$3(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P
      ? value
      : new P(function (resolve2) {
          resolve2(value);
        });
  }
  return new (P || (P = Promise))(function (resolve2, reject2) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject2(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject2(e);
      }
    }
    function step(result) {
      result.done
        ? resolve2(result.value)
        : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
var Provider = class {
  constructor(url) {
    this.provider = new nearAPI$1.providers.JsonRpcProvider({
      url,
    });
  }
  query(params) {
    return this.provider.query(params);
  }
  viewAccessKey({ accountId, publicKey }) {
    return this.query({
      request_type: "view_access_key",
      finality: "final",
      account_id: accountId,
      public_key: publicKey,
    });
  }
  block(reference) {
    return this.provider.block(reference);
  }
  sendTransaction(signedTransaction) {
    return this.provider.sendTransaction(signedTransaction);
  }
};
var KEY_DELIMITER = ":";
var JsonStorage = class {
  constructor(storage, namespace) {
    this.storage = storage;
    this.namespace = Array.isArray(namespace)
      ? namespace.join(KEY_DELIMITER)
      : namespace;
  }
  resolveKey(key) {
    return [this.namespace, key].join(KEY_DELIMITER);
  }
  getItem(key) {
    return this.storage.getItem(this.resolveKey(key)).then((item) => {
      return typeof item === "string" ? JSON.parse(item) : null;
    });
  }
  setItem(key, value) {
    return this.storage.setItem(this.resolveKey(key), JSON.stringify(value));
  }
  removeItem(key) {
    return this.storage.removeItem(this.resolveKey(key));
  }
};
var commonjsGlobal$3 =
  typeof globalThis !== "undefined"
    ? globalThis
    : typeof window !== "undefined"
    ? window
    : typeof global !== "undefined"
    ? global
    : typeof self !== "undefined"
    ? self
    : {};
var check$3 = function (it) {
  return it && it.Math == Math && it;
};
var global$t =
  // eslint-disable-next-line es-x/no-global-this -- safe
  check$3(typeof globalThis == "object" && globalThis) ||
  check$3(typeof window == "object" && window) || // eslint-disable-next-line no-restricted-globals -- safe
  check$3(typeof self == "object" && self) ||
  check$3(typeof commonjsGlobal$3 == "object" && commonjsGlobal$3) || // eslint-disable-next-line no-new-func -- fallback
  (function () {
    return this;
  })() ||
  Function("return this")();
var objectGetOwnPropertyDescriptor$3 = {};
var fails$r = function (exec2) {
  try {
    return !!exec2();
  } catch (error) {
    return true;
  }
};
var fails$q = fails$r;
var descriptors$3 = !fails$q(function () {
  return (
    Object.defineProperty({}, 1, {
      get: function () {
        return 7;
      },
    })[1] != 7
  );
});
var fails$p = fails$r;
var functionBindNative$3 = !fails$p(function () {
  var test2 = function () {}.bind();
  return typeof test2 != "function" || test2.hasOwnProperty("prototype");
});
var NATIVE_BIND$3$2 = functionBindNative$3;
var call$l = Function.prototype.call;
var functionCall$3 = NATIVE_BIND$3$2
  ? call$l.bind(call$l)
  : function () {
      return call$l.apply(call$l, arguments);
    };
var objectPropertyIsEnumerable$3 = {};
var $propertyIsEnumerable$3 = {}.propertyIsEnumerable;
var getOwnPropertyDescriptor$2$2 = Object.getOwnPropertyDescriptor;
var NASHORN_BUG$3 =
  getOwnPropertyDescriptor$2$2 && !$propertyIsEnumerable$3.call({ 1: 2 }, 1);
objectPropertyIsEnumerable$3.f = NASHORN_BUG$3
  ? function propertyIsEnumerable(V) {
      var descriptor = getOwnPropertyDescriptor$2$2(this, V);
      return !!descriptor && descriptor.enumerable;
    }
  : $propertyIsEnumerable$3;
var createPropertyDescriptor$5$1 = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value,
  };
};
var NATIVE_BIND$2$2 = functionBindNative$3;
var FunctionPrototype$2$2 = Function.prototype;
var bind$7$1 = FunctionPrototype$2$2.bind;
var call$k = FunctionPrototype$2$2.call;
var uncurryThis$o = NATIVE_BIND$2$2 && bind$7$1.bind(call$k, call$k);
var functionUncurryThis$3 = NATIVE_BIND$2$2
  ? function (fn) {
      return fn && uncurryThis$o(fn);
    }
  : function (fn) {
      return (
        fn &&
        function () {
          return call$k.apply(fn, arguments);
        }
      );
    };
var uncurryThis$n = functionUncurryThis$3;
var toString$6 = uncurryThis$n({}.toString);
var stringSlice$3 = uncurryThis$n("".slice);
var classofRaw$1$2 = function (it) {
  return stringSlice$3(toString$6(it), 8, -1);
};
var uncurryThis$m = functionUncurryThis$3;
var fails$o = fails$r;
var classof$b = classofRaw$1$2;
var $Object$4$2 = Object;
var split$3 = uncurryThis$m("".split);
var indexedObject$3 = fails$o(function () {
  return !$Object$4$2("z").propertyIsEnumerable(0);
})
  ? function (it) {
      return classof$b(it) == "String" ? split$3(it, "") : $Object$4$2(it);
    }
  : $Object$4$2;
var $TypeError$f$1 = TypeError;
var requireObjectCoercible$5 = function (it) {
  if (it == void 0) throw $TypeError$f$1("Can't call method on " + it);
  return it;
};
var IndexedObject$3$1 = indexedObject$3;
var requireObjectCoercible$4$1 = requireObjectCoercible$5;
var toIndexedObject$6$1 = function (it) {
  return IndexedObject$3$1(requireObjectCoercible$4$1(it));
};
var isCallable$n = function (argument) {
  return typeof argument == "function";
};
var isCallable$m$1 = isCallable$n;
var isObject$d = function (it) {
  return typeof it == "object" ? it !== null : isCallable$m$1(it);
};
var global$s = global$t;
var isCallable$l$2 = isCallable$n;
var aFunction$3 = function (argument) {
  return isCallable$l$2(argument) ? argument : void 0;
};
var getBuiltIn$8$2 = function (namespace, method) {
  return arguments.length < 2
    ? aFunction$3(global$s[namespace])
    : global$s[namespace] && global$s[namespace][method];
};
var uncurryThis$l = functionUncurryThis$3;
var objectIsPrototypeOf$3 = uncurryThis$l({}.isPrototypeOf);
var getBuiltIn$7$2 = getBuiltIn$8$2;
var engineUserAgent$3 = getBuiltIn$7$2("navigator", "userAgent") || "";
var global$r = global$t;
var userAgent$5$1 = engineUserAgent$3;
var process$3$2 = global$r.process;
var Deno$1$3 = global$r.Deno;
var versions$3 =
  (process$3$2 && process$3$2.versions) || (Deno$1$3 && Deno$1$3.version);
var v8$3 = versions$3 && versions$3.v8;
var match$3;
var version$3;
if (v8$3) {
  match$3 = v8$3.split(".");
  version$3 = match$3[0] > 0 && match$3[0] < 4 ? 1 : +(match$3[0] + match$3[1]);
}
if (!version$3 && userAgent$5$1) {
  match$3 = userAgent$5$1.match(/Edge\/(\d+)/);
  if (!match$3 || match$3[1] >= 74) {
    match$3 = userAgent$5$1.match(/Chrome\/(\d+)/);
    if (match$3) version$3 = +match$3[1];
  }
}
var engineV8Version$3 = version$3;
var V8_VERSION$1$2 = engineV8Version$3;
var fails$n = fails$r;
var nativeSymbol$3 =
  !!Object.getOwnPropertySymbols &&
  !fails$n(function () {
    var symbol = Symbol();
    return (
      !String(symbol) ||
      !(Object(symbol) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
      (!Symbol.sham && V8_VERSION$1$2 && V8_VERSION$1$2 < 41)
    );
  });
var NATIVE_SYMBOL$1$3 = nativeSymbol$3;
var useSymbolAsUid$3 =
  NATIVE_SYMBOL$1$3 && !Symbol.sham && typeof Symbol.iterator == "symbol";
var getBuiltIn$6$2 = getBuiltIn$8$2;
var isCallable$k$2 = isCallable$n;
var isPrototypeOf$4$2 = objectIsPrototypeOf$3;
var USE_SYMBOL_AS_UID$1$3 = useSymbolAsUid$3;
var $Object$3$2 = Object;
var isSymbol$3$1 = USE_SYMBOL_AS_UID$1$3
  ? function (it) {
      return typeof it == "symbol";
    }
  : function (it) {
      var $Symbol = getBuiltIn$6$2("Symbol");
      return (
        isCallable$k$2($Symbol) &&
        isPrototypeOf$4$2($Symbol.prototype, $Object$3$2(it))
      );
    };
var $String$3$2 = String;
var tryToString$5$2 = function (argument) {
  try {
    return $String$3$2(argument);
  } catch (error) {
    return "Object";
  }
};
var isCallable$j$2 = isCallable$n;
var tryToString$4$2 = tryToString$5$2;
var $TypeError$e$1 = TypeError;
var aCallable$9$1 = function (argument) {
  if (isCallable$j$2(argument)) return argument;
  throw $TypeError$e$1(tryToString$4$2(argument) + " is not a function");
};
var aCallable$8$2 = aCallable$9$1;
var getMethod$4$1 = function (V, P) {
  var func = V[P];
  return func == null ? void 0 : aCallable$8$2(func);
};
var call$j = functionCall$3;
var isCallable$i$2 = isCallable$n;
var isObject$c = isObject$d;
var $TypeError$d$1 = TypeError;
var ordinaryToPrimitive$1$3 = function (input, pref) {
  var fn, val;
  if (
    pref === "string" &&
    isCallable$i$2((fn = input.toString)) &&
    !isObject$c((val = call$j(fn, input)))
  )
    return val;
  if (
    isCallable$i$2((fn = input.valueOf)) &&
    !isObject$c((val = call$j(fn, input)))
  )
    return val;
  if (
    pref !== "string" &&
    isCallable$i$2((fn = input.toString)) &&
    !isObject$c((val = call$j(fn, input)))
  )
    return val;
  throw $TypeError$d$1("Can't convert object to primitive value");
};
var shared$4$1 = { exports: {} };
var global$q = global$t;
var defineProperty$7 = Object.defineProperty;
var defineGlobalProperty$3$3 = function (key, value) {
  try {
    defineProperty$7(global$q, key, {
      value,
      configurable: true,
      writable: true,
    });
  } catch (error) {
    global$q[key] = value;
  }
  return value;
};
var global$p = global$t;
var defineGlobalProperty$2$3 = defineGlobalProperty$3$3;
var SHARED$3 = "__core-js_shared__";
var store$3$3 = global$p[SHARED$3] || defineGlobalProperty$2$3(SHARED$3, {});
var sharedStore$3 = store$3$3;
var store$2$3 = sharedStore$3;
(shared$4$1.exports = function (key, value) {
  return store$2$3[key] || (store$2$3[key] = value !== void 0 ? value : {});
})("versions", []).push({
  version: "3.23.3",
  mode: "global",
  copyright: " 2014-2022 Denis Pushkarev (zloirock.ru)",
  license: "https://github.com/zloirock/core-js/blob/v3.23.3/LICENSE",
  source: "https://github.com/zloirock/core-js",
});
var requireObjectCoercible$3$2 = requireObjectCoercible$5;
var $Object$2$3 = Object;
var toObject$7 = function (argument) {
  return $Object$2$3(requireObjectCoercible$3$2(argument));
};
var uncurryThis$k = functionUncurryThis$3;
var toObject$6$1 = toObject$7;
var hasOwnProperty$3 = uncurryThis$k({}.hasOwnProperty);
var hasOwnProperty_1$3 =
  Object.hasOwn ||
  function hasOwn(it, key) {
    return hasOwnProperty$3(toObject$6$1(it), key);
  };
var uncurryThis$j = functionUncurryThis$3;
var id$3 = 0;
var postfix$3 = Math.random();
var toString$5$1 = uncurryThis$j((1).toString);
var uid$3$1 = function (key) {
  return (
    "Symbol(" +
    (key === void 0 ? "" : key) +
    ")_" +
    toString$5$1(++id$3 + postfix$3, 36)
  );
};
var global$o = global$t;
var shared$3$3 = shared$4$1.exports;
var hasOwn$b$1 = hasOwnProperty_1$3;
var uid$2$3 = uid$3$1;
var NATIVE_SYMBOL$4 = nativeSymbol$3;
var USE_SYMBOL_AS_UID$4 = useSymbolAsUid$3;
var WellKnownSymbolsStore$3 = shared$3$3("wks");
var Symbol$1$3 = global$o.Symbol;
var symbolFor$3 = Symbol$1$3 && Symbol$1$3["for"];
var createWellKnownSymbol$3 = USE_SYMBOL_AS_UID$4
  ? Symbol$1$3
  : (Symbol$1$3 && Symbol$1$3.withoutSetter) || uid$2$3;
var wellKnownSymbol$j = function (name) {
  if (
    !hasOwn$b$1(WellKnownSymbolsStore$3, name) ||
    !(NATIVE_SYMBOL$4 || typeof WellKnownSymbolsStore$3[name] == "string")
  ) {
    var description = "Symbol." + name;
    if (NATIVE_SYMBOL$4 && hasOwn$b$1(Symbol$1$3, name)) {
      WellKnownSymbolsStore$3[name] = Symbol$1$3[name];
    } else if (USE_SYMBOL_AS_UID$4 && symbolFor$3) {
      WellKnownSymbolsStore$3[name] = symbolFor$3(description);
    } else {
      WellKnownSymbolsStore$3[name] = createWellKnownSymbol$3(description);
    }
  }
  return WellKnownSymbolsStore$3[name];
};
var call$i = functionCall$3;
var isObject$b = isObject$d;
var isSymbol$2$3 = isSymbol$3$1;
var getMethod$3$2 = getMethod$4$1;
var ordinaryToPrimitive$4 = ordinaryToPrimitive$1$3;
var wellKnownSymbol$i = wellKnownSymbol$j;
var $TypeError$c$2 = TypeError;
var TO_PRIMITIVE$3 = wellKnownSymbol$i("toPrimitive");
var toPrimitive$2$1 = function (input, pref) {
  if (!isObject$b(input) || isSymbol$2$3(input)) return input;
  var exoticToPrim = getMethod$3$2(input, TO_PRIMITIVE$3);
  var result;
  if (exoticToPrim) {
    if (pref === void 0) pref = "default";
    result = call$i(exoticToPrim, input, pref);
    if (!isObject$b(result) || isSymbol$2$3(result)) return result;
    throw $TypeError$c$2("Can't convert object to primitive value");
  }
  if (pref === void 0) pref = "number";
  return ordinaryToPrimitive$4(input, pref);
};
var toPrimitive$1$3 = toPrimitive$2$1;
var isSymbol$1$3 = isSymbol$3$1;
var toPropertyKey$4$1 = function (argument) {
  var key = toPrimitive$1$3(argument, "string");
  return isSymbol$1$3(key) ? key : key + "";
};
var global$n = global$t;
var isObject$a = isObject$d;
var document$3$2 = global$n.document;
var EXISTS$1$3 =
  isObject$a(document$3$2) && isObject$a(document$3$2.createElement);
var documentCreateElement$2$2 = function (it) {
  return EXISTS$1$3 ? document$3$2.createElement(it) : {};
};
var DESCRIPTORS$d = descriptors$3;
var fails$m = fails$r;
var createElement$1$2 = documentCreateElement$2$2;
var ie8DomDefine$3 =
  !DESCRIPTORS$d &&
  !fails$m(function () {
    return (
      Object.defineProperty(createElement$1$2("div"), "a", {
        get: function () {
          return 7;
        },
      }).a != 7
    );
  });
var DESCRIPTORS$c$1 = descriptors$3;
var call$h = functionCall$3;
var propertyIsEnumerableModule$1$3 = objectPropertyIsEnumerable$3;
var createPropertyDescriptor$4$2 = createPropertyDescriptor$5$1;
var toIndexedObject$5$2 = toIndexedObject$6$1;
var toPropertyKey$3$2 = toPropertyKey$4$1;
var hasOwn$a$2 = hasOwnProperty_1$3;
var IE8_DOM_DEFINE$1$3 = ie8DomDefine$3;
var $getOwnPropertyDescriptor$1$3 = Object.getOwnPropertyDescriptor;
objectGetOwnPropertyDescriptor$3.f = DESCRIPTORS$c$1
  ? $getOwnPropertyDescriptor$1$3
  : function getOwnPropertyDescriptor(O, P) {
      O = toIndexedObject$5$2(O);
      P = toPropertyKey$3$2(P);
      if (IE8_DOM_DEFINE$1$3)
        try {
          return $getOwnPropertyDescriptor$1$3(O, P);
        } catch (error) {}
      if (hasOwn$a$2(O, P))
        return createPropertyDescriptor$4$2(
          !call$h(propertyIsEnumerableModule$1$3.f, O, P),
          O[P]
        );
    };
var objectDefineProperty$3 = {};
var DESCRIPTORS$b$1 = descriptors$3;
var fails$l = fails$r;
var v8PrototypeDefineBug$3 =
  DESCRIPTORS$b$1 &&
  fails$l(function () {
    return (
      Object.defineProperty(function () {}, "prototype", {
        value: 42,
        writable: false,
      }).prototype != 42
    );
  });
var isObject$9$1 = isObject$d;
var $String$2$2 = String;
var $TypeError$b$2 = TypeError;
var anObject$e$1 = function (argument) {
  if (isObject$9$1(argument)) return argument;
  throw $TypeError$b$2($String$2$2(argument) + " is not an object");
};
var DESCRIPTORS$a$3 = descriptors$3;
var IE8_DOM_DEFINE$4 = ie8DomDefine$3;
var V8_PROTOTYPE_DEFINE_BUG$1$2 = v8PrototypeDefineBug$3;
var anObject$d$1 = anObject$e$1;
var toPropertyKey$2$3 = toPropertyKey$4$1;
var $TypeError$a$2 = TypeError;
var $defineProperty$3 = Object.defineProperty;
var $getOwnPropertyDescriptor$4 = Object.getOwnPropertyDescriptor;
var ENUMERABLE$3 = "enumerable";
var CONFIGURABLE$1$3 = "configurable";
var WRITABLE$3 = "writable";
objectDefineProperty$3.f = DESCRIPTORS$a$3
  ? V8_PROTOTYPE_DEFINE_BUG$1$2
    ? function defineProperty(O, P, Attributes) {
        anObject$d$1(O);
        P = toPropertyKey$2$3(P);
        anObject$d$1(Attributes);
        if (
          typeof O === "function" &&
          P === "prototype" &&
          "value" in Attributes &&
          WRITABLE$3 in Attributes &&
          !Attributes[WRITABLE$3]
        ) {
          var current = $getOwnPropertyDescriptor$4(O, P);
          if (current && current[WRITABLE$3]) {
            O[P] = Attributes.value;
            Attributes = {
              configurable:
                CONFIGURABLE$1$3 in Attributes
                  ? Attributes[CONFIGURABLE$1$3]
                  : current[CONFIGURABLE$1$3],
              enumerable:
                ENUMERABLE$3 in Attributes
                  ? Attributes[ENUMERABLE$3]
                  : current[ENUMERABLE$3],
              writable: false,
            };
          }
        }
        return $defineProperty$3(O, P, Attributes);
      }
    : $defineProperty$3
  : function defineProperty2(O, P, Attributes) {
      anObject$d$1(O);
      P = toPropertyKey$2$3(P);
      anObject$d$1(Attributes);
      if (IE8_DOM_DEFINE$4)
        try {
          return $defineProperty$3(O, P, Attributes);
        } catch (error) {}
      if ("get" in Attributes || "set" in Attributes)
        throw $TypeError$a$2("Accessors not supported");
      if ("value" in Attributes) O[P] = Attributes.value;
      return O;
    };
var DESCRIPTORS$9$2 = descriptors$3;
var definePropertyModule$6$1 = objectDefineProperty$3;
var createPropertyDescriptor$3$2 = createPropertyDescriptor$5$1;
var createNonEnumerableProperty$8 = DESCRIPTORS$9$2
  ? function (object, key, value) {
      return definePropertyModule$6$1.f(
        object,
        key,
        createPropertyDescriptor$3$2(1, value)
      );
    }
  : function (object, key, value) {
      object[key] = value;
      return object;
    };
var makeBuiltIn$2$3 = { exports: {} };
var DESCRIPTORS$8$2 = descriptors$3;
var hasOwn$9$2 = hasOwnProperty_1$3;
var FunctionPrototype$1$3 = Function.prototype;
var getDescriptor$3 = DESCRIPTORS$8$2 && Object.getOwnPropertyDescriptor;
var EXISTS$4 = hasOwn$9$2(FunctionPrototype$1$3, "name");
var PROPER$3 = EXISTS$4 && function something() {}.name === "something";
var CONFIGURABLE$4 =
  EXISTS$4 &&
  (!DESCRIPTORS$8$2 ||
    (DESCRIPTORS$8$2 &&
      getDescriptor$3(FunctionPrototype$1$3, "name").configurable));
var functionName$3 = {
  EXISTS: EXISTS$4,
  PROPER: PROPER$3,
  CONFIGURABLE: CONFIGURABLE$4,
};
var uncurryThis$i$1 = functionUncurryThis$3;
var isCallable$h$2 = isCallable$n;
var store$1$3 = sharedStore$3;
var functionToString$3 = uncurryThis$i$1(Function.toString);
if (!isCallable$h$2(store$1$3.inspectSource)) {
  store$1$3.inspectSource = function (it) {
    return functionToString$3(it);
  };
}
var inspectSource$4$2 = store$1$3.inspectSource;
var global$m = global$t;
var isCallable$g$2 = isCallable$n;
var inspectSource$3$2 = inspectSource$4$2;
var WeakMap$1$3 = global$m.WeakMap;
var nativeWeakMap$3 =
  isCallable$g$2(WeakMap$1$3) &&
  /native code/.test(inspectSource$3$2(WeakMap$1$3));
var shared$2$3 = shared$4$1.exports;
var uid$1$3 = uid$3$1;
var keys$1 = shared$2$3("keys");
var sharedKey$3$2 = function (key) {
  return keys$1[key] || (keys$1[key] = uid$1$3(key));
};
var hiddenKeys$4$2 = {};
var NATIVE_WEAK_MAP$3 = nativeWeakMap$3;
var global$l = global$t;
var uncurryThis$h$1 = functionUncurryThis$3;
var isObject$8$2 = isObject$d;
var createNonEnumerableProperty$7 = createNonEnumerableProperty$8;
var hasOwn$8$2 = hasOwnProperty_1$3;
var shared$1$3 = sharedStore$3;
var sharedKey$2$2 = sharedKey$3$2;
var hiddenKeys$3$3 = hiddenKeys$4$2;
var OBJECT_ALREADY_INITIALIZED$3 = "Object already initialized";
var TypeError$3 = global$l.TypeError;
var WeakMap$4 = global$l.WeakMap;
var set$2$1;
var get$1$1;
var has$3;
var enforce$3 = function (it) {
  return has$3(it) ? get$1$1(it) : set$2$1(it, {});
};
var getterFor$3 = function (TYPE) {
  return function (it) {
    var state;
    if (!isObject$8$2(it) || (state = get$1$1(it)).type !== TYPE) {
      throw TypeError$3("Incompatible receiver, " + TYPE + " required");
    }
    return state;
  };
};
if (NATIVE_WEAK_MAP$3 || shared$1$3.state) {
  store$6 = shared$1$3.state || (shared$1$3.state = new WeakMap$4());
  wmget$3 = uncurryThis$h$1(store$6.get);
  wmhas$3 = uncurryThis$h$1(store$6.has);
  wmset$3 = uncurryThis$h$1(store$6.set);
  set$2$1 = function (it, metadata) {
    if (wmhas$3(store$6, it))
      throw new TypeError$3(OBJECT_ALREADY_INITIALIZED$3);
    metadata.facade = it;
    wmset$3(store$6, it, metadata);
    return metadata;
  };
  get$1$1 = function (it) {
    return wmget$3(store$6, it) || {};
  };
  has$3 = function (it) {
    return wmhas$3(store$6, it);
  };
} else {
  STATE$3 = sharedKey$2$2("state");
  hiddenKeys$3$3[STATE$3] = true;
  set$2$1 = function (it, metadata) {
    if (hasOwn$8$2(it, STATE$3))
      throw new TypeError$3(OBJECT_ALREADY_INITIALIZED$3);
    metadata.facade = it;
    createNonEnumerableProperty$7(it, STATE$3, metadata);
    return metadata;
  };
  get$1$1 = function (it) {
    return hasOwn$8$2(it, STATE$3) ? it[STATE$3] : {};
  };
  has$3 = function (it) {
    return hasOwn$8$2(it, STATE$3);
  };
}
var store$6;
var wmget$3;
var wmhas$3;
var wmset$3;
var STATE$3;
var internalState$3 = {
  set: set$2$1,
  get: get$1$1,
  has: has$3,
  enforce: enforce$3,
  getterFor: getterFor$3,
};
var fails$k = fails$r;
var isCallable$f$2 = isCallable$n;
var hasOwn$7$2 = hasOwnProperty_1$3;
var DESCRIPTORS$7$3 = descriptors$3;
var CONFIGURABLE_FUNCTION_NAME$2$1 = functionName$3.CONFIGURABLE;
var inspectSource$2$3 = inspectSource$4$2;
var InternalStateModule$5 = internalState$3;
var enforceInternalState$2$1 = InternalStateModule$5.enforce;
var getInternalState$5 = InternalStateModule$5.get;
var defineProperty$6$1 = Object.defineProperty;
var CONFIGURABLE_LENGTH$3 =
  DESCRIPTORS$7$3 &&
  !fails$k(function () {
    return (
      defineProperty$6$1(function () {}, "length", { value: 8 }).length !== 8
    );
  });
var TEMPLATE$3 = String(String).split("String");
var makeBuiltIn$1$3 = (makeBuiltIn$2$3.exports = function (
  value,
  name,
  options
) {
  if (String(name).slice(0, 7) === "Symbol(") {
    name = "[" + String(name).replace(/^Symbol\(([^)]*)\)/, "$1") + "]";
  }
  if (options && options.getter) name = "get " + name;
  if (options && options.setter) name = "set " + name;
  if (
    !hasOwn$7$2(value, "name") ||
    (CONFIGURABLE_FUNCTION_NAME$2$1 && value.name !== name)
  ) {
    if (DESCRIPTORS$7$3)
      defineProperty$6$1(value, "name", { value: name, configurable: true });
    else value.name = name;
  }
  if (
    CONFIGURABLE_LENGTH$3 &&
    options &&
    hasOwn$7$2(options, "arity") &&
    value.length !== options.arity
  ) {
    defineProperty$6$1(value, "length", { value: options.arity });
  }
  try {
    if (options && hasOwn$7$2(options, "constructor") && options.constructor) {
      if (DESCRIPTORS$7$3)
        defineProperty$6$1(value, "prototype", { writable: false });
    } else if (value.prototype) value.prototype = void 0;
  } catch (error) {}
  var state = enforceInternalState$2$1(value);
  if (!hasOwn$7$2(state, "source")) {
    state.source = TEMPLATE$3.join(typeof name == "string" ? name : "");
  }
  return value;
});
Function.prototype.toString = makeBuiltIn$1$3(function toString() {
  return (
    (isCallable$f$2(this) && getInternalState$5(this).source) ||
    inspectSource$2$3(this)
  );
}, "toString");
var isCallable$e$2 = isCallable$n;
var definePropertyModule$5$2 = objectDefineProperty$3;
var makeBuiltIn$5 = makeBuiltIn$2$3.exports;
var defineGlobalProperty$1$3 = defineGlobalProperty$3$3;
var defineBuiltIn$8$1 = function (O, key, value, options) {
  if (!options) options = {};
  var simple = options.enumerable;
  var name = options.name !== void 0 ? options.name : key;
  if (isCallable$e$2(value)) makeBuiltIn$5(value, name, options);
  if (options.global) {
    if (simple) O[key] = value;
    else defineGlobalProperty$1$3(key, value);
  } else {
    try {
      if (!options.unsafe) delete O[key];
      else if (O[key]) simple = true;
    } catch (error) {}
    if (simple) O[key] = value;
    else
      definePropertyModule$5$2.f(O, key, {
        value,
        enumerable: false,
        configurable: !options.nonConfigurable,
        writable: !options.nonWritable,
      });
  }
  return O;
};
var objectGetOwnPropertyNames$3 = {};
var ceil$3 = Math.ceil;
var floor$3 = Math.floor;
var mathTrunc$3 =
  Math.trunc ||
  function trunc(x) {
    var n = +x;
    return (n > 0 ? floor$3 : ceil$3)(n);
  };
var trunc2$3 = mathTrunc$3;
var toIntegerOrInfinity$6 = function (argument) {
  var number = +argument;
  return number !== number || number === 0 ? 0 : trunc2$3(number);
};
var toIntegerOrInfinity$5 = toIntegerOrInfinity$6;
var max$1$2 = Math.max;
var min$2$1 = Math.min;
var toAbsoluteIndex$4 = function (index, length) {
  var integer = toIntegerOrInfinity$5(index);
  return integer < 0 ? max$1$2(integer + length, 0) : min$2$1(integer, length);
};
var toIntegerOrInfinity$4$1 = toIntegerOrInfinity$6;
var min$1$3 = Math.min;
var toLength$6 = function (argument) {
  return argument > 0
    ? min$1$3(toIntegerOrInfinity$4$1(argument), 9007199254740991)
    : 0;
};
var toLength$5 = toLength$6;
var lengthOfArrayLike$8 = function (obj) {
  return toLength$5(obj.length);
};
var toIndexedObject$4$2 = toIndexedObject$6$1;
var toAbsoluteIndex$3$1 = toAbsoluteIndex$4;
var lengthOfArrayLike$7 = lengthOfArrayLike$8;
var createMethod$3 = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIndexedObject$4$2($this);
    var length = lengthOfArrayLike$7(O);
    var index = toAbsoluteIndex$3$1(fromIndex, length);
    var value;
    if (IS_INCLUDES && el != el)
      while (length > index) {
        value = O[index++];
        if (value != value) return true;
      }
    else
      for (; length > index; index++) {
        if ((IS_INCLUDES || index in O) && O[index] === el)
          return IS_INCLUDES || index || 0;
      }
    return !IS_INCLUDES && -1;
  };
};
var arrayIncludes$3 = {
  // `Array.prototype.includes` method
  // https://tc39.es/ecma262/#sec-array.prototype.includes
  includes: createMethod$3(true),
  // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof
  indexOf: createMethod$3(false),
};
var uncurryThis$g$1 = functionUncurryThis$3;
var hasOwn$6$3 = hasOwnProperty_1$3;
var toIndexedObject$3$3 = toIndexedObject$6$1;
var indexOf$1$1 = arrayIncludes$3.indexOf;
var hiddenKeys$2$3 = hiddenKeys$4$2;
var push$2$1 = uncurryThis$g$1([].push);
var objectKeysInternal$3 = function (object, names) {
  var O = toIndexedObject$3$3(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O)
    !hasOwn$6$3(hiddenKeys$2$3, key) &&
      hasOwn$6$3(O, key) &&
      push$2$1(result, key);
  while (names.length > i)
    if (hasOwn$6$3(O, (key = names[i++]))) {
      ~indexOf$1$1(result, key) || push$2$1(result, key);
    }
  return result;
};
var enumBugKeys$3$2 = [
  "constructor",
  "hasOwnProperty",
  "isPrototypeOf",
  "propertyIsEnumerable",
  "toLocaleString",
  "toString",
  "valueOf",
];
var internalObjectKeys$1$3 = objectKeysInternal$3;
var enumBugKeys$2$3 = enumBugKeys$3$2;
var hiddenKeys$1$3 = enumBugKeys$2$3.concat("length", "prototype");
objectGetOwnPropertyNames$3.f =
  Object.getOwnPropertyNames ||
  function getOwnPropertyNames(O) {
    return internalObjectKeys$1$3(O, hiddenKeys$1$3);
  };
var objectGetOwnPropertySymbols$3 = {};
objectGetOwnPropertySymbols$3.f = Object.getOwnPropertySymbols;
var getBuiltIn$5$2 = getBuiltIn$8$2;
var uncurryThis$f$1 = functionUncurryThis$3;
var getOwnPropertyNamesModule$3 = objectGetOwnPropertyNames$3;
var getOwnPropertySymbolsModule$1$3 = objectGetOwnPropertySymbols$3;
var anObject$c$2 = anObject$e$1;
var concat$1$3 = uncurryThis$f$1([].concat);
var ownKeys$1$3 =
  getBuiltIn$5$2("Reflect", "ownKeys") ||
  function ownKeys(it) {
    var keys2 = getOwnPropertyNamesModule$3.f(anObject$c$2(it));
    var getOwnPropertySymbols = getOwnPropertySymbolsModule$1$3.f;
    return getOwnPropertySymbols
      ? concat$1$3(keys2, getOwnPropertySymbols(it))
      : keys2;
  };
var hasOwn$5$3 = hasOwnProperty_1$3;
var ownKeys2$3 = ownKeys$1$3;
var getOwnPropertyDescriptorModule$1$1 = objectGetOwnPropertyDescriptor$3;
var definePropertyModule$4$2 = objectDefineProperty$3;
var copyConstructorProperties$1$3 = function (target, source, exceptions) {
  var keys2 = ownKeys2$3(source);
  var defineProperty5 = definePropertyModule$4$2.f;
  var getOwnPropertyDescriptor4 = getOwnPropertyDescriptorModule$1$1.f;
  for (var i = 0; i < keys2.length; i++) {
    var key = keys2[i];
    if (
      !hasOwn$5$3(target, key) &&
      !(exceptions && hasOwn$5$3(exceptions, key))
    ) {
      defineProperty5(target, key, getOwnPropertyDescriptor4(source, key));
    }
  }
};
var fails$j = fails$r;
var isCallable$d$2 = isCallable$n;
var replacement$3 = /#|\.prototype\./;
var isForced$2$2 = function (feature, detection) {
  var value = data$3[normalize$3(feature)];
  return value == POLYFILL$3
    ? true
    : value == NATIVE$3
    ? false
    : isCallable$d$2(detection)
    ? fails$j(detection)
    : !!detection;
};
var normalize$3 = (isForced$2$2.normalize = function (string) {
  return String(string).replace(replacement$3, ".").toLowerCase();
});
var data$3 = (isForced$2$2.data = {});
var NATIVE$3 = (isForced$2$2.NATIVE = "N");
var POLYFILL$3 = (isForced$2$2.POLYFILL = "P");
var isForced_1$3 = isForced$2$2;
var global$k$1 = global$t;
var getOwnPropertyDescriptor$1$3 = objectGetOwnPropertyDescriptor$3.f;
var createNonEnumerableProperty$6$1 = createNonEnumerableProperty$8;
var defineBuiltIn$7$1 = defineBuiltIn$8$1;
var defineGlobalProperty$6 = defineGlobalProperty$3$3;
var copyConstructorProperties$4 = copyConstructorProperties$1$3;
var isForced$1$3 = isForced_1$3;
var _export$3 = function (options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var FORCED2, target, key, targetProperty, sourceProperty, descriptor;
  if (GLOBAL) {
    target = global$k$1;
  } else if (STATIC) {
    target = global$k$1[TARGET] || defineGlobalProperty$6(TARGET, {});
  } else {
    target = (global$k$1[TARGET] || {}).prototype;
  }
  if (target)
    for (key in source) {
      sourceProperty = source[key];
      if (options.dontCallGetSet) {
        descriptor = getOwnPropertyDescriptor$1$3(target, key);
        targetProperty = descriptor && descriptor.value;
      } else targetProperty = target[key];
      FORCED2 = isForced$1$3(
        GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key,
        options.forced
      );
      if (!FORCED2 && targetProperty !== void 0) {
        if (typeof sourceProperty == typeof targetProperty) continue;
        copyConstructorProperties$4(sourceProperty, targetProperty);
      }
      if (options.sham || (targetProperty && targetProperty.sham)) {
        createNonEnumerableProperty$6$1(sourceProperty, "sham", true);
      }
      defineBuiltIn$7$1(target, key, sourceProperty, options);
    }
};
var classof$a = classofRaw$1$2;
var global$j$2 = global$t;
var engineIsNode$2 = classof$a(global$j$2.process) == "process";
var isCallable$c$2 = isCallable$n;
var $String$1$3 = String;
var $TypeError$9$2 = TypeError;
var aPossiblePrototype$1$2 = function (argument) {
  if (typeof argument == "object" || isCallable$c$2(argument)) return argument;
  throw $TypeError$9$2(
    "Can't set " + $String$1$3(argument) + " as a prototype"
  );
};
var uncurryThis$e$3 = functionUncurryThis$3;
var anObject$b$2 = anObject$e$1;
var aPossiblePrototype$3 = aPossiblePrototype$1$2;
var objectSetPrototypeOf$2 =
  Object.setPrototypeOf ||
  ("__proto__" in {}
    ? (function () {
        var CORRECT_SETTER = false;
        var test2 = {};
        var setter;
        try {
          setter = uncurryThis$e$3(
            Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set
          );
          setter(test2, []);
          CORRECT_SETTER = test2 instanceof Array;
        } catch (error) {}
        return function setPrototypeOf2(O, proto) {
          anObject$b$2(O);
          aPossiblePrototype$3(proto);
          if (CORRECT_SETTER) setter(O, proto);
          else O.__proto__ = proto;
          return O;
        };
      })()
    : void 0);
var defineProperty$5$2 = objectDefineProperty$3.f;
var hasOwn$4$3 = hasOwnProperty_1$3;
var wellKnownSymbol$h$1 = wellKnownSymbol$j;
var TO_STRING_TAG$4$1 = wellKnownSymbol$h$1("toStringTag");
var setToStringTag$4$1 = function (target, TAG, STATIC) {
  if (target && !STATIC) target = target.prototype;
  if (target && !hasOwn$4$3(target, TO_STRING_TAG$4$1)) {
    defineProperty$5$2(target, TO_STRING_TAG$4$1, {
      configurable: true,
      value: TAG,
    });
  }
};
var getBuiltIn$4$2 = getBuiltIn$8$2;
var definePropertyModule$3$2 = objectDefineProperty$3;
var wellKnownSymbol$g$1 = wellKnownSymbol$j;
var DESCRIPTORS$6$3 = descriptors$3;
var SPECIES$4 = wellKnownSymbol$g$1("species");
var setSpecies$2$1 = function (CONSTRUCTOR_NAME) {
  var Constructor2 = getBuiltIn$4$2(CONSTRUCTOR_NAME);
  var defineProperty5 = definePropertyModule$3$2.f;
  if (DESCRIPTORS$6$3 && Constructor2 && !Constructor2[SPECIES$4]) {
    defineProperty5(Constructor2, SPECIES$4, {
      configurable: true,
      get: function () {
        return this;
      },
    });
  }
};
var isPrototypeOf$3$2 = objectIsPrototypeOf$3;
var $TypeError$8$2 = TypeError;
var anInstance$3 = function (it, Prototype2) {
  if (isPrototypeOf$3$2(Prototype2, it)) return it;
  throw $TypeError$8$2("Incorrect invocation");
};
var wellKnownSymbol$f$2 = wellKnownSymbol$j;
var TO_STRING_TAG$3$2 = wellKnownSymbol$f$2("toStringTag");
var test$3 = {};
test$3[TO_STRING_TAG$3$2] = "z";
var toStringTagSupport$2 = String(test$3) === "[object z]";
var TO_STRING_TAG_SUPPORT$2 = toStringTagSupport$2;
var isCallable$b$2 = isCallable$n;
var classofRaw$4 = classofRaw$1$2;
var wellKnownSymbol$e$2 = wellKnownSymbol$j;
var TO_STRING_TAG$2$2 = wellKnownSymbol$e$2("toStringTag");
var $Object$1$3 = Object;
var CORRECT_ARGUMENTS$2 =
  classofRaw$4(
    (function () {
      return arguments;
    })()
  ) == "Arguments";
var tryGet$2 = function (it, key) {
  try {
    return it[key];
  } catch (error) {}
};
var classof$9 = TO_STRING_TAG_SUPPORT$2
  ? classofRaw$4
  : function (it) {
      var O, tag, result;
      return it === void 0
        ? "Undefined"
        : it === null
        ? "Null"
        : typeof (tag = tryGet$2((O = $Object$1$3(it)), TO_STRING_TAG$2$2)) ==
          "string"
        ? tag
        : CORRECT_ARGUMENTS$2
        ? classofRaw$4(O)
        : (result = classofRaw$4(O)) == "Object" && isCallable$b$2(O.callee)
        ? "Arguments"
        : result;
    };
var uncurryThis$d$2 = functionUncurryThis$3;
var fails$i$1 = fails$r;
var isCallable$a$3 = isCallable$n;
var classof$8 = classof$9;
var getBuiltIn$3$3 = getBuiltIn$8$2;
var inspectSource$1$3 = inspectSource$4$2;
var noop2$1 = function () {};
var empty$2 = [];
var construct$2 = getBuiltIn$3$3("Reflect", "construct");
var constructorRegExp$2 = /^\s*(?:class|function)\b/;
var exec$2 = uncurryThis$d$2(constructorRegExp$2.exec);
var INCORRECT_TO_STRING$2 = !constructorRegExp$2.exec(noop2$1);
var isConstructorModern$2 = function isConstructor(argument) {
  if (!isCallable$a$3(argument)) return false;
  try {
    construct$2(noop2$1, empty$2, argument);
    return true;
  } catch (error) {
    return false;
  }
};
var isConstructorLegacy$2 = function isConstructor2(argument) {
  if (!isCallable$a$3(argument)) return false;
  switch (classof$8(argument)) {
    case "AsyncFunction":
    case "GeneratorFunction":
    case "AsyncGeneratorFunction":
      return false;
  }
  try {
    return (
      INCORRECT_TO_STRING$2 ||
      !!exec$2(constructorRegExp$2, inspectSource$1$3(argument))
    );
  } catch (error) {
    return true;
  }
};
isConstructorLegacy$2.sham = true;
var isConstructor$2 =
  !construct$2 ||
  fails$i$1(function () {
    var called;
    return (
      isConstructorModern$2(isConstructorModern$2.call) ||
      !isConstructorModern$2(Object) ||
      !isConstructorModern$2(function () {
        called = true;
      }) ||
      called
    );
  })
    ? isConstructorLegacy$2
    : isConstructorModern$2;
var isConstructor$1$2 = isConstructor$2;
var tryToString$3$2 = tryToString$5$2;
var $TypeError$7$2 = TypeError;
var aConstructor$2$1 = function (argument) {
  if (isConstructor$1$2(argument)) return argument;
  throw $TypeError$7$2(tryToString$3$2(argument) + " is not a constructor");
};
var anObject$a$2 = anObject$e$1;
var aConstructor$1$2 = aConstructor$2$1;
var wellKnownSymbol$d$2 = wellKnownSymbol$j;
var SPECIES$3$1 = wellKnownSymbol$d$2("species");
var speciesConstructor$3 = function (O, defaultConstructor) {
  var C = anObject$a$2(O).constructor;
  var S;
  return C === void 0 || (S = anObject$a$2(C)[SPECIES$3$1]) == void 0
    ? defaultConstructor
    : aConstructor$1$2(S);
};
var NATIVE_BIND$1$3 = functionBindNative$3;
var FunctionPrototype$5 = Function.prototype;
var apply$3 = FunctionPrototype$5.apply;
var call$g$1 = FunctionPrototype$5.call;
var functionApply$2 =
  (typeof Reflect == "object" && Reflect.apply) ||
  (NATIVE_BIND$1$3
    ? call$g$1.bind(apply$3)
    : function () {
        return call$g$1.apply(apply$3, arguments);
      });
var uncurryThis$c$2 = functionUncurryThis$3;
var aCallable$7$2 = aCallable$9$1;
var NATIVE_BIND$6 = functionBindNative$3;
var bind$6$1 = uncurryThis$c$2(uncurryThis$c$2.bind);
var functionBindContext$2 = function (fn, that) {
  aCallable$7$2(fn);
  return that === void 0
    ? fn
    : NATIVE_BIND$6
    ? bind$6$1(fn, that)
    : function () {
        return fn.apply(that, arguments);
      };
};
var getBuiltIn$2$3 = getBuiltIn$8$2;
var html$2$2 = getBuiltIn$2$3("document", "documentElement");
var uncurryThis$b$2 = functionUncurryThis$3;
var arraySlice$5 = uncurryThis$b$2([].slice);
var $TypeError$6$2 = TypeError;
var validateArgumentsLength$1$2 = function (passed, required) {
  if (passed < required) throw $TypeError$6$2("Not enough arguments");
  return passed;
};
var userAgent$4$2 = engineUserAgent$3;
var engineIsIos$2 = /(?:ipad|iphone|ipod).*applewebkit/i.test(userAgent$4$2);
var global$i$2 = global$t;
var apply$2$1 = functionApply$2;
var bind$5$2 = functionBindContext$2;
var isCallable$9$3 = isCallable$n;
var hasOwn$3$3 = hasOwnProperty_1$3;
var fails$h$1 = fails$r;
var html$1$2 = html$2$2;
var arraySlice$4 = arraySlice$5;
var createElement$4 = documentCreateElement$2$2;
var validateArgumentsLength$3 = validateArgumentsLength$1$2;
var IS_IOS$1$2 = engineIsIos$2;
var IS_NODE$3$1 = engineIsNode$2;
var set$1$2 = global$i$2.setImmediate;
var clear$2 = global$i$2.clearImmediate;
var process$2$2 = global$i$2.process;
var Dispatch$2 = global$i$2.Dispatch;
var Function$1$2 = global$i$2.Function;
var MessageChannel$2 = global$i$2.MessageChannel;
var String$1$2 = global$i$2.String;
var counter$2 = 0;
var queue$1$2 = {};
var ONREADYSTATECHANGE$2 = "onreadystatechange";
var location$3;
var defer$2;
var channel$2;
var port$2;
try {
  location$3 = global$i$2.location;
} catch (error) {}
var run$2 = function (id2) {
  if (hasOwn$3$3(queue$1$2, id2)) {
    var fn = queue$1$2[id2];
    delete queue$1$2[id2];
    fn();
  }
};
var runner$2 = function (id2) {
  return function () {
    run$2(id2);
  };
};
var listener$2 = function (event) {
  run$2(event.data);
};
var post$2 = function (id2) {
  global$i$2.postMessage(
    String$1$2(id2),
    location$3.protocol + "//" + location$3.host
  );
};
if (!set$1$2 || !clear$2) {
  set$1$2 = function setImmediate(handler) {
    validateArgumentsLength$3(arguments.length, 1);
    var fn = isCallable$9$3(handler) ? handler : Function$1$2(handler);
    var args = arraySlice$4(arguments, 1);
    queue$1$2[++counter$2] = function () {
      apply$2$1(fn, void 0, args);
    };
    defer$2(counter$2);
    return counter$2;
  };
  clear$2 = function clearImmediate(id2) {
    delete queue$1$2[id2];
  };
  if (IS_NODE$3$1) {
    defer$2 = function (id2) {
      process$2$2.nextTick(runner$2(id2));
    };
  } else if (Dispatch$2 && Dispatch$2.now) {
    defer$2 = function (id2) {
      Dispatch$2.now(runner$2(id2));
    };
  } else if (MessageChannel$2 && !IS_IOS$1$2) {
    channel$2 = new MessageChannel$2();
    port$2 = channel$2.port2;
    channel$2.port1.onmessage = listener$2;
    defer$2 = bind$5$2(port$2.postMessage, port$2);
  } else if (
    global$i$2.addEventListener &&
    isCallable$9$3(global$i$2.postMessage) &&
    !global$i$2.importScripts &&
    location$3 &&
    location$3.protocol !== "file:" &&
    !fails$h$1(post$2)
  ) {
    defer$2 = post$2;
    global$i$2.addEventListener("message", listener$2, false);
  } else if (ONREADYSTATECHANGE$2 in createElement$4("script")) {
    defer$2 = function (id2) {
      html$1$2.appendChild(createElement$4("script"))[ONREADYSTATECHANGE$2] =
        function () {
          html$1$2.removeChild(this);
          run$2(id2);
        };
    };
  } else {
    defer$2 = function (id2) {
      setTimeout(runner$2(id2), 0);
    };
  }
}
var task$1$2 = {
  set: set$1$2,
  clear: clear$2,
};
var userAgent$3$2 = engineUserAgent$3;
var global$h$2 = global$t;
var engineIsIosPebble$2 =
  /ipad|iphone|ipod/i.test(userAgent$3$2) && global$h$2.Pebble !== void 0;
var userAgent$2$2 = engineUserAgent$3;
var engineIsWebosWebkit$2 = /web0s(?!.*chrome)/i.test(userAgent$2$2);
var global$g$2 = global$t;
var bind$4$2 = functionBindContext$2;
var getOwnPropertyDescriptor2$3 = objectGetOwnPropertyDescriptor$3.f;
var macrotask$2 = task$1$2.set;
var IS_IOS$3 = engineIsIos$2;
var IS_IOS_PEBBLE$2 = engineIsIosPebble$2;
var IS_WEBOS_WEBKIT$2 = engineIsWebosWebkit$2;
var IS_NODE$2$2 = engineIsNode$2;
var MutationObserver$3 =
  global$g$2.MutationObserver || global$g$2.WebKitMutationObserver;
var document$2$2 = global$g$2.document;
var process$1$3 = global$g$2.process;
var Promise$1$2 = global$g$2.Promise;
var queueMicrotaskDescriptor$2 = getOwnPropertyDescriptor2$3(
  global$g$2,
  "queueMicrotask"
);
var queueMicrotask$2 =
  queueMicrotaskDescriptor$2 && queueMicrotaskDescriptor$2.value;
var flush$2;
var head$2;
var last$2;
var notify$1$2;
var toggle$2;
var node$2;
var promise$2;
var then$2;
if (!queueMicrotask$2) {
  flush$2 = function () {
    var parent, fn;
    if (IS_NODE$2$2 && (parent = process$1$3.domain)) parent.exit();
    while (head$2) {
      fn = head$2.fn;
      head$2 = head$2.next;
      try {
        fn();
      } catch (error) {
        if (head$2) notify$1$2();
        else last$2 = void 0;
        throw error;
      }
    }
    last$2 = void 0;
    if (parent) parent.enter();
  };
  if (
    !IS_IOS$3 &&
    !IS_NODE$2$2 &&
    !IS_WEBOS_WEBKIT$2 &&
    MutationObserver$3 &&
    document$2$2
  ) {
    toggle$2 = true;
    node$2 = document$2$2.createTextNode("");
    new MutationObserver$3(flush$2).observe(node$2, { characterData: true });
    notify$1$2 = function () {
      node$2.data = toggle$2 = !toggle$2;
    };
  } else if (!IS_IOS_PEBBLE$2 && Promise$1$2 && Promise$1$2.resolve) {
    promise$2 = Promise$1$2.resolve(void 0);
    promise$2.constructor = Promise$1$2;
    then$2 = bind$4$2(promise$2.then, promise$2);
    notify$1$2 = function () {
      then$2(flush$2);
    };
  } else if (IS_NODE$2$2) {
    notify$1$2 = function () {
      process$1$3.nextTick(flush$2);
    };
  } else {
    macrotask$2 = bind$4$2(macrotask$2, global$g$2);
    notify$1$2 = function () {
      macrotask$2(flush$2);
    };
  }
}
var microtask$1$2 =
  queueMicrotask$2 ||
  function (fn) {
    var task2 = { fn, next: void 0 };
    if (last$2) last$2.next = task2;
    if (!head$2) {
      head$2 = task2;
      notify$1$2();
    }
    last$2 = task2;
  };
var global$f$2 = global$t;
var hostReportErrors$1$2 = function (a, b) {
  var console2 = global$f$2.console;
  if (console2 && console2.error) {
    arguments.length == 1 ? console2.error(a) : console2.error(a, b);
  }
};
var perform$3$2 = function (exec2) {
  try {
    return { error: false, value: exec2() };
  } catch (error) {
    return { error: true, value: error };
  }
};
var Queue$1$2 = function () {
  this.head = null;
  this.tail = null;
};
Queue$1$2.prototype = {
  add: function (item) {
    var entry = { item, next: null };
    if (this.head) this.tail.next = entry;
    else this.head = entry;
    this.tail = entry;
  },
  get: function () {
    var entry = this.head;
    if (entry) {
      this.head = entry.next;
      if (this.tail === entry) this.tail = null;
      return entry.item;
    }
  },
};
var queue$3 = Queue$1$2;
var global$e$2 = global$t;
var promiseNativeConstructor$2 = global$e$2.Promise;
var engineIsBrowser$2 = typeof window == "object" && typeof Deno != "object";
var global$d$2 = global$t;
var NativePromiseConstructor$3$2 = promiseNativeConstructor$2;
var isCallable$8$3 = isCallable$n;
var isForced$5 = isForced_1$3;
var inspectSource$7 = inspectSource$4$2;
var wellKnownSymbol$c$2 = wellKnownSymbol$j;
var IS_BROWSER$2 = engineIsBrowser$2;
var V8_VERSION$4 = engineV8Version$3;
NativePromiseConstructor$3$2 && NativePromiseConstructor$3$2.prototype;
var SPECIES$2$2 = wellKnownSymbol$c$2("species");
var SUBCLASSING$2 = false;
var NATIVE_PROMISE_REJECTION_EVENT$1$2 = isCallable$8$3(
  global$d$2.PromiseRejectionEvent
);
var FORCED_PROMISE_CONSTRUCTOR$5$2 = isForced$5("Promise", function () {
  var PROMISE_CONSTRUCTOR_SOURCE = inspectSource$7(
    NativePromiseConstructor$3$2
  );
  var GLOBAL_CORE_JS_PROMISE =
    PROMISE_CONSTRUCTOR_SOURCE !== String(NativePromiseConstructor$3$2);
  if (!GLOBAL_CORE_JS_PROMISE && V8_VERSION$4 === 66) return true;
  if (V8_VERSION$4 >= 51 && /native code/.test(PROMISE_CONSTRUCTOR_SOURCE))
    return false;
  var promise2 = new NativePromiseConstructor$3$2(function (resolve2) {
    resolve2(1);
  });
  var FakePromise = function (exec2) {
    exec2(
      function () {},
      function () {}
    );
  };
  var constructor = (promise2.constructor = {});
  constructor[SPECIES$2$2] = FakePromise;
  SUBCLASSING$2 = promise2.then(function () {}) instanceof FakePromise;
  if (!SUBCLASSING$2) return true;
  return (
    !GLOBAL_CORE_JS_PROMISE &&
    IS_BROWSER$2 &&
    !NATIVE_PROMISE_REJECTION_EVENT$1$2
  );
});
var promiseConstructorDetection$2 = {
  CONSTRUCTOR: FORCED_PROMISE_CONSTRUCTOR$5$2,
  REJECTION_EVENT: NATIVE_PROMISE_REJECTION_EVENT$1$2,
  SUBCLASSING: SUBCLASSING$2,
};
var newPromiseCapability$2$2 = {};
var aCallable$6$2 = aCallable$9$1;
var PromiseCapability$2 = function (C) {
  var resolve2, reject2;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve2 !== void 0 || reject2 !== void 0)
      throw TypeError("Bad Promise constructor");
    resolve2 = $$resolve;
    reject2 = $$reject;
  });
  this.resolve = aCallable$6$2(resolve2);
  this.reject = aCallable$6$2(reject2);
};
newPromiseCapability$2$2.f = function (C) {
  return new PromiseCapability$2(C);
};
var $$d$1 = _export$3;
var IS_NODE$1$2 = engineIsNode$2;
var global$c$2 = global$t;
var call$f$3 = functionCall$3;
var defineBuiltIn$6$2 = defineBuiltIn$8$1;
var setPrototypeOf$5 = objectSetPrototypeOf$2;
var setToStringTag$3$2 = setToStringTag$4$1;
var setSpecies$1$2 = setSpecies$2$1;
var aCallable$5$2 = aCallable$9$1;
var isCallable$7$3 = isCallable$n;
var isObject$7$2 = isObject$d;
var anInstance$2$1 = anInstance$3;
var speciesConstructor$2$1 = speciesConstructor$3;
var task$3 = task$1$2.set;
var microtask$3 = microtask$1$2;
var hostReportErrors$3 = hostReportErrors$1$2;
var perform$2$2 = perform$3$2;
var Queue$3 = queue$3;
var InternalStateModule$4$1 = internalState$3;
var NativePromiseConstructor$2$2 = promiseNativeConstructor$2;
var PromiseConstructorDetection$2 = promiseConstructorDetection$2;
var newPromiseCapabilityModule$3$2 = newPromiseCapability$2$2;
var PROMISE$2 = "Promise";
var FORCED_PROMISE_CONSTRUCTOR$4$2 = PromiseConstructorDetection$2.CONSTRUCTOR;
var NATIVE_PROMISE_REJECTION_EVENT$3 =
  PromiseConstructorDetection$2.REJECTION_EVENT;
var NATIVE_PROMISE_SUBCLASSING$2 = PromiseConstructorDetection$2.SUBCLASSING;
var getInternalPromiseState$2 = InternalStateModule$4$1.getterFor(PROMISE$2);
var setInternalState$3 = InternalStateModule$4$1.set;
var NativePromisePrototype$1$2 =
  NativePromiseConstructor$2$2 && NativePromiseConstructor$2$2.prototype;
var PromiseConstructor$2 = NativePromiseConstructor$2$2;
var PromisePrototype$2 = NativePromisePrototype$1$2;
var TypeError$2$2 = global$c$2.TypeError;
var document$1$3 = global$c$2.document;
var process$5 = global$c$2.process;
var newPromiseCapability$1$2 = newPromiseCapabilityModule$3$2.f;
var newGenericPromiseCapability$2 = newPromiseCapability$1$2;
var DISPATCH_EVENT$2 = !!(
  document$1$3 &&
  document$1$3.createEvent &&
  global$c$2.dispatchEvent
);
var UNHANDLED_REJECTION$2 = "unhandledrejection";
var REJECTION_HANDLED$2 = "rejectionhandled";
var PENDING$2 = 0;
var FULFILLED$2 = 1;
var REJECTED$2 = 2;
var HANDLED$2 = 1;
var UNHANDLED$2 = 2;
var Internal$2;
var OwnPromiseCapability$2;
var PromiseWrapper$2;
var nativeThen$2;
var isThenable$2 = function (it) {
  var then2;
  return isObject$7$2(it) && isCallable$7$3((then2 = it.then)) ? then2 : false;
};
var callReaction$2 = function (reaction, state) {
  var value = state.value;
  var ok = state.state == FULFILLED$2;
  var handler = ok ? reaction.ok : reaction.fail;
  var resolve2 = reaction.resolve;
  var reject2 = reaction.reject;
  var domain = reaction.domain;
  var result, then2, exited;
  try {
    if (handler) {
      if (!ok) {
        if (state.rejection === UNHANDLED$2) onHandleUnhandled$2(state);
        state.rejection = HANDLED$2;
      }
      if (handler === true) result = value;
      else {
        if (domain) domain.enter();
        result = handler(value);
        if (domain) {
          domain.exit();
          exited = true;
        }
      }
      if (result === reaction.promise) {
        reject2(TypeError$2$2("Promise-chain cycle"));
      } else if ((then2 = isThenable$2(result))) {
        call$f$3(then2, result, resolve2, reject2);
      } else resolve2(result);
    } else reject2(value);
  } catch (error) {
    if (domain && !exited) domain.exit();
    reject2(error);
  }
};
var notify$3 = function (state, isReject) {
  if (state.notified) return;
  state.notified = true;
  microtask$3(function () {
    var reactions = state.reactions;
    var reaction;
    while ((reaction = reactions.get())) {
      callReaction$2(reaction, state);
    }
    state.notified = false;
    if (isReject && !state.rejection) onUnhandled$2(state);
  });
};
var dispatchEvent$2 = function (name, promise2, reason) {
  var event, handler;
  if (DISPATCH_EVENT$2) {
    event = document$1$3.createEvent("Event");
    event.promise = promise2;
    event.reason = reason;
    event.initEvent(name, false, true);
    global$c$2.dispatchEvent(event);
  } else event = { promise: promise2, reason };
  if (!NATIVE_PROMISE_REJECTION_EVENT$3 && (handler = global$c$2["on" + name]))
    handler(event);
  else if (name === UNHANDLED_REJECTION$2)
    hostReportErrors$3("Unhandled promise rejection", reason);
};
var onUnhandled$2 = function (state) {
  call$f$3(task$3, global$c$2, function () {
    var promise2 = state.facade;
    var value = state.value;
    var IS_UNHANDLED = isUnhandled$2(state);
    var result;
    if (IS_UNHANDLED) {
      result = perform$2$2(function () {
        if (IS_NODE$1$2) {
          process$5.emit("unhandledRejection", value, promise2);
        } else dispatchEvent$2(UNHANDLED_REJECTION$2, promise2, value);
      });
      state.rejection =
        IS_NODE$1$2 || isUnhandled$2(state) ? UNHANDLED$2 : HANDLED$2;
      if (result.error) throw result.value;
    }
  });
};
var isUnhandled$2 = function (state) {
  return state.rejection !== HANDLED$2 && !state.parent;
};
var onHandleUnhandled$2 = function (state) {
  call$f$3(task$3, global$c$2, function () {
    var promise2 = state.facade;
    if (IS_NODE$1$2) {
      process$5.emit("rejectionHandled", promise2);
    } else dispatchEvent$2(REJECTION_HANDLED$2, promise2, state.value);
  });
};
var bind$3$2 = function (fn, state, unwrap) {
  return function (value) {
    fn(state, value, unwrap);
  };
};
var internalReject$2 = function (state, value, unwrap) {
  if (state.done) return;
  state.done = true;
  if (unwrap) state = unwrap;
  state.value = value;
  state.state = REJECTED$2;
  notify$3(state, true);
};
var internalResolve$2 = function (state, value, unwrap) {
  if (state.done) return;
  state.done = true;
  if (unwrap) state = unwrap;
  try {
    if (state.facade === value)
      throw TypeError$2$2("Promise can't be resolved itself");
    var then2 = isThenable$2(value);
    if (then2) {
      microtask$3(function () {
        var wrapper = { done: false };
        try {
          call$f$3(
            then2,
            value,
            bind$3$2(internalResolve$2, wrapper, state),
            bind$3$2(internalReject$2, wrapper, state)
          );
        } catch (error) {
          internalReject$2(wrapper, error, state);
        }
      });
    } else {
      state.value = value;
      state.state = FULFILLED$2;
      notify$3(state, false);
    }
  } catch (error) {
    internalReject$2({ done: false }, error, state);
  }
};
if (FORCED_PROMISE_CONSTRUCTOR$4$2) {
  PromiseConstructor$2 = function Promise2(executor) {
    anInstance$2$1(this, PromisePrototype$2);
    aCallable$5$2(executor);
    call$f$3(Internal$2, this);
    var state = getInternalPromiseState$2(this);
    try {
      executor(
        bind$3$2(internalResolve$2, state),
        bind$3$2(internalReject$2, state)
      );
    } catch (error) {
      internalReject$2(state, error);
    }
  };
  PromisePrototype$2 = PromiseConstructor$2.prototype;
  Internal$2 = function Promise2(executor) {
    setInternalState$3(this, {
      type: PROMISE$2,
      done: false,
      notified: false,
      parent: false,
      reactions: new Queue$3(),
      rejection: false,
      state: PENDING$2,
      value: void 0,
    });
  };
  Internal$2.prototype = defineBuiltIn$6$2(
    PromisePrototype$2,
    "then",
    function then2(onFulfilled, onRejected) {
      var state = getInternalPromiseState$2(this);
      var reaction = newPromiseCapability$1$2(
        speciesConstructor$2$1(this, PromiseConstructor$2)
      );
      state.parent = true;
      reaction.ok = isCallable$7$3(onFulfilled) ? onFulfilled : true;
      reaction.fail = isCallable$7$3(onRejected) && onRejected;
      reaction.domain = IS_NODE$1$2 ? process$5.domain : void 0;
      if (state.state == PENDING$2) state.reactions.add(reaction);
      else
        microtask$3(function () {
          callReaction$2(reaction, state);
        });
      return reaction.promise;
    }
  );
  OwnPromiseCapability$2 = function () {
    var promise2 = new Internal$2();
    var state = getInternalPromiseState$2(promise2);
    this.promise = promise2;
    this.resolve = bind$3$2(internalResolve$2, state);
    this.reject = bind$3$2(internalReject$2, state);
  };
  newPromiseCapabilityModule$3$2.f = newPromiseCapability$1$2 = function (C) {
    return C === PromiseConstructor$2 || C === PromiseWrapper$2
      ? new OwnPromiseCapability$2(C)
      : newGenericPromiseCapability$2(C);
  };
  if (
    isCallable$7$3(NativePromiseConstructor$2$2) &&
    NativePromisePrototype$1$2 !== Object.prototype
  ) {
    nativeThen$2 = NativePromisePrototype$1$2.then;
    if (!NATIVE_PROMISE_SUBCLASSING$2) {
      defineBuiltIn$6$2(
        NativePromisePrototype$1$2,
        "then",
        function then2(onFulfilled, onRejected) {
          var that = this;
          return new PromiseConstructor$2(function (resolve2, reject2) {
            call$f$3(nativeThen$2, that, resolve2, reject2);
          }).then(onFulfilled, onRejected);
        },
        { unsafe: true }
      );
    }
    try {
      delete NativePromisePrototype$1$2.constructor;
    } catch (error) {}
    if (setPrototypeOf$5) {
      setPrototypeOf$5(NativePromisePrototype$1$2, PromisePrototype$2);
    }
  }
}
$$d$1(
  {
    global: true,
    constructor: true,
    wrap: true,
    forced: FORCED_PROMISE_CONSTRUCTOR$4$2,
  },
  {
    Promise: PromiseConstructor$2,
  }
);
setToStringTag$3$2(PromiseConstructor$2, PROMISE$2, false);
setSpecies$1$2(PROMISE$2);
var iterators$2 = {};
var wellKnownSymbol$b$2 = wellKnownSymbol$j;
var Iterators$4$2 = iterators$2;
var ITERATOR$5$2 = wellKnownSymbol$b$2("iterator");
var ArrayPrototype$1$2 = Array.prototype;
var isArrayIteratorMethod$2$1 = function (it) {
  return (
    it !== void 0 &&
    (Iterators$4$2.Array === it || ArrayPrototype$1$2[ITERATOR$5$2] === it)
  );
};
var classof$7$1 = classof$9;
var getMethod$2$2 = getMethod$4$1;
var Iterators$3$2 = iterators$2;
var wellKnownSymbol$a$2 = wellKnownSymbol$j;
var ITERATOR$4$2 = wellKnownSymbol$a$2("iterator");
var getIteratorMethod$3$1 = function (it) {
  if (it != void 0)
    return (
      getMethod$2$2(it, ITERATOR$4$2) ||
      getMethod$2$2(it, "@@iterator") ||
      Iterators$3$2[classof$7$1(it)]
    );
};
var call$e$2 = functionCall$3;
var aCallable$4$2 = aCallable$9$1;
var anObject$9$2 = anObject$e$1;
var tryToString$2$2 = tryToString$5$2;
var getIteratorMethod$2$2 = getIteratorMethod$3$1;
var $TypeError$5$3 = TypeError;
var getIterator$2$1 = function (argument, usingIterator) {
  var iteratorMethod =
    arguments.length < 2 ? getIteratorMethod$2$2(argument) : usingIterator;
  if (aCallable$4$2(iteratorMethod))
    return anObject$9$2(call$e$2(iteratorMethod, argument));
  throw $TypeError$5$3(tryToString$2$2(argument) + " is not iterable");
};
var call$d$2 = functionCall$3;
var anObject$8$2 = anObject$e$1;
var getMethod$1$3 = getMethod$4$1;
var iteratorClose$1$2 = function (iterator, kind, value) {
  var innerResult, innerError;
  anObject$8$2(iterator);
  try {
    innerResult = getMethod$1$3(iterator, "return");
    if (!innerResult) {
      if (kind === "throw") throw value;
      return value;
    }
    innerResult = call$d$2(innerResult, iterator);
  } catch (error) {
    innerError = true;
    innerResult = error;
  }
  if (kind === "throw") throw value;
  if (innerError) throw innerResult;
  anObject$8$2(innerResult);
  return value;
};
var bind$2$2 = functionBindContext$2;
var call$c$2 = functionCall$3;
var anObject$7$2 = anObject$e$1;
var tryToString$1$3 = tryToString$5$2;
var isArrayIteratorMethod$1$2 = isArrayIteratorMethod$2$1;
var lengthOfArrayLike$6$1 = lengthOfArrayLike$8;
var isPrototypeOf$2$2 = objectIsPrototypeOf$3;
var getIterator$1$2 = getIterator$2$1;
var getIteratorMethod$1$2 = getIteratorMethod$3$1;
var iteratorClose$3 = iteratorClose$1$2;
var $TypeError$4$3 = TypeError;
var Result$2 = function (stopped, result) {
  this.stopped = stopped;
  this.result = result;
};
var ResultPrototype$2 = Result$2.prototype;
var iterate$2$2 = function (iterable, unboundFunction, options) {
  var that = options && options.that;
  var AS_ENTRIES = !!(options && options.AS_ENTRIES);
  var IS_ITERATOR = !!(options && options.IS_ITERATOR);
  var INTERRUPTED = !!(options && options.INTERRUPTED);
  var fn = bind$2$2(unboundFunction, that);
  var iterator, iterFn, index, length, result, next, step;
  var stop = function (condition) {
    if (iterator) iteratorClose$3(iterator, "normal", condition);
    return new Result$2(true, condition);
  };
  var callFn = function (value) {
    if (AS_ENTRIES) {
      anObject$7$2(value);
      return INTERRUPTED
        ? fn(value[0], value[1], stop)
        : fn(value[0], value[1]);
    }
    return INTERRUPTED ? fn(value, stop) : fn(value);
  };
  if (IS_ITERATOR) {
    iterator = iterable;
  } else {
    iterFn = getIteratorMethod$1$2(iterable);
    if (!iterFn)
      throw $TypeError$4$3(tryToString$1$3(iterable) + " is not iterable");
    if (isArrayIteratorMethod$1$2(iterFn)) {
      for (
        index = 0, length = lengthOfArrayLike$6$1(iterable);
        length > index;
        index++
      ) {
        result = callFn(iterable[index]);
        if (result && isPrototypeOf$2$2(ResultPrototype$2, result))
          return result;
      }
      return new Result$2(false);
    }
    iterator = getIterator$1$2(iterable, iterFn);
  }
  next = iterator.next;
  while (!(step = call$c$2(next, iterator)).done) {
    try {
      result = callFn(step.value);
    } catch (error) {
      iteratorClose$3(iterator, "throw", error);
    }
    if (
      typeof result == "object" &&
      result &&
      isPrototypeOf$2$2(ResultPrototype$2, result)
    )
      return result;
  }
  return new Result$2(false);
};
var wellKnownSymbol$9$2 = wellKnownSymbol$j;
var ITERATOR$3$2 = wellKnownSymbol$9$2("iterator");
var SAFE_CLOSING$2 = false;
try {
  called$2 = 0;
  iteratorWithReturn$2 = {
    next: function () {
      return { done: !!called$2++ };
    },
    return: function () {
      SAFE_CLOSING$2 = true;
    },
  };
  iteratorWithReturn$2[ITERATOR$3$2] = function () {
    return this;
  };
  Array.from(iteratorWithReturn$2, function () {
    throw 2;
  });
} catch (error) {}
var called$2;
var iteratorWithReturn$2;
var checkCorrectnessOfIteration$2$1 = function (exec2, SKIP_CLOSING) {
  if (!SKIP_CLOSING && !SAFE_CLOSING$2) return false;
  var ITERATION_SUPPORT = false;
  try {
    var object = {};
    object[ITERATOR$3$2] = function () {
      return {
        next: function () {
          return { done: (ITERATION_SUPPORT = true) };
        },
      };
    };
    exec2(object);
  } catch (error) {}
  return ITERATION_SUPPORT;
};
var NativePromiseConstructor$1$2 = promiseNativeConstructor$2;
var checkCorrectnessOfIteration$1$2 = checkCorrectnessOfIteration$2$1;
var FORCED_PROMISE_CONSTRUCTOR$3$2 = promiseConstructorDetection$2.CONSTRUCTOR;
var promiseStaticsIncorrectIteration$2 =
  FORCED_PROMISE_CONSTRUCTOR$3$2 ||
  !checkCorrectnessOfIteration$1$2(function (iterable) {
    NativePromiseConstructor$1$2.all(iterable).then(void 0, function () {});
  });
var $$c$1 = _export$3;
var call$b$2 = functionCall$3;
var aCallable$3$2 = aCallable$9$1;
var newPromiseCapabilityModule$2$2 = newPromiseCapability$2$2;
var perform$1$2 = perform$3$2;
var iterate$1$2 = iterate$2$2;
var PROMISE_STATICS_INCORRECT_ITERATION$1$2 =
  promiseStaticsIncorrectIteration$2;
$$c$1(
  {
    target: "Promise",
    stat: true,
    forced: PROMISE_STATICS_INCORRECT_ITERATION$1$2,
  },
  {
    all: function all(iterable) {
      var C = this;
      var capability = newPromiseCapabilityModule$2$2.f(C);
      var resolve2 = capability.resolve;
      var reject2 = capability.reject;
      var result = perform$1$2(function () {
        var $promiseResolve = aCallable$3$2(C.resolve);
        var values2 = [];
        var counter2 = 0;
        var remaining = 1;
        iterate$1$2(iterable, function (promise2) {
          var index = counter2++;
          var alreadyCalled = false;
          remaining++;
          call$b$2($promiseResolve, C, promise2).then(function (value) {
            if (alreadyCalled) return;
            alreadyCalled = true;
            values2[index] = value;
            --remaining || resolve2(values2);
          }, reject2);
        });
        --remaining || resolve2(values2);
      });
      if (result.error) reject2(result.value);
      return capability.promise;
    },
  }
);
var $$b$1 = _export$3;
var FORCED_PROMISE_CONSTRUCTOR$2$2 = promiseConstructorDetection$2.CONSTRUCTOR;
var NativePromiseConstructor$5 = promiseNativeConstructor$2;
var getBuiltIn$1$3 = getBuiltIn$8$2;
var isCallable$6$3 = isCallable$n;
var defineBuiltIn$5$2 = defineBuiltIn$8$1;
var NativePromisePrototype$3 =
  NativePromiseConstructor$5 && NativePromiseConstructor$5.prototype;
$$b$1(
  {
    target: "Promise",
    proto: true,
    forced: FORCED_PROMISE_CONSTRUCTOR$2$2,
    real: true,
  },
  {
    catch: function (onRejected) {
      return this.then(void 0, onRejected);
    },
  }
);
if (isCallable$6$3(NativePromiseConstructor$5)) {
  method$2 = getBuiltIn$1$3("Promise").prototype["catch"];
  if (NativePromisePrototype$3["catch"] !== method$2) {
    defineBuiltIn$5$2(NativePromisePrototype$3, "catch", method$2, {
      unsafe: true,
    });
  }
}
var method$2;
var $$a$1 = _export$3;
var call$a$2 = functionCall$3;
var aCallable$2$2 = aCallable$9$1;
var newPromiseCapabilityModule$1$2 = newPromiseCapability$2$2;
var perform$5 = perform$3$2;
var iterate$4 = iterate$2$2;
var PROMISE_STATICS_INCORRECT_ITERATION$3 = promiseStaticsIncorrectIteration$2;
$$a$1(
  {
    target: "Promise",
    stat: true,
    forced: PROMISE_STATICS_INCORRECT_ITERATION$3,
  },
  {
    race: function race(iterable) {
      var C = this;
      var capability = newPromiseCapabilityModule$1$2.f(C);
      var reject2 = capability.reject;
      var result = perform$5(function () {
        var $promiseResolve = aCallable$2$2(C.resolve);
        iterate$4(iterable, function (promise2) {
          call$a$2($promiseResolve, C, promise2).then(
            capability.resolve,
            reject2
          );
        });
      });
      if (result.error) reject2(result.value);
      return capability.promise;
    },
  }
);
var $$9$1 = _export$3;
var call$9$2 = functionCall$3;
var newPromiseCapabilityModule$5 = newPromiseCapability$2$2;
var FORCED_PROMISE_CONSTRUCTOR$1$2 = promiseConstructorDetection$2.CONSTRUCTOR;
$$9$1(
  { target: "Promise", stat: true, forced: FORCED_PROMISE_CONSTRUCTOR$1$2 },
  {
    reject: function reject(r) {
      var capability = newPromiseCapabilityModule$5.f(this);
      call$9$2(capability.reject, void 0, r);
      return capability.promise;
    },
  }
);
var anObject$6$2 = anObject$e$1;
var isObject$6$2 = isObject$d;
var newPromiseCapability$4 = newPromiseCapability$2$2;
var promiseResolve$1$2 = function (C, x) {
  anObject$6$2(C);
  if (isObject$6$2(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability$4.f(C);
  var resolve2 = promiseCapability.resolve;
  resolve2(x);
  return promiseCapability.promise;
};
var $$8$1 = _export$3;
var getBuiltIn$b = getBuiltIn$8$2;
var FORCED_PROMISE_CONSTRUCTOR$7 = promiseConstructorDetection$2.CONSTRUCTOR;
var promiseResolve$3 = promiseResolve$1$2;
getBuiltIn$b("Promise");
$$8$1(
  { target: "Promise", stat: true, forced: FORCED_PROMISE_CONSTRUCTOR$7 },
  {
    resolve: function resolve(x) {
      return promiseResolve$3(this, x);
    },
  }
);
var WebStorageService = class {
  getItem(key) {
    return new Promise((resolve2) => {
      const value = localStorage.getItem(key);
      resolve2(value);
    });
  }
  setItem(key, value) {
    return new Promise((resolve2) => {
      localStorage.setItem(key, value);
      resolve2();
    });
  }
  removeItem(key) {
    return new Promise((resolve2) => {
      localStorage.removeItem(key);
      resolve2();
    });
  }
};
var objectDefineProperties$2 = {};
var internalObjectKeys$4 = objectKeysInternal$3;
var enumBugKeys$1$3 = enumBugKeys$3$2;
var objectKeys$2$3 =
  Object.keys ||
  function keys(O) {
    return internalObjectKeys$4(O, enumBugKeys$1$3);
  };
var DESCRIPTORS$5$3 = descriptors$3;
var V8_PROTOTYPE_DEFINE_BUG$4 = v8PrototypeDefineBug$3;
var definePropertyModule$2$3 = objectDefineProperty$3;
var anObject$5$2 = anObject$e$1;
var toIndexedObject$2$3 = toIndexedObject$6$1;
var objectKeys$1$3 = objectKeys$2$3;
objectDefineProperties$2.f =
  DESCRIPTORS$5$3 && !V8_PROTOTYPE_DEFINE_BUG$4
    ? Object.defineProperties
    : function defineProperties(O, Properties) {
        anObject$5$2(O);
        var props = toIndexedObject$2$3(Properties);
        var keys2 = objectKeys$1$3(Properties);
        var length = keys2.length;
        var index = 0;
        var key;
        while (length > index)
          definePropertyModule$2$3.f(O, (key = keys2[index++]), props[key]);
        return O;
      };
var anObject$4$2 = anObject$e$1;
var definePropertiesModule$2 = objectDefineProperties$2;
var enumBugKeys$6 = enumBugKeys$3$2;
var hiddenKeys$7 = hiddenKeys$4$2;
var html$4 = html$2$2;
var documentCreateElement$1$2 = documentCreateElement$2$2;
var sharedKey$1$3 = sharedKey$3$2;
var GT$2 = ">";
var LT$2 = "<";
var PROTOTYPE$1$1 = "prototype";
var SCRIPT$2 = "script";
var IE_PROTO$1$2 = sharedKey$1$3("IE_PROTO");
var EmptyConstructor$2 = function () {};
var scriptTag$2 = function (content) {
  return LT$2 + SCRIPT$2 + GT$2 + content + LT$2 + "/" + SCRIPT$2 + GT$2;
};
var NullProtoObjectViaActiveX$2 = function (activeXDocument2) {
  activeXDocument2.write(scriptTag$2(""));
  activeXDocument2.close();
  var temp = activeXDocument2.parentWindow.Object;
  activeXDocument2 = null;
  return temp;
};
var NullProtoObjectViaIFrame$2 = function () {
  var iframe = documentCreateElement$1$2("iframe");
  var JS = "java" + SCRIPT$2 + ":";
  var iframeDocument;
  iframe.style.display = "none";
  html$4.appendChild(iframe);
  iframe.src = String(JS);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(scriptTag$2("document.F=Object"));
  iframeDocument.close();
  return iframeDocument.F;
};
var activeXDocument$2;
var NullProtoObject$2 = function () {
  try {
    activeXDocument$2 = new ActiveXObject("htmlfile");
  } catch (error) {}
  NullProtoObject$2 =
    typeof document != "undefined"
      ? document.domain && activeXDocument$2
        ? NullProtoObjectViaActiveX$2(activeXDocument$2)
        : NullProtoObjectViaIFrame$2()
      : NullProtoObjectViaActiveX$2(activeXDocument$2);
  var length = enumBugKeys$6.length;
  while (length--)
    delete NullProtoObject$2[PROTOTYPE$1$1][enumBugKeys$6[length]];
  return NullProtoObject$2();
};
hiddenKeys$7[IE_PROTO$1$2] = true;
var objectCreate$2 =
  Object.create ||
  function create(O, Properties) {
    var result;
    if (O !== null) {
      EmptyConstructor$2[PROTOTYPE$1$1] = anObject$4$2(O);
      result = new EmptyConstructor$2();
      EmptyConstructor$2[PROTOTYPE$1$1] = null;
      result[IE_PROTO$1$2] = O;
    } else result = NullProtoObject$2();
    return Properties === void 0
      ? result
      : definePropertiesModule$2.f(result, Properties);
  };
var wellKnownSymbol$8$2 = wellKnownSymbol$j;
var create$3 = objectCreate$2;
var defineProperty$4$2 = objectDefineProperty$3.f;
var UNSCOPABLES$2 = wellKnownSymbol$8$2("unscopables");
var ArrayPrototype$3 = Array.prototype;
if (ArrayPrototype$3[UNSCOPABLES$2] == void 0) {
  defineProperty$4$2(ArrayPrototype$3, UNSCOPABLES$2, {
    configurable: true,
    value: create$3(null),
  });
}
var addToUnscopables$2$1 = function (key) {
  ArrayPrototype$3[UNSCOPABLES$2][key] = true;
};
var fails$g$1 = fails$r;
var correctPrototypeGetter$2 = !fails$g$1(function () {
  function F() {}
  F.prototype.constructor = null;
  return Object.getPrototypeOf(new F()) !== F.prototype;
});
var hasOwn$2$3 = hasOwnProperty_1$3;
var isCallable$5$3 = isCallable$n;
var toObject$5$1 = toObject$7;
var sharedKey$6 = sharedKey$3$2;
var CORRECT_PROTOTYPE_GETTER$2 = correctPrototypeGetter$2;
var IE_PROTO$3 = sharedKey$6("IE_PROTO");
var $Object$7 = Object;
var ObjectPrototype$2 = $Object$7.prototype;
var objectGetPrototypeOf$2 = CORRECT_PROTOTYPE_GETTER$2
  ? $Object$7.getPrototypeOf
  : function (O) {
      var object = toObject$5$1(O);
      if (hasOwn$2$3(object, IE_PROTO$3)) return object[IE_PROTO$3];
      var constructor = object.constructor;
      if (isCallable$5$3(constructor) && object instanceof constructor) {
        return constructor.prototype;
      }
      return object instanceof $Object$7 ? ObjectPrototype$2 : null;
    };
var fails$f$1 = fails$r;
var isCallable$4$3 = isCallable$n;
var getPrototypeOf$3 = objectGetPrototypeOf$2;
var defineBuiltIn$4$2 = defineBuiltIn$8$1;
var wellKnownSymbol$7$2 = wellKnownSymbol$j;
var ITERATOR$2$2 = wellKnownSymbol$7$2("iterator");
var BUGGY_SAFARI_ITERATORS$1$2 = false;
var IteratorPrototype$2$2;
var PrototypeOfArrayIteratorPrototype$2;
var arrayIterator$2;
if ([].keys) {
  arrayIterator$2 = [].keys();
  if (!("next" in arrayIterator$2)) BUGGY_SAFARI_ITERATORS$1$2 = true;
  else {
    PrototypeOfArrayIteratorPrototype$2 = getPrototypeOf$3(
      getPrototypeOf$3(arrayIterator$2)
    );
    if (PrototypeOfArrayIteratorPrototype$2 !== Object.prototype)
      IteratorPrototype$2$2 = PrototypeOfArrayIteratorPrototype$2;
  }
}
var NEW_ITERATOR_PROTOTYPE$2 =
  IteratorPrototype$2$2 == void 0 ||
  fails$f$1(function () {
    var test2 = {};
    return IteratorPrototype$2$2[ITERATOR$2$2].call(test2) !== test2;
  });
if (NEW_ITERATOR_PROTOTYPE$2) IteratorPrototype$2$2 = {};
if (!isCallable$4$3(IteratorPrototype$2$2[ITERATOR$2$2])) {
  defineBuiltIn$4$2(IteratorPrototype$2$2, ITERATOR$2$2, function () {
    return this;
  });
}
var iteratorsCore$2 = {
  IteratorPrototype: IteratorPrototype$2$2,
  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS$1$2,
};
var IteratorPrototype$1$2 = iteratorsCore$2.IteratorPrototype;
var create$2 = objectCreate$2;
var createPropertyDescriptor$2$3 = createPropertyDescriptor$5$1;
var setToStringTag$2$2 = setToStringTag$4$1;
var Iterators$2$2 = iterators$2;
var returnThis$1$2 = function () {
  return this;
};
var createIteratorConstructor$1$2 = function (
  IteratorConstructor,
  NAME2,
  next,
  ENUMERABLE_NEXT
) {
  var TO_STRING_TAG2 = NAME2 + " Iterator";
  IteratorConstructor.prototype = create$2(IteratorPrototype$1$2, {
    next: createPropertyDescriptor$2$3(+!ENUMERABLE_NEXT, next),
  });
  setToStringTag$2$2(IteratorConstructor, TO_STRING_TAG2, false);
  Iterators$2$2[TO_STRING_TAG2] = returnThis$1$2;
  return IteratorConstructor;
};
var $$7$3 = _export$3;
var call$8$2 = functionCall$3;
var FunctionName$1$1 = functionName$3;
var isCallable$3$3 = isCallable$n;
var createIteratorConstructor$3 = createIteratorConstructor$1$2;
var getPrototypeOf$2$1 = objectGetPrototypeOf$2;
var setPrototypeOf$4 = objectSetPrototypeOf$2;
var setToStringTag$1$2 = setToStringTag$4$1;
var createNonEnumerableProperty$5$1 = createNonEnumerableProperty$8;
var defineBuiltIn$3$2 = defineBuiltIn$8$1;
var wellKnownSymbol$6$2 = wellKnownSymbol$j;
var Iterators$1$2 = iterators$2;
var IteratorsCore$2 = iteratorsCore$2;
var PROPER_FUNCTION_NAME$1$2 = FunctionName$1$1.PROPER;
var CONFIGURABLE_FUNCTION_NAME$1$2 = FunctionName$1$1.CONFIGURABLE;
var IteratorPrototype$4 = IteratorsCore$2.IteratorPrototype;
var BUGGY_SAFARI_ITERATORS$3 = IteratorsCore$2.BUGGY_SAFARI_ITERATORS;
var ITERATOR$1$2 = wellKnownSymbol$6$2("iterator");
var KEYS$2 = "keys";
var VALUES$2 = "values";
var ENTRIES$2 = "entries";
var returnThis$3 = function () {
  return this;
};
var defineIterator$1$2 = function (
  Iterable,
  NAME2,
  IteratorConstructor,
  next,
  DEFAULT,
  IS_SET,
  FORCED2
) {
  createIteratorConstructor$3(IteratorConstructor, NAME2, next);
  var getIterationMethod = function (KIND) {
    if (KIND === DEFAULT && defaultIterator) return defaultIterator;
    if (!BUGGY_SAFARI_ITERATORS$3 && KIND in IterablePrototype)
      return IterablePrototype[KIND];
    switch (KIND) {
      case KEYS$2:
        return function keys2() {
          return new IteratorConstructor(this, KIND);
        };
      case VALUES$2:
        return function values2() {
          return new IteratorConstructor(this, KIND);
        };
      case ENTRIES$2:
        return function entries() {
          return new IteratorConstructor(this, KIND);
        };
    }
    return function () {
      return new IteratorConstructor(this);
    };
  };
  var TO_STRING_TAG2 = NAME2 + " Iterator";
  var INCORRECT_VALUES_NAME = false;
  var IterablePrototype = Iterable.prototype;
  var nativeIterator =
    IterablePrototype[ITERATOR$1$2] ||
    IterablePrototype["@@iterator"] ||
    (DEFAULT && IterablePrototype[DEFAULT]);
  var defaultIterator =
    (!BUGGY_SAFARI_ITERATORS$3 && nativeIterator) ||
    getIterationMethod(DEFAULT);
  var anyNativeIterator =
    NAME2 == "Array"
      ? IterablePrototype.entries || nativeIterator
      : nativeIterator;
  var CurrentIteratorPrototype, methods, KEY;
  if (anyNativeIterator) {
    CurrentIteratorPrototype = getPrototypeOf$2$1(
      anyNativeIterator.call(new Iterable())
    );
    if (
      CurrentIteratorPrototype !== Object.prototype &&
      CurrentIteratorPrototype.next
    ) {
      if (
        getPrototypeOf$2$1(CurrentIteratorPrototype) !== IteratorPrototype$4
      ) {
        if (setPrototypeOf$4) {
          setPrototypeOf$4(CurrentIteratorPrototype, IteratorPrototype$4);
        } else if (!isCallable$3$3(CurrentIteratorPrototype[ITERATOR$1$2])) {
          defineBuiltIn$3$2(
            CurrentIteratorPrototype,
            ITERATOR$1$2,
            returnThis$3
          );
        }
      }
      setToStringTag$1$2(CurrentIteratorPrototype, TO_STRING_TAG2, true);
    }
  }
  if (
    PROPER_FUNCTION_NAME$1$2 &&
    DEFAULT == VALUES$2 &&
    nativeIterator &&
    nativeIterator.name !== VALUES$2
  ) {
    if (CONFIGURABLE_FUNCTION_NAME$1$2) {
      createNonEnumerableProperty$5$1(IterablePrototype, "name", VALUES$2);
    } else {
      INCORRECT_VALUES_NAME = true;
      defaultIterator = function values2() {
        return call$8$2(nativeIterator, this);
      };
    }
  }
  if (DEFAULT) {
    methods = {
      values: getIterationMethod(VALUES$2),
      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS$2),
      entries: getIterationMethod(ENTRIES$2),
    };
    if (FORCED2)
      for (KEY in methods) {
        if (
          BUGGY_SAFARI_ITERATORS$3 ||
          INCORRECT_VALUES_NAME ||
          !(KEY in IterablePrototype)
        ) {
          defineBuiltIn$3$2(IterablePrototype, KEY, methods[KEY]);
        }
      }
    else
      $$7$3(
        {
          target: NAME2,
          proto: true,
          forced: BUGGY_SAFARI_ITERATORS$3 || INCORRECT_VALUES_NAME,
        },
        methods
      );
  }
  if (IterablePrototype[ITERATOR$1$2] !== defaultIterator) {
    defineBuiltIn$3$2(IterablePrototype, ITERATOR$1$2, defaultIterator, {
      name: DEFAULT,
    });
  }
  Iterators$1$2[NAME2] = defaultIterator;
  return methods;
};
var toIndexedObject$1$3 = toIndexedObject$6$1;
var addToUnscopables$1$2 = addToUnscopables$2$1;
var Iterators$6 = iterators$2;
var InternalStateModule$3$1 = internalState$3;
var defineProperty$3$2 = objectDefineProperty$3.f;
var defineIterator$3 = defineIterator$1$2;
var DESCRIPTORS$4$3 = descriptors$3;
var ARRAY_ITERATOR$2 = "Array Iterator";
var setInternalState$2$1 = InternalStateModule$3$1.set;
var getInternalState$4 = InternalStateModule$3$1.getterFor(ARRAY_ITERATOR$2);
var es_array_iterator$2 = defineIterator$3(
  Array,
  "Array",
  function (iterated, kind) {
    setInternalState$2$1(this, {
      type: ARRAY_ITERATOR$2,
      target: toIndexedObject$1$3(iterated),
      // target
      index: 0,
      // next index
      kind,
      // kind
    });
  },
  function () {
    var state = getInternalState$4(this);
    var target = state.target;
    var kind = state.kind;
    var index = state.index++;
    if (!target || index >= target.length) {
      state.target = void 0;
      return { value: void 0, done: true };
    }
    if (kind == "keys") return { value: index, done: false };
    if (kind == "values") return { value: target[index], done: false };
    return { value: [index, target[index]], done: false };
  },
  "values"
);
var values$2 = (Iterators$6.Arguments = Iterators$6.Array);
addToUnscopables$1$2("keys");
addToUnscopables$1$2("values");
addToUnscopables$1$2("entries");
if (DESCRIPTORS$4$3 && values$2.name !== "values")
  try {
    defineProperty$3$2(values$2, "name", { value: "values" });
  } catch (error) {}
var domIterables$2 = {
  CSSRuleList: 0,
  CSSStyleDeclaration: 0,
  CSSValueList: 0,
  ClientRectList: 0,
  DOMRectList: 0,
  DOMStringList: 0,
  DOMTokenList: 1,
  DataTransferItemList: 0,
  FileList: 0,
  HTMLAllCollection: 0,
  HTMLCollection: 0,
  HTMLFormElement: 0,
  HTMLSelectElement: 0,
  MediaList: 0,
  MimeTypeArray: 0,
  NamedNodeMap: 0,
  NodeList: 1,
  PaintRequestList: 0,
  Plugin: 0,
  PluginArray: 0,
  SVGLengthList: 0,
  SVGNumberList: 0,
  SVGPathSegList: 0,
  SVGPointList: 0,
  SVGStringList: 0,
  SVGTransformList: 0,
  SourceBufferList: 0,
  StyleSheetList: 0,
  TextTrackCueList: 0,
  TextTrackList: 0,
  TouchList: 0,
};
var documentCreateElement$5 = documentCreateElement$2$2;
var classList$2 = documentCreateElement$5("span").classList;
var DOMTokenListPrototype$1$2 =
  classList$2 && classList$2.constructor && classList$2.constructor.prototype;
var domTokenListPrototype$2 =
  DOMTokenListPrototype$1$2 === Object.prototype
    ? void 0
    : DOMTokenListPrototype$1$2;
var global$b$2 = global$t;
var DOMIterables$2 = domIterables$2;
var DOMTokenListPrototype$3 = domTokenListPrototype$2;
var ArrayIteratorMethods$2 = es_array_iterator$2;
var createNonEnumerableProperty$4$2 = createNonEnumerableProperty$8;
var wellKnownSymbol$5$2 = wellKnownSymbol$j;
var ITERATOR$7 = wellKnownSymbol$5$2("iterator");
var TO_STRING_TAG$1$2 = wellKnownSymbol$5$2("toStringTag");
var ArrayValues$2 = ArrayIteratorMethods$2.values;
var handlePrototype$2 = function (CollectionPrototype, COLLECTION_NAME) {
  if (CollectionPrototype) {
    if (CollectionPrototype[ITERATOR$7] !== ArrayValues$2)
      try {
        createNonEnumerableProperty$4$2(
          CollectionPrototype,
          ITERATOR$7,
          ArrayValues$2
        );
      } catch (error) {
        CollectionPrototype[ITERATOR$7] = ArrayValues$2;
      }
    if (!CollectionPrototype[TO_STRING_TAG$1$2]) {
      createNonEnumerableProperty$4$2(
        CollectionPrototype,
        TO_STRING_TAG$1$2,
        COLLECTION_NAME
      );
    }
    if (DOMIterables$2[COLLECTION_NAME])
      for (var METHOD_NAME in ArrayIteratorMethods$2) {
        if (
          CollectionPrototype[METHOD_NAME] !==
          ArrayIteratorMethods$2[METHOD_NAME]
        )
          try {
            createNonEnumerableProperty$4$2(
              CollectionPrototype,
              METHOD_NAME,
              ArrayIteratorMethods$2[METHOD_NAME]
            );
          } catch (error) {
            CollectionPrototype[METHOD_NAME] =
              ArrayIteratorMethods$2[METHOD_NAME];
          }
      }
  }
};
for (COLLECTION_NAME$2 in DOMIterables$2) {
  handlePrototype$2(
    global$b$2[COLLECTION_NAME$2] && global$b$2[COLLECTION_NAME$2].prototype,
    COLLECTION_NAME$2
  );
}
var COLLECTION_NAME$2;
handlePrototype$2(DOMTokenListPrototype$3, "DOMTokenList");
var Logger = class _Logger {
  constructor(namespace) {
    this.namespace = namespace;
  }
  emit(method, ...params) {
    if (!_Logger.debug) {
      return;
    }
    if (this.namespace && method !== "error") {
      console[method](this.namespace, ...params);
      return;
    }
    console[method](...params);
  }
  log(...params) {
    this.emit("log", ...params);
  }
  info(...params) {
    this.emit("info", ...params);
  }
  warn(...params) {
    this.emit("warn", ...params);
  }
  error(...params) {
    this.emit("error", ...params);
  }
};
Logger.debug = false;
var logger = new Logger();
var $$6$2 = _export$3;
var $includes$1 = arrayIncludes$3.includes;
var fails$e$3 = fails$r;
var addToUnscopables$4 = addToUnscopables$2$1;
var BROKEN_ON_SPARSE$1 = fails$e$3(function () {
  return !Array(1).includes();
});
$$6$2(
  { target: "Array", proto: true, forced: BROKEN_ON_SPARSE$1 },
  {
    includes: function includes(el) {
      return $includes$1(
        this,
        el,
        arguments.length > 1 ? arguments[1] : void 0
      );
    },
  }
);
addToUnscopables$4("includes");
var isObject$5$3 = isObject$d;
var classof$6$2 = classofRaw$1$2;
var wellKnownSymbol$4$2 = wellKnownSymbol$j;
var MATCH$1$1 = wellKnownSymbol$4$2("match");
var isRegexp$1 = function (it) {
  var isRegExp2;
  return (
    isObject$5$3(it) &&
    ((isRegExp2 = it[MATCH$1$1]) !== void 0
      ? !!isRegExp2
      : classof$6$2(it) == "RegExp")
  );
};
var isRegExp$1 = isRegexp$1;
var $TypeError$3$3 = TypeError;
var notARegexp$1 = function (it) {
  if (isRegExp$1(it)) {
    throw $TypeError$3$3("The method doesn't accept regular expressions");
  }
  return it;
};
var classof$5$2 = classof$9;
var $String$6 = String;
var toString$4$1 = function (argument) {
  if (classof$5$2(argument) === "Symbol")
    throw TypeError("Cannot convert a Symbol value to a string");
  return $String$6(argument);
};
var wellKnownSymbol$3$2 = wellKnownSymbol$j;
var MATCH$2 = wellKnownSymbol$3$2("match");
var correctIsRegexpLogic$1 = function (METHOD_NAME) {
  var regexp = /./;
  try {
    "/./"[METHOD_NAME](regexp);
  } catch (error1) {
    try {
      regexp[MATCH$2] = false;
      return "/./"[METHOD_NAME](regexp);
    } catch (error2) {}
  }
  return false;
};
var $$5$2 = _export$3;
var uncurryThis$a$3 = functionUncurryThis$3;
var notARegExp$1 = notARegexp$1;
var requireObjectCoercible$2$3 = requireObjectCoercible$5;
var toString$3$1 = toString$4$1;
var correctIsRegExpLogic$1 = correctIsRegexpLogic$1;
var stringIndexOf$1 = uncurryThis$a$3("".indexOf);
$$5$2(
  {
    target: "String",
    proto: true,
    forced: !correctIsRegExpLogic$1("includes"),
  },
  {
    includes: function includes2(searchString) {
      return !!~stringIndexOf$1(
        toString$3$1(requireObjectCoercible$2$3(this)),
        toString$3$1(notARegExp$1(searchString)),
        arguments.length > 1 ? arguments[1] : void 0
      );
    },
  }
);
var DESCRIPTORS$3$3 = descriptors$3;
var uncurryThis$9$3 = functionUncurryThis$3;
var call$7$2 = functionCall$3;
var fails$d$2 = fails$r;
var objectKeys$4 = objectKeys$2$3;
var getOwnPropertySymbolsModule$4 = objectGetOwnPropertySymbols$3;
var propertyIsEnumerableModule$4 = objectPropertyIsEnumerable$3;
var toObject$4$1 = toObject$7;
var IndexedObject$2$2 = indexedObject$3;
var $assign$3 = Object.assign;
var defineProperty$2$3 = Object.defineProperty;
var concat$4 = uncurryThis$9$3([].concat);
var objectAssign$3 =
  !$assign$3 ||
  fails$d$2(function () {
    if (
      DESCRIPTORS$3$3 &&
      $assign$3(
        { b: 1 },
        $assign$3(
          defineProperty$2$3({}, "a", {
            enumerable: true,
            get: function () {
              defineProperty$2$3(this, "b", {
                value: 3,
                enumerable: false,
              });
            },
          }),
          { b: 2 }
        )
      ).b !== 1
    )
      return true;
    var A = {};
    var B = {};
    var symbol = Symbol();
    var alphabet = "abcdefghijklmnopqrst";
    A[symbol] = 7;
    alphabet.split("").forEach(function (chr) {
      B[chr] = chr;
    });
    return (
      $assign$3({}, A)[symbol] != 7 ||
      objectKeys$4($assign$3({}, B)).join("") != alphabet
    );
  })
    ? function assign(target, source) {
        var T = toObject$4$1(target);
        var argumentsLength = arguments.length;
        var index = 1;
        var getOwnPropertySymbols = getOwnPropertySymbolsModule$4.f;
        var propertyIsEnumerable2 = propertyIsEnumerableModule$4.f;
        while (argumentsLength > index) {
          var S = IndexedObject$2$2(arguments[index++]);
          var keys2 = getOwnPropertySymbols
            ? concat$4(objectKeys$4(S), getOwnPropertySymbols(S))
            : objectKeys$4(S);
          var length = keys2.length;
          var j = 0;
          var key;
          while (length > j) {
            key = keys2[j++];
            if (!DESCRIPTORS$3$3 || call$7$2(propertyIsEnumerable2, S, key))
              T[key] = S[key];
          }
        }
        return T;
      }
    : $assign$3;
var $$4$2 = _export$3;
var assign2$3 = objectAssign$3;
$$4$2(
  {
    target: "Object",
    stat: true,
    arity: 2,
    forced: Object.assign !== assign2$3,
  },
  {
    assign: assign2$3,
  }
);
var EventEmitter = class {
  constructor() {
    this.emitter = new import_events.EventEmitter();
  }
  on(eventName, callback) {
    this.emitter.on(eventName, callback);
    return {
      remove: () => this.emitter.off(eventName, callback),
    };
  }
  off(eventName, callback) {
    this.emitter.off(eventName, callback);
  }
  emit(eventName, event) {
    this.emitter.emit(eventName, event);
  }
};
var PACKAGE_NAME = "near-wallet-selector";
var RECENTLY_SIGNED_IN_WALLETS = "recentlySignedInWallets";
var CONTRACT = "contract";
var PENDING_CONTRACT = "contract:pending";
var SELECTED_WALLET_ID = `selectedWalletId`;
var PENDING_SELECTED_WALLET_ID = `selectedWalletId:pending`;
var WalletModules = class {
  constructor({ factories, storage, options, store, emitter, provider }) {
    this.factories = factories;
    this.storage = storage;
    this.options = options;
    this.store = store;
    this.emitter = emitter;
    this.provider = provider;
    this.modules = [];
    this.instances = {};
  }
  validateWallet(id2) {
    return __awaiter$3(this, void 0, void 0, function* () {
      let accounts = [];
      const wallet = yield this.getWallet(id2);
      if (wallet) {
        accounts = yield wallet.getAccounts().catch((err) => {
          logger.log(`Failed to validate ${wallet.id} during setup`);
          logger.error(err);
          return [];
        });
      }
      return accounts;
    });
  }
  resolveStorageState() {
    return __awaiter$3(this, void 0, void 0, function* () {
      const jsonStorage = new JsonStorage(this.storage, PACKAGE_NAME);
      const pendingSelectedWalletId = yield jsonStorage.getItem(
        PENDING_SELECTED_WALLET_ID
      );
      const pendingContract = yield jsonStorage.getItem(PENDING_CONTRACT);
      if (pendingSelectedWalletId && pendingContract) {
        const _accounts = yield this.validateWallet(pendingSelectedWalletId);
        yield jsonStorage.removeItem(PENDING_SELECTED_WALLET_ID);
        yield jsonStorage.removeItem(PENDING_CONTRACT);
        if (_accounts.length) {
          const { selectedWalletId: _selectedWalletId } = this.store.getState();
          const selectedWallet = yield this.getWallet(_selectedWalletId);
          if (selectedWallet && pendingSelectedWalletId !== _selectedWalletId) {
            yield selectedWallet.signOut().catch((err) => {
              logger.log("Failed to sign out existing wallet");
              logger.error(err);
            });
          }
          const recentlySignedInWalletsFromPending =
            yield this.setWalletAsRecentlySignedIn(pendingSelectedWalletId);
          return {
            accounts: _accounts,
            contract: pendingContract,
            selectedWalletId: pendingSelectedWalletId,
            recentlySignedInWallets: recentlySignedInWalletsFromPending,
          };
        }
      }
      const { contract, selectedWalletId } = this.store.getState();
      const accounts = yield this.validateWallet(selectedWalletId);
      const recentlySignedInWallets = yield jsonStorage.getItem(
        RECENTLY_SIGNED_IN_WALLETS
      );
      if (!accounts.length) {
        return {
          accounts: [],
          contract: null,
          selectedWalletId: null,
          recentlySignedInWallets: recentlySignedInWallets || [],
        };
      }
      return {
        accounts,
        contract,
        selectedWalletId,
        recentlySignedInWallets: recentlySignedInWallets || [],
      };
    });
  }
  setWalletAsRecentlySignedIn(walletId) {
    return __awaiter$3(this, void 0, void 0, function* () {
      const jsonStorage = new JsonStorage(this.storage, PACKAGE_NAME);
      let recentlySignedInWallets = yield jsonStorage.getItem(
        RECENTLY_SIGNED_IN_WALLETS
      );
      if (!recentlySignedInWallets) {
        recentlySignedInWallets = [];
      }
      if (!recentlySignedInWallets.includes(walletId)) {
        recentlySignedInWallets.unshift(walletId);
        recentlySignedInWallets = recentlySignedInWallets.slice(0, 5);
        yield jsonStorage.setItem(
          RECENTLY_SIGNED_IN_WALLETS,
          recentlySignedInWallets
        );
      }
      return recentlySignedInWallets;
    });
  }
  signOutWallet(walletId) {
    return __awaiter$3(this, void 0, void 0, function* () {
      const wallet = yield this.getWallet(walletId);
      yield wallet.signOut().catch((err) => {
        logger.log(`Failed to sign out ${wallet.id}`);
        logger.error(err);
        this.onWalletSignedOut(wallet.id);
      });
    });
  }
  onWalletSignedIn(walletId, { accounts, contractId, methodNames }) {
    return __awaiter$3(this, void 0, void 0, function* () {
      const { selectedWalletId } = this.store.getState();
      const jsonStorage = new JsonStorage(this.storage, PACKAGE_NAME);
      const contract = {
        contractId,
        methodNames,
      };
      if (!accounts.length) {
        const module = this.getModule(walletId);
        if (module.type === "browser") {
          yield jsonStorage.setItem(PENDING_SELECTED_WALLET_ID, walletId);
          yield jsonStorage.setItem(PENDING_CONTRACT, contract);
        }
        return;
      }
      if (selectedWalletId && selectedWalletId !== walletId) {
        yield this.signOutWallet(selectedWalletId);
      }
      const recentlySignedInWallets = yield this.setWalletAsRecentlySignedIn(
        walletId
      );
      this.store.dispatch({
        type: "WALLET_CONNECTED",
        payload: {
          walletId,
          contract,
          accounts,
          recentlySignedInWallets,
        },
      });
      this.emitter.emit("signedIn", {
        walletId,
        contractId,
        methodNames,
        accounts,
      });
    });
  }
  onWalletSignedOut(walletId) {
    this.store.dispatch({
      type: "WALLET_DISCONNECTED",
      payload: {
        walletId,
      },
    });
    this.emitter.emit("signedOut", {
      walletId,
    });
  }
  setupWalletEmitter(module) {
    const emitter = new EventEmitter();
    emitter.on("signedOut", () => {
      this.onWalletSignedOut(module.id);
    });
    emitter.on("signedIn", (event) => {
      this.onWalletSignedIn(module.id, event);
    });
    emitter.on("accountsChanged", ({ accounts }) =>
      __awaiter$3(this, void 0, void 0, function* () {
        this.emitter.emit("accountsChanged", {
          walletId: module.id,
          accounts,
        });
        if (!accounts.length) {
          return this.signOutWallet(module.id);
        }
        this.store.dispatch({
          type: "ACCOUNTS_CHANGED",
          payload: {
            walletId: module.id,
            accounts,
          },
        });
      })
    );
    emitter.on("networkChanged", ({ networkId }) => {
      this.emitter.emit("networkChanged", {
        walletId: module.id,
        networkId,
      });
    });
    emitter.on("uriChanged", ({ uri }) => {
      this.emitter.emit("uriChanged", {
        walletId: module.id,
        uri,
      });
    });
    return emitter;
  }
  decorateWallet(wallet) {
    const _signIn = wallet.signIn;
    const _signOut = wallet.signOut;
    const _signMessage = wallet.signMessage;
    wallet.signIn = (params) =>
      __awaiter$3(this, void 0, void 0, function* () {
        const accounts = yield _signIn(params);
        const { contractId, methodNames = [] } = params;
        yield this.onWalletSignedIn(wallet.id, {
          accounts,
          contractId,
          methodNames,
        });
        return accounts;
      });
    wallet.signOut = () =>
      __awaiter$3(this, void 0, void 0, function* () {
        yield _signOut();
        this.onWalletSignedOut(wallet.id);
      });
    wallet.signMessage = (params) =>
      __awaiter$3(this, void 0, void 0, function* () {
        if (_signMessage === void 0) {
          throw Error(
            `The signMessage method is not supported by ${wallet.metadata.name}`
          );
        }
        return yield _signMessage(params);
      });
    return wallet;
  }
  setupInstance(module) {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (!module.metadata.available) {
        const message =
          module.type === "injected" ? "not installed" : "not available";
        throw Error(`${module.metadata.name} is ${message}`);
      }
      const wallet = Object.assign(
        {
          id: module.id,
          type: module.type,
          metadata: module.metadata,
        },
        yield module.init({
          id: module.id,
          type: module.type,
          metadata: module.metadata,
          options: this.options,
          store: this.store.toReadOnly(),
          provider: this.provider,
          emitter: this.setupWalletEmitter(module),
          logger: new Logger(module.id),
          storage: new JsonStorage(this.storage, [PACKAGE_NAME, module.id]),
        })
      );
      return this.decorateWallet(wallet);
    });
  }
  getModule(id2) {
    return this.modules.find((x) => x.id === id2);
  }
  getWallet(id2) {
    return __awaiter$3(this, void 0, void 0, function* () {
      const module = this.getModule(id2);
      if (!module) {
        return null;
      }
      const { selectedWalletId } = this.store.getState();
      if (!module.metadata.available && selectedWalletId) {
        this.onWalletSignedOut(selectedWalletId);
        return null;
      }
      return yield module.wallet();
    });
  }
  setup() {
    return __awaiter$3(this, void 0, void 0, function* () {
      const modules = [];
      for (let i = 0; i < this.factories.length; i += 1) {
        const module = yield this.factories[i]({
          options: this.options,
        }).catch((err) => {
          logger.log("Failed to setup module");
          logger.error(err);
          return null;
        });
        if (!module) {
          continue;
        }
        if (modules.some((x) => x.id === module.id)) {
          continue;
        }
        modules.push({
          id: module.id,
          type: module.type,
          metadata: module.metadata,
          wallet: () =>
            __awaiter$3(this, void 0, void 0, function* () {
              let instance = this.instances[module.id];
              if (instance) {
                return instance;
              }
              instance = yield this.setupInstance(module);
              this.instances[module.id] = instance;
              return instance;
            }),
        });
      }
      this.modules = modules;
      const { accounts, contract, selectedWalletId, recentlySignedInWallets } =
        yield this.resolveStorageState();
      this.store.dispatch({
        type: "SETUP_WALLET_MODULES",
        payload: {
          modules,
          accounts,
          contract,
          selectedWalletId,
          recentlySignedInWallets,
        },
      });
      for (let i = 0; i < this.modules.length; i++) {
        if (this.modules[i].type !== "instant-link") {
          continue;
        }
        const wallet = yield this.modules[i].wallet();
        if (!wallet.metadata.runOnStartup) {
          continue;
        }
        try {
          yield wallet.signIn({
            contractId: wallet.getContractId(),
          });
        } catch (err) {
          logger.error("Failed to sign in to wallet. " + err);
        }
      }
    });
  }
};
var getNetworkPreset = (networkId) => {
  switch (networkId) {
    case "mainnet":
      return {
        networkId,
        nodeUrl: "https://rpc.mainnet.near.org",
        helperUrl: "https://helper.mainnet.near.org",
        explorerUrl: "https://explorer.near.org",
        indexerUrl: "https://api.kitwallet.app",
      };
    case "testnet":
      return {
        networkId,
        nodeUrl: "https://rpc.testnet.near.org",
        helperUrl: "https://helper.testnet.near.org",
        explorerUrl: "https://explorer.testnet.near.org",
        indexerUrl: "https://testnet-api.kitwallet.app",
      };
    default:
      throw Error(`Failed to find config for: '${networkId}'`);
  }
};
var resolveNetwork = (network) => {
  return typeof network === "string" ? getNetworkPreset(network) : network;
};
var resolveOptions = (params) => {
  const options = {
    languageCode: params.languageCode || void 0,
    network: resolveNetwork(params.network),
    debug: params.debug || false,
    optimizeWalletOrder: params.optimizeWalletOrder === false ? false : true,
    randomizeWalletOrder: params.randomizeWalletOrder || false,
    relayerUrl: params.relayerUrl || void 0,
  };
  return {
    options,
    storage: params.storage || new WebStorageService(),
  };
};
var reducer = (state, action) => {
  logger.log("Store Action", action);
  switch (action.type) {
    case "SETUP_WALLET_MODULES": {
      const {
        modules,
        accounts,
        contract,
        selectedWalletId,
        recentlySignedInWallets,
      } = action.payload;
      const accountStates = accounts.map((account, i) => {
        return Object.assign(Object.assign({}, account), {
          active: i === 0,
        });
      });
      return Object.assign(Object.assign({}, state), {
        modules,
        accounts: accountStates,
        contract,
        selectedWalletId,
        recentlySignedInWallets,
      });
    }
    case "WALLET_CONNECTED": {
      const { walletId, contract, accounts, recentlySignedInWallets } =
        action.payload;
      if (!accounts.length) {
        return state;
      }
      const activeAccountIndex = state.accounts.findIndex(
        (account) => account.active
      );
      const accountStates = accounts.map((account, i) => {
        return Object.assign(Object.assign({}, account), {
          active: i === (activeAccountIndex > -1 ? activeAccountIndex : 0),
        });
      });
      return Object.assign(Object.assign({}, state), {
        contract,
        accounts: accountStates,
        selectedWalletId: walletId,
        recentlySignedInWallets,
      });
    }
    case "WALLET_DISCONNECTED": {
      const { walletId } = action.payload;
      if (walletId !== state.selectedWalletId) {
        return state;
      }
      return Object.assign(Object.assign({}, state), {
        contract: null,
        accounts: [],
        selectedWalletId: null,
      });
    }
    case "ACCOUNTS_CHANGED": {
      const { walletId, accounts } = action.payload;
      if (walletId !== state.selectedWalletId) {
        return state;
      }
      const activeAccount = state.accounts.find((account) => account.active);
      const isActiveAccountRemoved = !accounts.some(
        (account) =>
          account.accountId ===
          (activeAccount === null || activeAccount === void 0
            ? void 0
            : activeAccount.accountId)
      );
      const accountStates = accounts.map((account, i) => {
        return Object.assign(Object.assign({}, account), {
          active: isActiveAccountRemoved
            ? i === 0
            : account.accountId ===
              (activeAccount === null || activeAccount === void 0
                ? void 0
                : activeAccount.accountId),
        });
      });
      return Object.assign(Object.assign({}, state), {
        accounts: accountStates,
      });
    }
    case "SET_ACTIVE_ACCOUNT": {
      const { accountId } = action.payload;
      const accountStates = state.accounts.map((account) => {
        return Object.assign(Object.assign({}, account), {
          active: account.accountId === accountId,
        });
      });
      return Object.assign(Object.assign({}, state), {
        accounts: accountStates,
      });
    }
    default:
      return state;
  }
};
var createStore = (storage) =>
  __awaiter$3(void 0, void 0, void 0, function* () {
    const jsonStorage = new JsonStorage(storage, PACKAGE_NAME);
    const initialState = {
      modules: [],
      accounts: [],
      contract: yield jsonStorage.getItem(CONTRACT),
      selectedWalletId: yield jsonStorage.getItem(SELECTED_WALLET_ID),
      recentlySignedInWallets:
        (yield jsonStorage.getItem(RECENTLY_SIGNED_IN_WALLETS)) || [],
    };
    const state$ = new BehaviorSubject(initialState);
    const actions$ = new Subject();
    actions$.pipe(scan(reducer, initialState)).subscribe(state$);
    const syncStorage = (prevState2, state, storageKey, property) =>
      __awaiter$3(void 0, void 0, void 0, function* () {
        if (state[property] === prevState2[property]) {
          return;
        }
        if (state[property]) {
          yield jsonStorage.setItem(storageKey, state[property]);
          return;
        }
        yield jsonStorage.removeItem(storageKey);
      });
    let prevState = state$.getValue();
    state$.subscribe((state) => {
      syncStorage(prevState, state, SELECTED_WALLET_ID, "selectedWalletId");
      syncStorage(prevState, state, CONTRACT, "contract");
      syncStorage(
        prevState,
        state,
        RECENTLY_SIGNED_IN_WALLETS,
        "recentlySignedInWallets"
      );
      prevState = state;
    });
    return {
      observable: state$,
      getState: () => state$.getValue(),
      dispatch: (action) => actions$.next(action),
      toReadOnly: () => ({
        getState: () => state$.getValue(),
        observable: state$.asObservable(),
      }),
    };
  });
var walletSelectorInstance = null;
var createSelector = (options, store, walletModules, emitter) => {
  return {
    options,
    store: store.toReadOnly(),
    wallet: (id2) =>
      __awaiter$3(void 0, void 0, void 0, function* () {
        const { selectedWalletId } = store.getState();
        const wallet = yield walletModules.getWallet(id2 || selectedWalletId);
        if (!wallet) {
          if (id2) {
            throw new Error("Invalid wallet id");
          }
          throw new Error("No wallet selected");
        }
        return wallet;
      }),
    setActiveAccount: (accountId) => {
      const { accounts } = store.getState();
      if (!accounts.some((account) => account.accountId === accountId)) {
        throw new Error("Invalid account id");
      }
      store.dispatch({
        type: "SET_ACTIVE_ACCOUNT",
        payload: {
          accountId,
        },
      });
    },
    isSignedIn() {
      const { accounts } = store.getState();
      return Boolean(accounts.length);
    },
    on: (eventName, callback) => {
      return emitter.on(eventName, callback);
    },
    off: (eventName, callback) => {
      emitter.off(eventName, callback);
    },
  };
};
var setupWalletSelector = (params) =>
  __awaiter$3(void 0, void 0, void 0, function* () {
    const { options, storage } = resolveOptions(params);
    Logger.debug = options.debug;
    const emitter = new EventEmitter();
    const store = yield createStore(storage);
    const walletModules = new WalletModules({
      factories: params.modules,
      storage,
      options,
      store,
      emitter,
      provider: new Provider(options.network.nodeUrl),
    });
    yield walletModules.setup();
    if (params.allowMultipleSelectors) {
      return createSelector(options, store, walletModules, emitter);
    }
    if (!walletSelectorInstance) {
      walletSelectorInstance = createSelector(
        options,
        store,
        walletModules,
        emitter
      );
    }
    return walletSelectorInstance;
  });
var aCallable$1$3 = aCallable$9$1;
var toObject$3$3 = toObject$7;
var IndexedObject$1$3 = indexedObject$3;
var lengthOfArrayLike$5$1 = lengthOfArrayLike$8;
var $TypeError$2$3 = TypeError;
var createMethod$2$1 = function (IS_RIGHT) {
  return function (that, callbackfn, argumentsLength, memo) {
    aCallable$1$3(callbackfn);
    var O = toObject$3$3(that);
    var self2 = IndexedObject$1$3(O);
    var length = lengthOfArrayLike$5$1(O);
    var index = IS_RIGHT ? length - 1 : 0;
    var i = IS_RIGHT ? -1 : 1;
    if (argumentsLength < 2)
      while (true) {
        if (index in self2) {
          memo = self2[index];
          index += i;
          break;
        }
        index += i;
        if (IS_RIGHT ? index < 0 : length <= index) {
          throw $TypeError$2$3("Reduce of empty array with no initial value");
        }
      }
    for (; IS_RIGHT ? index >= 0 : length > index; index += i)
      if (index in self2) {
        memo = callbackfn(memo, self2[index], index, O);
      }
    return memo;
  };
};
var arrayReduce$1 = {
  // `Array.prototype.reduce` method
  // https://tc39.es/ecma262/#sec-array.prototype.reduce
  left: createMethod$2$1(false),
  // `Array.prototype.reduceRight` method
  // https://tc39.es/ecma262/#sec-array.prototype.reduceright
  right: createMethod$2$1(true),
};
var fails$c$2 = fails$r;
var arrayMethodIsStrict$1$1 = function (METHOD_NAME, argument) {
  var method = [][METHOD_NAME];
  return (
    !!method &&
    fails$c$2(function () {
      method.call(
        null,
        argument ||
          function () {
            return 1;
          },
        1
      );
    })
  );
};
var $$3$2 = _export$3;
var $reduce$1 = arrayReduce$1.left;
var arrayMethodIsStrict$3 = arrayMethodIsStrict$1$1;
var CHROME_VERSION$1 = engineV8Version$3;
var IS_NODE$5 = engineIsNode$2;
var STRICT_METHOD$2 = arrayMethodIsStrict$3("reduce");
var CHROME_BUG$1 = !IS_NODE$5 && CHROME_VERSION$1 > 79 && CHROME_VERSION$1 < 83;
$$3$2(
  { target: "Array", proto: true, forced: !STRICT_METHOD$2 || CHROME_BUG$1 },
  {
    reduce: function reduce(callbackfn) {
      var length = arguments.length;
      return $reduce$1(
        this,
        callbackfn,
        length,
        length > 1 ? arguments[1] : void 0
      );
    },
  }
);
var anObject$3$2 = anObject$e$1;
var regexpFlags$1$1 = function () {
  var that = anObject$3$2(this);
  var result = "";
  if (that.hasIndices) result += "d";
  if (that.global) result += "g";
  if (that.ignoreCase) result += "i";
  if (that.multiline) result += "m";
  if (that.dotAll) result += "s";
  if (that.unicode) result += "u";
  if (that.unicodeSets) result += "v";
  if (that.sticky) result += "y";
  return result;
};
var fails$b$2 = fails$r;
var global$a$3 = global$t;
var $RegExp$2 = global$a$3.RegExp;
var UNSUPPORTED_Y$2 = fails$b$2(function () {
  var re = $RegExp$2("a", "y");
  re.lastIndex = 2;
  return re.exec("abcd") != null;
});
var MISSED_STICKY =
  UNSUPPORTED_Y$2 ||
  fails$b$2(function () {
    return !$RegExp$2("a", "y").sticky;
  });
var BROKEN_CARET =
  UNSUPPORTED_Y$2 ||
  fails$b$2(function () {
    var re = $RegExp$2("^r", "gy");
    re.lastIndex = 2;
    return re.exec("str") != null;
  });
var regexpStickyHelpers = {
  BROKEN_CARET,
  MISSED_STICKY,
  UNSUPPORTED_Y: UNSUPPORTED_Y$2,
};
var fails$a$2 = fails$r;
var global$9$3 = global$t;
var $RegExp$1 = global$9$3.RegExp;
var regexpUnsupportedDotAll = fails$a$2(function () {
  var re = $RegExp$1(".", "s");
  return !(re.dotAll && re.exec("\n") && re.flags === "s");
});
var fails$9$3 = fails$r;
var global$8$3 = global$t;
var $RegExp = global$8$3.RegExp;
var regexpUnsupportedNcg = fails$9$3(function () {
  var re = $RegExp("(?<a>b)", "g");
  return re.exec("b").groups.a !== "b" || "b".replace(re, "$<a>c") !== "bc";
});
var call$6$2 = functionCall$3;
var uncurryThis$8$3 = functionUncurryThis$3;
var toString$2$2 = toString$4$1;
var regexpFlags$2 = regexpFlags$1$1;
var stickyHelpers$1 = regexpStickyHelpers;
var shared$6 = shared$4$1.exports;
var create$1$2 = objectCreate$2;
var getInternalState$3$1 = internalState$3.get;
var UNSUPPORTED_DOT_ALL = regexpUnsupportedDotAll;
var UNSUPPORTED_NCG = regexpUnsupportedNcg;
var nativeReplace = shared$6("native-string-replace", String.prototype.replace);
var nativeExec = RegExp.prototype.exec;
var patchedExec = nativeExec;
var charAt$2 = uncurryThis$8$3("".charAt);
var indexOf$3 = uncurryThis$8$3("".indexOf);
var replace$1 = uncurryThis$8$3("".replace);
var stringSlice$2$1 = uncurryThis$8$3("".slice);
var UPDATES_LAST_INDEX_WRONG = (function () {
  var re1 = /a/;
  var re2 = /b*/g;
  call$6$2(nativeExec, re1, "a");
  call$6$2(nativeExec, re2, "a");
  return re1.lastIndex !== 0 || re2.lastIndex !== 0;
})();
var UNSUPPORTED_Y$1 = stickyHelpers$1.BROKEN_CARET;
var NPCG_INCLUDED = /()??/.exec("")[1] !== void 0;
var PATCH =
  UPDATES_LAST_INDEX_WRONG ||
  NPCG_INCLUDED ||
  UNSUPPORTED_Y$1 ||
  UNSUPPORTED_DOT_ALL ||
  UNSUPPORTED_NCG;
if (PATCH) {
  patchedExec = function exec2(string) {
    var re = this;
    var state = getInternalState$3$1(re);
    var str = toString$2$2(string);
    var raw = state.raw;
    var result, reCopy, lastIndex, match2, i, object, group;
    if (raw) {
      raw.lastIndex = re.lastIndex;
      result = call$6$2(patchedExec, raw, str);
      re.lastIndex = raw.lastIndex;
      return result;
    }
    var groups = state.groups;
    var sticky = UNSUPPORTED_Y$1 && re.sticky;
    var flags = call$6$2(regexpFlags$2, re);
    var source = re.source;
    var charsAdded = 0;
    var strCopy = str;
    if (sticky) {
      flags = replace$1(flags, "y", "");
      if (indexOf$3(flags, "g") === -1) {
        flags += "g";
      }
      strCopy = stringSlice$2$1(str, re.lastIndex);
      if (
        re.lastIndex > 0 &&
        (!re.multiline ||
          (re.multiline && charAt$2(str, re.lastIndex - 1) !== "\n"))
      ) {
        source = "(?: " + source + ")";
        strCopy = " " + strCopy;
        charsAdded++;
      }
      reCopy = new RegExp("^(?:" + source + ")", flags);
    }
    if (NPCG_INCLUDED) {
      reCopy = new RegExp("^" + source + "$(?!\\s)", flags);
    }
    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex;
    match2 = call$6$2(nativeExec, sticky ? reCopy : re, strCopy);
    if (sticky) {
      if (match2) {
        match2.input = stringSlice$2$1(match2.input, charsAdded);
        match2[0] = stringSlice$2$1(match2[0], charsAdded);
        match2.index = re.lastIndex;
        re.lastIndex += match2[0].length;
      } else re.lastIndex = 0;
    } else if (UPDATES_LAST_INDEX_WRONG && match2) {
      re.lastIndex = re.global ? match2.index + match2[0].length : lastIndex;
    }
    if (NPCG_INCLUDED && match2 && match2.length > 1) {
      call$6$2(nativeReplace, match2[0], reCopy, function () {
        for (i = 1; i < arguments.length - 2; i++) {
          if (arguments[i] === void 0) match2[i] = void 0;
        }
      });
    }
    if (match2 && groups) {
      match2.groups = object = create$1$2(null);
      for (i = 0; i < groups.length; i++) {
        group = groups[i];
        object[group[0]] = match2[group[1]];
      }
    }
    return match2;
  };
}
var regexpExec$3 = patchedExec;
var $$2$2 = _export$3;
var exec$1$1 = regexpExec$3;
$$2$2(
  { target: "RegExp", proto: true, forced: /./.exec !== exec$1$1 },
  {
    exec: exec$1$1,
  }
);
var arrayBufferNative =
  typeof ArrayBuffer != "undefined" && typeof DataView != "undefined";
var NATIVE_ARRAY_BUFFER$1 = arrayBufferNative;
var DESCRIPTORS$2$3 = descriptors$3;
var global$7$3 = global$t;
var isCallable$2$3 = isCallable$n;
var isObject$4$3 = isObject$d;
var hasOwn$1$3 = hasOwnProperty_1$3;
var classof$4$2 = classof$9;
var tryToString$7 = tryToString$5$2;
var createNonEnumerableProperty$3$2 = createNonEnumerableProperty$8;
var defineBuiltIn$2$2 = defineBuiltIn$8$1;
var defineProperty$1$3 = objectDefineProperty$3.f;
var isPrototypeOf$1$2 = objectIsPrototypeOf$3;
var getPrototypeOf$1$2 = objectGetPrototypeOf$2;
var setPrototypeOf$3 = objectSetPrototypeOf$2;
var wellKnownSymbol$2$2 = wellKnownSymbol$j;
var uid$5 = uid$3$1;
var InternalStateModule$2$2 = internalState$3;
var enforceInternalState$1$1 = InternalStateModule$2$2.enforce;
var getInternalState$2$1 = InternalStateModule$2$2.get;
var Int8Array$4 = global$7$3.Int8Array;
var Int8ArrayPrototype$1 = Int8Array$4 && Int8Array$4.prototype;
var Uint8ClampedArray$1 = global$7$3.Uint8ClampedArray;
var Uint8ClampedArrayPrototype =
  Uint8ClampedArray$1 && Uint8ClampedArray$1.prototype;
var TypedArray$1 = Int8Array$4 && getPrototypeOf$1$2(Int8Array$4);
var TypedArrayPrototype$1 =
  Int8ArrayPrototype$1 && getPrototypeOf$1$2(Int8ArrayPrototype$1);
var ObjectPrototype$1$1 = Object.prototype;
var TypeError$1$3 = global$7$3.TypeError;
var TO_STRING_TAG$5 = wellKnownSymbol$2$2("toStringTag");
var TYPED_ARRAY_TAG$1 = uid$5("TYPED_ARRAY_TAG");
var TYPED_ARRAY_CONSTRUCTOR = "TypedArrayConstructor";
var NATIVE_ARRAY_BUFFER_VIEWS$2 =
  NATIVE_ARRAY_BUFFER$1 &&
  !!setPrototypeOf$3 &&
  classof$4$2(global$7$3.opera) !== "Opera";
var TYPED_ARRAY_TAG_REQUIRED = false;
var NAME;
var Constructor;
var Prototype;
var TypedArrayConstructorsList = {
  Int8Array: 1,
  Uint8Array: 1,
  Uint8ClampedArray: 1,
  Int16Array: 2,
  Uint16Array: 2,
  Int32Array: 4,
  Uint32Array: 4,
  Float32Array: 4,
  Float64Array: 8,
};
var BigIntArrayConstructorsList = {
  BigInt64Array: 8,
  BigUint64Array: 8,
};
var isView = function isView2(it) {
  if (!isObject$4$3(it)) return false;
  var klass = classof$4$2(it);
  return (
    klass === "DataView" ||
    hasOwn$1$3(TypedArrayConstructorsList, klass) ||
    hasOwn$1$3(BigIntArrayConstructorsList, klass)
  );
};
var getTypedArrayConstructor = function (it) {
  var proto = getPrototypeOf$1$2(it);
  if (!isObject$4$3(proto)) return;
  var state = getInternalState$2$1(proto);
  return state && hasOwn$1$3(state, TYPED_ARRAY_CONSTRUCTOR)
    ? state[TYPED_ARRAY_CONSTRUCTOR]
    : getTypedArrayConstructor(proto);
};
var isTypedArray$1 = function (it) {
  if (!isObject$4$3(it)) return false;
  var klass = classof$4$2(it);
  return (
    hasOwn$1$3(TypedArrayConstructorsList, klass) ||
    hasOwn$1$3(BigIntArrayConstructorsList, klass)
  );
};
var aTypedArray$4 = function (it) {
  if (isTypedArray$1(it)) return it;
  throw TypeError$1$3("Target is not a typed array");
};
var aTypedArrayConstructor$2 = function (C) {
  if (
    isCallable$2$3(C) &&
    (!setPrototypeOf$3 || isPrototypeOf$1$2(TypedArray$1, C))
  )
    return C;
  throw TypeError$1$3(tryToString$7(C) + " is not a typed array constructor");
};
var exportTypedArrayMethod$4 = function (KEY, property, forced, options) {
  if (!DESCRIPTORS$2$3) return;
  if (forced)
    for (var ARRAY in TypedArrayConstructorsList) {
      var TypedArrayConstructor = global$7$3[ARRAY];
      if (
        TypedArrayConstructor &&
        hasOwn$1$3(TypedArrayConstructor.prototype, KEY)
      )
        try {
          delete TypedArrayConstructor.prototype[KEY];
        } catch (error) {
          try {
            TypedArrayConstructor.prototype[KEY] = property;
          } catch (error2) {}
        }
    }
  if (!TypedArrayPrototype$1[KEY] || forced) {
    defineBuiltIn$2$2(
      TypedArrayPrototype$1,
      KEY,
      forced
        ? property
        : (NATIVE_ARRAY_BUFFER_VIEWS$2 && Int8ArrayPrototype$1[KEY]) ||
            property,
      options
    );
  }
};
var exportTypedArrayStaticMethod$1 = function (KEY, property, forced) {
  var ARRAY, TypedArrayConstructor;
  if (!DESCRIPTORS$2$3) return;
  if (setPrototypeOf$3) {
    if (forced)
      for (ARRAY in TypedArrayConstructorsList) {
        TypedArrayConstructor = global$7$3[ARRAY];
        if (TypedArrayConstructor && hasOwn$1$3(TypedArrayConstructor, KEY))
          try {
            delete TypedArrayConstructor[KEY];
          } catch (error) {}
      }
    if (!TypedArray$1[KEY] || forced) {
      try {
        return defineBuiltIn$2$2(
          TypedArray$1,
          KEY,
          forced
            ? property
            : (NATIVE_ARRAY_BUFFER_VIEWS$2 && TypedArray$1[KEY]) || property
        );
      } catch (error) {}
    } else return;
  }
  for (ARRAY in TypedArrayConstructorsList) {
    TypedArrayConstructor = global$7$3[ARRAY];
    if (TypedArrayConstructor && (!TypedArrayConstructor[KEY] || forced)) {
      defineBuiltIn$2$2(TypedArrayConstructor, KEY, property);
    }
  }
};
for (NAME in TypedArrayConstructorsList) {
  Constructor = global$7$3[NAME];
  Prototype = Constructor && Constructor.prototype;
  if (Prototype)
    enforceInternalState$1$1(Prototype)[TYPED_ARRAY_CONSTRUCTOR] = Constructor;
  else NATIVE_ARRAY_BUFFER_VIEWS$2 = false;
}
for (NAME in BigIntArrayConstructorsList) {
  Constructor = global$7$3[NAME];
  Prototype = Constructor && Constructor.prototype;
  if (Prototype)
    enforceInternalState$1$1(Prototype)[TYPED_ARRAY_CONSTRUCTOR] = Constructor;
}
if (
  !NATIVE_ARRAY_BUFFER_VIEWS$2 ||
  !isCallable$2$3(TypedArray$1) ||
  TypedArray$1 === Function.prototype
) {
  TypedArray$1 = function TypedArray2() {
    throw TypeError$1$3("Incorrect invocation");
  };
  if (NATIVE_ARRAY_BUFFER_VIEWS$2)
    for (NAME in TypedArrayConstructorsList) {
      if (global$7$3[NAME]) setPrototypeOf$3(global$7$3[NAME], TypedArray$1);
    }
}
if (
  !NATIVE_ARRAY_BUFFER_VIEWS$2 ||
  !TypedArrayPrototype$1 ||
  TypedArrayPrototype$1 === ObjectPrototype$1$1
) {
  TypedArrayPrototype$1 = TypedArray$1.prototype;
  if (NATIVE_ARRAY_BUFFER_VIEWS$2)
    for (NAME in TypedArrayConstructorsList) {
      if (global$7$3[NAME])
        setPrototypeOf$3(global$7$3[NAME].prototype, TypedArrayPrototype$1);
    }
}
if (
  NATIVE_ARRAY_BUFFER_VIEWS$2 &&
  getPrototypeOf$1$2(Uint8ClampedArrayPrototype) !== TypedArrayPrototype$1
) {
  setPrototypeOf$3(Uint8ClampedArrayPrototype, TypedArrayPrototype$1);
}
if (DESCRIPTORS$2$3 && !hasOwn$1$3(TypedArrayPrototype$1, TO_STRING_TAG$5)) {
  TYPED_ARRAY_TAG_REQUIRED = true;
  defineProperty$1$3(TypedArrayPrototype$1, TO_STRING_TAG$5, {
    get: function () {
      return isObject$4$3(this) ? this[TYPED_ARRAY_TAG$1] : void 0;
    },
  });
  for (NAME in TypedArrayConstructorsList)
    if (global$7$3[NAME]) {
      createNonEnumerableProperty$3$2(
        global$7$3[NAME],
        TYPED_ARRAY_TAG$1,
        NAME
      );
    }
}
var arrayBufferViewCore = {
  NATIVE_ARRAY_BUFFER_VIEWS: NATIVE_ARRAY_BUFFER_VIEWS$2,
  TYPED_ARRAY_TAG: TYPED_ARRAY_TAG_REQUIRED && TYPED_ARRAY_TAG$1,
  aTypedArray: aTypedArray$4,
  aTypedArrayConstructor: aTypedArrayConstructor$2,
  exportTypedArrayMethod: exportTypedArrayMethod$4,
  exportTypedArrayStaticMethod: exportTypedArrayStaticMethod$1,
  getTypedArrayConstructor,
  isView,
  isTypedArray: isTypedArray$1,
  TypedArray: TypedArray$1,
  TypedArrayPrototype: TypedArrayPrototype$1,
};
var global$6$3 = global$t;
var fails$8$3 = fails$r;
var checkCorrectnessOfIteration$3 = checkCorrectnessOfIteration$2$1;
var NATIVE_ARRAY_BUFFER_VIEWS$1 = arrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;
var ArrayBuffer$3 = global$6$3.ArrayBuffer;
var Int8Array$3 = global$6$3.Int8Array;
var typedArrayConstructorsRequireWrappers =
  !NATIVE_ARRAY_BUFFER_VIEWS$1 ||
  !fails$8$3(function () {
    Int8Array$3(1);
  }) ||
  !fails$8$3(function () {
    new Int8Array$3(-1);
  }) ||
  !checkCorrectnessOfIteration$3(function (iterable) {
    new Int8Array$3();
    new Int8Array$3(null);
    new Int8Array$3(1.5);
    new Int8Array$3(iterable);
  }, true) ||
  fails$8$3(function () {
    return new Int8Array$3(new ArrayBuffer$3(2), 1, void 0).length !== 1;
  });
var bind$1$2 = functionBindContext$2;
var call$5$3 = functionCall$3;
var aConstructor$3 = aConstructor$2$1;
var toObject$2$3 = toObject$7;
var lengthOfArrayLike$4$1 = lengthOfArrayLike$8;
var getIterator$3 = getIterator$2$1;
var getIteratorMethod$4 = getIteratorMethod$3$1;
var isArrayIteratorMethod$3 = isArrayIteratorMethod$2$1;
var aTypedArrayConstructor$1 = arrayBufferViewCore.aTypedArrayConstructor;
var typedArrayFrom$2 = function from(source) {
  var C = aConstructor$3(this);
  var O = toObject$2$3(source);
  var argumentsLength = arguments.length;
  var mapfn = argumentsLength > 1 ? arguments[1] : void 0;
  var mapping = mapfn !== void 0;
  var iteratorMethod = getIteratorMethod$4(O);
  var i, length, result, step, iterator, next;
  if (iteratorMethod && !isArrayIteratorMethod$3(iteratorMethod)) {
    iterator = getIterator$3(O, iteratorMethod);
    next = iterator.next;
    O = [];
    while (!(step = call$5$3(next, iterator)).done) {
      O.push(step.value);
    }
  }
  if (mapping && argumentsLength > 2) {
    mapfn = bind$1$2(mapfn, arguments[2]);
  }
  length = lengthOfArrayLike$4$1(O);
  result = new (aTypedArrayConstructor$1(C))(length);
  for (i = 0; length > i; i++) {
    result[i] = mapping ? mapfn(O[i], i) : O[i];
  }
  return result;
};
var TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS$1 =
  typedArrayConstructorsRequireWrappers;
var exportTypedArrayStaticMethod =
  arrayBufferViewCore.exportTypedArrayStaticMethod;
var typedArrayFrom$1 = typedArrayFrom$2;
exportTypedArrayStaticMethod(
  "from",
  typedArrayFrom$1,
  TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS$1
);
var defineBuiltIn$1$3 = defineBuiltIn$8$1;
var defineBuiltIns$1 = function (target, src, options) {
  for (var key in src) defineBuiltIn$1$3(target, key, src[key], options);
  return target;
};
var toIntegerOrInfinity$3$1 = toIntegerOrInfinity$6;
var toLength$4 = toLength$6;
var $RangeError$2 = RangeError;
var toIndex$2 = function (it) {
  if (it === void 0) return 0;
  var number = toIntegerOrInfinity$3$1(it);
  var length = toLength$4(number);
  if (number !== length) throw $RangeError$2("Wrong length or index");
  return length;
};
var $Array$2 = Array;
var abs = Math.abs;
var pow = Math.pow;
var floor$2$1 = Math.floor;
var log = Math.log;
var LN2 = Math.LN2;
var pack = function (number, mantissaLength, bytes) {
  var buffer = $Array$2(bytes);
  var exponentLength = bytes * 8 - mantissaLength - 1;
  var eMax = (1 << exponentLength) - 1;
  var eBias = eMax >> 1;
  var rt = mantissaLength === 23 ? pow(2, -24) - pow(2, -77) : 0;
  var sign = number < 0 || (number === 0 && 1 / number < 0) ? 1 : 0;
  var index = 0;
  var exponent, mantissa, c;
  number = abs(number);
  if (number != number || number === Infinity) {
    mantissa = number != number ? 1 : 0;
    exponent = eMax;
  } else {
    exponent = floor$2$1(log(number) / LN2);
    c = pow(2, -exponent);
    if (number * c < 1) {
      exponent--;
      c *= 2;
    }
    if (exponent + eBias >= 1) {
      number += rt / c;
    } else {
      number += rt * pow(2, 1 - eBias);
    }
    if (number * c >= 2) {
      exponent++;
      c /= 2;
    }
    if (exponent + eBias >= eMax) {
      mantissa = 0;
      exponent = eMax;
    } else if (exponent + eBias >= 1) {
      mantissa = (number * c - 1) * pow(2, mantissaLength);
      exponent = exponent + eBias;
    } else {
      mantissa = number * pow(2, eBias - 1) * pow(2, mantissaLength);
      exponent = 0;
    }
  }
  while (mantissaLength >= 8) {
    buffer[index++] = mantissa & 255;
    mantissa /= 256;
    mantissaLength -= 8;
  }
  exponent = (exponent << mantissaLength) | mantissa;
  exponentLength += mantissaLength;
  while (exponentLength > 0) {
    buffer[index++] = exponent & 255;
    exponent /= 256;
    exponentLength -= 8;
  }
  buffer[--index] |= sign * 128;
  return buffer;
};
var unpack = function (buffer, mantissaLength) {
  var bytes = buffer.length;
  var exponentLength = bytes * 8 - mantissaLength - 1;
  var eMax = (1 << exponentLength) - 1;
  var eBias = eMax >> 1;
  var nBits = exponentLength - 7;
  var index = bytes - 1;
  var sign = buffer[index--];
  var exponent = sign & 127;
  var mantissa;
  sign >>= 7;
  while (nBits > 0) {
    exponent = exponent * 256 + buffer[index--];
    nBits -= 8;
  }
  mantissa = exponent & ((1 << -nBits) - 1);
  exponent >>= -nBits;
  nBits += mantissaLength;
  while (nBits > 0) {
    mantissa = mantissa * 256 + buffer[index--];
    nBits -= 8;
  }
  if (exponent === 0) {
    exponent = 1 - eBias;
  } else if (exponent === eMax) {
    return mantissa ? NaN : sign ? -Infinity : Infinity;
  } else {
    mantissa = mantissa + pow(2, mantissaLength);
    exponent = exponent - eBias;
  }
  return (sign ? -1 : 1) * mantissa * pow(2, exponent - mantissaLength);
};
var ieee754 = {
  pack,
  unpack,
};
var toObject$1$3 = toObject$7;
var toAbsoluteIndex$2$2 = toAbsoluteIndex$4;
var lengthOfArrayLike$3$2 = lengthOfArrayLike$8;
var arrayFill$1 = function fill(value) {
  var O = toObject$1$3(this);
  var length = lengthOfArrayLike$3$2(O);
  var argumentsLength = arguments.length;
  var index = toAbsoluteIndex$2$2(
    argumentsLength > 1 ? arguments[1] : void 0,
    length
  );
  var end = argumentsLength > 2 ? arguments[2] : void 0;
  var endPos = end === void 0 ? length : toAbsoluteIndex$2$2(end, length);
  while (endPos > index) O[index++] = value;
  return O;
};
var toPropertyKey$1$3 = toPropertyKey$4$1;
var definePropertyModule$1$3 = objectDefineProperty$3;
var createPropertyDescriptor$1$3 = createPropertyDescriptor$5$1;
var createProperty$1$1 = function (object, key, value) {
  var propertyKey = toPropertyKey$1$3(key);
  if (propertyKey in object)
    definePropertyModule$1$3.f(
      object,
      propertyKey,
      createPropertyDescriptor$1$3(0, value)
    );
  else object[propertyKey] = value;
};
var toAbsoluteIndex$1$3 = toAbsoluteIndex$4;
var lengthOfArrayLike$2$2 = lengthOfArrayLike$8;
var createProperty$2 = createProperty$1$1;
var $Array$1 = Array;
var max$3 = Math.max;
var arraySliceSimple$1 = function (O, start, end) {
  var length = lengthOfArrayLike$2$2(O);
  var k = toAbsoluteIndex$1$3(start, length);
  var fin = toAbsoluteIndex$1$3(end === void 0 ? length : end, length);
  var result = $Array$1(max$3(fin - k, 0));
  for (var n = 0; k < fin; k++, n++) createProperty$2(result, n, O[k]);
  result.length = n;
  return result;
};
var global$5$3 = global$t;
var uncurryThis$7$3 = functionUncurryThis$3;
var DESCRIPTORS$1$3 = descriptors$3;
var NATIVE_ARRAY_BUFFER = arrayBufferNative;
var FunctionName$2 = functionName$3;
var createNonEnumerableProperty$2$3 = createNonEnumerableProperty$8;
var defineBuiltIns = defineBuiltIns$1;
var fails$7$3 = fails$r;
var anInstance$1$2 = anInstance$3;
var toIntegerOrInfinity$2$3 = toIntegerOrInfinity$6;
var toLength$3$1 = toLength$6;
var toIndex$1 = toIndex$2;
var IEEE754 = ieee754;
var getPrototypeOf$4 = objectGetPrototypeOf$2;
var setPrototypeOf$2$1 = objectSetPrototypeOf$2;
var getOwnPropertyNames$1 = objectGetOwnPropertyNames$3.f;
var defineProperty3$3 = objectDefineProperty$3.f;
var arrayFill = arrayFill$1;
var arraySlice$3$1 = arraySliceSimple$1;
var setToStringTag$5 = setToStringTag$4$1;
var InternalStateModule$1$2 = internalState$3;
var PROPER_FUNCTION_NAME$3 = FunctionName$2.PROPER;
var CONFIGURABLE_FUNCTION_NAME$4 = FunctionName$2.CONFIGURABLE;
var getInternalState$1$2 = InternalStateModule$1$2.get;
var setInternalState$1$2 = InternalStateModule$1$2.set;
var ARRAY_BUFFER = "ArrayBuffer";
var DATA_VIEW = "DataView";
var PROTOTYPE$2 = "prototype";
var WRONG_LENGTH$1 = "Wrong length";
var WRONG_INDEX = "Wrong index";
var NativeArrayBuffer = global$5$3[ARRAY_BUFFER];
var $ArrayBuffer = NativeArrayBuffer;
var ArrayBufferPrototype$1 = $ArrayBuffer && $ArrayBuffer[PROTOTYPE$2];
var $DataView = global$5$3[DATA_VIEW];
var DataViewPrototype$1 = $DataView && $DataView[PROTOTYPE$2];
var ObjectPrototype$3 = Object.prototype;
var Array$1 = global$5$3.Array;
var RangeError$3 = global$5$3.RangeError;
var fill2 = uncurryThis$7$3(arrayFill);
var reverse = uncurryThis$7$3([].reverse);
var packIEEE754 = IEEE754.pack;
var unpackIEEE754 = IEEE754.unpack;
var packInt8 = function (number) {
  return [number & 255];
};
var packInt16 = function (number) {
  return [number & 255, (number >> 8) & 255];
};
var packInt32 = function (number) {
  return [
    number & 255,
    (number >> 8) & 255,
    (number >> 16) & 255,
    (number >> 24) & 255,
  ];
};
var unpackInt32 = function (buffer) {
  return (buffer[3] << 24) | (buffer[2] << 16) | (buffer[1] << 8) | buffer[0];
};
var packFloat32 = function (number) {
  return packIEEE754(number, 23, 4);
};
var packFloat64 = function (number) {
  return packIEEE754(number, 52, 8);
};
var addGetter$1 = function (Constructor2, key) {
  defineProperty3$3(Constructor2[PROTOTYPE$2], key, {
    get: function () {
      return getInternalState$1$2(this)[key];
    },
  });
};
var get$3 = function (view, count, index, isLittleEndian) {
  var intIndex = toIndex$1(index);
  var store = getInternalState$1$2(view);
  if (intIndex + count > store.byteLength) throw RangeError$3(WRONG_INDEX);
  var bytes = getInternalState$1$2(store.buffer).bytes;
  var start = intIndex + store.byteOffset;
  var pack2 = arraySlice$3$1(bytes, start, start + count);
  return isLittleEndian ? pack2 : reverse(pack2);
};
var set$4 = function (view, count, index, conversion, value, isLittleEndian) {
  var intIndex = toIndex$1(index);
  var store = getInternalState$1$2(view);
  if (intIndex + count > store.byteLength) throw RangeError$3(WRONG_INDEX);
  var bytes = getInternalState$1$2(store.buffer).bytes;
  var start = intIndex + store.byteOffset;
  var pack2 = conversion(+value);
  for (var i = 0; i < count; i++)
    bytes[start + i] = pack2[isLittleEndian ? i : count - i - 1];
};
if (!NATIVE_ARRAY_BUFFER) {
  $ArrayBuffer = function ArrayBuffer2(length) {
    anInstance$1$2(this, ArrayBufferPrototype$1);
    var byteLength = toIndex$1(length);
    setInternalState$1$2(this, {
      bytes: fill2(Array$1(byteLength), 0),
      byteLength,
    });
    if (!DESCRIPTORS$1$3) this.byteLength = byteLength;
  };
  ArrayBufferPrototype$1 = $ArrayBuffer[PROTOTYPE$2];
  $DataView = function DataView2(buffer, byteOffset, byteLength) {
    anInstance$1$2(this, DataViewPrototype$1);
    anInstance$1$2(buffer, ArrayBufferPrototype$1);
    var bufferLength = getInternalState$1$2(buffer).byteLength;
    var offset = toIntegerOrInfinity$2$3(byteOffset);
    if (offset < 0 || offset > bufferLength) throw RangeError$3("Wrong offset");
    byteLength =
      byteLength === void 0 ? bufferLength - offset : toLength$3$1(byteLength);
    if (offset + byteLength > bufferLength) throw RangeError$3(WRONG_LENGTH$1);
    setInternalState$1$2(this, {
      buffer,
      byteLength,
      byteOffset: offset,
    });
    if (!DESCRIPTORS$1$3) {
      this.buffer = buffer;
      this.byteLength = byteLength;
      this.byteOffset = offset;
    }
  };
  DataViewPrototype$1 = $DataView[PROTOTYPE$2];
  if (DESCRIPTORS$1$3) {
    addGetter$1($ArrayBuffer, "byteLength");
    addGetter$1($DataView, "buffer");
    addGetter$1($DataView, "byteLength");
    addGetter$1($DataView, "byteOffset");
  }
  defineBuiltIns(DataViewPrototype$1, {
    getInt8: function getInt8(byteOffset) {
      return (get$3(this, 1, byteOffset)[0] << 24) >> 24;
    },
    getUint8: function getUint82(byteOffset) {
      return get$3(this, 1, byteOffset)[0];
    },
    getInt16: function getInt16(byteOffset) {
      var bytes = get$3(
        this,
        2,
        byteOffset,
        arguments.length > 1 ? arguments[1] : void 0
      );
      return (((bytes[1] << 8) | bytes[0]) << 16) >> 16;
    },
    getUint16: function getUint16(byteOffset) {
      var bytes = get$3(
        this,
        2,
        byteOffset,
        arguments.length > 1 ? arguments[1] : void 0
      );
      return (bytes[1] << 8) | bytes[0];
    },
    getInt32: function getInt32(byteOffset) {
      return unpackInt32(
        get$3(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : void 0)
      );
    },
    getUint32: function getUint32(byteOffset) {
      return (
        unpackInt32(
          get$3(
            this,
            4,
            byteOffset,
            arguments.length > 1 ? arguments[1] : void 0
          )
        ) >>> 0
      );
    },
    getFloat32: function getFloat32(byteOffset) {
      return unpackIEEE754(
        get$3(
          this,
          4,
          byteOffset,
          arguments.length > 1 ? arguments[1] : void 0
        ),
        23
      );
    },
    getFloat64: function getFloat64(byteOffset) {
      return unpackIEEE754(
        get$3(
          this,
          8,
          byteOffset,
          arguments.length > 1 ? arguments[1] : void 0
        ),
        52
      );
    },
    setInt8: function setInt8(byteOffset, value) {
      set$4(this, 1, byteOffset, packInt8, value);
    },
    setUint8: function setUint82(byteOffset, value) {
      set$4(this, 1, byteOffset, packInt8, value);
    },
    setInt16: function setInt16(byteOffset, value) {
      set$4(
        this,
        2,
        byteOffset,
        packInt16,
        value,
        arguments.length > 2 ? arguments[2] : void 0
      );
    },
    setUint16: function setUint16(byteOffset, value) {
      set$4(
        this,
        2,
        byteOffset,
        packInt16,
        value,
        arguments.length > 2 ? arguments[2] : void 0
      );
    },
    setInt32: function setInt32(byteOffset, value) {
      set$4(
        this,
        4,
        byteOffset,
        packInt32,
        value,
        arguments.length > 2 ? arguments[2] : void 0
      );
    },
    setUint32: function setUint32(byteOffset, value) {
      set$4(
        this,
        4,
        byteOffset,
        packInt32,
        value,
        arguments.length > 2 ? arguments[2] : void 0
      );
    },
    setFloat32: function setFloat32(byteOffset, value) {
      set$4(
        this,
        4,
        byteOffset,
        packFloat32,
        value,
        arguments.length > 2 ? arguments[2] : void 0
      );
    },
    setFloat64: function setFloat64(byteOffset, value) {
      set$4(
        this,
        8,
        byteOffset,
        packFloat64,
        value,
        arguments.length > 2 ? arguments[2] : void 0
      );
    },
  });
} else {
  INCORRECT_ARRAY_BUFFER_NAME =
    PROPER_FUNCTION_NAME$3 && NativeArrayBuffer.name !== ARRAY_BUFFER;
  if (
    !fails$7$3(function () {
      NativeArrayBuffer(1);
    }) ||
    !fails$7$3(function () {
      new NativeArrayBuffer(-1);
    }) ||
    fails$7$3(function () {
      new NativeArrayBuffer();
      new NativeArrayBuffer(1.5);
      new NativeArrayBuffer(NaN);
      return INCORRECT_ARRAY_BUFFER_NAME && !CONFIGURABLE_FUNCTION_NAME$4;
    })
  ) {
    $ArrayBuffer = function ArrayBuffer2(length) {
      anInstance$1$2(this, ArrayBufferPrototype$1);
      return new NativeArrayBuffer(toIndex$1(length));
    };
    $ArrayBuffer[PROTOTYPE$2] = ArrayBufferPrototype$1;
    for (
      keys2$2 = getOwnPropertyNames$1(NativeArrayBuffer), j = 0;
      keys2$2.length > j;

    ) {
      if (!((key = keys2$2[j++]) in $ArrayBuffer)) {
        createNonEnumerableProperty$2$3(
          $ArrayBuffer,
          key,
          NativeArrayBuffer[key]
        );
      }
    }
    ArrayBufferPrototype$1.constructor = $ArrayBuffer;
  } else if (INCORRECT_ARRAY_BUFFER_NAME && CONFIGURABLE_FUNCTION_NAME$4) {
    createNonEnumerableProperty$2$3(NativeArrayBuffer, "name", ARRAY_BUFFER);
  }
  if (
    setPrototypeOf$2$1 &&
    getPrototypeOf$4(DataViewPrototype$1) !== ObjectPrototype$3
  ) {
    setPrototypeOf$2$1(DataViewPrototype$1, ObjectPrototype$3);
  }
  testView = new $DataView(new $ArrayBuffer(2));
  $setInt8 = uncurryThis$7$3(DataViewPrototype$1.setInt8);
  testView.setInt8(0, 2147483648);
  testView.setInt8(1, 2147483649);
  if (testView.getInt8(0) || !testView.getInt8(1))
    defineBuiltIns(
      DataViewPrototype$1,
      {
        setInt8: function setInt8(byteOffset, value) {
          $setInt8(this, byteOffset, (value << 24) >> 24);
        },
        setUint8: function setUint82(byteOffset, value) {
          $setInt8(this, byteOffset, (value << 24) >> 24);
        },
      },
      { unsafe: true }
    );
}
var INCORRECT_ARRAY_BUFFER_NAME;
var keys2$2;
var j;
var key;
var testView;
var $setInt8;
setToStringTag$5($ArrayBuffer, ARRAY_BUFFER);
setToStringTag$5($DataView, DATA_VIEW);
var arrayBuffer = {
  ArrayBuffer: $ArrayBuffer,
  DataView: $DataView,
};
var $$1$2 = _export$3;
var uncurryThis$6$3 = functionUncurryThis$3;
var fails$6$3 = fails$r;
var ArrayBufferModule$1 = arrayBuffer;
var anObject$2$3 = anObject$e$1;
var toAbsoluteIndex$5 = toAbsoluteIndex$4;
var toLength$2$1 = toLength$6;
var speciesConstructor$1$2 = speciesConstructor$3;
var ArrayBuffer$2 = ArrayBufferModule$1.ArrayBuffer;
var DataView$2 = ArrayBufferModule$1.DataView;
var DataViewPrototype = DataView$2.prototype;
var un$ArrayBufferSlice = uncurryThis$6$3(ArrayBuffer$2.prototype.slice);
var getUint8 = uncurryThis$6$3(DataViewPrototype.getUint8);
var setUint8 = uncurryThis$6$3(DataViewPrototype.setUint8);
var INCORRECT_SLICE = fails$6$3(function () {
  return !new ArrayBuffer$2(2).slice(1, void 0).byteLength;
});
$$1$2(
  { target: "ArrayBuffer", proto: true, unsafe: true, forced: INCORRECT_SLICE },
  {
    slice: function slice(start, end) {
      if (un$ArrayBufferSlice && end === void 0) {
        return un$ArrayBufferSlice(anObject$2$3(this), start);
      }
      var length = anObject$2$3(this).byteLength;
      var first = toAbsoluteIndex$5(start, length);
      var fin = toAbsoluteIndex$5(end === void 0 ? length : end, length);
      var result = new (speciesConstructor$1$2(this, ArrayBuffer$2))(
        toLength$2$1(fin - first)
      );
      var viewSource = new DataView$2(this);
      var viewTarget = new DataView$2(result);
      var index = 0;
      while (first < fin) {
        setUint8(viewTarget, index++, getUint8(viewSource, first++));
      }
      return result;
    },
  }
);
var typedArrayConstructor = { exports: {} };
var isObject$3$3 = isObject$d;
var floor$1$2 = Math.floor;
var isIntegralNumber$1 =
  Number.isInteger ||
  function isInteger(it) {
    return !isObject$3$3(it) && isFinite(it) && floor$1$2(it) === it;
  };
var toIntegerOrInfinity$1$3 = toIntegerOrInfinity$6;
var $RangeError$1 = RangeError;
var toPositiveInteger$1 = function (it) {
  var result = toIntegerOrInfinity$1$3(it);
  if (result < 0) throw $RangeError$1("The argument can't be less than 0");
  return result;
};
var toPositiveInteger = toPositiveInteger$1;
var $RangeError = RangeError;
var toOffset$2 = function (it, BYTES) {
  var offset = toPositiveInteger(it);
  if (offset % BYTES) throw $RangeError("Wrong offset");
  return offset;
};
var classof$3$2 = classofRaw$1$2;
var isArray$1 =
  Array.isArray ||
  function isArray(argument) {
    return classof$3$2(argument) == "Array";
  };
var isArray2 = isArray$1;
var isConstructor3$2 = isConstructor$2;
var isObject$2$3 = isObject$d;
var wellKnownSymbol$1$3 = wellKnownSymbol$j;
var SPECIES$1$2 = wellKnownSymbol$1$3("species");
var $Array$3 = Array;
var arraySpeciesConstructor$1 = function (originalArray) {
  var C;
  if (isArray2(originalArray)) {
    C = originalArray.constructor;
    if (isConstructor3$2(C) && (C === $Array$3 || isArray2(C.prototype)))
      C = void 0;
    else if (isObject$2$3(C)) {
      C = C[SPECIES$1$2];
      if (C === null) C = void 0;
    }
  }
  return C === void 0 ? $Array$3 : C;
};
var arraySpeciesConstructor = arraySpeciesConstructor$1;
var arraySpeciesCreate$1 = function (originalArray, length) {
  return new (arraySpeciesConstructor(originalArray))(
    length === 0 ? 0 : length
  );
};
var bind2$1 = functionBindContext$2;
var uncurryThis$5$3 = functionUncurryThis$3;
var IndexedObject$4 = indexedObject$3;
var toObject$8 = toObject$7;
var lengthOfArrayLike$1$3 = lengthOfArrayLike$8;
var arraySpeciesCreate = arraySpeciesCreate$1;
var push$1$2 = uncurryThis$5$3([].push);
var createMethod$1$2 = function (TYPE) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var IS_FILTER_REJECT = TYPE == 7;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  return function ($this, callbackfn, that, specificCreate) {
    var O = toObject$8($this);
    var self2 = IndexedObject$4(O);
    var boundFunction = bind2$1(callbackfn, that);
    var length = lengthOfArrayLike$1$3(self2);
    var index = 0;
    var create3 = specificCreate || arraySpeciesCreate;
    var target = IS_MAP
      ? create3($this, length)
      : IS_FILTER || IS_FILTER_REJECT
      ? create3($this, 0)
      : void 0;
    var value, result;
    for (; length > index; index++)
      if (NO_HOLES || index in self2) {
        value = self2[index];
        result = boundFunction(value, index, O);
        if (TYPE) {
          if (IS_MAP) target[index] = result;
          else if (result)
            switch (TYPE) {
              case 3:
                return true;
              case 5:
                return value;
              case 6:
                return index;
              case 2:
                push$1$2(target, value);
            }
          else
            switch (TYPE) {
              case 4:
                return false;
              case 7:
                push$1$2(target, value);
            }
        }
      }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
  };
};
var arrayIteration = {
  // `Array.prototype.forEach` method
  // https://tc39.es/ecma262/#sec-array.prototype.foreach
  forEach: createMethod$1$2(0),
  // `Array.prototype.map` method
  // https://tc39.es/ecma262/#sec-array.prototype.map
  map: createMethod$1$2(1),
  // `Array.prototype.filter` method
  // https://tc39.es/ecma262/#sec-array.prototype.filter
  filter: createMethod$1$2(2),
  // `Array.prototype.some` method
  // https://tc39.es/ecma262/#sec-array.prototype.some
  some: createMethod$1$2(3),
  // `Array.prototype.every` method
  // https://tc39.es/ecma262/#sec-array.prototype.every
  every: createMethod$1$2(4),
  // `Array.prototype.find` method
  // https://tc39.es/ecma262/#sec-array.prototype.find
  find: createMethod$1$2(5),
  // `Array.prototype.findIndex` method
  // https://tc39.es/ecma262/#sec-array.prototype.findIndex
  findIndex: createMethod$1$2(6),
  // `Array.prototype.filterReject` method
  // https://github.com/tc39/proposal-array-filtering
  filterReject: createMethod$1$2(7),
};
var isCallable$1$3 = isCallable$n;
var isObject$1$3 = isObject$d;
var setPrototypeOf$1$2 = objectSetPrototypeOf$2;
var inheritIfRequired$1 = function ($this, dummy, Wrapper) {
  var NewTarget, NewTargetPrototype;
  if (
    // it can work only with native `setPrototypeOf`
    setPrototypeOf$1$2 && // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
    isCallable$1$3((NewTarget = dummy.constructor)) &&
    NewTarget !== Wrapper &&
    isObject$1$3((NewTargetPrototype = NewTarget.prototype)) &&
    NewTargetPrototype !== Wrapper.prototype
  )
    setPrototypeOf$1$2($this, NewTargetPrototype);
  return $this;
};
var $$e = _export$3;
var global$4$3 = global$t;
var call$4$3 = functionCall$3;
var DESCRIPTORS$e = descriptors$3;
var TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS =
  typedArrayConstructorsRequireWrappers;
var ArrayBufferViewCore$4 = arrayBufferViewCore;
var ArrayBufferModule = arrayBuffer;
var anInstance$4 = anInstance$3;
var createPropertyDescriptor$6 = createPropertyDescriptor$5$1;
var createNonEnumerableProperty$1$3 = createNonEnumerableProperty$8;
var isIntegralNumber = isIntegralNumber$1;
var toLength$1$3 = toLength$6;
var toIndex = toIndex$2;
var toOffset$1 = toOffset$2;
var toPropertyKey$5 = toPropertyKey$4$1;
var hasOwn2$3 = hasOwnProperty_1$3;
var classof$2$2 = classof$9;
var isObject$e = isObject$d;
var isSymbol$5 = isSymbol$3$1;
var create2$2 = objectCreate$2;
var isPrototypeOf$6 = objectIsPrototypeOf$3;
var setPrototypeOf$6 = objectSetPrototypeOf$2;
var getOwnPropertyNames2 = objectGetOwnPropertyNames$3.f;
var typedArrayFrom = typedArrayFrom$2;
var forEach = arrayIteration.forEach;
var setSpecies$3 = setSpecies$2$1;
var definePropertyModule$7 = objectDefineProperty$3;
var getOwnPropertyDescriptorModule$3 = objectGetOwnPropertyDescriptor$3;
var InternalStateModule$6 = internalState$3;
var inheritIfRequired = inheritIfRequired$1;
var getInternalState$6 = InternalStateModule$6.get;
var setInternalState$4 = InternalStateModule$6.set;
var enforceInternalState$3 = InternalStateModule$6.enforce;
var nativeDefineProperty = definePropertyModule$7.f;
var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule$3.f;
var round = Math.round;
var RangeError$2 = global$4$3.RangeError;
var ArrayBuffer$1 = ArrayBufferModule.ArrayBuffer;
var ArrayBufferPrototype = ArrayBuffer$1.prototype;
var DataView$1 = ArrayBufferModule.DataView;
var NATIVE_ARRAY_BUFFER_VIEWS = ArrayBufferViewCore$4.NATIVE_ARRAY_BUFFER_VIEWS;
var TYPED_ARRAY_TAG = ArrayBufferViewCore$4.TYPED_ARRAY_TAG;
var TypedArray = ArrayBufferViewCore$4.TypedArray;
var TypedArrayPrototype = ArrayBufferViewCore$4.TypedArrayPrototype;
var aTypedArrayConstructor = ArrayBufferViewCore$4.aTypedArrayConstructor;
var isTypedArray = ArrayBufferViewCore$4.isTypedArray;
var BYTES_PER_ELEMENT = "BYTES_PER_ELEMENT";
var WRONG_LENGTH = "Wrong length";
var fromList = function (C, list) {
  aTypedArrayConstructor(C);
  var index = 0;
  var length = list.length;
  var result = new C(length);
  while (length > index) result[index] = list[index++];
  return result;
};
var addGetter = function (it, key) {
  nativeDefineProperty(it, key, {
    get: function () {
      return getInternalState$6(this)[key];
    },
  });
};
var isArrayBuffer = function (it) {
  var klass;
  return (
    isPrototypeOf$6(ArrayBufferPrototype, it) ||
    (klass = classof$2$2(it)) == "ArrayBuffer" ||
    klass == "SharedArrayBuffer"
  );
};
var isTypedArrayIndex = function (target, key) {
  return (
    isTypedArray(target) &&
    !isSymbol$5(key) &&
    key in target &&
    isIntegralNumber(+key) &&
    key >= 0
  );
};
var wrappedGetOwnPropertyDescriptor = function getOwnPropertyDescriptor3(
  target,
  key
) {
  key = toPropertyKey$5(key);
  return isTypedArrayIndex(target, key)
    ? createPropertyDescriptor$6(2, target[key])
    : nativeGetOwnPropertyDescriptor(target, key);
};
var wrappedDefineProperty = function defineProperty4(target, key, descriptor) {
  key = toPropertyKey$5(key);
  if (
    isTypedArrayIndex(target, key) &&
    isObject$e(descriptor) &&
    hasOwn2$3(descriptor, "value") &&
    !hasOwn2$3(descriptor, "get") &&
    !hasOwn2$3(descriptor, "set") &&
    !descriptor.configurable &&
    (!hasOwn2$3(descriptor, "writable") || descriptor.writable) &&
    (!hasOwn2$3(descriptor, "enumerable") || descriptor.enumerable)
  ) {
    target[key] = descriptor.value;
    return target;
  }
  return nativeDefineProperty(target, key, descriptor);
};
if (DESCRIPTORS$e) {
  if (!NATIVE_ARRAY_BUFFER_VIEWS) {
    getOwnPropertyDescriptorModule$3.f = wrappedGetOwnPropertyDescriptor;
    definePropertyModule$7.f = wrappedDefineProperty;
    addGetter(TypedArrayPrototype, "buffer");
    addGetter(TypedArrayPrototype, "byteOffset");
    addGetter(TypedArrayPrototype, "byteLength");
    addGetter(TypedArrayPrototype, "length");
  }
  $$e(
    { target: "Object", stat: true, forced: !NATIVE_ARRAY_BUFFER_VIEWS },
    {
      getOwnPropertyDescriptor: wrappedGetOwnPropertyDescriptor,
      defineProperty: wrappedDefineProperty,
    }
  );
  typedArrayConstructor.exports = function (TYPE, wrapper, CLAMPED) {
    var BYTES = TYPE.match(/\d+$/)[0] / 8;
    var CONSTRUCTOR_NAME = TYPE + (CLAMPED ? "Clamped" : "") + "Array";
    var GETTER = "get" + TYPE;
    var SETTER = "set" + TYPE;
    var NativeTypedArrayConstructor = global$4$3[CONSTRUCTOR_NAME];
    var TypedArrayConstructor = NativeTypedArrayConstructor;
    var TypedArrayConstructorPrototype =
      TypedArrayConstructor && TypedArrayConstructor.prototype;
    var exported = {};
    var getter = function (that, index) {
      var data2 = getInternalState$6(that);
      return data2.view[GETTER](index * BYTES + data2.byteOffset, true);
    };
    var setter = function (that, index, value) {
      var data2 = getInternalState$6(that);
      if (CLAMPED)
        value =
          (value = round(value)) < 0 ? 0 : value > 255 ? 255 : value & 255;
      data2.view[SETTER](index * BYTES + data2.byteOffset, value, true);
    };
    var addElement = function (that, index) {
      nativeDefineProperty(that, index, {
        get: function () {
          return getter(this, index);
        },
        set: function (value) {
          return setter(this, index, value);
        },
        enumerable: true,
      });
    };
    if (!NATIVE_ARRAY_BUFFER_VIEWS) {
      TypedArrayConstructor = wrapper(function (that, data2, offset, $length) {
        anInstance$4(that, TypedArrayConstructorPrototype);
        var index = 0;
        var byteOffset = 0;
        var buffer, byteLength, length;
        if (!isObject$e(data2)) {
          length = toIndex(data2);
          byteLength = length * BYTES;
          buffer = new ArrayBuffer$1(byteLength);
        } else if (isArrayBuffer(data2)) {
          buffer = data2;
          byteOffset = toOffset$1(offset, BYTES);
          var $len = data2.byteLength;
          if ($length === void 0) {
            if ($len % BYTES) throw RangeError$2(WRONG_LENGTH);
            byteLength = $len - byteOffset;
            if (byteLength < 0) throw RangeError$2(WRONG_LENGTH);
          } else {
            byteLength = toLength$1$3($length) * BYTES;
            if (byteLength + byteOffset > $len)
              throw RangeError$2(WRONG_LENGTH);
          }
          length = byteLength / BYTES;
        } else if (isTypedArray(data2)) {
          return fromList(TypedArrayConstructor, data2);
        } else {
          return call$4$3(typedArrayFrom, TypedArrayConstructor, data2);
        }
        setInternalState$4(that, {
          buffer,
          byteOffset,
          byteLength,
          length,
          view: new DataView$1(buffer),
        });
        while (index < length) addElement(that, index++);
      });
      if (setPrototypeOf$6) setPrototypeOf$6(TypedArrayConstructor, TypedArray);
      TypedArrayConstructorPrototype = TypedArrayConstructor.prototype =
        create2$2(TypedArrayPrototype);
    } else if (TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS) {
      TypedArrayConstructor = wrapper(function (
        dummy,
        data2,
        typedArrayOffset,
        $length
      ) {
        anInstance$4(dummy, TypedArrayConstructorPrototype);
        return inheritIfRequired(
          (function () {
            if (!isObject$e(data2))
              return new NativeTypedArrayConstructor(toIndex(data2));
            if (isArrayBuffer(data2))
              return $length !== void 0
                ? new NativeTypedArrayConstructor(
                    data2,
                    toOffset$1(typedArrayOffset, BYTES),
                    $length
                  )
                : typedArrayOffset !== void 0
                ? new NativeTypedArrayConstructor(
                    data2,
                    toOffset$1(typedArrayOffset, BYTES)
                  )
                : new NativeTypedArrayConstructor(data2);
            if (isTypedArray(data2))
              return fromList(TypedArrayConstructor, data2);
            return call$4$3(typedArrayFrom, TypedArrayConstructor, data2);
          })(),
          dummy,
          TypedArrayConstructor
        );
      });
      if (setPrototypeOf$6) setPrototypeOf$6(TypedArrayConstructor, TypedArray);
      forEach(
        getOwnPropertyNames2(NativeTypedArrayConstructor),
        function (key) {
          if (!(key in TypedArrayConstructor)) {
            createNonEnumerableProperty$1$3(
              TypedArrayConstructor,
              key,
              NativeTypedArrayConstructor[key]
            );
          }
        }
      );
      TypedArrayConstructor.prototype = TypedArrayConstructorPrototype;
    }
    if (TypedArrayConstructorPrototype.constructor !== TypedArrayConstructor) {
      createNonEnumerableProperty$1$3(
        TypedArrayConstructorPrototype,
        "constructor",
        TypedArrayConstructor
      );
    }
    enforceInternalState$3(
      TypedArrayConstructorPrototype
    ).TypedArrayConstructor = TypedArrayConstructor;
    if (TYPED_ARRAY_TAG) {
      createNonEnumerableProperty$1$3(
        TypedArrayConstructorPrototype,
        TYPED_ARRAY_TAG,
        CONSTRUCTOR_NAME
      );
    }
    var FORCED2 = TypedArrayConstructor != NativeTypedArrayConstructor;
    exported[CONSTRUCTOR_NAME] = TypedArrayConstructor;
    $$e(
      {
        global: true,
        constructor: true,
        forced: FORCED2,
        sham: !NATIVE_ARRAY_BUFFER_VIEWS,
      },
      exported
    );
    if (!(BYTES_PER_ELEMENT in TypedArrayConstructor)) {
      createNonEnumerableProperty$1$3(
        TypedArrayConstructor,
        BYTES_PER_ELEMENT,
        BYTES
      );
    }
    if (!(BYTES_PER_ELEMENT in TypedArrayConstructorPrototype)) {
      createNonEnumerableProperty$1$3(
        TypedArrayConstructorPrototype,
        BYTES_PER_ELEMENT,
        BYTES
      );
    }
    setSpecies$3(CONSTRUCTOR_NAME);
  };
} else typedArrayConstructor.exports = function () {};
var createTypedArrayConstructor = typedArrayConstructor.exports;
createTypedArrayConstructor("Uint8", function (init) {
  return function Uint8Array2(data2, byteOffset, length) {
    return init(this, data2, byteOffset, length);
  };
});
var toPrimitive$4 = toPrimitive$2$1;
var $TypeError$1$3 = TypeError;
var toBigInt$1 = function (argument) {
  var prim = toPrimitive$4(argument, "number");
  if (typeof prim == "number")
    throw $TypeError$1$3("Can't convert number to bigint");
  return BigInt(prim);
};
var ArrayBufferViewCore$3 = arrayBufferViewCore;
var $fill = arrayFill$1;
var toBigInt = toBigInt$1;
var classof$1$2 = classof$9;
var call$3$3 = functionCall$3;
var uncurryThis$4$3 = functionUncurryThis$3;
var fails$5$3 = fails$r;
var aTypedArray$3 = ArrayBufferViewCore$3.aTypedArray;
var exportTypedArrayMethod$3 = ArrayBufferViewCore$3.exportTypedArrayMethod;
var slice2 = uncurryThis$4$3("".slice);
var CONVERSION_BUG = fails$5$3(function () {
  var count = 0;
  new Int8Array(2).fill({
    valueOf: function () {
      return count++;
    },
  });
  return count !== 1;
});
exportTypedArrayMethod$3(
  "fill",
  function fill3(value) {
    var length = arguments.length;
    aTypedArray$3(this);
    var actualValue =
      slice2(classof$1$2(this), 0, 3) === "Big" ? toBigInt(value) : +value;
    return call$3$3(
      $fill,
      this,
      actualValue,
      length > 1 ? arguments[1] : void 0,
      length > 2 ? arguments[2] : void 0
    );
  },
  CONVERSION_BUG
);
var global$3$3 = global$t;
var call$2$3 = functionCall$3;
var ArrayBufferViewCore$2 = arrayBufferViewCore;
var lengthOfArrayLike$9 = lengthOfArrayLike$8;
var toOffset = toOffset$2;
var toIndexedObject$8 = toObject$7;
var fails$4$3 = fails$r;
var RangeError$1 = global$3$3.RangeError;
var Int8Array$2 = global$3$3.Int8Array;
var Int8ArrayPrototype = Int8Array$2 && Int8Array$2.prototype;
var $set = Int8ArrayPrototype && Int8ArrayPrototype.set;
var aTypedArray$2 = ArrayBufferViewCore$2.aTypedArray;
var exportTypedArrayMethod$2 = ArrayBufferViewCore$2.exportTypedArrayMethod;
var WORKS_WITH_OBJECTS_AND_GEERIC_ON_TYPED_ARRAYS = !fails$4$3(function () {
  var array = new Uint8ClampedArray(2);
  call$2$3($set, array, { length: 1, 0: 3 }, 1);
  return array[1] !== 3;
});
var TO_OBJECT_BUG =
  WORKS_WITH_OBJECTS_AND_GEERIC_ON_TYPED_ARRAYS &&
  ArrayBufferViewCore$2.NATIVE_ARRAY_BUFFER_VIEWS &&
  fails$4$3(function () {
    var array = new Int8Array$2(2);
    array.set(1);
    array.set("2", 1);
    return array[0] !== 0 || array[1] !== 2;
  });
exportTypedArrayMethod$2(
  "set",
  function set2(arrayLike) {
    aTypedArray$2(this);
    var offset = toOffset(arguments.length > 1 ? arguments[1] : void 0, 1);
    var src = toIndexedObject$8(arrayLike);
    if (WORKS_WITH_OBJECTS_AND_GEERIC_ON_TYPED_ARRAYS)
      return call$2$3($set, this, src, offset);
    var length = this.length;
    var len = lengthOfArrayLike$9(src);
    var index = 0;
    if (len + offset > length) throw RangeError$1("Wrong length");
    while (index < len) this[offset + index] = src[index++];
  },
  !WORKS_WITH_OBJECTS_AND_GEERIC_ON_TYPED_ARRAYS || TO_OBJECT_BUG
);
var arraySlice$2$1 = arraySliceSimple$1;
var floor$4 = Math.floor;
var mergeSort$1 = function (array, comparefn) {
  var length = array.length;
  var middle = floor$4(length / 2);
  return length < 8
    ? insertionSort$1(array, comparefn)
    : merge$1(
        array,
        mergeSort$1(arraySlice$2$1(array, 0, middle), comparefn),
        mergeSort$1(arraySlice$2$1(array, middle), comparefn),
        comparefn
      );
};
var insertionSort$1 = function (array, comparefn) {
  var length = array.length;
  var i = 1;
  var element, j;
  while (i < length) {
    j = i;
    element = array[i];
    while (j && comparefn(array[j - 1], element) > 0) {
      array[j] = array[--j];
    }
    if (j !== i++) array[j] = element;
  }
  return array;
};
var merge$1 = function (array, left, right, comparefn) {
  var llength = left.length;
  var rlength = right.length;
  var lindex = 0;
  var rindex = 0;
  while (lindex < llength || rindex < rlength) {
    array[lindex + rindex] =
      lindex < llength && rindex < rlength
        ? comparefn(left[lindex], right[rindex]) <= 0
          ? left[lindex++]
          : right[rindex++]
        : lindex < llength
        ? left[lindex++]
        : right[rindex++];
  }
  return array;
};
var arraySort$1 = mergeSort$1;
var userAgent$1$2 = engineUserAgent$3;
var firefox$1 = userAgent$1$2.match(/firefox\/(\d+)/i);
var engineFfVersion$1 = !!firefox$1 && +firefox$1[1];
var UA$1 = engineUserAgent$3;
var engineIsIeOrEdge$1 = /MSIE|Trident/.test(UA$1);
var userAgent$7 = engineUserAgent$3;
var webkit$1 = userAgent$7.match(/AppleWebKit\/(\d+)\./);
var engineWebkitVersion$1 = !!webkit$1 && +webkit$1[1];
var global$2$3 = global$t;
var uncurryThis$3$3 = functionUncurryThis$3;
var fails$3$3 = fails$r;
var aCallable$b = aCallable$9$1;
var internalSort$1 = arraySort$1;
var ArrayBufferViewCore$1 = arrayBufferViewCore;
var FF$1 = engineFfVersion$1;
var IE_OR_EDGE$1 = engineIsIeOrEdge$1;
var V8$1 = engineV8Version$3;
var WEBKIT$1 = engineWebkitVersion$1;
var aTypedArray$1 = ArrayBufferViewCore$1.aTypedArray;
var exportTypedArrayMethod$1 = ArrayBufferViewCore$1.exportTypedArrayMethod;
var Uint16Array$1 = global$2$3.Uint16Array;
var un$Sort$1 = Uint16Array$1 && uncurryThis$3$3(Uint16Array$1.prototype.sort);
var ACCEPT_INCORRECT_ARGUMENTS =
  !!un$Sort$1 &&
  !(
    fails$3$3(function () {
      un$Sort$1(new Uint16Array$1(2), null);
    }) &&
    fails$3$3(function () {
      un$Sort$1(new Uint16Array$1(2), {});
    })
  );
var STABLE_SORT$1 =
  !!un$Sort$1 &&
  !fails$3$3(function () {
    if (V8$1) return V8$1 < 74;
    if (FF$1) return FF$1 < 67;
    if (IE_OR_EDGE$1) return true;
    if (WEBKIT$1) return WEBKIT$1 < 602;
    var array = new Uint16Array$1(516);
    var expected = Array(516);
    var index, mod;
    for (index = 0; index < 516; index++) {
      mod = index % 4;
      array[index] = 515 - index;
      expected[index] = index - 2 * mod + 3;
    }
    un$Sort$1(array, function (a, b) {
      return ((a / 4) | 0) - ((b / 4) | 0);
    });
    for (index = 0; index < 516; index++) {
      if (array[index] !== expected[index]) return true;
    }
  });
var getSortCompare$1 = function (comparefn) {
  return function (x, y) {
    if (comparefn !== void 0) return +comparefn(x, y) || 0;
    if (y !== y) return -1;
    if (x !== x) return 1;
    if (x === 0 && y === 0) return 1 / x > 0 && 1 / y < 0 ? 1 : -1;
    return x > y;
  };
};
exportTypedArrayMethod$1(
  "sort",
  function sort(comparefn) {
    if (comparefn !== void 0) aCallable$b(comparefn);
    if (STABLE_SORT$1) return un$Sort$1(this, comparefn);
    return internalSort$1(aTypedArray$1(this), getSortCompare$1(comparefn));
  },
  !STABLE_SORT$1 || ACCEPT_INCORRECT_ARGUMENTS
);
var global$1$3 = global$t;
var apply$1$2 = functionApply$2;
var ArrayBufferViewCore = arrayBufferViewCore;
var fails$2$3 = fails$r;
var arraySlice$1$2 = arraySlice$5;
var Int8Array$1 = global$1$3.Int8Array;
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
var $toLocaleString = [].toLocaleString;
var TO_LOCALE_STRING_BUG =
  !!Int8Array$1 &&
  fails$2$3(function () {
    $toLocaleString.call(new Int8Array$1(1));
  });
var FORCED$1 =
  fails$2$3(function () {
    return [1, 2].toLocaleString() != new Int8Array$1([1, 2]).toLocaleString();
  }) ||
  !fails$2$3(function () {
    Int8Array$1.prototype.toLocaleString.call([1, 2]);
  });
exportTypedArrayMethod(
  "toLocaleString",
  function toLocaleString() {
    return apply$1$2(
      $toLocaleString,
      TO_LOCALE_STRING_BUG
        ? arraySlice$1$2(aTypedArray(this))
        : aTypedArray(this),
      arraySlice$1$2(arguments)
    );
  },
  FORCED$1
);
var uncurryThis$2$3 = functionUncurryThis$3;
var defineBuiltIn$9 = defineBuiltIn$8$1;
var regexpExec$2 = regexpExec$3;
var fails$1$3 = fails$r;
var wellKnownSymbol$k = wellKnownSymbol$j;
var createNonEnumerableProperty$9 = createNonEnumerableProperty$8;
var SPECIES$5 = wellKnownSymbol$k("species");
var RegExpPrototype$3 = RegExp.prototype;
var fixRegexpWellKnownSymbolLogic = function (KEY, exec2, FORCED2, SHAM) {
  var SYMBOL = wellKnownSymbol$k(KEY);
  var DELEGATES_TO_SYMBOL = !fails$1$3(function () {
    var O = {};
    O[SYMBOL] = function () {
      return 7;
    };
    return ""[KEY](O) != 7;
  });
  var DELEGATES_TO_EXEC =
    DELEGATES_TO_SYMBOL &&
    !fails$1$3(function () {
      var execCalled = false;
      var re = /a/;
      if (KEY === "split") {
        re = {};
        re.constructor = {};
        re.constructor[SPECIES$5] = function () {
          return re;
        };
        re.flags = "";
        re[SYMBOL] = /./[SYMBOL];
      }
      re.exec = function () {
        execCalled = true;
        return null;
      };
      re[SYMBOL]("");
      return !execCalled;
    });
  if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || FORCED2) {
    var uncurriedNativeRegExpMethod = uncurryThis$2$3(/./[SYMBOL]);
    var methods = exec2(
      SYMBOL,
      ""[KEY],
      function (nativeMethod, regexp, str, arg2, forceStringMethod) {
        var uncurriedNativeMethod = uncurryThis$2$3(nativeMethod);
        var $exec = regexp.exec;
        if ($exec === regexpExec$2 || $exec === RegExpPrototype$3.exec) {
          if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
            return {
              done: true,
              value: uncurriedNativeRegExpMethod(regexp, str, arg2),
            };
          }
          return {
            done: true,
            value: uncurriedNativeMethod(str, regexp, arg2),
          };
        }
        return { done: false };
      }
    );
    defineBuiltIn$9(String.prototype, KEY, methods[0]);
    defineBuiltIn$9(RegExpPrototype$3, SYMBOL, methods[1]);
  }
  if (SHAM)
    createNonEnumerableProperty$9(RegExpPrototype$3[SYMBOL], "sham", true);
};
var uncurryThis$1$3 = functionUncurryThis$3;
var toIntegerOrInfinity$7 = toIntegerOrInfinity$6;
var toString$1$3 = toString$4$1;
var requireObjectCoercible$1$3 = requireObjectCoercible$5;
var charAt$1 = uncurryThis$1$3("".charAt);
var charCodeAt = uncurryThis$1$3("".charCodeAt);
var stringSlice$1$2 = uncurryThis$1$3("".slice);
var createMethod$4 = function (CONVERT_TO_STRING) {
  return function ($this, pos) {
    var S = toString$1$3(requireObjectCoercible$1$3($this));
    var position = toIntegerOrInfinity$7(pos);
    var size = S.length;
    var first, second;
    if (position < 0 || position >= size)
      return CONVERT_TO_STRING ? "" : void 0;
    first = charCodeAt(S, position);
    return first < 55296 ||
      first > 56319 ||
      position + 1 === size ||
      (second = charCodeAt(S, position + 1)) < 56320 ||
      second > 57343
      ? CONVERT_TO_STRING
        ? charAt$1(S, position)
        : first
      : CONVERT_TO_STRING
      ? stringSlice$1$2(S, position, position + 2)
      : ((first - 55296) << 10) + (second - 56320) + 65536;
  };
};
var stringMultibyte = {
  // `String.prototype.codePointAt` method
  // https://tc39.es/ecma262/#sec-string.prototype.codepointat
  codeAt: createMethod$4(false),
  // `String.prototype.at` method
  // https://github.com/mathiasbynens/String.prototype.at
  charAt: createMethod$4(true),
};
var charAt = stringMultibyte.charAt;
var advanceStringIndex$1 = function (S, index, unicode) {
  return index + (unicode ? charAt(S, index).length : 1);
};
var call$1$3 = functionCall$3;
var anObject$1$3 = anObject$e$1;
var isCallable$o = isCallable$n;
var classof$c = classofRaw$1$2;
var regexpExec$1 = regexpExec$3;
var $TypeError$g = TypeError;
var regexpExecAbstract = function (R, S) {
  var exec2 = R.exec;
  if (isCallable$o(exec2)) {
    var result = call$1$3(exec2, R, S);
    if (result !== null) anObject$1$3(result);
    return result;
  }
  if (classof$c(R) === "RegExp") return call$1$3(regexpExec$1, R, S);
  throw $TypeError$g("RegExp#exec called on incompatible receiver");
};
var apply$4 = functionApply$2;
var call$m = functionCall$3;
var uncurryThis$p = functionUncurryThis$3;
var fixRegExpWellKnownSymbolLogic = fixRegexpWellKnownSymbolLogic;
var isRegExp$2 = isRegexp$1;
var anObject$f = anObject$e$1;
var requireObjectCoercible$6 = requireObjectCoercible$5;
var speciesConstructor$4 = speciesConstructor$3;
var advanceStringIndex = advanceStringIndex$1;
var toLength$7 = toLength$6;
var toString2$2 = toString$4$1;
var getMethod$6 = getMethod$4$1;
var arraySlice$6 = arraySliceSimple$1;
var callRegExpExec = regexpExecAbstract;
var regexpExec = regexpExec$3;
var stickyHelpers = regexpStickyHelpers;
var fails$s = fails$r;
var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y;
var MAX_UINT32 = 4294967295;
var min$4 = Math.min;
var $push = [].push;
var exec$3 = uncurryThis$p(/./.exec);
var push$3 = uncurryThis$p($push);
var stringSlice$4 = uncurryThis$p("".slice);
var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails$s(function () {
  var re = /(?:)/;
  var originalExec = re.exec;
  re.exec = function () {
    return originalExec.apply(this, arguments);
  };
  var result = "ab".split(re);
  return result.length !== 2 || result[0] !== "a" || result[1] !== "b";
});
fixRegExpWellKnownSymbolLogic(
  "split",
  function (SPLIT, nativeSplit, maybeCallNative) {
    var internalSplit;
    if (
      "abbc".split(/(b)*/)[1] == "c" || // eslint-disable-next-line regexp/no-empty-group -- required for testing
      "test".split(/(?:)/, -1).length != 4 ||
      "ab".split(/(?:ab)*/).length != 2 ||
      ".".split(/(.?)(.?)/).length != 4 || // eslint-disable-next-line regexp/no-empty-capturing-group, regexp/no-empty-group -- required for testing
      ".".split(/()()/).length > 1 ||
      "".split(/.?/).length
    ) {
      internalSplit = function (separator, limit) {
        var string = toString2$2(requireObjectCoercible$6(this));
        var lim = limit === void 0 ? MAX_UINT32 : limit >>> 0;
        if (lim === 0) return [];
        if (separator === void 0) return [string];
        if (!isRegExp$2(separator)) {
          return call$m(nativeSplit, string, separator, lim);
        }
        var output = [];
        var flags =
          (separator.ignoreCase ? "i" : "") +
          (separator.multiline ? "m" : "") +
          (separator.unicode ? "u" : "") +
          (separator.sticky ? "y" : "");
        var lastLastIndex = 0;
        var separatorCopy = new RegExp(separator.source, flags + "g");
        var match2, lastIndex, lastLength;
        while ((match2 = call$m(regexpExec, separatorCopy, string))) {
          lastIndex = separatorCopy.lastIndex;
          if (lastIndex > lastLastIndex) {
            push$3(output, stringSlice$4(string, lastLastIndex, match2.index));
            if (match2.length > 1 && match2.index < string.length)
              apply$4($push, output, arraySlice$6(match2, 1));
            lastLength = match2[0].length;
            lastLastIndex = lastIndex;
            if (output.length >= lim) break;
          }
          if (separatorCopy.lastIndex === match2.index)
            separatorCopy.lastIndex++;
        }
        if (lastLastIndex === string.length) {
          if (lastLength || !exec$3(separatorCopy, "")) push$3(output, "");
        } else push$3(output, stringSlice$4(string, lastLastIndex));
        return output.length > lim ? arraySlice$6(output, 0, lim) : output;
      };
    } else if ("0".split(void 0, 0).length) {
      internalSplit = function (separator, limit) {
        return separator === void 0 && limit === 0
          ? []
          : call$m(nativeSplit, this, separator, limit);
      };
    } else internalSplit = nativeSplit;
    return [
      // `String.prototype.split` method
      // https://tc39.es/ecma262/#sec-string.prototype.split
      function split2(separator, limit) {
        var O = requireObjectCoercible$6(this);
        var splitter =
          separator == void 0 ? void 0 : getMethod$6(separator, SPLIT);
        return splitter
          ? call$m(splitter, separator, O, limit)
          : call$m(internalSplit, toString2$2(O), separator, limit);
      },
      // `RegExp.prototype[@@split]` method
      // https://tc39.es/ecma262/#sec-regexp.prototype-@@split
      //
      // NOTE: This cannot be properly polyfilled in engines that don't support
      // the 'y' flag.
      function (string, limit) {
        var rx = anObject$f(this);
        var S = toString2$2(string);
        var res = maybeCallNative(
          internalSplit,
          rx,
          S,
          limit,
          internalSplit !== nativeSplit
        );
        if (res.done) return res.value;
        var C = speciesConstructor$4(rx, RegExp);
        var unicodeMatching = rx.unicode;
        var flags =
          (rx.ignoreCase ? "i" : "") +
          (rx.multiline ? "m" : "") +
          (rx.unicode ? "u" : "") +
          (UNSUPPORTED_Y ? "g" : "y");
        var splitter = new C(
          UNSUPPORTED_Y ? "^(?:" + rx.source + ")" : rx,
          flags
        );
        var lim = limit === void 0 ? MAX_UINT32 : limit >>> 0;
        if (lim === 0) return [];
        if (S.length === 0)
          return callRegExpExec(splitter, S) === null ? [S] : [];
        var p = 0;
        var q = 0;
        var A = [];
        while (q < S.length) {
          splitter.lastIndex = UNSUPPORTED_Y ? 0 : q;
          var z = callRegExpExec(
            splitter,
            UNSUPPORTED_Y ? stringSlice$4(S, q) : S
          );
          var e;
          if (
            z === null ||
            (e = min$4(
              toLength$7(splitter.lastIndex + (UNSUPPORTED_Y ? q : 0)),
              S.length
            )) === p
          ) {
            q = advanceStringIndex(S, q, unicodeMatching);
          } else {
            push$3(A, stringSlice$4(S, p, q));
            if (A.length === lim) return A;
            for (var i = 1; i <= z.length - 1; i++) {
              push$3(A, z[i]);
              if (A.length === lim) return A;
            }
            q = p = e;
          }
        }
        push$3(A, stringSlice$4(S, p));
        return A;
      },
    ];
  },
  !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC,
  UNSUPPORTED_Y
);
var modal$b = {
  wallet: {
    connectYourWallet: "Connect Your Wallet",
    whatIsAWallet: "What is a Wallet?",
    secureAndManage: "Secure & Manage Your Digital Assets",
    safelyStore: "Safely store and transfer your crypto and NFTs.",
    logInToAny: "Log In to Any NEAR App",
    noNeedToCreate:
      "No need to create new accounts or credentials. Connect your wallet and you are good to go!",
    getAWallet: "Get a Wallet",
    useAWallet:
      "Use a wallet to secure and manage your NEAR assets, and to log in to any NEAR app without the need for usernames and passwords.",
    connectionFailed: "Connection Failed",
    connectionSuccessful: "Connection Successful",
    connected: "Connected",
    connectingTo: "Connecting to",
    connectingMessage: {
      injected: "Confirm the connection in the extension window",
      browser: "Confirm the connection in the wallet after redirect",
      hardware: "Confirm the connection in the ledger device",
      bridge: "Confirm the connection in the wallet",
    },
  },
  ledger: {
    connectWithLedger: "Connect with Ledger",
    makeSureYourLedger:
      "Make sure your Ledger is connected securely, and that the NEAR app is open on your device",
    continue: "Continue",
    specifyHDPath: "Specify HD Path",
    enterYourPreferredHDPath:
      "Enter your preferred HD path, then scan for any active accounts.",
    scan: "Scan",
    retry: "Retry",
    ledgerIsNotAvailable: "Ledger is not available",
    accessDeniedToUseLedgerDevice: "Access denied to use Ledger device",
    noAccountsFound: "No Accounts Found",
    selectYourAccounts: "Select Your Accounts",
    connecting1Account: "Connecting 1 Account",
    cantFindAnyAccount:
      "Can't find any account associated with this Ledger. Please create a new NEAR account on",
    orConnectAnAnotherLedger: "or connect an another Ledger.",
    connecting: "Connecting",
    ofAccounts: "of Accounts",
    failedToAutomatically:
      "Failed to automatically find account id. Provide it manually:",
    overviewTheListOfAuthorized:
      "Overview the list of authorized account(s), complete sign in by clicking the button below.",
    finish: "Finish",
  },
  install: {
    youllNeedToInstall: "You'll need to install",
    toContinueAfterInstalling: "to continue. After installing",
    refreshThePage: "refresh the page.",
    open: "Open",
  },
  qr: {
    copiedToClipboard: "Copied to clipboard",
    failedToCopy: "Failed to copy to clipboard",
    scanWithYourMobile: "Scan with Your Mobile Device",
    copyToClipboard: " Copy to clipboard",
    preferTheOfficial: "Prefer the official dialogue of",
    open: "Open",
  },
  walletTypes: {
    hardware: "Hardware Wallet",
    browser: "Browser Wallet",
    injected: "Wallet Extension",
    bridge: "Bridge Wallet",
    mobile: "Mobile Wallet",
    "instant-link": "Instant Wallet",
  },
  exportAccounts: {
    chooseAWallet: "Choose a Wallet",
    transferYourAccounts: "Transfer Your Accounts",
    selectAWallet:
      "Select a wallet that fits your needs and supports your connected accounts.",
    selectYourAccounts: "Select Your Accounts",
    afterDecide:
      "After you decide on a wallet, you can select which accounts you want to transfer.",
    disclaimer:
      "You wont be able to transfer accounts that have never been funded or used on NEAR.",
    warning:
      "does not support account export at this time. Please select another wallet.",
    walletTypes: {
      hardware: "Hardware Wallet",
      browser: "Browser Wallet",
      injected: "Wallet Extension",
      bridge: "Bridge Wallet",
      mobile: "Mobile Wallet",
    },
    selectAccounts: {
      title: "Select Accounts to Transfer",
      button: "Continue",
      deselectAll: "Deselect All",
      selectAll: "Select All",
      unavailable: "Transfer Unavailable",
      error: "Account does not exist",
      warningLedger: "Ledger support required",
      noBalance: "Account not funded",
    },
    getPassphrase: {
      title: "Copy Temporary Password",
      desc: "Youll need to enter this password when you begin exporting your accounts to a different wallet.",
      button: "Continue",
      transferButton: "Transfer Accounts",
      label: "Click to Copy",
      checkLabel: "I copied or wrote down the password",
    },
    complete: {
      title: "Complete the Transfer",
      descOne:
        "You will now be redirected to the wallet you selected to complete the transfer.",
      descTwo:
        "Once import part of process is completed from selected wallet, press button to complete the transfer process.",
      startOverButton: "Start Over",
      button: "Complete",
    },
  },
};
var component$1 = {
  clickToCopy: {
    label: "Copied",
    tooltip: "Click to copy",
  },
};
var en = {
  modal: modal$b,
  component: component$1,
};
var modal$a = {
  wallet: {
    connectYourWallet: "Conecta Tu Billetera",
    whatIsAWallet: "Que es una Billetera?",
    secureAndManage: "Resguarda y Administrar Tus Activos Digitales",
    safelyStore: "Almacena de forma segura y transfiere tus cryptos y NFT's",
    logInToAny: "Inicie sesin en Cualquier Aplicacion NEAR",
    noNeedToCreate:
      "No es necesario crear nuevas cuentas o credenciales, Conecta tu billetera y listo!",
    getAWallet: "Obten una Billetera",
    useAWallet:
      "Usa tu Billetera para resguardar y administrar tus activos en NEAR, e Iniciar sesin en cualquier aplicacion NEAR sin la necesidad de nombres de usuarios y contraseas",
    connectionFailed: "Conexin Fallida",
    connectionSuccessful: "Conexin Existosa",
    connected: "Conectado",
    connectingTo: "Conectando a ",
    connectingMessage: {
      injected: "Confirme la conexin en la ventana de extensin",
      browser: "Confirme la conexin en la billetera despus de la redireccin",
      hardware: "Confirme la conexin en el dispositivo de libro mayor",
      bridge: "Confirmar la conexin en la billetera",
    },
  },
  ledger: {
    connectWithLedger: "Conectar con Ledger",
    makeSureYourLedger:
      "Asegrese de que su ledger est conectada de forma segura y que la aplicacion NEAR est abierta en su dispositivo",
    continue: "Continuar",
    specifyHDPath: "Especifique la ruta HD",
    enterYourPreferredHDPath:
      "Ingrese su ruta HD prerida,y luego busque cualquier cuenta activa.",
    scan: "Escanear",
    retry: "Reintentar",
    ledgerIsNotAvailable: "El Ledger no est disponible",
    accessDeniedToUseLedgerDevice:
      "Acceso denegado para usar el dispositivo ledger",
    noAccountsFound: "No se encontraron cuentas",
    selectYourAccounts: "Selecciona tus cuentas",
    connecting1Account: "Conectando a 1 cuenta",
    cantFindAnyAccount:
      "No se pudo encontrar ninguna cuenta asociada con este ledger,Por favor crea una nueva cuenta en NEAR",
    orConnectAnAnotherLedger: "o conecta otro ledger",
    connecting: "Conectando",
    ofAccounts: "de Cuentas",
    failedToAutomatically:
      "No se pudo encontrar automaticamente el id de la cuenta,Ingresalo manualmente:",
    overviewTheListOfAuthorized:
      "Revise la lista de las cuentas autorizadas,Complete el inicio de sesin haciedo click a countinuacion.",
    finish: "Finalizar",
  },
  install: {
    youllNeedToInstall: "Tendrs que instalar",
    toContinueAfterInstalling: "Para continuar, Despues de instalar",
    refreshThePage: "Recarga la pagina",
    open: "Abrir",
  },
  qr: {
    copiedToClipboard: "Copiado al Portapapeles",
    failedToCopy: "Fall la copia al Portapapeles",
    scanWithYourMobile: "Busca con tu dispositivo movil",
    copyToClipboard: " Copiar al Portapapeles",
    preferTheOfficial: "Prefires el dilogo oficial de",
    open: "Abrir",
  },
  walletTypes: {
    hardware: "Hardware Wallet",
    browser: "Browser Wallet",
    injected: "Wallet Extension",
    bridge: "Bridge Wallet",
    mobile: "Mobile Wallet",
    "instant-link": "Instant Wallet",
  },
};
var es = {
  modal: modal$a,
};
var modal$9 = {
  wallet: {
    connectYourWallet: "",
    whatIsAWallet: "",
    secureAndManage: "",
    safelyStore: "NFT",
    logInToAny: " NEAR ",
    noNeedToCreate: "",
    getAWallet: "",
    useAWallet:
      " NEAR  NEAR ",
    connectionFailed: "",
    connectionSuccessful: "",
    connected: "",
    connectingTo: "",
  },
  ledger: {
    connectWithLedger: " Ledger",
    makeSureYourLedger:
      " Ledger  NEAR ",
    continue: "",
    specifyHDPath: " HD ",
    enterYourPreferredHDPath: " HD ",
    scan: "",
    retry: "",
    ledgerIsNotAvailable: "Ledger ",
    accessDeniedToUseLedgerDevice: " Ledger ",
    noAccountsFound: "",
    selectYourAccounts: "",
    connecting1Account: "1",
    cantFindAnyAccount:
      " Ledger ",
    "orConnectAnAnotherLedger.": " Ledger",
    connecting: "",
    ofAccounts: "",
    failedToAutomatically: "ID",
    overviewTheListOfAuthorized: "",
    finish: "",
  },
  install: {
    youllNeedToInstall: "",
    toContinueAfterInstalling: "",
    refreshThePage: "",
    open: "",
  },
  qr: {
    copiedToClipboard: "",
    failedToCopy: "",
    scanWithYourMobile: "",
    copyToClipboard: " ",
    preferTheOfficial: "",
    open: "",
  },
  walletTypes: {
    hardware: "Hardware Wallet",
    browser: "Browser Wallet",
    injected: "Wallet Extension",
    bridge: "Bridge Wallet",
    mobile: "Mobile Wallet",
    "instant-link": "Instant Wallet",
  },
};
var zh = {
  modal: modal$9,
};
var modal$8 = {
  wallet: {
    connectYourWallet: "  ",
    whatIsAWallet: "  ?",
    secureAndManage: "     ",
    safelyStore: "       NFT.",
    logInToAny: "    NEAR",
    noNeedToCreate:
      "     .      !",
    getAWallet: " ",
    useAWallet:
      " ,         NEAR        NEAR       .",
    connectionFailed: " ",
    connectionSuccessful: " ",
    connected: "",
    connectingTo: " ",
    connectingMessage: {
      injected: "     ",
      browser: "     ",
      hardware: "    ",
      bridge: "   ",
    },
  },
  ledger: {
    connectWithLedger: "   Ledger",
    makeSureYourLedger:
      " ,   Ledger      NEAR   a .",
    continue: "",
    specifyHDPath: " HD ",
    enterYourPreferredHDPath:
      "  HD ,      .",
    scan: "",
    retry: " ",
    ledgerIsNotAvailable: "Ledger    ",
    accessDeniedToUseLedgerDevice: "    Ledger  ",
    noAccountsFound: "  ",
    selectYourAccounts: "  ",
    connecting1Account: "  1 ",
    cantFindAnyAccount:
      "  ,    Ledger. ,   NEAR  ",
    orConnectAnAnotherLedger: "   Ledger.",
    connecting: "",
    ofAccounts: " ",
    failedToAutomatically:
      "      .   :",
    overviewTheListOfAuthorized:
      "    ,  ,     -..",
    finish: "",
  },
  install: {
    youllNeedToInstall: "   ",
    toContinueAfterInstalling: "  .  ",
    refreshThePage: " .",
    open: "",
  },
  qr: {
    copiedToClipboard: "  ",
    failedToCopy: "   ",
    scanWithYourMobile: "     ",
    copyToClipboard: "   ",
    preferTheOfficial: "   ",
    open: "",
  },
  walletTypes: {
    hardware: "Hardware Wallet",
    browser: "Browser Wallet",
    injected: "Wallet Extension",
    bridge: "Bridge Wallet",
    mobile: "Mobile Wallet",
    "instant-link": "Instant Wallet",
  },
};
var bg = {
  modal: modal$8,
};
var modal$7 = {
  wallet: {
    connectYourWallet: " ",
    whatIsAWallet: "   ?",
    secureAndManage: "    .",
    safelyStore: " NFT     .",
    logInToAny: "NEAR App .",
    noNeedToCreate:
      "            .",
    getAWallet: " ",
    useAWallet:
      "  NEAR  ,    NEAR    .",
    connectionFailed: " ",
    connectionSuccessful: " ",
    connected: "Connected",
    connectingTo: " : ",
    connectingMessage: {
      injected: "   ",
      browser: "    ",
      hardware: "Ledger   ",
      bridge: "  ",
    },
  },
  ledger: {
    connectWithLedger: "Ledger ",
    makeSureYourLedger:
      "Ledger   , NEAR     ",
    continue: "",
    specifyHDPath: "HD Path ",
    enterYourPreferredHDPath:
      " HD Path ,     ",
    scan: "",
    retry: " ",
    ledgerIsNotAvailable: "Ledger   ",
    accessDeniedToUseLedgerDevice: "Ledger    ",
    noAccountsFound: "   ",
    selectYourAccounts: " ",
    connecting1Account: "  ",
    cantFindAnyAccount:
      "Ledger     .    ",
    orConnectAnAnotherLedger: " Ledger ",
    connecting: " : ",
    ofAccounts: "  ",
    failedToAutomatically: " ID  .  .",
    overviewTheListOfAuthorized:
      "         ",
    finish: "",
  },
  walletTypes: {
    hardware: " ",
    browser: " ",
    injected: " ",
    bridge: " ",
    mobile: " ",
    "instant-link": " ",
  },
  install: {
    youllNeedToInstall: "   :",
    toContinueAfterInstalling: ".       . ",
    refreshThePage: " ",
    open: "Open",
  },
  qr: {
    copiedToClipboard: "  ",
    failedToCopy: "  ",
    scanWithYourMobile: "   ",
    copyToClipboard: "  ",
    preferTheOfficial:
      "     : ",
    open: "Open",
  },
};
var ko = {
  modal: modal$7,
};
var modal$6 = {
  wallet: {
    connectYourWallet: "Kt ni v ca bn",
    whatIsAWallet: "V l g?",
    secureAndManage: "Bo mt & Qun l ti sn s ca bn",
    safelyStore:
      "Lu tr v chuyn tin in t v NFT ca bn mt cch an ton.",
    logInToAny: "ng nhp vo bt k ng dng trn NEAR",
    noNeedToCreate:
      "Khng cn to ti khon hoc thng tin ng nhp mi. Kt ni v ca bn v bt u!",
    getAWallet: "To V",
    useAWallet:
      "S dng v  bo mt v qun l ti sn trn NEAR ca bn v ng nhp vo bt k ng dng NEAR no, khng cn tn ngi dng v mt khu.",
    connectionFailed: "Kt ni tht bi",
    connectionSuccessful: "Kt ni thnh cng",
    connected: " kt ni",
    connectingTo: "ang kt ni ti",
    connectingMessage: {
      injected: "Xc nhn kt ni trong ca s tin ch m rng",
      browser: "Xc nhn kt ni trong v sau khi c chuyn hng",
      hardware: "Xc nhn kt ni vi v lnh",
      bridge: "Xc nhn kt ni trong v",
    },
  },
  ledger: {
    connectWithLedger: "Kt ni v Ledger",
    makeSureYourLedger:
      "m bo Ledger ca bn c kt ni an ton v ng dng NEAR ang m sn trn thit b",
    continue: "Tip tc",
    specifyHDPath: "Ch nh HD Path",
    enterYourPreferredHDPath:
      "Nhp HD Path ca bn, sau  qut tm cc ti khon hot ng",
    scan: "Qut",
    retry: "Th li",
    ledgerIsNotAvailable: "Ledger khng kh dng",
    accessDeniedToUseLedgerDevice: "Truy cp Ledger b t chi",
    noAccountsFound: "Khng tm thy ti khon",
    selectYourAccounts: "Chn ti khon ca bn",
    connecting1Account: "ang kt ni 1 ti khon",
    cantFindAnyAccount:
      "Khng th tm thy bt k ti khon no c lin kt vi Ledger ny. Vui lng to mt ti khon NEAR mi",
    orConnectAnAnotherLedger: "hoc kt ni vi v Ledger khc.",
    connecting: "ang kt ni",
    ofAccounts: "ca ti khon",
    failedToAutomatically: "Khng th t ng tm id ti khon. Nhp th cng:",
    overviewTheListOfAuthorized:
      "Tng quan danh sch cc ti khon c y quyn, hon tt ng nhp bng cch bm vo nt bn di.",
    finish: "Hon thnh",
  },
  install: {
    youllNeedToInstall: "Bn s cn ci t",
    toContinueAfterInstalling: " bt u. Sau khi ci t xong",
    refreshThePage: "Ti li trang.",
    open: "M",
  },
  qr: {
    copiedToClipboard: " sao chp vo bng ghi tm",
    failedToCopy: "Sao chp vo bng ghi tm tht bi",
    scanWithYourMobile: "Qut vi in thoi ca bn",
    copyToClipboard: " Sao chp vo bng ghi tm",
    preferTheOfficial: "Dialogue chnh thc ca",
    open: "M",
  },
  walletTypes: {
    hardware: "V lnh",
    browser: "V trnh duyt",
    injected: "V tin ch m rng",
    bridge: "V Cu",
    mobile: "V Mobile",
    "instant-link": "V tc th",
  },
  exportAccounts: {
    chooseAWallet: "Chn v",
    transferYourAccounts: "Chuyn ti khon",
    selectAWallet:
      "Chn v ph hp vi nhu cu ca bn, v c chn cn h tr cc ti khon ang s dng.",
    selectYourAccounts: "Chn ti khon",
    afterDecide: "Sau khi chn c ti khon bn c chuyn.",
    disclaimer:
      "Bn khng th chuyn ti khon nu ti khon  cha c nhn tin hoc cha pht sinh giao dch trn NEAR.",
    warning: "khng h tr xut ti khon. Vui lng chn v khc.",
    walletTypes: {
      hardware: "V lnh",
      browser: "V trnh duyt",
      injected: "V tin ch m rng",
      bridge: "V Cu",
      mobile: "V Mobile",
    },
    selectAccounts: {
      title: "Chn ti khon  chuyn",
      button: "Ly cm mt khu",
      deselectAll: "B chn tt c",
      selectAll: "Chn tt c",
      unavailable: "Chuyn khng kh dng",
      error: "Ti khon khng tn ti",
      warningLedger: "Yu cu h tr Ledger",
      noBalance: "Ti khon trng",
    },
    getPassphrase: {
      title: "Sao chp mt khu tm thi",
      desc: "Bn s cn nhp mt khu khi bt u xut cc khon ti v khc.",
      button: "Tip tc",
      label: "Bm  sao chp",
      checkLabel: "Ti  chp hoc ghi li mt khu",
    },
    complete: {
      title: "Hon thnh chuyn",
      descOne:
        "Bn s c chuyn hng ti ti khon  chn  hon tt qu trnh.",
      descTwo: "Sau khi nhp, nhn nt  hon tt quy trnh chuyn.",
      button: "Hon thnh",
    },
  },
};
var component = {
  clickToCopy: {
    label: " sao chp",
    tooltip: "Bm  sao chp",
  },
};
var vi = {
  modal: modal$6,
  component,
};
var modal$5 = {
  wallet: {
    connectYourWallet: "  (Wallet)  ",
    whatIsAWallet: "  ?",
    secureAndManage: "   ",
    safelyStore:
      "           ",
    logInToAny: "NEAR        ",
    noNeedToCreate:
      "          (NEAR Wallet)    ",
    getAWallet: "  ",
    useAWallet:
      " NEAR                NEAR  (app)    ,   (user)       ",
    connectionFailed: " |",
    connectionSuccessful: " |",
    connected: "  |",
    connectingTo: "   |",
    connectingMessage: {
      injected: "      |",
      browser: "         |",
      hardware: "       |",
    },
  },
  ledger: {
    connectWithLedger: "(Ledger)  |",
    makeSureYourLedger:
      "            NEAR    (Device)     |",
    continue: " |",
    specifyHDPath: " (Hard Disk)(Path) |",
    enterYourPreferredHDPath:
      "    ,       |",
    scan: " |",
    retry: "  |",
    ledgerIsNotAvailable: "   |",
    accessDeniedToUseLedgerDevice:
      "        |",
    noAccountsFound: "  |",
    selectYourAccounts: "  |",
    connecting1Account: "     |",
    cantFindAnyAccount:
      "           NEAR  |",
    orConnectAnAnotherLedger: "      ",
    connecting: "  |",
    ofAccounts: "    |",
    failedToAutomatically:
      "         (Manuall)    |",
    overviewTheListOfAuthorized:
      "   ,          ",
    finish: "|",
  },
  install: {
    youllNeedToInstall: "   |",
    toContinueAfterInstalling: "     |",
    refreshThePage: ":  ",
    open: "|",
  },
  qr: {
    copiedToClipboard: "(Clipboard)   |",
    failedToCopy: "     |",
    scanWithYourMobile: "  (Mobile)  |",
    copyToClipboard: "    |",
    preferTheOfficial: "    |",
    open: "|",
  },
  walletTypes: {
    hardware: "Hardware Wallet",
    browser: "Browser Wallet",
    injected: "Wallet Extension",
    bridge: "Bridge Wallet",
    mobile: "Mobile Wallet",
    "instant-link": "Instant Wallet",
  },
};
var hi = {
  modal: modal$5,
};
var modal$4 = {
  wallet: {
    connectYourWallet: " ",
    whatIsAWallet: "  ",
    secureAndManage: "     ",
    safelyStore: "        ",
    logInToAny: "      ",
    noNeedToCreate: ".    .     ",
    getAWallet: "  ",
    useAWallet:
      "                  ",
    connectionFailed: " ",
    connectionSuccessful: " ",
    connected: "",
    connectingTo: "  ",
    connectingMessage: {
      injected: "     ",
      browser: "       ",
      hardware: "     ",
      bridge: "    ",
    },
  },
  ledger: {
    connectWithLedger: "  ",
    makeSureYourLedger:
      "    ,       ",
    continue: "",
    specifyHDPath: "  ",
    enterYourPreferredHDPath:
      "         ",
    scan: "",
    retry: " ",
    ledgerIsNotAvailable: "  ",
    accessDeniedToUseLedgerDevice: "   ",
    noAccountsFound: "     ",
    selectYourAccounts: " ",
    connecting1Account: "   ",
    cantFindAnyAccount:
      "              ",
    orConnectAnAnotherLedger: "    ",
    connecting: " ",
    ofAccounts: " ",
    failedToAutomatically:
      "    .    ",
    overviewTheListOfAuthorized:
      "   ,       ",
    finish: "",
  },
  install: {
    youllNeedToInstall: " ",
    toContinueAfterInstalling: ".  ",
    refreshThePage: "  ",
    open: "",
  },
  qr: {
    copiedToClipboard: " ",
    failedToCopy: " ",
    scanWithYourMobile: "  ",
    copyToClipboard: "",
    preferTheOfficial: "   ",
    open: "",
  },
  walletTypes: {
    hardware: "Hardware Wallet",
    browser: "Browser Wallet",
    injected: "Wallet Extension",
    bridge: "Bridge Wallet",
    mobile: "Mobile Wallet",
    "instant-link": "Instant Wallet",
  },
};
var ar = {
  modal: modal$4,
};
var modal$3 = {
  wallet: {
    connectYourWallet: "Spojite crypto novanik!",
    whatIsAWallet: "to je to crypto novanik?",
    secureAndManage: "Osigurajte i upravljajte svojom digitalnom imovinom.",
    safelyStore: "Sigurno pohranite i prebacite svoj crypto i NFT-eve.",
    logInToAny: " Prijavite se u bilo koju NEAR aplikaciju",
    noNeedToCreate:
      "Nema potrebe za stvaranjem novih naloga ili korisnikih podataka. Spojite svoj crypto novanik i spremni ste!",
    getAWallet: "Otvorite crypto novanik",
    useAWallet:
      "Koristite crypto novanik da biste osigurali i upravljali svojom NEAR imovinom, te se prijavite u bilo koju NEAR aplikaciju bez korisnikog imena i lozinke.",
    connectionFailed: "Neuspjeno povezivanje.",
    connectionSuccessful: "Uspjeno povezivanje.",
    connected: "Povezano.",
    connectingTo: "Povezivanje u tijeku",
    connectingMessage: {
      injected: "Potvrdite vezu u eksternom prozoru",
      browser: "Nakon redirekcije, potvrdite vezu u novaniku",
      hardware: "Potvrdite vezu sa novanikom",
      bridge: "Potvrdite vezu u novaniku",
    },
  },
  ledger: {
    connectWithLedger: "Poveite se hardverskim novanikom",
    makeSureYourLedger:
      "Osigurajte sigurnu vezu s hardverskim novanikom, te da je NEAR aplikacija otvorena na vaem ureaju",
    continue: "Nastavite",
    specifyHDPath: "Specificirajte HD putanju",
    enterYourPreferredHDPath:
      "Upiite preferiranu HD putanju, zatim skenirajte aktivne naloge",
    scan: "Skenirajte",
    retry: "Pokuajte ponovno",
    ledgerIsNotAvailable: "Hardverski novanik nije dostupan.",
    accessDeniedToUseLedgerDevice:
      "Odbijen pristup za koritenjem hardverskog novanika",
    noAccountsFound: "Nalozi nisu pronaeni",
    selectYourAccounts: "Odaberite svoje naloge",
    connecting1Account: "Povezivanje 1 naloga",
    cantFindAnyAccount:
      "Nije mogue pronai niti jedan nalog povezan s ovim hardverskim novanikom. Molimo vas, kreirajte novi NEAR nalog",
    orConnectAnAnotherLedger: "Ili poveite drugi hardverski novanik.",
    connecting: "Povezivanje",
    ofAccounts: "naloga",
    failedToAutomatically:
      "Neuspjeno automatsko pronalaenje ID naloga. Unesite runo:",
    overviewTheListOfAuthorized:
      "Pregledajte popis odobrenih naloga, zavrite prijavu pritiskom na nie prikazani gumb.",
    finish: "Zavrite",
  },
  install: {
    youllNeedToInstall: " Potrebno je instalirati modal",
    toContinueAfterInstalling: "za nastavak. Nakon instalacije",
    refreshThePage: "osvjeite stranicu.",
    open: "Otvorite QR modal",
  },
  qr: {
    copiedToClipboard: "Kopirano u meuspremnik",
    failedToCopy: "Neupsjeno kopiranje u meuspremnik",
    scanWithYourMobile: "Skenirajte svojim mobilnim ureajem",
    copyToClipboard: " Kopirajte u meuspremnik",
    preferTheOfficial: "Odaberite slubeni dijalog",
    open: "Otvorite",
  },
  walletTypes: {
    hardware: "Hardware Wallet",
    browser: "Browser Wallet",
    injected: "Wallet Extension",
    bridge: "Bridge Wallet",
    mobile: "Mobile Wallet",
    "instant-link": "Instant Wallet",
  },
  exportAccounts: {
    chooseAWallet: "Odaberi Wallet",
    transferYourAccounts: "Prenesi svoje naloge",
    selectAWallet:
      "Odaberite wallet koji odgovara vaim potrebama i podrava vae povezane naloge.",
    selectYourAccounts: "Odaberi svoje naloge",
    afterDecide:
      "Nakon to odluite koji wallet koristite, moete odabrati koje raune elite prebaciti.",
    disclaimer:
      "Neete moi prebaciti naloge koji nisu nikada bili koriteni na NEAR-u.",
    warning:
      "ne podrava izvoz naloga u ovom trenutku. Molimo odaberite drugi wallet.",
    walletTypes: {
      hardware: "Hardware Wallet",
      browser: "Browser Wallet",
      injected: "Wallet Extension",
      bridge: "Bridge Wallet",
      mobile: "Mobile Wallet",
    },
    selectAccounts: {
      title: "Odaberi naloge za prijenos",
      button: "Generiraj lozinku",
      deselectAll: "Makni odabir sa svih",
      selectAll: "Odaberi sve",
      unavailable: "Prijenos nije dostupan",
      error: "Nalog ne postoji",
      warningLedger: "Potrebna ledger podrka",
      noBalance: "Nalog nema sredstava",
    },
    getPassphrase: {
      title: "Kopiraj privremenu lozinku",
      desc: "Bit e potrebno unijeti ovu lozinku na poetku izvoza naloga na drugi wallet.",
      button: "Nastavi",
      label: "Klikni za kopiju",
      checkLabel: "Kopirao sam ili zapisao lozinku",
    },
    complete: {
      title: "Zavri prijenos",
      descOne:
        "You will now be redirected to the wallet you selected to complete the transfer.",
      descTwo:
        "Kada je unos s odabranog walleta zavren, pritisnite gumb da biste zavrili prijenos.",
      button: "Zavri",
    },
  },
};
var hr = {
  modal: modal$3,
};
var modal$2 = {
  wallet: {
    connectYourWallet: "   !",
    whatIsAWallet: "  ?",
    secureAndManage: "       .",
    safelyStore:
      "         NFT.",
    logInToAny: "     NEAR ",
    noNeedToCreate:
      "       .       !",
    getAWallet: " ",
    useAWallet:
      "         NEAR         NEAR        .",
    connectionFailed: "   .",
    connectionSuccessful: " .",
    connected: ".",
    connectingTo: " ",
    connectingMessage: {
      injected: "     ",
      browser: " ,     ",
      hardware: "     ",
      bridge: "    ",
    },
  },
  ledger: {
    connectWithLedger: "   ",
    makeSureYourLedger:
      "       ,   NEAR      ",
    continue: "",
    specifyHDPath: "  ",
    enterYourPreferredHDPath:
      "     ,        .",
    scan: "",
    retry: "  ",
    ledgerIsNotAvailable: "   .",
    accessDeniedToUseLedgerDevice:
      "       ",
    noAccountsFound: "  ",
    selectYourAccounts: "   ",
    connecting1Account: "   ",
    cantFindAnyAccount:
      "       .     NEAR  ",
    orConnectAnAnotherLedger: "   .",
    connecting: "",
    ofAccounts: " ",
    failedToAutomatically:
      "      .   :",
    overviewTheListOfAuthorized:
      "     ,        .",
    finish: "",
  },
  install: {
    youllNeedToInstall: "  ",
    toContinueAfterInstalling: "  .  ",
    refreshThePage: "  .",
    open: "",
  },
  qr: {
    copiedToClipboard: "  ",
    failedToCopy: "   ",
    scanWithYourMobile: "    ",
    copyToClipboard: "  ",
    preferTheOfficial: "   ",
    open: "",
  },
  walletTypes: {
    hardware: " ",
    browser: "   ",
    injected: "  ",
    bridge: "Bridge ",
    mobile: " ",
    "instant-link": " ",
  },
  exportAccounts: {
    chooseAWallet: " ",
    transferYourAccounts: "    ",
    selectAWallet:
      "             .",
    selectYourAccounts: "    ",
    afterDecide:
      "   ,          .",
    disclaimer:
      "              NEAR.",
    warning:
      "        .     .",
    walletTypes: {
      hardware: " ",
      browser: "   ",
      injected: "  ",
      bridge: "Bridge ",
      mobile: " ",
    },
    selectAccounts: {
      title: "       .",
      button: " ",
      deselectAll: " ",
      selectAll: " ",
      unavailable: "  ",
      error: "   ",
      warningLedger: "    ",
      noBalance: "   ",
    },
    getPassphrase: {
      title: "   ",
      desc: "                 .",
      button: "",
      label: "   ",
      checkLabel: "    ",
    },
    complete: {
      title: "  ",
      descOne:
        "          .",
      descTwo:
        "      ,        .",
      button: "",
    },
  },
};
var mk = {
  modal: modal$2,
};
var modal$1 = {
  wallet: {
    connectYourWallet: "Poveite svojo denarnico!",
    whatIsAWallet: "Kaj je denarnica?",
    secureAndManage: "Zavarujte in upravljajte svoja digitalna sredstva.",
    safelyStore: "Varno shranjujte in prenaajte svoje kriptovalute in NFTje.",
    logInToAny: "Prijavite se v katero koli aplikacijo na NEAR",
    noNeedToCreate:
      "Ni vam treba ustvarjati novih raunov. Poveite svojo denarnico in zanite!",
    getAWallet: "Ustvarite denarnico",
    useAWallet:
      "Uporabite denarnico, da bi zavarovali in upravljali s svoja NEAR digitalna sredstva, in se prijavite v katero koli aplikacijo ekosistema NEAR",
    connectionFailed: "Povezava ni bila uspena.",
    connectionSuccessful: "Povezava je bila uspena.",
    connected: "Vaa denarnica je povezana.",
    connectingTo: "Povezovanje z",
    connectingMessage: {
      injected: "Potrdite povezavo v oknu raziritve",
      browser: "Po preusmeritvi potrdite povezavo v denarnici",
      hardware: "Potrdite povezavo s hladno denarnico",
      bridge: "Potrdite povezavo v denarnici",
    },
  },
  ledger: {
    connectWithLedger: "Poveite se z Ledger",
    makeSureYourLedger:
      "Prepriajte se, da je va Ledger varno povezan in da je aplikacija NEAR odprta v vai napravi",
    continue: "Nadaljuj",
    specifyHDPath: "Doloite HD pot",
    enterYourPreferredHDPath:
      "Vnesite eleno HD pot, nato poiite vse aktivne raune.",
    scan: "Skenirajte",
    retry: "Poskusite znova",
    ledgerIsNotAvailable: "Ledger ni na voljo",
    accessDeniedToUseLedgerDevice: "Dostop za uporabo naprave Ledger zavrnjen",
    noAccountsFound: "Ni najdenih raunov",
    selectYourAccounts: "Izberite Vai rauni",
    connecting1Account: "Povezovanje enega rauna",
    cantFindAnyAccount:
      "Ni mogoe najti nobenega rauna, povezanega s tem Ledgerjem. Ustvarite nov NEAR raun ",
    orConnectAnAnotherLedger: "ali poveite drug Ledger..",
    connecting: "Povezovanje",
    ofAccounts: "raunov",
    failedToAutomatically:
      "ID-ja rauna ni bilo mogoe samodejno najti. Zagotovite ga rono:",
    overviewTheListOfAuthorized:
      "Oglejte si seznam pooblaenih raunov, dokonajte prijavo s klikom na spodnji gumb.",
    finish: "Konajte",
  },
  install: {
    youllNeedToInstall: "Morali ga boste namestiti",
    toContinueAfterInstalling: "nadaljevati. Po namestitvi",
    refreshThePage: "Osveite stran.",
    open: "Odprite",
  },
  qr: {
    copiedToClipboard: "Kopirano v podloni mapi",
    failedToCopy: "Kopiranje v podloni mapi ni uspelo",
    scanWithYourMobile: "Skenirajte s svojo mobilno napravo",
    copyToClipboard: " Kopirajte v podloni mapi",
    preferTheOfficial: "Preferirajte uradno pogovorno okno",
    open: "Odprite",
  },
  walletTypes: {
    hardware: "Hladna denarnica",
    browser: "Denarnica brskalnika",
    injected: "Raziritev za denarnico",
    bridge: "Bridge denarnica",
    mobile: "Mobilna denarnica",
    "instant-link": "Takojnja denarnica",
  },
  exportAccounts: {
    chooseAWallet: "Izberite denarnico",
    transferYourAccounts: "Prenesite svoje raune",
    selectAWallet:
      "Izberite denarnico, ki ustreza vaim potrebam in podpira vae povezane raune.",
    selectYourAccounts: "Izberite vai rauni",
    afterDecide:
      "Ko se odloite za denarnico, lahko izberete, katere raune elite prenesti.",
    disclaimer:
      "Ne boste mogli prenesti Raunov, ki nikoli niso bili financirani ali uporabljeni na NEAR.",
    warning: "trenutno ne podpira izvoza rauna. Izberite drugo denarnico",
    walletTypes: {
      hardware: "Hladna denarnica",
      browser: "Denarnica brskalnika",
      injected: "Raziritev za denarnico",
      bridge: "Bridge denarnica",
      mobile: "Mobilna denarnica",
    },
    selectAccounts: {
      title: "Izberite rauni za prenos.",
      button: "Pridobite geslo",
      deselectAll: "Preklii izbiro vseh",
      selectAll: "Izberi vse",
      unavailable: "Prenos ni na voljo",
      error: "Raun ne obstaja",
      warningLedger: "Potrebna je podpora za Ledger",
      noBalance: "Raun ni financiran",
    },
    getPassphrase: {
      title: "Kopiraj zaasno geslo",
      desc: "To geslo boste morali vnesti, ko boste zaeli izvaati svoje raune v drugo denarnico.",
      button: "Nadaljujte",
      label: "Kliknite za kopiranje",
      checkLabel: "Geslo sem kopiral ali zapisal",
    },
    complete: {
      title: "Dokonajte prenos",
      descOne:
        "Zdaj boste preusmerjeni v denarnico, ki ste jo izbrali za dokonanje prenosa.",
      descTwo:
        "Ko je uvozni del postopka konan iz izbrane denarnice, pritisnite gumb za dokonanje postopka prenosa.",
      button: "Konajte",
    },
  },
};
var sl = {
  modal: modal$1,
};
var modal$c = {
  wallet: {
    connectYourWallet: "  !",
    whatIsAWallet: "  ?",
    secureAndManage: "     .",
    safelyStore: "       NFT.",
    logInToAny: "      NEAR",
    noNeedToCreate:
      "       .     e!",
    getAWallet: " ",
    useAWallet:
      "       NEAR          NEAR       .",
    connectionFailed: "  .",
    connectionSuccessful: "  .",
    connected: ".",
    connectingTo: " ",
    connectingMessage: {
      injected: "    ",
      browser: " ,    ",
      hardware: "    ",
      bridge: "   ",
    },
  },
  ledger: {
    connectWithLedger: "   Ledger",
    makeSureYourLedger:
      "     Ledger       NEAR    ",
    continue: "",
    specifyHDPath: "  ",
    enterYourPreferredHDPath:
      "    ,      .",
    scan: "",
    retry: " ",
    ledgerIsNotAvailable: "Ledger  .",
    accessDeniedToUseLedgerDevice:
      "     Ledger ",
    noAccountsFound: "l  ",
    selectYourAccounts: "  l",
    connecting1Account: " 1 l",
    cantFindAnyAccount:
      "    l    Ledger-.   NEAR l",
    orConnectAnAnotherLedger: "   Ledger.",
    connecting: "",
    ofAccounts: "l",
    failedToAutomatically:
      "  ID-a l  .   :",
    overviewTheListOfAuthorized:
      "   ,      .",
    finish: "",
  },
  install: {
    youllNeedToInstall: "  ",
    toContinueAfterInstalling: " .  ",
    refreshThePage: "  .",
    open: "",
  },
  qr: {
    copiedToClipboard: "  ",
    failedToCopy: "    ",
    scanWithYourMobile: "   ",
    copyToClipboard: "   ",
    preferTheOfficial: "   ",
    open: "",
  },
  walletTypes: {
    hardware: " ",
    browser: " ,",
    injected: "  ,",
    bridge: "Bridge ",
    mobile: " ",
    "instant-link": " ",
  },
  exportAccounts: {
    chooseAWallet: " ",
    transferYourAccounts: "  ",
    selectAWallet:
      "           .",
    selectYourAccounts: "  ",
    afterDecide:
      "     ,       .",
    disclaimer:
      "              NEAR.",
    warning: "    .   .",
    walletTypes: {
      hardware: " ",
      browser: " ,",
      injected: "  ,",
      bridge: "Bridge ",
      mobile: " ",
    },
    selectAccounts: {
      title: "   .",
      button: "  ",
      deselectAll: " ",
      selectAll: " ",
      unavailable: "  ",
      error: "  ",
      warningLedger: "   Ledger",
      noBalance: "  ",
    },
    getPassphrase: {
      title: "  ",
      desc: "             .",
      button: "",
      label: "   ",
      checkLabel: "    ",
    },
    complete: {
      title: " ",
      descOne:
        "           .",
      descTwo:
        "        ,      .",
      button: "",
    },
  },
};
var sr = {
  modal: modal$c,
};
var getLanguage = (languageCode) => {
  switch (languageCode) {
    case "en":
      return en;
    case "es":
      return es;
    case "zh":
      return zh;
    case "bg":
      return bg;
    case "ko":
      return ko;
    case "vi":
      return vi;
    case "hi":
      return hi;
    case "ar":
      return ar;
    case "hr":
      return hr;
    case "mk":
      return mk;
    case "sl":
      return sl;
    case "sr":
      return sr;
    default:
      return en;
  }
};
var chosenLang;
var allowOnlyLanguage = (langCode) => {
  chosenLang = langCode;
};
var shortenLanguageCode = (lang) => {
  return lang.indexOf("-") !== -1 ? lang.split("-")[0] : lang.split("_")[0];
};
var findObjectPropByStringPath = (obj, prop) => {
  if (!obj) {
    return "";
  }
  const _index = prop.indexOf(".");
  if (_index > -1) {
    const currentProp = prop.substring(0, _index);
    const nextProp = prop.substring(_index + 1);
    return findObjectPropByStringPath(obj[currentProp], nextProp);
  }
  return obj[prop];
};
var translate = (path) => {
  let browserLang = window.navigator.languages
    ? window.navigator.languages[0]
    : null;
  browserLang = browserLang || window.navigator.language;
  const languageCode = shortenLanguageCode(chosenLang || browserLang);
  const selectedLanguage = getLanguage(languageCode);
  const text = findObjectPropByStringPath(selectedLanguage, path);
  return text && typeof text === "string" ? text : path;
};

// node_modules/react/cjs/react.production.min.js
var require_react_production_min = __commonJS({
  "node_modules/react/cjs/react.production.min.js"(exports) {
    var l = Symbol.for("react.element");
    var n = Symbol.for("react.portal");
    var p = Symbol.for("react.fragment");
    var q = Symbol.for("react.strict_mode");
    var r = Symbol.for("react.profiler");
    var t = Symbol.for("react.provider");
    var u = Symbol.for("react.context");
    var v = Symbol.for("react.forward_ref");
    var w = Symbol.for("react.suspense");
    var x = Symbol.for("react.memo");
    var y = Symbol.for("react.lazy");
    var z = Symbol.iterator;
    function A(a) {
      if (null === a || "object" !== typeof a) return null;
      a = (z && a[z]) || a["@@iterator"];
      return "function" === typeof a ? a : null;
    }
    var B = {
      isMounted: function () {
        return false;
      },
      enqueueForceUpdate: function () {},
      enqueueReplaceState: function () {},
      enqueueSetState: function () {},
    };
    var C = Object.assign;
    var D = {};
    function E(a, b, e) {
      this.props = a;
      this.context = b;
      this.refs = D;
      this.updater = e || B;
    }
    E.prototype.isReactComponent = {};
    E.prototype.setState = function (a, b) {
      if ("object" !== typeof a && "function" !== typeof a && null != a)
        throw Error(
          "setState(...): takes an object of state variables to update or a function which returns an object of state variables."
        );
      this.updater.enqueueSetState(this, a, b, "setState");
    };
    E.prototype.forceUpdate = function (a) {
      this.updater.enqueueForceUpdate(this, a, "forceUpdate");
    };
    function F() {}
    F.prototype = E.prototype;
    function G(a, b, e) {
      this.props = a;
      this.context = b;
      this.refs = D;
      this.updater = e || B;
    }
    var H = (G.prototype = new F());
    H.constructor = G;
    C(H, E.prototype);
    H.isPureReactComponent = true;
    var I = Array.isArray;
    var J = Object.prototype.hasOwnProperty;
    var K = { current: null };
    var L = { key: true, ref: true, __self: true, __source: true };
    function M(a, b, e) {
      var d,
        c = {},
        k = null,
        h = null;
      if (null != b)
        for (d in (void 0 !== b.ref && (h = b.ref),
        void 0 !== b.key && (k = "" + b.key),
        b))
          J.call(b, d) && !L.hasOwnProperty(d) && (c[d] = b[d]);
      var g = arguments.length - 2;
      if (1 === g) c.children = e;
      else if (1 < g) {
        for (var f = Array(g), m = 0; m < g; m++) f[m] = arguments[m + 2];
        c.children = f;
      }
      if (a && a.defaultProps)
        for (d in ((g = a.defaultProps), g)) void 0 === c[d] && (c[d] = g[d]);
      return {
        $$typeof: l,
        type: a,
        key: k,
        ref: h,
        props: c,
        _owner: K.current,
      };
    }
    function N(a, b) {
      return {
        $$typeof: l,
        type: a.type,
        key: b,
        ref: a.ref,
        props: a.props,
        _owner: a._owner,
      };
    }
    function O(a) {
      return "object" === typeof a && null !== a && a.$$typeof === l;
    }
    function escape(a) {
      var b = { "=": "=0", ":": "=2" };
      return (
        "$" +
        a.replace(/[=:]/g, function (a2) {
          return b[a2];
        })
      );
    }
    var P = /\/+/g;
    function Q(a, b) {
      return "object" === typeof a && null !== a && null != a.key
        ? escape("" + a.key)
        : b.toString(36);
    }
    function R(a, b, e, d, c) {
      var k = typeof a;
      if ("undefined" === k || "boolean" === k) a = null;
      var h = false;
      if (null === a) h = true;
      else
        switch (k) {
          case "string":
          case "number":
            h = true;
            break;
          case "object":
            switch (a.$$typeof) {
              case l:
              case n:
                h = true;
            }
        }
      if (h)
        return (
          (h = a),
          (c = c(h)),
          (a = "" === d ? "." + Q(h, 0) : d),
          I(c)
            ? ((e = ""),
              null != a && (e = a.replace(P, "$&/") + "/"),
              R(c, b, e, "", function (a2) {
                return a2;
              }))
            : null != c &&
              (O(c) &&
                (c = N(
                  c,
                  e +
                    (!c.key || (h && h.key === c.key)
                      ? ""
                      : ("" + c.key).replace(P, "$&/") + "/") +
                    a
                )),
              b.push(c)),
          1
        );
      h = 0;
      d = "" === d ? "." : d + ":";
      if (I(a))
        for (var g = 0; g < a.length; g++) {
          k = a[g];
          var f = d + Q(k, g);
          h += R(k, b, e, f, c);
        }
      else if (((f = A(a)), "function" === typeof f))
        for (a = f.call(a), g = 0; !(k = a.next()).done; )
          (k = k.value), (f = d + Q(k, g++)), (h += R(k, b, e, f, c));
      else if ("object" === k)
        throw (
          ((b = String(a)),
          Error(
            "Objects are not valid as a React child (found: " +
              ("[object Object]" === b
                ? "object with keys {" + Object.keys(a).join(", ") + "}"
                : b) +
              "). If you meant to render a collection of children, use an array instead."
          ))
        );
      return h;
    }
    function S(a, b, e) {
      if (null == a) return a;
      var d = [],
        c = 0;
      R(a, d, "", "", function (a2) {
        return b.call(e, a2, c++);
      });
      return d;
    }
    function T(a) {
      if (-1 === a._status) {
        var b = a._result;
        b = b();
        b.then(
          function (b2) {
            if (0 === a._status || -1 === a._status)
              (a._status = 1), (a._result = b2);
          },
          function (b2) {
            if (0 === a._status || -1 === a._status)
              (a._status = 2), (a._result = b2);
          }
        );
        -1 === a._status && ((a._status = 0), (a._result = b));
      }
      if (1 === a._status) return a._result.default;
      throw a._result;
    }
    var U = { current: null };
    var V = { transition: null };
    var W = {
      ReactCurrentDispatcher: U,
      ReactCurrentBatchConfig: V,
      ReactCurrentOwner: K,
    };
    exports.Children = {
      map: S,
      forEach: function (a, b, e) {
        S(
          a,
          function () {
            b.apply(this, arguments);
          },
          e
        );
      },
      count: function (a) {
        var b = 0;
        S(a, function () {
          b++;
        });
        return b;
      },
      toArray: function (a) {
        return (
          S(a, function (a2) {
            return a2;
          }) || []
        );
      },
      only: function (a) {
        if (!O(a))
          throw Error(
            "React.Children.only expected to receive a single React element child."
          );
        return a;
      },
    };
    exports.Component = E;
    exports.Fragment = p;
    exports.Profiler = r;
    exports.PureComponent = G;
    exports.StrictMode = q;
    exports.Suspense = w;
    exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W;
    exports.cloneElement = function (a, b, e) {
      if (null === a || void 0 === a)
        throw Error(
          "React.cloneElement(...): The argument must be a React element, but you passed " +
            a +
            "."
        );
      var d = C({}, a.props),
        c = a.key,
        k = a.ref,
        h = a._owner;
      if (null != b) {
        void 0 !== b.ref && ((k = b.ref), (h = K.current));
        void 0 !== b.key && (c = "" + b.key);
        if (a.type && a.type.defaultProps) var g = a.type.defaultProps;
        for (f in b)
          J.call(b, f) &&
            !L.hasOwnProperty(f) &&
            (d[f] = void 0 === b[f] && void 0 !== g ? g[f] : b[f]);
      }
      var f = arguments.length - 2;
      if (1 === f) d.children = e;
      else if (1 < f) {
        g = Array(f);
        for (var m = 0; m < f; m++) g[m] = arguments[m + 2];
        d.children = g;
      }
      return { $$typeof: l, type: a.type, key: c, ref: k, props: d, _owner: h };
    };
    exports.createContext = function (a) {
      a = {
        $$typeof: u,
        _currentValue: a,
        _currentValue2: a,
        _threadCount: 0,
        Provider: null,
        Consumer: null,
        _defaultValue: null,
        _globalName: null,
      };
      a.Provider = { $$typeof: t, _context: a };
      return (a.Consumer = a);
    };
    exports.createElement = M;
    exports.createFactory = function (a) {
      var b = M.bind(null, a);
      b.type = a;
      return b;
    };
    exports.createRef = function () {
      return { current: null };
    };
    exports.forwardRef = function (a) {
      return { $$typeof: v, render: a };
    };
    exports.isValidElement = O;
    exports.lazy = function (a) {
      return { $$typeof: y, _payload: { _status: -1, _result: a }, _init: T };
    };
    exports.memo = function (a, b) {
      return { $$typeof: x, type: a, compare: void 0 === b ? null : b };
    };
    exports.startTransition = function (a) {
      var b = V.transition;
      V.transition = {};
      try {
        a();
      } finally {
        V.transition = b;
      }
    };
    exports.unstable_act = function () {
      throw Error("act(...) is not supported in production builds of React.");
    };
    exports.useCallback = function (a, b) {
      return U.current.useCallback(a, b);
    };
    exports.useContext = function (a) {
      return U.current.useContext(a);
    };
    exports.useDebugValue = function () {};
    exports.useDeferredValue = function (a) {
      return U.current.useDeferredValue(a);
    };
    exports.useEffect = function (a, b) {
      return U.current.useEffect(a, b);
    };
    exports.useId = function () {
      return U.current.useId();
    };
    exports.useImperativeHandle = function (a, b, e) {
      return U.current.useImperativeHandle(a, b, e);
    };
    exports.useInsertionEffect = function (a, b) {
      return U.current.useInsertionEffect(a, b);
    };
    exports.useLayoutEffect = function (a, b) {
      return U.current.useLayoutEffect(a, b);
    };
    exports.useMemo = function (a, b) {
      return U.current.useMemo(a, b);
    };
    exports.useReducer = function (a, b, e) {
      return U.current.useReducer(a, b, e);
    };
    exports.useRef = function (a) {
      return U.current.useRef(a);
    };
    exports.useState = function (a) {
      return U.current.useState(a);
    };
    exports.useSyncExternalStore = function (a, b, e) {
      return U.current.useSyncExternalStore(a, b, e);
    };
    exports.useTransition = function () {
      return U.current.useTransition();
    };
    exports.version = "18.2.0";
  },
});

// node_modules/react/index.js
var require_react = __commonJS({
  "node_modules/react/index.js"(exports, module) {
    {
      module.exports = require_react_production_min();
    }
  },
});

// node_modules/react/cjs/react-jsx-runtime.production.min.js
var require_react_jsx_runtime_production_min = __commonJS({
  "node_modules/react/cjs/react-jsx-runtime.production.min.js"(exports) {
    var f = require_react();
    var k = Symbol.for("react.element");
    var l = Symbol.for("react.fragment");
    var m = Object.prototype.hasOwnProperty;
    var n =
      f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner;
    var p = { key: true, ref: true, __self: true, __source: true };
    function q(c, a, g) {
      var b,
        d = {},
        e = null,
        h = null;
      void 0 !== g && (e = "" + g);
      void 0 !== a.key && (e = "" + a.key);
      void 0 !== a.ref && (h = a.ref);
      for (b in a) m.call(a, b) && !p.hasOwnProperty(b) && (d[b] = a[b]);
      if (c && c.defaultProps)
        for (b in ((a = c.defaultProps), a)) void 0 === d[b] && (d[b] = a[b]);
      return {
        $$typeof: k,
        type: c,
        key: e,
        ref: h,
        props: d,
        _owner: n.current,
      };
    }
    exports.Fragment = l;
    exports.jsx = q;
    exports.jsxs = q;
  },
});

// node_modules/react/jsx-runtime.js
var require_jsx_runtime = __commonJS({
  "node_modules/react/jsx-runtime.js"(exports, module) {
    {
      module.exports = require_react_jsx_runtime_production_min();
    }
  },
});

// node_modules/scheduler/cjs/scheduler.production.min.js
var require_scheduler_production_min = __commonJS({
  "node_modules/scheduler/cjs/scheduler.production.min.js"(exports) {
    function f(a, b) {
      var c = a.length;
      a.push(b);
      a: for (; 0 < c; ) {
        var d = (c - 1) >>> 1,
          e = a[d];
        if (0 < g(e, b)) (a[d] = b), (a[c] = e), (c = d);
        else break a;
      }
    }
    function h(a) {
      return 0 === a.length ? null : a[0];
    }
    function k(a) {
      if (0 === a.length) return null;
      var b = a[0],
        c = a.pop();
      if (c !== b) {
        a[0] = c;
        a: for (var d = 0, e = a.length, w = e >>> 1; d < w; ) {
          var m = 2 * (d + 1) - 1,
            C = a[m],
            n = m + 1,
            x = a[n];
          if (0 > g(C, c))
            n < e && 0 > g(x, C)
              ? ((a[d] = x), (a[n] = c), (d = n))
              : ((a[d] = C), (a[m] = c), (d = m));
          else if (n < e && 0 > g(x, c)) (a[d] = x), (a[n] = c), (d = n);
          else break a;
        }
      }
      return b;
    }
    function g(a, b) {
      var c = a.sortIndex - b.sortIndex;
      return 0 !== c ? c : a.id - b.id;
    }
    if (
      "object" === typeof performance &&
      "function" === typeof performance.now
    ) {
      l = performance;
      exports.unstable_now = function () {
        return l.now();
      };
    } else {
      (p = Date), (q = p.now());
      exports.unstable_now = function () {
        return p.now() - q;
      };
    }
    var l;
    var p;
    var q;
    var r = [];
    var t = [];
    var u = 1;
    var v = null;
    var y = 3;
    var z = false;
    var A = false;
    var B = false;
    var D = "function" === typeof setTimeout ? setTimeout : null;
    var E = "function" === typeof clearTimeout ? clearTimeout : null;
    var F = "undefined" !== typeof setImmediate ? setImmediate : null;
    "undefined" !== typeof navigator &&
      void 0 !== navigator.scheduling &&
      void 0 !== navigator.scheduling.isInputPending &&
      navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function G(a) {
      for (var b = h(t); null !== b; ) {
        if (null === b.callback) k(t);
        else if (b.startTime <= a)
          k(t), (b.sortIndex = b.expirationTime), f(r, b);
        else break;
        b = h(t);
      }
    }
    function H(a) {
      B = false;
      G(a);
      if (!A)
        if (null !== h(r)) (A = true), I(J);
        else {
          var b = h(t);
          null !== b && K(H, b.startTime - a);
        }
    }
    function J(a, b) {
      A = false;
      B && ((B = false), E(L), (L = -1));
      z = true;
      var c = y;
      try {
        G(b);
        for (
          v = h(r);
          null !== v && (!(v.expirationTime > b) || (a && !M()));

        ) {
          var d = v.callback;
          if ("function" === typeof d) {
            v.callback = null;
            y = v.priorityLevel;
            var e = d(v.expirationTime <= b);
            b = exports.unstable_now();
            "function" === typeof e ? (v.callback = e) : v === h(r) && k(r);
            G(b);
          } else k(r);
          v = h(r);
        }
        if (null !== v) var w = true;
        else {
          var m = h(t);
          null !== m && K(H, m.startTime - b);
          w = false;
        }
        return w;
      } finally {
        (v = null), (y = c), (z = false);
      }
    }
    var N = false;
    var O = null;
    var L = -1;
    var P = 5;
    var Q = -1;
    function M() {
      return exports.unstable_now() - Q < P ? false : true;
    }
    function R() {
      if (null !== O) {
        var a = exports.unstable_now();
        Q = a;
        var b = true;
        try {
          b = O(true, a);
        } finally {
          b ? S() : ((N = false), (O = null));
        }
      } else N = false;
    }
    var S;
    if ("function" === typeof F)
      S = function () {
        F(R);
      };
    else if ("undefined" !== typeof MessageChannel) {
      (T = new MessageChannel()), (U = T.port2);
      T.port1.onmessage = R;
      S = function () {
        U.postMessage(null);
      };
    } else
      S = function () {
        D(R, 0);
      };
    var T;
    var U;
    function I(a) {
      O = a;
      N || ((N = true), S());
    }
    function K(a, b) {
      L = D(function () {
        a(exports.unstable_now());
      }, b);
    }
    exports.unstable_IdlePriority = 5;
    exports.unstable_ImmediatePriority = 1;
    exports.unstable_LowPriority = 4;
    exports.unstable_NormalPriority = 3;
    exports.unstable_Profiling = null;
    exports.unstable_UserBlockingPriority = 2;
    exports.unstable_cancelCallback = function (a) {
      a.callback = null;
    };
    exports.unstable_continueExecution = function () {
      A || z || ((A = true), I(J));
    };
    exports.unstable_forceFrameRate = function (a) {
      0 > a || 125 < a
        ? console.error(
            "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
          )
        : (P = 0 < a ? Math.floor(1e3 / a) : 5);
    };
    exports.unstable_getCurrentPriorityLevel = function () {
      return y;
    };
    exports.unstable_getFirstCallbackNode = function () {
      return h(r);
    };
    exports.unstable_next = function (a) {
      switch (y) {
        case 1:
        case 2:
        case 3:
          var b = 3;
          break;
        default:
          b = y;
      }
      var c = y;
      y = b;
      try {
        return a();
      } finally {
        y = c;
      }
    };
    exports.unstable_pauseExecution = function () {};
    exports.unstable_requestPaint = function () {};
    exports.unstable_runWithPriority = function (a, b) {
      switch (a) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          a = 3;
      }
      var c = y;
      y = a;
      try {
        return b();
      } finally {
        y = c;
      }
    };
    exports.unstable_scheduleCallback = function (a, b, c) {
      var d = exports.unstable_now();
      "object" === typeof c && null !== c
        ? ((c = c.delay), (c = "number" === typeof c && 0 < c ? d + c : d))
        : (c = d);
      switch (a) {
        case 1:
          var e = -1;
          break;
        case 2:
          e = 250;
          break;
        case 5:
          e = 1073741823;
          break;
        case 4:
          e = 1e4;
          break;
        default:
          e = 5e3;
      }
      e = c + e;
      a = {
        id: u++,
        callback: b,
        priorityLevel: a,
        startTime: c,
        expirationTime: e,
        sortIndex: -1,
      };
      c > d
        ? ((a.sortIndex = c),
          f(t, a),
          null === h(r) &&
            a === h(t) &&
            (B ? (E(L), (L = -1)) : (B = true), K(H, c - d)))
        : ((a.sortIndex = e), f(r, a), A || z || ((A = true), I(J)));
      return a;
    };
    exports.unstable_shouldYield = M;
    exports.unstable_wrapCallback = function (a) {
      var b = y;
      return function () {
        var c = y;
        y = b;
        try {
          return a.apply(this, arguments);
        } finally {
          y = c;
        }
      };
    };
  },
});

// node_modules/scheduler/index.js
var require_scheduler = __commonJS({
  "node_modules/scheduler/index.js"(exports, module) {
    {
      module.exports = require_scheduler_production_min();
    }
  },
});

// node_modules/react-dom/cjs/react-dom.production.min.js
var require_react_dom_production_min = __commonJS({
  "node_modules/react-dom/cjs/react-dom.production.min.js"(exports) {
    var aa = require_react();
    var ca = require_scheduler();
    function p(a) {
      for (
        var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a,
          c = 1;
        c < arguments.length;
        c++
      )
        b += "&args[]=" + encodeURIComponent(arguments[c]);
      return (
        "Minified React error #" +
        a +
        "; visit " +
        b +
        " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
      );
    }
    var da = /* @__PURE__ */ new Set();
    var ea = {};
    function fa(a, b) {
      ha(a, b);
      ha(a + "Capture", b);
    }
    function ha(a, b) {
      ea[a] = b;
      for (a = 0; a < b.length; a++) da.add(b[a]);
    }
    var ia = !(
      "undefined" === typeof window ||
      "undefined" === typeof window.document ||
      "undefined" === typeof window.document.createElement
    );
    var ja = Object.prototype.hasOwnProperty;
    var ka =
      /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/;
    var la = {};
    var ma = {};
    function oa(a) {
      if (ja.call(ma, a)) return true;
      if (ja.call(la, a)) return false;
      if (ka.test(a)) return (ma[a] = true);
      la[a] = true;
      return false;
    }
    function pa(a, b, c, d) {
      if (null !== c && 0 === c.type) return false;
      switch (typeof b) {
        case "function":
        case "symbol":
          return true;
        case "boolean":
          if (d) return false;
          if (null !== c) return !c.acceptsBooleans;
          a = a.toLowerCase().slice(0, 5);
          return "data-" !== a && "aria-" !== a;
        default:
          return false;
      }
    }
    function qa(a, b, c, d) {
      if (null === b || "undefined" === typeof b || pa(a, b, c, d)) return true;
      if (d) return false;
      if (null !== c)
        switch (c.type) {
          case 3:
            return !b;
          case 4:
            return false === b;
          case 5:
            return isNaN(b);
          case 6:
            return isNaN(b) || 1 > b;
        }
      return false;
    }
    function v(a, b, c, d, e, f, g) {
      this.acceptsBooleans = 2 === b || 3 === b || 4 === b;
      this.attributeName = d;
      this.attributeNamespace = e;
      this.mustUseProperty = c;
      this.propertyName = a;
      this.type = b;
      this.sanitizeURL = f;
      this.removeEmptyString = g;
    }
    var z = {};
    "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style"
      .split(" ")
      .forEach(function (a) {
        z[a] = new v(a, 0, false, a, null, false, false);
      });
    [
      ["acceptCharset", "accept-charset"],
      ["className", "class"],
      ["htmlFor", "for"],
      ["httpEquiv", "http-equiv"],
    ].forEach(function (a) {
      var b = a[0];
      z[b] = new v(b, 1, false, a[1], null, false, false);
    });
    ["contentEditable", "draggable", "spellCheck", "value"].forEach(function (
      a
    ) {
      z[a] = new v(a, 2, false, a.toLowerCase(), null, false, false);
    });
    [
      "autoReverse",
      "externalResourcesRequired",
      "focusable",
      "preserveAlpha",
    ].forEach(function (a) {
      z[a] = new v(a, 2, false, a, null, false, false);
    });
    "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope"
      .split(" ")
      .forEach(function (a) {
        z[a] = new v(a, 3, false, a.toLowerCase(), null, false, false);
      });
    ["checked", "multiple", "muted", "selected"].forEach(function (a) {
      z[a] = new v(a, 3, true, a, null, false, false);
    });
    ["capture", "download"].forEach(function (a) {
      z[a] = new v(a, 4, false, a, null, false, false);
    });
    ["cols", "rows", "size", "span"].forEach(function (a) {
      z[a] = new v(a, 6, false, a, null, false, false);
    });
    ["rowSpan", "start"].forEach(function (a) {
      z[a] = new v(a, 5, false, a.toLowerCase(), null, false, false);
    });
    var ra = /[\-:]([a-z])/g;
    function sa(a) {
      return a[1].toUpperCase();
    }
    "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height"
      .split(" ")
      .forEach(function (a) {
        var b = a.replace(ra, sa);
        z[b] = new v(b, 1, false, a, null, false, false);
      });
    "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type"
      .split(" ")
      .forEach(function (a) {
        var b = a.replace(ra, sa);
        z[b] = new v(
          b,
          1,
          false,
          a,
          "http://www.w3.org/1999/xlink",
          false,
          false
        );
      });
    ["xml:base", "xml:lang", "xml:space"].forEach(function (a) {
      var b = a.replace(ra, sa);
      z[b] = new v(
        b,
        1,
        false,
        a,
        "http://www.w3.org/XML/1998/namespace",
        false,
        false
      );
    });
    ["tabIndex", "crossOrigin"].forEach(function (a) {
      z[a] = new v(a, 1, false, a.toLowerCase(), null, false, false);
    });
    z.xlinkHref = new v(
      "xlinkHref",
      1,
      false,
      "xlink:href",
      "http://www.w3.org/1999/xlink",
      true,
      false
    );
    ["src", "href", "action", "formAction"].forEach(function (a) {
      z[a] = new v(a, 1, false, a.toLowerCase(), null, true, true);
    });
    function ta(a, b, c, d) {
      var e = z.hasOwnProperty(b) ? z[b] : null;
      if (
        null !== e
          ? 0 !== e.type
          : d ||
            !(2 < b.length) ||
            ("o" !== b[0] && "O" !== b[0]) ||
            ("n" !== b[1] && "N" !== b[1])
      )
        qa(b, c, e, d) && (c = null),
          d || null === e
            ? oa(b) &&
              (null === c ? a.removeAttribute(b) : a.setAttribute(b, "" + c))
            : e.mustUseProperty
            ? (a[e.propertyName] = null === c ? (3 === e.type ? false : "") : c)
            : ((b = e.attributeName),
              (d = e.attributeNamespace),
              null === c
                ? a.removeAttribute(b)
                : ((e = e.type),
                  (c = 3 === e || (4 === e && true === c) ? "" : "" + c),
                  d ? a.setAttributeNS(d, b, c) : a.setAttribute(b, c)));
    }
    var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    var va = Symbol.for("react.element");
    var wa = Symbol.for("react.portal");
    var ya = Symbol.for("react.fragment");
    var za = Symbol.for("react.strict_mode");
    var Aa = Symbol.for("react.profiler");
    var Ba = Symbol.for("react.provider");
    var Ca = Symbol.for("react.context");
    var Da = Symbol.for("react.forward_ref");
    var Ea = Symbol.for("react.suspense");
    var Fa = Symbol.for("react.suspense_list");
    var Ga = Symbol.for("react.memo");
    var Ha = Symbol.for("react.lazy");
    var Ia = Symbol.for("react.offscreen");
    var Ja = Symbol.iterator;
    function Ka(a) {
      if (null === a || "object" !== typeof a) return null;
      a = (Ja && a[Ja]) || a["@@iterator"];
      return "function" === typeof a ? a : null;
    }
    var A = Object.assign;
    var La;
    function Ma(a) {
      if (void 0 === La)
        try {
          throw Error();
        } catch (c) {
          var b = c.stack.trim().match(/\n( *(at )?)/);
          La = (b && b[1]) || "";
        }
      return "\n" + La + a;
    }
    var Na = false;
    function Oa(a, b) {
      if (!a || Na) return "";
      Na = true;
      var c = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      try {
        if (b)
          if (
            ((b = function () {
              throw Error();
            }),
            Object.defineProperty(b.prototype, "props", {
              set: function () {
                throw Error();
              },
            }),
            "object" === typeof Reflect && Reflect.construct)
          ) {
            try {
              Reflect.construct(b, []);
            } catch (l) {
              var d = l;
            }
            Reflect.construct(a, [], b);
          } else {
            try {
              b.call();
            } catch (l) {
              d = l;
            }
            a.call(b.prototype);
          }
        else {
          try {
            throw Error();
          } catch (l) {
            d = l;
          }
          a();
        }
      } catch (l) {
        if (l && d && "string" === typeof l.stack) {
          for (
            var e = l.stack.split("\n"),
              f = d.stack.split("\n"),
              g = e.length - 1,
              h = f.length - 1;
            1 <= g && 0 <= h && e[g] !== f[h];

          )
            h--;
          for (; 1 <= g && 0 <= h; g--, h--)
            if (e[g] !== f[h]) {
              if (1 !== g || 1 !== h) {
                do
                  if ((g--, h--, 0 > h || e[g] !== f[h])) {
                    var k = "\n" + e[g].replace(" at new ", " at ");
                    a.displayName &&
                      k.includes("<anonymous>") &&
                      (k = k.replace("<anonymous>", a.displayName));
                    return k;
                  }
                while (1 <= g && 0 <= h);
              }
              break;
            }
        }
      } finally {
        (Na = false), (Error.prepareStackTrace = c);
      }
      return (a = a ? a.displayName || a.name : "") ? Ma(a) : "";
    }
    function Pa(a) {
      switch (a.tag) {
        case 5:
          return Ma(a.type);
        case 16:
          return Ma("Lazy");
        case 13:
          return Ma("Suspense");
        case 19:
          return Ma("SuspenseList");
        case 0:
        case 2:
        case 15:
          return (a = Oa(a.type, false)), a;
        case 11:
          return (a = Oa(a.type.render, false)), a;
        case 1:
          return (a = Oa(a.type, true)), a;
        default:
          return "";
      }
    }
    function Qa(a) {
      if (null == a) return null;
      if ("function" === typeof a) return a.displayName || a.name || null;
      if ("string" === typeof a) return a;
      switch (a) {
        case ya:
          return "Fragment";
        case wa:
          return "Portal";
        case Aa:
          return "Profiler";
        case za:
          return "StrictMode";
        case Ea:
          return "Suspense";
        case Fa:
          return "SuspenseList";
      }
      if ("object" === typeof a)
        switch (a.$$typeof) {
          case Ca:
            return (a.displayName || "Context") + ".Consumer";
          case Ba:
            return (a._context.displayName || "Context") + ".Provider";
          case Da:
            var b = a.render;
            a = a.displayName;
            a ||
              ((a = b.displayName || b.name || ""),
              (a = "" !== a ? "ForwardRef(" + a + ")" : "ForwardRef"));
            return a;
          case Ga:
            return (
              (b = a.displayName || null), null !== b ? b : Qa(a.type) || "Memo"
            );
          case Ha:
            b = a._payload;
            a = a._init;
            try {
              return Qa(a(b));
            } catch (c) {}
        }
      return null;
    }
    function Ra(a) {
      var b = a.type;
      switch (a.tag) {
        case 24:
          return "Cache";
        case 9:
          return (b.displayName || "Context") + ".Consumer";
        case 10:
          return (b._context.displayName || "Context") + ".Provider";
        case 18:
          return "DehydratedFragment";
        case 11:
          return (
            (a = b.render),
            (a = a.displayName || a.name || ""),
            b.displayName || ("" !== a ? "ForwardRef(" + a + ")" : "ForwardRef")
          );
        case 7:
          return "Fragment";
        case 5:
          return b;
        case 4:
          return "Portal";
        case 3:
          return "Root";
        case 6:
          return "Text";
        case 16:
          return Qa(b);
        case 8:
          return b === za ? "StrictMode" : "Mode";
        case 22:
          return "Offscreen";
        case 12:
          return "Profiler";
        case 21:
          return "Scope";
        case 13:
          return "Suspense";
        case 19:
          return "SuspenseList";
        case 25:
          return "TracingMarker";
        case 1:
        case 0:
        case 17:
        case 2:
        case 14:
        case 15:
          if ("function" === typeof b) return b.displayName || b.name || null;
          if ("string" === typeof b) return b;
      }
      return null;
    }
    function Sa(a) {
      switch (typeof a) {
        case "boolean":
        case "number":
        case "string":
        case "undefined":
          return a;
        case "object":
          return a;
        default:
          return "";
      }
    }
    function Ta(a) {
      var b = a.type;
      return (
        (a = a.nodeName) &&
        "input" === a.toLowerCase() &&
        ("checkbox" === b || "radio" === b)
      );
    }
    function Ua(a) {
      var b = Ta(a) ? "checked" : "value",
        c = Object.getOwnPropertyDescriptor(a.constructor.prototype, b),
        d = "" + a[b];
      if (
        !a.hasOwnProperty(b) &&
        "undefined" !== typeof c &&
        "function" === typeof c.get &&
        "function" === typeof c.set
      ) {
        var e = c.get,
          f = c.set;
        Object.defineProperty(a, b, {
          configurable: true,
          get: function () {
            return e.call(this);
          },
          set: function (a2) {
            d = "" + a2;
            f.call(this, a2);
          },
        });
        Object.defineProperty(a, b, { enumerable: c.enumerable });
        return {
          getValue: function () {
            return d;
          },
          setValue: function (a2) {
            d = "" + a2;
          },
          stopTracking: function () {
            a._valueTracker = null;
            delete a[b];
          },
        };
      }
    }
    function Va(a) {
      a._valueTracker || (a._valueTracker = Ua(a));
    }
    function Wa(a) {
      if (!a) return false;
      var b = a._valueTracker;
      if (!b) return true;
      var c = b.getValue();
      var d = "";
      a && (d = Ta(a) ? (a.checked ? "true" : "false") : a.value);
      a = d;
      return a !== c ? (b.setValue(a), true) : false;
    }
    function Xa(a) {
      a = a || ("undefined" !== typeof document ? document : void 0);
      if ("undefined" === typeof a) return null;
      try {
        return a.activeElement || a.body;
      } catch (b) {
        return a.body;
      }
    }
    function Ya(a, b) {
      var c = b.checked;
      return A({}, b, {
        defaultChecked: void 0,
        defaultValue: void 0,
        value: void 0,
        checked: null != c ? c : a._wrapperState.initialChecked,
      });
    }
    function Za(a, b) {
      var c = null == b.defaultValue ? "" : b.defaultValue,
        d = null != b.checked ? b.checked : b.defaultChecked;
      c = Sa(null != b.value ? b.value : c);
      a._wrapperState = {
        initialChecked: d,
        initialValue: c,
        controlled:
          "checkbox" === b.type || "radio" === b.type
            ? null != b.checked
            : null != b.value,
      };
    }
    function ab(a, b) {
      b = b.checked;
      null != b && ta(a, "checked", b, false);
    }
    function bb(a, b) {
      ab(a, b);
      var c = Sa(b.value),
        d = b.type;
      if (null != c)
        if ("number" === d) {
          if ((0 === c && "" === a.value) || a.value != c) a.value = "" + c;
        } else a.value !== "" + c && (a.value = "" + c);
      else if ("submit" === d || "reset" === d) {
        a.removeAttribute("value");
        return;
      }
      b.hasOwnProperty("value")
        ? cb(a, b.type, c)
        : b.hasOwnProperty("defaultValue") && cb(a, b.type, Sa(b.defaultValue));
      null == b.checked &&
        null != b.defaultChecked &&
        (a.defaultChecked = !!b.defaultChecked);
    }
    function db(a, b, c) {
      if (b.hasOwnProperty("value") || b.hasOwnProperty("defaultValue")) {
        var d = b.type;
        if (
          !(
            ("submit" !== d && "reset" !== d) ||
            (void 0 !== b.value && null !== b.value)
          )
        )
          return;
        b = "" + a._wrapperState.initialValue;
        c || b === a.value || (a.value = b);
        a.defaultValue = b;
      }
      c = a.name;
      "" !== c && (a.name = "");
      a.defaultChecked = !!a._wrapperState.initialChecked;
      "" !== c && (a.name = c);
    }
    function cb(a, b, c) {
      if ("number" !== b || Xa(a.ownerDocument) !== a)
        null == c
          ? (a.defaultValue = "" + a._wrapperState.initialValue)
          : a.defaultValue !== "" + c && (a.defaultValue = "" + c);
    }
    var eb = Array.isArray;
    function fb(a, b, c, d) {
      a = a.options;
      if (b) {
        b = {};
        for (var e = 0; e < c.length; e++) b["$" + c[e]] = true;
        for (c = 0; c < a.length; c++)
          (e = b.hasOwnProperty("$" + a[c].value)),
            a[c].selected !== e && (a[c].selected = e),
            e && d && (a[c].defaultSelected = true);
      } else {
        c = "" + Sa(c);
        b = null;
        for (e = 0; e < a.length; e++) {
          if (a[e].value === c) {
            a[e].selected = true;
            d && (a[e].defaultSelected = true);
            return;
          }
          null !== b || a[e].disabled || (b = a[e]);
        }
        null !== b && (b.selected = true);
      }
    }
    function gb(a, b) {
      if (null != b.dangerouslySetInnerHTML) throw Error(p(91));
      return A({}, b, {
        value: void 0,
        defaultValue: void 0,
        children: "" + a._wrapperState.initialValue,
      });
    }
    function hb(a, b) {
      var c = b.value;
      if (null == c) {
        c = b.children;
        b = b.defaultValue;
        if (null != c) {
          if (null != b) throw Error(p(92));
          if (eb(c)) {
            if (1 < c.length) throw Error(p(93));
            c = c[0];
          }
          b = c;
        }
        null == b && (b = "");
        c = b;
      }
      a._wrapperState = { initialValue: Sa(c) };
    }
    function ib(a, b) {
      var c = Sa(b.value),
        d = Sa(b.defaultValue);
      null != c &&
        ((c = "" + c),
        c !== a.value && (a.value = c),
        null == b.defaultValue && a.defaultValue !== c && (a.defaultValue = c));
      null != d && (a.defaultValue = "" + d);
    }
    function jb(a) {
      var b = a.textContent;
      b === a._wrapperState.initialValue &&
        "" !== b &&
        null !== b &&
        (a.value = b);
    }
    function kb(a) {
      switch (a) {
        case "svg":
          return "http://www.w3.org/2000/svg";
        case "math":
          return "http://www.w3.org/1998/Math/MathML";
        default:
          return "http://www.w3.org/1999/xhtml";
      }
    }
    function lb(a, b) {
      return null == a || "http://www.w3.org/1999/xhtml" === a
        ? kb(b)
        : "http://www.w3.org/2000/svg" === a && "foreignObject" === b
        ? "http://www.w3.org/1999/xhtml"
        : a;
    }
    var mb;
    var nb = (function (a) {
      return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction
        ? function (b, c, d, e) {
            MSApp.execUnsafeLocalFunction(function () {
              return a(b, c, d, e);
            });
          }
        : a;
    })(function (a, b) {
      if ("http://www.w3.org/2000/svg" !== a.namespaceURI || "innerHTML" in a)
        a.innerHTML = b;
      else {
        mb = mb || document.createElement("div");
        mb.innerHTML = "<svg>" + b.valueOf().toString() + "</svg>";
        for (b = mb.firstChild; a.firstChild; ) a.removeChild(a.firstChild);
        for (; b.firstChild; ) a.appendChild(b.firstChild);
      }
    });
    function ob(a, b) {
      if (b) {
        var c = a.firstChild;
        if (c && c === a.lastChild && 3 === c.nodeType) {
          c.nodeValue = b;
          return;
        }
      }
      a.textContent = b;
    }
    var pb = {
      animationIterationCount: true,
      aspectRatio: true,
      borderImageOutset: true,
      borderImageSlice: true,
      borderImageWidth: true,
      boxFlex: true,
      boxFlexGroup: true,
      boxOrdinalGroup: true,
      columnCount: true,
      columns: true,
      flex: true,
      flexGrow: true,
      flexPositive: true,
      flexShrink: true,
      flexNegative: true,
      flexOrder: true,
      gridArea: true,
      gridRow: true,
      gridRowEnd: true,
      gridRowSpan: true,
      gridRowStart: true,
      gridColumn: true,
      gridColumnEnd: true,
      gridColumnSpan: true,
      gridColumnStart: true,
      fontWeight: true,
      lineClamp: true,
      lineHeight: true,
      opacity: true,
      order: true,
      orphans: true,
      tabSize: true,
      widows: true,
      zIndex: true,
      zoom: true,
      fillOpacity: true,
      floodOpacity: true,
      stopOpacity: true,
      strokeDasharray: true,
      strokeDashoffset: true,
      strokeMiterlimit: true,
      strokeOpacity: true,
      strokeWidth: true,
    };
    var qb = ["Webkit", "ms", "Moz", "O"];
    Object.keys(pb).forEach(function (a) {
      qb.forEach(function (b) {
        b = b + a.charAt(0).toUpperCase() + a.substring(1);
        pb[b] = pb[a];
      });
    });
    function rb(a, b, c) {
      return null == b || "boolean" === typeof b || "" === b
        ? ""
        : c ||
          "number" !== typeof b ||
          0 === b ||
          (pb.hasOwnProperty(a) && pb[a])
        ? ("" + b).trim()
        : b + "px";
    }
    function sb(a, b) {
      a = a.style;
      for (var c in b)
        if (b.hasOwnProperty(c)) {
          var d = 0 === c.indexOf("--"),
            e = rb(c, b[c], d);
          "float" === c && (c = "cssFloat");
          d ? a.setProperty(c, e) : (a[c] = e);
        }
    }
    var tb = A(
      { menuitem: true },
      {
        area: true,
        base: true,
        br: true,
        col: true,
        embed: true,
        hr: true,
        img: true,
        input: true,
        keygen: true,
        link: true,
        meta: true,
        param: true,
        source: true,
        track: true,
        wbr: true,
      }
    );
    function ub(a, b) {
      if (b) {
        if (tb[a] && (null != b.children || null != b.dangerouslySetInnerHTML))
          throw Error(p(137, a));
        if (null != b.dangerouslySetInnerHTML) {
          if (null != b.children) throw Error(p(60));
          if (
            "object" !== typeof b.dangerouslySetInnerHTML ||
            !("__html" in b.dangerouslySetInnerHTML)
          )
            throw Error(p(61));
        }
        if (null != b.style && "object" !== typeof b.style) throw Error(p(62));
      }
    }
    function vb(a, b) {
      if (-1 === a.indexOf("-")) return "string" === typeof b.is;
      switch (a) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return false;
        default:
          return true;
      }
    }
    var wb = null;
    function xb(a) {
      a = a.target || a.srcElement || window;
      a.correspondingUseElement && (a = a.correspondingUseElement);
      return 3 === a.nodeType ? a.parentNode : a;
    }
    var yb = null;
    var zb = null;
    var Ab = null;
    function Bb(a) {
      if ((a = Cb(a))) {
        if ("function" !== typeof yb) throw Error(p(280));
        var b = a.stateNode;
        b && ((b = Db(b)), yb(a.stateNode, a.type, b));
      }
    }
    function Eb(a) {
      zb ? (Ab ? Ab.push(a) : (Ab = [a])) : (zb = a);
    }
    function Fb() {
      if (zb) {
        var a = zb,
          b = Ab;
        Ab = zb = null;
        Bb(a);
        if (b) for (a = 0; a < b.length; a++) Bb(b[a]);
      }
    }
    function Gb(a, b) {
      return a(b);
    }
    function Hb() {}
    var Ib = false;
    function Jb(a, b, c) {
      if (Ib) return a(b, c);
      Ib = true;
      try {
        return Gb(a, b, c);
      } finally {
        if (((Ib = false), null !== zb || null !== Ab)) Hb(), Fb();
      }
    }
    function Kb(a, b) {
      var c = a.stateNode;
      if (null === c) return null;
      var d = Db(c);
      if (null === d) return null;
      c = d[b];
      a: switch (b) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          (d = !d.disabled) ||
            ((a = a.type),
            (d = !(
              "button" === a ||
              "input" === a ||
              "select" === a ||
              "textarea" === a
            )));
          a = !d;
          break a;
        default:
          a = false;
      }
      if (a) return null;
      if (c && "function" !== typeof c) throw Error(p(231, b, typeof c));
      return c;
    }
    var Lb = false;
    if (ia)
      try {
        Mb = {};
        Object.defineProperty(Mb, "passive", {
          get: function () {
            Lb = true;
          },
        });
        window.addEventListener("test", Mb, Mb);
        window.removeEventListener("test", Mb, Mb);
      } catch (a) {
        Lb = false;
      }
    var Mb;
    function Nb(a, b, c, d, e, f, g, h, k) {
      var l = Array.prototype.slice.call(arguments, 3);
      try {
        b.apply(c, l);
      } catch (m) {
        this.onError(m);
      }
    }
    var Ob = false;
    var Pb = null;
    var Qb = false;
    var Rb = null;
    var Sb = {
      onError: function (a) {
        Ob = true;
        Pb = a;
      },
    };
    function Tb(a, b, c, d, e, f, g, h, k) {
      Ob = false;
      Pb = null;
      Nb.apply(Sb, arguments);
    }
    function Ub(a, b, c, d, e, f, g, h, k) {
      Tb.apply(this, arguments);
      if (Ob) {
        if (Ob) {
          var l = Pb;
          Ob = false;
          Pb = null;
        } else throw Error(p(198));
        Qb || ((Qb = true), (Rb = l));
      }
    }
    function Vb(a) {
      var b = a,
        c = a;
      if (a.alternate) for (; b.return; ) b = b.return;
      else {
        a = b;
        do (b = a), 0 !== (b.flags & 4098) && (c = b.return), (a = b.return);
        while (a);
      }
      return 3 === b.tag ? c : null;
    }
    function Wb(a) {
      if (13 === a.tag) {
        var b = a.memoizedState;
        null === b && ((a = a.alternate), null !== a && (b = a.memoizedState));
        if (null !== b) return b.dehydrated;
      }
      return null;
    }
    function Xb(a) {
      if (Vb(a) !== a) throw Error(p(188));
    }
    function Yb(a) {
      var b = a.alternate;
      if (!b) {
        b = Vb(a);
        if (null === b) throw Error(p(188));
        return b !== a ? null : a;
      }
      for (var c = a, d = b; ; ) {
        var e = c.return;
        if (null === e) break;
        var f = e.alternate;
        if (null === f) {
          d = e.return;
          if (null !== d) {
            c = d;
            continue;
          }
          break;
        }
        if (e.child === f.child) {
          for (f = e.child; f; ) {
            if (f === c) return Xb(e), a;
            if (f === d) return Xb(e), b;
            f = f.sibling;
          }
          throw Error(p(188));
        }
        if (c.return !== d.return) (c = e), (d = f);
        else {
          for (var g = false, h = e.child; h; ) {
            if (h === c) {
              g = true;
              c = e;
              d = f;
              break;
            }
            if (h === d) {
              g = true;
              d = e;
              c = f;
              break;
            }
            h = h.sibling;
          }
          if (!g) {
            for (h = f.child; h; ) {
              if (h === c) {
                g = true;
                c = f;
                d = e;
                break;
              }
              if (h === d) {
                g = true;
                d = f;
                c = e;
                break;
              }
              h = h.sibling;
            }
            if (!g) throw Error(p(189));
          }
        }
        if (c.alternate !== d) throw Error(p(190));
      }
      if (3 !== c.tag) throw Error(p(188));
      return c.stateNode.current === c ? a : b;
    }
    function Zb(a) {
      a = Yb(a);
      return null !== a ? $b(a) : null;
    }
    function $b(a) {
      if (5 === a.tag || 6 === a.tag) return a;
      for (a = a.child; null !== a; ) {
        var b = $b(a);
        if (null !== b) return b;
        a = a.sibling;
      }
      return null;
    }
    var ac = ca.unstable_scheduleCallback;
    var bc = ca.unstable_cancelCallback;
    var cc = ca.unstable_shouldYield;
    var dc = ca.unstable_requestPaint;
    var B = ca.unstable_now;
    var ec = ca.unstable_getCurrentPriorityLevel;
    var fc = ca.unstable_ImmediatePriority;
    var gc = ca.unstable_UserBlockingPriority;
    var hc = ca.unstable_NormalPriority;
    var ic = ca.unstable_LowPriority;
    var jc = ca.unstable_IdlePriority;
    var kc = null;
    var lc = null;
    function mc(a) {
      if (lc && "function" === typeof lc.onCommitFiberRoot)
        try {
          lc.onCommitFiberRoot(kc, a, void 0, 128 === (a.current.flags & 128));
        } catch (b) {}
    }
    var oc = Math.clz32 ? Math.clz32 : nc;
    var pc = Math.log;
    var qc = Math.LN2;
    function nc(a) {
      a >>>= 0;
      return 0 === a ? 32 : (31 - ((pc(a) / qc) | 0)) | 0;
    }
    var rc = 64;
    var sc = 4194304;
    function tc(a) {
      switch (a & -a) {
        case 1:
          return 1;
        case 2:
          return 2;
        case 4:
          return 4;
        case 8:
          return 8;
        case 16:
          return 16;
        case 32:
          return 32;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return a & 4194240;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          return a & 130023424;
        case 134217728:
          return 134217728;
        case 268435456:
          return 268435456;
        case 536870912:
          return 536870912;
        case 1073741824:
          return 1073741824;
        default:
          return a;
      }
    }
    function uc(a, b) {
      var c = a.pendingLanes;
      if (0 === c) return 0;
      var d = 0,
        e = a.suspendedLanes,
        f = a.pingedLanes,
        g = c & 268435455;
      if (0 !== g) {
        var h = g & ~e;
        0 !== h ? (d = tc(h)) : ((f &= g), 0 !== f && (d = tc(f)));
      } else (g = c & ~e), 0 !== g ? (d = tc(g)) : 0 !== f && (d = tc(f));
      if (0 === d) return 0;
      if (
        0 !== b &&
        b !== d &&
        0 === (b & e) &&
        ((e = d & -d),
        (f = b & -b),
        e >= f || (16 === e && 0 !== (f & 4194240)))
      )
        return b;
      0 !== (d & 4) && (d |= c & 16);
      b = a.entangledLanes;
      if (0 !== b)
        for (a = a.entanglements, b &= d; 0 < b; )
          (c = 31 - oc(b)), (e = 1 << c), (d |= a[c]), (b &= ~e);
      return d;
    }
    function vc(a, b) {
      switch (a) {
        case 1:
        case 2:
        case 4:
          return b + 250;
        case 8:
        case 16:
        case 32:
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return b + 5e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          return -1;
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
          return -1;
        default:
          return -1;
      }
    }
    function wc(a, b) {
      for (
        var c = a.suspendedLanes,
          d = a.pingedLanes,
          e = a.expirationTimes,
          f = a.pendingLanes;
        0 < f;

      ) {
        var g = 31 - oc(f),
          h = 1 << g,
          k = e[g];
        if (-1 === k) {
          if (0 === (h & c) || 0 !== (h & d)) e[g] = vc(h, b);
        } else k <= b && (a.expiredLanes |= h);
        f &= ~h;
      }
    }
    function xc(a) {
      a = a.pendingLanes & -1073741825;
      return 0 !== a ? a : a & 1073741824 ? 1073741824 : 0;
    }
    function yc() {
      var a = rc;
      rc <<= 1;
      0 === (rc & 4194240) && (rc = 64);
      return a;
    }
    function zc(a) {
      for (var b = [], c = 0; 31 > c; c++) b.push(a);
      return b;
    }
    function Ac(a, b, c) {
      a.pendingLanes |= b;
      536870912 !== b && ((a.suspendedLanes = 0), (a.pingedLanes = 0));
      a = a.eventTimes;
      b = 31 - oc(b);
      a[b] = c;
    }
    function Bc(a, b) {
      var c = a.pendingLanes & ~b;
      a.pendingLanes = b;
      a.suspendedLanes = 0;
      a.pingedLanes = 0;
      a.expiredLanes &= b;
      a.mutableReadLanes &= b;
      a.entangledLanes &= b;
      b = a.entanglements;
      var d = a.eventTimes;
      for (a = a.expirationTimes; 0 < c; ) {
        var e = 31 - oc(c),
          f = 1 << e;
        b[e] = 0;
        d[e] = -1;
        a[e] = -1;
        c &= ~f;
      }
    }
    function Cc(a, b) {
      var c = (a.entangledLanes |= b);
      for (a = a.entanglements; c; ) {
        var d = 31 - oc(c),
          e = 1 << d;
        (e & b) | (a[d] & b) && (a[d] |= b);
        c &= ~e;
      }
    }
    var C = 0;
    function Dc(a) {
      a &= -a;
      return 1 < a ? (4 < a ? (0 !== (a & 268435455) ? 16 : 536870912) : 4) : 1;
    }
    var Ec;
    var Fc;
    var Gc;
    var Hc;
    var Ic;
    var Jc = false;
    var Kc = [];
    var Lc = null;
    var Mc = null;
    var Nc = null;
    var Oc = /* @__PURE__ */ new Map();
    var Pc = /* @__PURE__ */ new Map();
    var Qc = [];
    var Rc =
      "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(
        " "
      );
    function Sc(a, b) {
      switch (a) {
        case "focusin":
        case "focusout":
          Lc = null;
          break;
        case "dragenter":
        case "dragleave":
          Mc = null;
          break;
        case "mouseover":
        case "mouseout":
          Nc = null;
          break;
        case "pointerover":
        case "pointerout":
          Oc.delete(b.pointerId);
          break;
        case "gotpointercapture":
        case "lostpointercapture":
          Pc.delete(b.pointerId);
      }
    }
    function Tc(a, b, c, d, e, f) {
      if (null === a || a.nativeEvent !== f)
        return (
          (a = {
            blockedOn: b,
            domEventName: c,
            eventSystemFlags: d,
            nativeEvent: f,
            targetContainers: [e],
          }),
          null !== b && ((b = Cb(b)), null !== b && Fc(b)),
          a
        );
      a.eventSystemFlags |= d;
      b = a.targetContainers;
      null !== e && -1 === b.indexOf(e) && b.push(e);
      return a;
    }
    function Uc(a, b, c, d, e) {
      switch (b) {
        case "focusin":
          return (Lc = Tc(Lc, a, b, c, d, e)), true;
        case "dragenter":
          return (Mc = Tc(Mc, a, b, c, d, e)), true;
        case "mouseover":
          return (Nc = Tc(Nc, a, b, c, d, e)), true;
        case "pointerover":
          var f = e.pointerId;
          Oc.set(f, Tc(Oc.get(f) || null, a, b, c, d, e));
          return true;
        case "gotpointercapture":
          return (
            (f = e.pointerId),
            Pc.set(f, Tc(Pc.get(f) || null, a, b, c, d, e)),
            true
          );
      }
      return false;
    }
    function Vc(a) {
      var b = Wc(a.target);
      if (null !== b) {
        var c = Vb(b);
        if (null !== c) {
          if (((b = c.tag), 13 === b)) {
            if (((b = Wb(c)), null !== b)) {
              a.blockedOn = b;
              Ic(a.priority, function () {
                Gc(c);
              });
              return;
            }
          } else if (
            3 === b &&
            c.stateNode.current.memoizedState.isDehydrated
          ) {
            a.blockedOn = 3 === c.tag ? c.stateNode.containerInfo : null;
            return;
          }
        }
      }
      a.blockedOn = null;
    }
    function Xc(a) {
      if (null !== a.blockedOn) return false;
      for (var b = a.targetContainers; 0 < b.length; ) {
        var c = Yc(a.domEventName, a.eventSystemFlags, b[0], a.nativeEvent);
        if (null === c) {
          c = a.nativeEvent;
          var d = new c.constructor(c.type, c);
          wb = d;
          c.target.dispatchEvent(d);
          wb = null;
        } else
          return (b = Cb(c)), null !== b && Fc(b), (a.blockedOn = c), false;
        b.shift();
      }
      return true;
    }
    function Zc(a, b, c) {
      Xc(a) && c.delete(b);
    }
    function $c() {
      Jc = false;
      null !== Lc && Xc(Lc) && (Lc = null);
      null !== Mc && Xc(Mc) && (Mc = null);
      null !== Nc && Xc(Nc) && (Nc = null);
      Oc.forEach(Zc);
      Pc.forEach(Zc);
    }
    function ad(a, b) {
      a.blockedOn === b &&
        ((a.blockedOn = null),
        Jc ||
          ((Jc = true),
          ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
    }
    function bd(a) {
      function b(b2) {
        return ad(b2, a);
      }
      if (0 < Kc.length) {
        ad(Kc[0], a);
        for (var c = 1; c < Kc.length; c++) {
          var d = Kc[c];
          d.blockedOn === a && (d.blockedOn = null);
        }
      }
      null !== Lc && ad(Lc, a);
      null !== Mc && ad(Mc, a);
      null !== Nc && ad(Nc, a);
      Oc.forEach(b);
      Pc.forEach(b);
      for (c = 0; c < Qc.length; c++)
        (d = Qc[c]), d.blockedOn === a && (d.blockedOn = null);
      for (; 0 < Qc.length && ((c = Qc[0]), null === c.blockedOn); )
        Vc(c), null === c.blockedOn && Qc.shift();
    }
    var cd = ua.ReactCurrentBatchConfig;
    var dd = true;
    function ed(a, b, c, d) {
      var e = C,
        f = cd.transition;
      cd.transition = null;
      try {
        (C = 1), fd(a, b, c, d);
      } finally {
        (C = e), (cd.transition = f);
      }
    }
    function gd(a, b, c, d) {
      var e = C,
        f = cd.transition;
      cd.transition = null;
      try {
        (C = 4), fd(a, b, c, d);
      } finally {
        (C = e), (cd.transition = f);
      }
    }
    function fd(a, b, c, d) {
      if (dd) {
        var e = Yc(a, b, c, d);
        if (null === e) hd(a, b, d, id2, c), Sc(a, d);
        else if (Uc(e, a, b, c, d)) d.stopPropagation();
        else if ((Sc(a, d), b & 4 && -1 < Rc.indexOf(a))) {
          for (; null !== e; ) {
            var f = Cb(e);
            null !== f && Ec(f);
            f = Yc(a, b, c, d);
            null === f && hd(a, b, d, id2, c);
            if (f === e) break;
            e = f;
          }
          null !== e && d.stopPropagation();
        } else hd(a, b, d, null, c);
      }
    }
    var id2 = null;
    function Yc(a, b, c, d) {
      id2 = null;
      a = xb(d);
      a = Wc(a);
      if (null !== a)
        if (((b = Vb(a)), null === b)) a = null;
        else if (((c = b.tag), 13 === c)) {
          a = Wb(b);
          if (null !== a) return a;
          a = null;
        } else if (3 === c) {
          if (b.stateNode.current.memoizedState.isDehydrated)
            return 3 === b.tag ? b.stateNode.containerInfo : null;
          a = null;
        } else b !== a && (a = null);
      id2 = a;
      return null;
    }
    function jd(a) {
      switch (a) {
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
          return 1;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "toggle":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
          return 4;
        case "message":
          switch (ec()) {
            case fc:
              return 1;
            case gc:
              return 4;
            case hc:
            case ic:
              return 16;
            case jc:
              return 536870912;
            default:
              return 16;
          }
        default:
          return 16;
      }
    }
    var kd = null;
    var ld = null;
    var md = null;
    function nd() {
      if (md) return md;
      var a,
        b = ld,
        c = b.length,
        d,
        e = "value" in kd ? kd.value : kd.textContent,
        f = e.length;
      for (a = 0; a < c && b[a] === e[a]; a++);
      var g = c - a;
      for (d = 1; d <= g && b[c - d] === e[f - d]; d++);
      return (md = e.slice(a, 1 < d ? 1 - d : void 0));
    }
    function od(a) {
      var b = a.keyCode;
      "charCode" in a
        ? ((a = a.charCode), 0 === a && 13 === b && (a = 13))
        : (a = b);
      10 === a && (a = 13);
      return 32 <= a || 13 === a ? a : 0;
    }
    function pd() {
      return true;
    }
    function qd() {
      return false;
    }
    function rd(a) {
      function b(b2, d, e, f, g) {
        this._reactName = b2;
        this._targetInst = e;
        this.type = d;
        this.nativeEvent = f;
        this.target = g;
        this.currentTarget = null;
        for (var c in a)
          a.hasOwnProperty(c) && ((b2 = a[c]), (this[c] = b2 ? b2(f) : f[c]));
        this.isDefaultPrevented = (
          null != f.defaultPrevented
            ? f.defaultPrevented
            : false === f.returnValue
        )
          ? pd
          : qd;
        this.isPropagationStopped = qd;
        return this;
      }
      A(b.prototype, {
        preventDefault: function () {
          this.defaultPrevented = true;
          var a2 = this.nativeEvent;
          a2 &&
            (a2.preventDefault
              ? a2.preventDefault()
              : "unknown" !== typeof a2.returnValue && (a2.returnValue = false),
            (this.isDefaultPrevented = pd));
        },
        stopPropagation: function () {
          var a2 = this.nativeEvent;
          a2 &&
            (a2.stopPropagation
              ? a2.stopPropagation()
              : "unknown" !== typeof a2.cancelBubble &&
                (a2.cancelBubble = true),
            (this.isPropagationStopped = pd));
        },
        persist: function () {},
        isPersistent: pd,
      });
      return b;
    }
    var sd = {
      eventPhase: 0,
      bubbles: 0,
      cancelable: 0,
      timeStamp: function (a) {
        return a.timeStamp || Date.now();
      },
      defaultPrevented: 0,
      isTrusted: 0,
    };
    var td = rd(sd);
    var ud = A({}, sd, { view: 0, detail: 0 });
    var vd = rd(ud);
    var wd;
    var xd;
    var yd;
    var Ad = A({}, ud, {
      screenX: 0,
      screenY: 0,
      clientX: 0,
      clientY: 0,
      pageX: 0,
      pageY: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      getModifierState: zd,
      button: 0,
      buttons: 0,
      relatedTarget: function (a) {
        return void 0 === a.relatedTarget
          ? a.fromElement === a.srcElement
            ? a.toElement
            : a.fromElement
          : a.relatedTarget;
      },
      movementX: function (a) {
        if ("movementX" in a) return a.movementX;
        a !== yd &&
          (yd && "mousemove" === a.type
            ? ((wd = a.screenX - yd.screenX), (xd = a.screenY - yd.screenY))
            : (xd = wd = 0),
          (yd = a));
        return wd;
      },
      movementY: function (a) {
        return "movementY" in a ? a.movementY : xd;
      },
    });
    var Bd = rd(Ad);
    var Cd = A({}, Ad, { dataTransfer: 0 });
    var Dd = rd(Cd);
    var Ed = A({}, ud, { relatedTarget: 0 });
    var Fd = rd(Ed);
    var Gd = A({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 });
    var Hd = rd(Gd);
    var Id = A({}, sd, {
      clipboardData: function (a) {
        return "clipboardData" in a ? a.clipboardData : window.clipboardData;
      },
    });
    var Jd = rd(Id);
    var Kd = A({}, sd, { data: 0 });
    var Ld = rd(Kd);
    var Md = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified",
    };
    var Nd = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta",
    };
    var Od = {
      Alt: "altKey",
      Control: "ctrlKey",
      Meta: "metaKey",
      Shift: "shiftKey",
    };
    function Pd(a) {
      var b = this.nativeEvent;
      return b.getModifierState
        ? b.getModifierState(a)
        : (a = Od[a])
        ? !!b[a]
        : false;
    }
    function zd() {
      return Pd;
    }
    var Qd = A({}, ud, {
      key: function (a) {
        if (a.key) {
          var b = Md[a.key] || a.key;
          if ("Unidentified" !== b) return b;
        }
        return "keypress" === a.type
          ? ((a = od(a)), 13 === a ? "Enter" : String.fromCharCode(a))
          : "keydown" === a.type || "keyup" === a.type
          ? Nd[a.keyCode] || "Unidentified"
          : "";
      },
      code: 0,
      location: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      repeat: 0,
      locale: 0,
      getModifierState: zd,
      charCode: function (a) {
        return "keypress" === a.type ? od(a) : 0;
      },
      keyCode: function (a) {
        return "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
      },
      which: function (a) {
        return "keypress" === a.type
          ? od(a)
          : "keydown" === a.type || "keyup" === a.type
          ? a.keyCode
          : 0;
      },
    });
    var Rd = rd(Qd);
    var Sd = A({}, Ad, {
      pointerId: 0,
      width: 0,
      height: 0,
      pressure: 0,
      tangentialPressure: 0,
      tiltX: 0,
      tiltY: 0,
      twist: 0,
      pointerType: 0,
      isPrimary: 0,
    });
    var Td = rd(Sd);
    var Ud = A({}, ud, {
      touches: 0,
      targetTouches: 0,
      changedTouches: 0,
      altKey: 0,
      metaKey: 0,
      ctrlKey: 0,
      shiftKey: 0,
      getModifierState: zd,
    });
    var Vd = rd(Ud);
    var Wd = A({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 });
    var Xd = rd(Wd);
    var Yd = A({}, Ad, {
      deltaX: function (a) {
        return "deltaX" in a
          ? a.deltaX
          : "wheelDeltaX" in a
          ? -a.wheelDeltaX
          : 0;
      },
      deltaY: function (a) {
        return "deltaY" in a
          ? a.deltaY
          : "wheelDeltaY" in a
          ? -a.wheelDeltaY
          : "wheelDelta" in a
          ? -a.wheelDelta
          : 0;
      },
      deltaZ: 0,
      deltaMode: 0,
    });
    var Zd = rd(Yd);
    var $d = [9, 13, 27, 32];
    var ae = ia && "CompositionEvent" in window;
    var be = null;
    ia && "documentMode" in document && (be = document.documentMode);
    var ce = ia && "TextEvent" in window && !be;
    var de = ia && (!ae || (be && 8 < be && 11 >= be));
    var ee = String.fromCharCode(32);
    var fe = false;
    function ge(a, b) {
      switch (a) {
        case "keyup":
          return -1 !== $d.indexOf(b.keyCode);
        case "keydown":
          return 229 !== b.keyCode;
        case "keypress":
        case "mousedown":
        case "focusout":
          return true;
        default:
          return false;
      }
    }
    function he(a) {
      a = a.detail;
      return "object" === typeof a && "data" in a ? a.data : null;
    }
    var ie = false;
    function je(a, b) {
      switch (a) {
        case "compositionend":
          return he(b);
        case "keypress":
          if (32 !== b.which) return null;
          fe = true;
          return ee;
        case "textInput":
          return (a = b.data), a === ee && fe ? null : a;
        default:
          return null;
      }
    }
    function ke(a, b) {
      if (ie)
        return "compositionend" === a || (!ae && ge(a, b))
          ? ((a = nd()), (md = ld = kd = null), (ie = false), a)
          : null;
      switch (a) {
        case "paste":
          return null;
        case "keypress":
          if (
            !(b.ctrlKey || b.altKey || b.metaKey) ||
            (b.ctrlKey && b.altKey)
          ) {
            if (b.char && 1 < b.char.length) return b.char;
            if (b.which) return String.fromCharCode(b.which);
          }
          return null;
        case "compositionend":
          return de && "ko" !== b.locale ? null : b.data;
        default:
          return null;
      }
    }
    var le = {
      color: true,
      date: true,
      datetime: true,
      "datetime-local": true,
      email: true,
      month: true,
      number: true,
      password: true,
      range: true,
      search: true,
      tel: true,
      text: true,
      time: true,
      url: true,
      week: true,
    };
    function me(a) {
      var b = a && a.nodeName && a.nodeName.toLowerCase();
      return "input" === b ? !!le[a.type] : "textarea" === b ? true : false;
    }
    function ne(a, b, c, d) {
      Eb(d);
      b = oe(b, "onChange");
      0 < b.length &&
        ((c = new td("onChange", "change", null, c, d)),
        a.push({ event: c, listeners: b }));
    }
    var pe = null;
    var qe = null;
    function re(a) {
      se(a, 0);
    }
    function te(a) {
      var b = ue(a);
      if (Wa(b)) return a;
    }
    function ve(a, b) {
      if ("change" === a) return b;
    }
    var we = false;
    if (ia) {
      if (ia) {
        ye = "oninput" in document;
        if (!ye) {
          ze = document.createElement("div");
          ze.setAttribute("oninput", "return;");
          ye = "function" === typeof ze.oninput;
        }
        xe = ye;
      } else xe = false;
      we = xe && (!document.documentMode || 9 < document.documentMode);
    }
    var xe;
    var ye;
    var ze;
    function Ae() {
      pe && (pe.detachEvent("onpropertychange", Be), (qe = pe = null));
    }
    function Be(a) {
      if ("value" === a.propertyName && te(qe)) {
        var b = [];
        ne(b, qe, a, xb(a));
        Jb(re, b);
      }
    }
    function Ce(a, b, c) {
      "focusin" === a
        ? (Ae(), (pe = b), (qe = c), pe.attachEvent("onpropertychange", Be))
        : "focusout" === a && Ae();
    }
    function De(a) {
      if ("selectionchange" === a || "keyup" === a || "keydown" === a)
        return te(qe);
    }
    function Ee(a, b) {
      if ("click" === a) return te(b);
    }
    function Fe(a, b) {
      if ("input" === a || "change" === a) return te(b);
    }
    function Ge(a, b) {
      return (a === b && (0 !== a || 1 / a === 1 / b)) || (a !== a && b !== b);
    }
    var He = "function" === typeof Object.is ? Object.is : Ge;
    function Ie(a, b) {
      if (He(a, b)) return true;
      if (
        "object" !== typeof a ||
        null === a ||
        "object" !== typeof b ||
        null === b
      )
        return false;
      var c = Object.keys(a),
        d = Object.keys(b);
      if (c.length !== d.length) return false;
      for (d = 0; d < c.length; d++) {
        var e = c[d];
        if (!ja.call(b, e) || !He(a[e], b[e])) return false;
      }
      return true;
    }
    function Je(a) {
      for (; a && a.firstChild; ) a = a.firstChild;
      return a;
    }
    function Ke(a, b) {
      var c = Je(a);
      a = 0;
      for (var d; c; ) {
        if (3 === c.nodeType) {
          d = a + c.textContent.length;
          if (a <= b && d >= b) return { node: c, offset: b - a };
          a = d;
        }
        a: {
          for (; c; ) {
            if (c.nextSibling) {
              c = c.nextSibling;
              break a;
            }
            c = c.parentNode;
          }
          c = void 0;
        }
        c = Je(c);
      }
    }
    function Le(a, b) {
      return a && b
        ? a === b
          ? true
          : a && 3 === a.nodeType
          ? false
          : b && 3 === b.nodeType
          ? Le(a, b.parentNode)
          : "contains" in a
          ? a.contains(b)
          : a.compareDocumentPosition
          ? !!(a.compareDocumentPosition(b) & 16)
          : false
        : false;
    }
    function Me() {
      for (var a = window, b = Xa(); b instanceof a.HTMLIFrameElement; ) {
        try {
          var c = "string" === typeof b.contentWindow.location.href;
        } catch (d) {
          c = false;
        }
        if (c) a = b.contentWindow;
        else break;
        b = Xa(a.document);
      }
      return b;
    }
    function Ne(a) {
      var b = a && a.nodeName && a.nodeName.toLowerCase();
      return (
        b &&
        (("input" === b &&
          ("text" === a.type ||
            "search" === a.type ||
            "tel" === a.type ||
            "url" === a.type ||
            "password" === a.type)) ||
          "textarea" === b ||
          "true" === a.contentEditable)
      );
    }
    function Oe(a) {
      var b = Me(),
        c = a.focusedElem,
        d = a.selectionRange;
      if (
        b !== c &&
        c &&
        c.ownerDocument &&
        Le(c.ownerDocument.documentElement, c)
      ) {
        if (null !== d && Ne(c)) {
          if (
            ((b = d.start),
            (a = d.end),
            void 0 === a && (a = b),
            "selectionStart" in c)
          )
            (c.selectionStart = b),
              (c.selectionEnd = Math.min(a, c.value.length));
          else if (
            ((a =
              ((b = c.ownerDocument || document) && b.defaultView) || window),
            a.getSelection)
          ) {
            a = a.getSelection();
            var e = c.textContent.length,
              f = Math.min(d.start, e);
            d = void 0 === d.end ? f : Math.min(d.end, e);
            !a.extend && f > d && ((e = d), (d = f), (f = e));
            e = Ke(c, f);
            var g = Ke(c, d);
            e &&
              g &&
              (1 !== a.rangeCount ||
                a.anchorNode !== e.node ||
                a.anchorOffset !== e.offset ||
                a.focusNode !== g.node ||
                a.focusOffset !== g.offset) &&
              ((b = b.createRange()),
              b.setStart(e.node, e.offset),
              a.removeAllRanges(),
              f > d
                ? (a.addRange(b), a.extend(g.node, g.offset))
                : (b.setEnd(g.node, g.offset), a.addRange(b)));
          }
        }
        b = [];
        for (a = c; (a = a.parentNode); )
          1 === a.nodeType &&
            b.push({ element: a, left: a.scrollLeft, top: a.scrollTop });
        "function" === typeof c.focus && c.focus();
        for (c = 0; c < b.length; c++)
          (a = b[c]),
            (a.element.scrollLeft = a.left),
            (a.element.scrollTop = a.top);
      }
    }
    var Pe = ia && "documentMode" in document && 11 >= document.documentMode;
    var Qe = null;
    var Re = null;
    var Se = null;
    var Te = false;
    function Ue(a, b, c) {
      var d =
        c.window === c ? c.document : 9 === c.nodeType ? c : c.ownerDocument;
      Te ||
        null == Qe ||
        Qe !== Xa(d) ||
        ((d = Qe),
        "selectionStart" in d && Ne(d)
          ? (d = { start: d.selectionStart, end: d.selectionEnd })
          : ((d = (
              (d.ownerDocument && d.ownerDocument.defaultView) ||
              window
            ).getSelection()),
            (d = {
              anchorNode: d.anchorNode,
              anchorOffset: d.anchorOffset,
              focusNode: d.focusNode,
              focusOffset: d.focusOffset,
            })),
        (Se && Ie(Se, d)) ||
          ((Se = d),
          (d = oe(Re, "onSelect")),
          0 < d.length &&
            ((b = new td("onSelect", "select", null, b, c)),
            a.push({ event: b, listeners: d }),
            (b.target = Qe))));
    }
    function Ve(a, b) {
      var c = {};
      c[a.toLowerCase()] = b.toLowerCase();
      c["Webkit" + a] = "webkit" + b;
      c["Moz" + a] = "moz" + b;
      return c;
    }
    var We = {
      animationend: Ve("Animation", "AnimationEnd"),
      animationiteration: Ve("Animation", "AnimationIteration"),
      animationstart: Ve("Animation", "AnimationStart"),
      transitionend: Ve("Transition", "TransitionEnd"),
    };
    var Xe = {};
    var Ye = {};
    ia &&
      ((Ye = document.createElement("div").style),
      "AnimationEvent" in window ||
        (delete We.animationend.animation,
        delete We.animationiteration.animation,
        delete We.animationstart.animation),
      "TransitionEvent" in window || delete We.transitionend.transition);
    function Ze(a) {
      if (Xe[a]) return Xe[a];
      if (!We[a]) return a;
      var b = We[a],
        c;
      for (c in b) if (b.hasOwnProperty(c) && c in Ye) return (Xe[a] = b[c]);
      return a;
    }
    var $e = Ze("animationend");
    var af = Ze("animationiteration");
    var bf = Ze("animationstart");
    var cf = Ze("transitionend");
    var df = /* @__PURE__ */ new Map();
    var ef =
      "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
        " "
      );
    function ff(a, b) {
      df.set(a, b);
      fa(b, [a]);
    }
    for (gf = 0; gf < ef.length; gf++) {
      (hf = ef[gf]),
        (jf = hf.toLowerCase()),
        (kf = hf[0].toUpperCase() + hf.slice(1));
      ff(jf, "on" + kf);
    }
    var hf;
    var jf;
    var kf;
    var gf;
    ff($e, "onAnimationEnd");
    ff(af, "onAnimationIteration");
    ff(bf, "onAnimationStart");
    ff("dblclick", "onDoubleClick");
    ff("focusin", "onFocus");
    ff("focusout", "onBlur");
    ff(cf, "onTransitionEnd");
    ha("onMouseEnter", ["mouseout", "mouseover"]);
    ha("onMouseLeave", ["mouseout", "mouseover"]);
    ha("onPointerEnter", ["pointerout", "pointerover"]);
    ha("onPointerLeave", ["pointerout", "pointerover"]);
    fa(
      "onChange",
      "change click focusin focusout input keydown keyup selectionchange".split(
        " "
      )
    );
    fa(
      "onSelect",
      "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
        " "
      )
    );
    fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
    fa(
      "onCompositionEnd",
      "compositionend focusout keydown keypress keyup mousedown".split(" ")
    );
    fa(
      "onCompositionStart",
      "compositionstart focusout keydown keypress keyup mousedown".split(" ")
    );
    fa(
      "onCompositionUpdate",
      "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
    );
    var lf =
      "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
        " "
      );
    var mf = new Set(
      "cancel close invalid load scroll toggle".split(" ").concat(lf)
    );
    function nf(a, b, c) {
      var d = a.type || "unknown-event";
      a.currentTarget = c;
      Ub(d, b, void 0, a);
      a.currentTarget = null;
    }
    function se(a, b) {
      b = 0 !== (b & 4);
      for (var c = 0; c < a.length; c++) {
        var d = a[c],
          e = d.event;
        d = d.listeners;
        a: {
          var f = void 0;
          if (b)
            for (var g = d.length - 1; 0 <= g; g--) {
              var h = d[g],
                k = h.instance,
                l = h.currentTarget;
              h = h.listener;
              if (k !== f && e.isPropagationStopped()) break a;
              nf(e, h, l);
              f = k;
            }
          else
            for (g = 0; g < d.length; g++) {
              h = d[g];
              k = h.instance;
              l = h.currentTarget;
              h = h.listener;
              if (k !== f && e.isPropagationStopped()) break a;
              nf(e, h, l);
              f = k;
            }
        }
      }
      if (Qb) throw ((a = Rb), (Qb = false), (Rb = null), a);
    }
    function D(a, b) {
      var c = b[of];
      void 0 === c && (c = b[of] = /* @__PURE__ */ new Set());
      var d = a + "__bubble";
      c.has(d) || (pf(b, a, 2, false), c.add(d));
    }
    function qf(a, b, c) {
      var d = 0;
      b && (d |= 4);
      pf(c, a, d, b);
    }
    var rf = "_reactListening" + Math.random().toString(36).slice(2);
    function sf(a) {
      if (!a[rf]) {
        a[rf] = true;
        da.forEach(function (b2) {
          "selectionchange" !== b2 &&
            (mf.has(b2) || qf(b2, false, a), qf(b2, true, a));
        });
        var b = 9 === a.nodeType ? a : a.ownerDocument;
        null === b ||
          b[rf] ||
          ((b[rf] = true), qf("selectionchange", false, b));
      }
    }
    function pf(a, b, c, d) {
      switch (jd(b)) {
        case 1:
          var e = ed;
          break;
        case 4:
          e = gd;
          break;
        default:
          e = fd;
      }
      c = e.bind(null, b, c, a);
      e = void 0;
      !Lb ||
        ("touchstart" !== b && "touchmove" !== b && "wheel" !== b) ||
        (e = true);
      d
        ? void 0 !== e
          ? a.addEventListener(b, c, { capture: true, passive: e })
          : a.addEventListener(b, c, true)
        : void 0 !== e
        ? a.addEventListener(b, c, { passive: e })
        : a.addEventListener(b, c, false);
    }
    function hd(a, b, c, d, e) {
      var f = d;
      if (0 === (b & 1) && 0 === (b & 2) && null !== d)
        a: for (;;) {
          if (null === d) return;
          var g = d.tag;
          if (3 === g || 4 === g) {
            var h = d.stateNode.containerInfo;
            if (h === e || (8 === h.nodeType && h.parentNode === e)) break;
            if (4 === g)
              for (g = d.return; null !== g; ) {
                var k = g.tag;
                if (3 === k || 4 === k) {
                  if (
                    ((k = g.stateNode.containerInfo),
                    k === e || (8 === k.nodeType && k.parentNode === e))
                  )
                    return;
                }
                g = g.return;
              }
            for (; null !== h; ) {
              g = Wc(h);
              if (null === g) return;
              k = g.tag;
              if (5 === k || 6 === k) {
                d = f = g;
                continue a;
              }
              h = h.parentNode;
            }
          }
          d = d.return;
        }
      Jb(function () {
        var d2 = f,
          e2 = xb(c),
          g2 = [];
        a: {
          var h2 = df.get(a);
          if (void 0 !== h2) {
            var k2 = td,
              n = a;
            switch (a) {
              case "keypress":
                if (0 === od(c)) break a;
              case "keydown":
              case "keyup":
                k2 = Rd;
                break;
              case "focusin":
                n = "focus";
                k2 = Fd;
                break;
              case "focusout":
                n = "blur";
                k2 = Fd;
                break;
              case "beforeblur":
              case "afterblur":
                k2 = Fd;
                break;
              case "click":
                if (2 === c.button) break a;
              case "auxclick":
              case "dblclick":
              case "mousedown":
              case "mousemove":
              case "mouseup":
              case "mouseout":
              case "mouseover":
              case "contextmenu":
                k2 = Bd;
                break;
              case "drag":
              case "dragend":
              case "dragenter":
              case "dragexit":
              case "dragleave":
              case "dragover":
              case "dragstart":
              case "drop":
                k2 = Dd;
                break;
              case "touchcancel":
              case "touchend":
              case "touchmove":
              case "touchstart":
                k2 = Vd;
                break;
              case $e:
              case af:
              case bf:
                k2 = Hd;
                break;
              case cf:
                k2 = Xd;
                break;
              case "scroll":
                k2 = vd;
                break;
              case "wheel":
                k2 = Zd;
                break;
              case "copy":
              case "cut":
              case "paste":
                k2 = Jd;
                break;
              case "gotpointercapture":
              case "lostpointercapture":
              case "pointercancel":
              case "pointerdown":
              case "pointermove":
              case "pointerout":
              case "pointerover":
              case "pointerup":
                k2 = Td;
            }
            var t = 0 !== (b & 4),
              J = !t && "scroll" === a,
              x = t ? (null !== h2 ? h2 + "Capture" : null) : h2;
            t = [];
            for (var w = d2, u; null !== w; ) {
              u = w;
              var F = u.stateNode;
              5 === u.tag &&
                null !== F &&
                ((u = F),
                null !== x &&
                  ((F = Kb(w, x)), null != F && t.push(tf(w, F, u))));
              if (J) break;
              w = w.return;
            }
            0 < t.length &&
              ((h2 = new k2(h2, n, null, c, e2)),
              g2.push({ event: h2, listeners: t }));
          }
        }
        if (0 === (b & 7)) {
          a: {
            h2 = "mouseover" === a || "pointerover" === a;
            k2 = "mouseout" === a || "pointerout" === a;
            if (
              h2 &&
              c !== wb &&
              (n = c.relatedTarget || c.fromElement) &&
              (Wc(n) || n[uf])
            )
              break a;
            if (k2 || h2) {
              h2 =
                e2.window === e2
                  ? e2
                  : (h2 = e2.ownerDocument)
                  ? h2.defaultView || h2.parentWindow
                  : window;
              if (k2) {
                if (
                  ((n = c.relatedTarget || c.toElement),
                  (k2 = d2),
                  (n = n ? Wc(n) : null),
                  null !== n &&
                    ((J = Vb(n)), n !== J || (5 !== n.tag && 6 !== n.tag)))
                )
                  n = null;
              } else (k2 = null), (n = d2);
              if (k2 !== n) {
                t = Bd;
                F = "onMouseLeave";
                x = "onMouseEnter";
                w = "mouse";
                if ("pointerout" === a || "pointerover" === a)
                  (t = Td),
                    (F = "onPointerLeave"),
                    (x = "onPointerEnter"),
                    (w = "pointer");
                J = null == k2 ? h2 : ue(k2);
                u = null == n ? h2 : ue(n);
                h2 = new t(F, w + "leave", k2, c, e2);
                h2.target = J;
                h2.relatedTarget = u;
                F = null;
                Wc(e2) === d2 &&
                  ((t = new t(x, w + "enter", n, c, e2)),
                  (t.target = u),
                  (t.relatedTarget = J),
                  (F = t));
                J = F;
                if (k2 && n)
                  b: {
                    t = k2;
                    x = n;
                    w = 0;
                    for (u = t; u; u = vf(u)) w++;
                    u = 0;
                    for (F = x; F; F = vf(F)) u++;
                    for (; 0 < w - u; ) (t = vf(t)), w--;
                    for (; 0 < u - w; ) (x = vf(x)), u--;
                    for (; w--; ) {
                      if (t === x || (null !== x && t === x.alternate)) break b;
                      t = vf(t);
                      x = vf(x);
                    }
                    t = null;
                  }
                else t = null;
                null !== k2 && wf(g2, h2, k2, t, false);
                null !== n && null !== J && wf(g2, J, n, t, true);
              }
            }
          }
          a: {
            h2 = d2 ? ue(d2) : window;
            k2 = h2.nodeName && h2.nodeName.toLowerCase();
            if ("select" === k2 || ("input" === k2 && "file" === h2.type))
              var na = ve;
            else if (me(h2))
              if (we) na = Fe;
              else {
                na = De;
                var xa = Ce;
              }
            else
              (k2 = h2.nodeName) &&
                "input" === k2.toLowerCase() &&
                ("checkbox" === h2.type || "radio" === h2.type) &&
                (na = Ee);
            if (na && (na = na(a, d2))) {
              ne(g2, na, c, e2);
              break a;
            }
            xa && xa(a, h2, d2);
            "focusout" === a &&
              (xa = h2._wrapperState) &&
              xa.controlled &&
              "number" === h2.type &&
              cb(h2, "number", h2.value);
          }
          xa = d2 ? ue(d2) : window;
          switch (a) {
            case "focusin":
              if (me(xa) || "true" === xa.contentEditable)
                (Qe = xa), (Re = d2), (Se = null);
              break;
            case "focusout":
              Se = Re = Qe = null;
              break;
            case "mousedown":
              Te = true;
              break;
            case "contextmenu":
            case "mouseup":
            case "dragend":
              Te = false;
              Ue(g2, c, e2);
              break;
            case "selectionchange":
              if (Pe) break;
            case "keydown":
            case "keyup":
              Ue(g2, c, e2);
          }
          var $a;
          if (ae)
            b: {
              switch (a) {
                case "compositionstart":
                  var ba = "onCompositionStart";
                  break b;
                case "compositionend":
                  ba = "onCompositionEnd";
                  break b;
                case "compositionupdate":
                  ba = "onCompositionUpdate";
                  break b;
              }
              ba = void 0;
            }
          else
            ie
              ? ge(a, c) && (ba = "onCompositionEnd")
              : "keydown" === a &&
                229 === c.keyCode &&
                (ba = "onCompositionStart");
          ba &&
            (de &&
              "ko" !== c.locale &&
              (ie || "onCompositionStart" !== ba
                ? "onCompositionEnd" === ba && ie && ($a = nd())
                : ((kd = e2),
                  (ld = "value" in kd ? kd.value : kd.textContent),
                  (ie = true))),
            (xa = oe(d2, ba)),
            0 < xa.length &&
              ((ba = new Ld(ba, a, null, c, e2)),
              g2.push({ event: ba, listeners: xa }),
              $a
                ? (ba.data = $a)
                : (($a = he(c)), null !== $a && (ba.data = $a))));
          if (($a = ce ? je(a, c) : ke(a, c)))
            (d2 = oe(d2, "onBeforeInput")),
              0 < d2.length &&
                ((e2 = new Ld("onBeforeInput", "beforeinput", null, c, e2)),
                g2.push({ event: e2, listeners: d2 }),
                (e2.data = $a));
        }
        se(g2, b);
      });
    }
    function tf(a, b, c) {
      return { instance: a, listener: b, currentTarget: c };
    }
    function oe(a, b) {
      for (var c = b + "Capture", d = []; null !== a; ) {
        var e = a,
          f = e.stateNode;
        5 === e.tag &&
          null !== f &&
          ((e = f),
          (f = Kb(a, c)),
          null != f && d.unshift(tf(a, f, e)),
          (f = Kb(a, b)),
          null != f && d.push(tf(a, f, e)));
        a = a.return;
      }
      return d;
    }
    function vf(a) {
      if (null === a) return null;
      do a = a.return;
      while (a && 5 !== a.tag);
      return a ? a : null;
    }
    function wf(a, b, c, d, e) {
      for (var f = b._reactName, g = []; null !== c && c !== d; ) {
        var h = c,
          k = h.alternate,
          l = h.stateNode;
        if (null !== k && k === d) break;
        5 === h.tag &&
          null !== l &&
          ((h = l),
          e
            ? ((k = Kb(c, f)), null != k && g.unshift(tf(c, k, h)))
            : e || ((k = Kb(c, f)), null != k && g.push(tf(c, k, h))));
        c = c.return;
      }
      0 !== g.length && a.push({ event: b, listeners: g });
    }
    var xf = /\r\n?/g;
    var yf = /\u0000|\uFFFD/g;
    function zf(a) {
      return ("string" === typeof a ? a : "" + a)
        .replace(xf, "\n")
        .replace(yf, "");
    }
    function Af(a, b, c) {
      b = zf(b);
      if (zf(a) !== b && c) throw Error(p(425));
    }
    function Bf() {}
    var Cf = null;
    var Df = null;
    function Ef(a, b) {
      return (
        "textarea" === a ||
        "noscript" === a ||
        "string" === typeof b.children ||
        "number" === typeof b.children ||
        ("object" === typeof b.dangerouslySetInnerHTML &&
          null !== b.dangerouslySetInnerHTML &&
          null != b.dangerouslySetInnerHTML.__html)
      );
    }
    var Ff = "function" === typeof setTimeout ? setTimeout : void 0;
    var Gf = "function" === typeof clearTimeout ? clearTimeout : void 0;
    var Hf = "function" === typeof Promise ? Promise : void 0;
    var Jf =
      "function" === typeof queueMicrotask
        ? queueMicrotask
        : "undefined" !== typeof Hf
        ? function (a) {
            return Hf.resolve(null).then(a).catch(If);
          }
        : Ff;
    function If(a) {
      setTimeout(function () {
        throw a;
      });
    }
    function Kf(a, b) {
      var c = b,
        d = 0;
      do {
        var e = c.nextSibling;
        a.removeChild(c);
        if (e && 8 === e.nodeType)
          if (((c = e.data), "/$" === c)) {
            if (0 === d) {
              a.removeChild(e);
              bd(b);
              return;
            }
            d--;
          } else ("$" !== c && "$?" !== c && "$!" !== c) || d++;
        c = e;
      } while (c);
      bd(b);
    }
    function Lf(a) {
      for (; null != a; a = a.nextSibling) {
        var b = a.nodeType;
        if (1 === b || 3 === b) break;
        if (8 === b) {
          b = a.data;
          if ("$" === b || "$!" === b || "$?" === b) break;
          if ("/$" === b) return null;
        }
      }
      return a;
    }
    function Mf(a) {
      a = a.previousSibling;
      for (var b = 0; a; ) {
        if (8 === a.nodeType) {
          var c = a.data;
          if ("$" === c || "$!" === c || "$?" === c) {
            if (0 === b) return a;
            b--;
          } else "/$" === c && b++;
        }
        a = a.previousSibling;
      }
      return null;
    }
    var Nf = Math.random().toString(36).slice(2);
    var Of = "__reactFiber$" + Nf;
    var Pf = "__reactProps$" + Nf;
    var uf = "__reactContainer$" + Nf;
    var of = "__reactEvents$" + Nf;
    var Qf = "__reactListeners$" + Nf;
    var Rf = "__reactHandles$" + Nf;
    function Wc(a) {
      var b = a[Of];
      if (b) return b;
      for (var c = a.parentNode; c; ) {
        if ((b = c[uf] || c[Of])) {
          c = b.alternate;
          if (null !== b.child || (null !== c && null !== c.child))
            for (a = Mf(a); null !== a; ) {
              if ((c = a[Of])) return c;
              a = Mf(a);
            }
          return b;
        }
        a = c;
        c = a.parentNode;
      }
      return null;
    }
    function Cb(a) {
      a = a[Of] || a[uf];
      return !a || (5 !== a.tag && 6 !== a.tag && 13 !== a.tag && 3 !== a.tag)
        ? null
        : a;
    }
    function ue(a) {
      if (5 === a.tag || 6 === a.tag) return a.stateNode;
      throw Error(p(33));
    }
    function Db(a) {
      return a[Pf] || null;
    }
    var Sf = [];
    var Tf = -1;
    function Uf(a) {
      return { current: a };
    }
    function E(a) {
      0 > Tf || ((a.current = Sf[Tf]), (Sf[Tf] = null), Tf--);
    }
    function G(a, b) {
      Tf++;
      Sf[Tf] = a.current;
      a.current = b;
    }
    var Vf = {};
    var H = Uf(Vf);
    var Wf = Uf(false);
    var Xf = Vf;
    function Yf(a, b) {
      var c = a.type.contextTypes;
      if (!c) return Vf;
      var d = a.stateNode;
      if (d && d.__reactInternalMemoizedUnmaskedChildContext === b)
        return d.__reactInternalMemoizedMaskedChildContext;
      var e = {},
        f;
      for (f in c) e[f] = b[f];
      d &&
        ((a = a.stateNode),
        (a.__reactInternalMemoizedUnmaskedChildContext = b),
        (a.__reactInternalMemoizedMaskedChildContext = e));
      return e;
    }
    function Zf(a) {
      a = a.childContextTypes;
      return null !== a && void 0 !== a;
    }
    function $f() {
      E(Wf);
      E(H);
    }
    function ag(a, b, c) {
      if (H.current !== Vf) throw Error(p(168));
      G(H, b);
      G(Wf, c);
    }
    function bg(a, b, c) {
      var d = a.stateNode;
      b = b.childContextTypes;
      if ("function" !== typeof d.getChildContext) return c;
      d = d.getChildContext();
      for (var e in d)
        if (!(e in b)) throw Error(p(108, Ra(a) || "Unknown", e));
      return A({}, c, d);
    }
    function cg(a) {
      a =
        ((a = a.stateNode) && a.__reactInternalMemoizedMergedChildContext) ||
        Vf;
      Xf = H.current;
      G(H, a);
      G(Wf, Wf.current);
      return true;
    }
    function dg(a, b, c) {
      var d = a.stateNode;
      if (!d) throw Error(p(169));
      c
        ? ((a = bg(a, b, Xf)),
          (d.__reactInternalMemoizedMergedChildContext = a),
          E(Wf),
          E(H),
          G(H, a))
        : E(Wf);
      G(Wf, c);
    }
    var eg = null;
    var fg = false;
    var gg = false;
    function hg(a) {
      null === eg ? (eg = [a]) : eg.push(a);
    }
    function ig(a) {
      fg = true;
      hg(a);
    }
    function jg() {
      if (!gg && null !== eg) {
        gg = true;
        var a = 0,
          b = C;
        try {
          var c = eg;
          for (C = 1; a < c.length; a++) {
            var d = c[a];
            do d = d(true);
            while (null !== d);
          }
          eg = null;
          fg = false;
        } catch (e) {
          throw (null !== eg && (eg = eg.slice(a + 1)), ac(fc, jg), e);
        } finally {
          (C = b), (gg = false);
        }
      }
      return null;
    }
    var kg = [];
    var lg = 0;
    var mg = null;
    var ng = 0;
    var og = [];
    var pg = 0;
    var qg = null;
    var rg = 1;
    var sg = "";
    function tg(a, b) {
      kg[lg++] = ng;
      kg[lg++] = mg;
      mg = a;
      ng = b;
    }
    function ug(a, b, c) {
      og[pg++] = rg;
      og[pg++] = sg;
      og[pg++] = qg;
      qg = a;
      var d = rg;
      a = sg;
      var e = 32 - oc(d) - 1;
      d &= ~(1 << e);
      c += 1;
      var f = 32 - oc(b) + e;
      if (30 < f) {
        var g = e - (e % 5);
        f = (d & ((1 << g) - 1)).toString(32);
        d >>= g;
        e -= g;
        rg = (1 << (32 - oc(b) + e)) | (c << e) | d;
        sg = f + a;
      } else (rg = (1 << f) | (c << e) | d), (sg = a);
    }
    function vg(a) {
      null !== a.return && (tg(a, 1), ug(a, 1, 0));
    }
    function wg(a) {
      for (; a === mg; )
        (mg = kg[--lg]), (kg[lg] = null), (ng = kg[--lg]), (kg[lg] = null);
      for (; a === qg; )
        (qg = og[--pg]),
          (og[pg] = null),
          (sg = og[--pg]),
          (og[pg] = null),
          (rg = og[--pg]),
          (og[pg] = null);
    }
    var xg = null;
    var yg = null;
    var I = false;
    var zg = null;
    function Ag(a, b) {
      var c = Bg(5, null, null, 0);
      c.elementType = "DELETED";
      c.stateNode = b;
      c.return = a;
      b = a.deletions;
      null === b ? ((a.deletions = [c]), (a.flags |= 16)) : b.push(c);
    }
    function Cg(a, b) {
      switch (a.tag) {
        case 5:
          var c = a.type;
          b =
            1 !== b.nodeType || c.toLowerCase() !== b.nodeName.toLowerCase()
              ? null
              : b;
          return null !== b
            ? ((a.stateNode = b), (xg = a), (yg = Lf(b.firstChild)), true)
            : false;
        case 6:
          return (
            (b = "" === a.pendingProps || 3 !== b.nodeType ? null : b),
            null !== b
              ? ((a.stateNode = b), (xg = a), (yg = null), true)
              : false
          );
        case 13:
          return (
            (b = 8 !== b.nodeType ? null : b),
            null !== b
              ? ((c = null !== qg ? { id: rg, overflow: sg } : null),
                (a.memoizedState = {
                  dehydrated: b,
                  treeContext: c,
                  retryLane: 1073741824,
                }),
                (c = Bg(18, null, null, 0)),
                (c.stateNode = b),
                (c.return = a),
                (a.child = c),
                (xg = a),
                (yg = null),
                true)
              : false
          );
        default:
          return false;
      }
    }
    function Dg(a) {
      return 0 !== (a.mode & 1) && 0 === (a.flags & 128);
    }
    function Eg(a) {
      if (I) {
        var b = yg;
        if (b) {
          var c = b;
          if (!Cg(a, b)) {
            if (Dg(a)) throw Error(p(418));
            b = Lf(c.nextSibling);
            var d = xg;
            b && Cg(a, b)
              ? Ag(d, c)
              : ((a.flags = (a.flags & -4097) | 2), (I = false), (xg = a));
          }
        } else {
          if (Dg(a)) throw Error(p(418));
          a.flags = (a.flags & -4097) | 2;
          I = false;
          xg = a;
        }
      }
    }
    function Fg(a) {
      for (
        a = a.return;
        null !== a && 5 !== a.tag && 3 !== a.tag && 13 !== a.tag;

      )
        a = a.return;
      xg = a;
    }
    function Gg(a) {
      if (a !== xg) return false;
      if (!I) return Fg(a), (I = true), false;
      var b;
      (b = 3 !== a.tag) &&
        !(b = 5 !== a.tag) &&
        ((b = a.type),
        (b = "head" !== b && "body" !== b && !Ef(a.type, a.memoizedProps)));
      if (b && (b = yg)) {
        if (Dg(a)) throw (Hg(), Error(p(418)));
        for (; b; ) Ag(a, b), (b = Lf(b.nextSibling));
      }
      Fg(a);
      if (13 === a.tag) {
        a = a.memoizedState;
        a = null !== a ? a.dehydrated : null;
        if (!a) throw Error(p(317));
        a: {
          a = a.nextSibling;
          for (b = 0; a; ) {
            if (8 === a.nodeType) {
              var c = a.data;
              if ("/$" === c) {
                if (0 === b) {
                  yg = Lf(a.nextSibling);
                  break a;
                }
                b--;
              } else ("$" !== c && "$!" !== c && "$?" !== c) || b++;
            }
            a = a.nextSibling;
          }
          yg = null;
        }
      } else yg = xg ? Lf(a.stateNode.nextSibling) : null;
      return true;
    }
    function Hg() {
      for (var a = yg; a; ) a = Lf(a.nextSibling);
    }
    function Ig() {
      yg = xg = null;
      I = false;
    }
    function Jg(a) {
      null === zg ? (zg = [a]) : zg.push(a);
    }
    var Kg = ua.ReactCurrentBatchConfig;
    function Lg(a, b) {
      if (a && a.defaultProps) {
        b = A({}, b);
        a = a.defaultProps;
        for (var c in a) void 0 === b[c] && (b[c] = a[c]);
        return b;
      }
      return b;
    }
    var Mg = Uf(null);
    var Ng = null;
    var Og = null;
    var Pg = null;
    function Qg() {
      Pg = Og = Ng = null;
    }
    function Rg(a) {
      var b = Mg.current;
      E(Mg);
      a._currentValue = b;
    }
    function Sg(a, b, c) {
      for (; null !== a; ) {
        var d = a.alternate;
        (a.childLanes & b) !== b
          ? ((a.childLanes |= b), null !== d && (d.childLanes |= b))
          : null !== d && (d.childLanes & b) !== b && (d.childLanes |= b);
        if (a === c) break;
        a = a.return;
      }
    }
    function Tg(a, b) {
      Ng = a;
      Pg = Og = null;
      a = a.dependencies;
      null !== a &&
        null !== a.firstContext &&
        (0 !== (a.lanes & b) && (Ug = true), (a.firstContext = null));
    }
    function Vg(a) {
      var b = a._currentValue;
      if (Pg !== a)
        if (((a = { context: a, memoizedValue: b, next: null }), null === Og)) {
          if (null === Ng) throw Error(p(308));
          Og = a;
          Ng.dependencies = { lanes: 0, firstContext: a };
        } else Og = Og.next = a;
      return b;
    }
    var Wg = null;
    function Xg(a) {
      null === Wg ? (Wg = [a]) : Wg.push(a);
    }
    function Yg(a, b, c, d) {
      var e = b.interleaved;
      null === e ? ((c.next = c), Xg(b)) : ((c.next = e.next), (e.next = c));
      b.interleaved = c;
      return Zg(a, d);
    }
    function Zg(a, b) {
      a.lanes |= b;
      var c = a.alternate;
      null !== c && (c.lanes |= b);
      c = a;
      for (a = a.return; null !== a; )
        (a.childLanes |= b),
          (c = a.alternate),
          null !== c && (c.childLanes |= b),
          (c = a),
          (a = a.return);
      return 3 === c.tag ? c.stateNode : null;
    }
    var $g = false;
    function ah(a) {
      a.updateQueue = {
        baseState: a.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: { pending: null, interleaved: null, lanes: 0 },
        effects: null,
      };
    }
    function bh(a, b) {
      a = a.updateQueue;
      b.updateQueue === a &&
        (b.updateQueue = {
          baseState: a.baseState,
          firstBaseUpdate: a.firstBaseUpdate,
          lastBaseUpdate: a.lastBaseUpdate,
          shared: a.shared,
          effects: a.effects,
        });
    }
    function ch(a, b) {
      return {
        eventTime: a,
        lane: b,
        tag: 0,
        payload: null,
        callback: null,
        next: null,
      };
    }
    function dh(a, b, c) {
      var d = a.updateQueue;
      if (null === d) return null;
      d = d.shared;
      if (0 !== (K & 2)) {
        var e = d.pending;
        null === e ? (b.next = b) : ((b.next = e.next), (e.next = b));
        d.pending = b;
        return Zg(a, c);
      }
      e = d.interleaved;
      null === e ? ((b.next = b), Xg(d)) : ((b.next = e.next), (e.next = b));
      d.interleaved = b;
      return Zg(a, c);
    }
    function eh(a, b, c) {
      b = b.updateQueue;
      if (null !== b && ((b = b.shared), 0 !== (c & 4194240))) {
        var d = b.lanes;
        d &= a.pendingLanes;
        c |= d;
        b.lanes = c;
        Cc(a, c);
      }
    }
    function fh(a, b) {
      var c = a.updateQueue,
        d = a.alternate;
      if (null !== d && ((d = d.updateQueue), c === d)) {
        var e = null,
          f = null;
        c = c.firstBaseUpdate;
        if (null !== c) {
          do {
            var g = {
              eventTime: c.eventTime,
              lane: c.lane,
              tag: c.tag,
              payload: c.payload,
              callback: c.callback,
              next: null,
            };
            null === f ? (e = f = g) : (f = f.next = g);
            c = c.next;
          } while (null !== c);
          null === f ? (e = f = b) : (f = f.next = b);
        } else e = f = b;
        c = {
          baseState: d.baseState,
          firstBaseUpdate: e,
          lastBaseUpdate: f,
          shared: d.shared,
          effects: d.effects,
        };
        a.updateQueue = c;
        return;
      }
      a = c.lastBaseUpdate;
      null === a ? (c.firstBaseUpdate = b) : (a.next = b);
      c.lastBaseUpdate = b;
    }
    function gh(a, b, c, d) {
      var e = a.updateQueue;
      $g = false;
      var f = e.firstBaseUpdate,
        g = e.lastBaseUpdate,
        h = e.shared.pending;
      if (null !== h) {
        e.shared.pending = null;
        var k = h,
          l = k.next;
        k.next = null;
        null === g ? (f = l) : (g.next = l);
        g = k;
        var m = a.alternate;
        null !== m &&
          ((m = m.updateQueue),
          (h = m.lastBaseUpdate),
          h !== g &&
            (null === h ? (m.firstBaseUpdate = l) : (h.next = l),
            (m.lastBaseUpdate = k)));
      }
      if (null !== f) {
        var q = e.baseState;
        g = 0;
        m = l = k = null;
        h = f;
        do {
          var r = h.lane,
            y = h.eventTime;
          if ((d & r) === r) {
            null !== m &&
              (m = m.next =
                {
                  eventTime: y,
                  lane: 0,
                  tag: h.tag,
                  payload: h.payload,
                  callback: h.callback,
                  next: null,
                });
            a: {
              var n = a,
                t = h;
              r = b;
              y = c;
              switch (t.tag) {
                case 1:
                  n = t.payload;
                  if ("function" === typeof n) {
                    q = n.call(y, q, r);
                    break a;
                  }
                  q = n;
                  break a;
                case 3:
                  n.flags = (n.flags & -65537) | 128;
                case 0:
                  n = t.payload;
                  r = "function" === typeof n ? n.call(y, q, r) : n;
                  if (null === r || void 0 === r) break a;
                  q = A({}, q, r);
                  break a;
                case 2:
                  $g = true;
              }
            }
            null !== h.callback &&
              0 !== h.lane &&
              ((a.flags |= 64),
              (r = e.effects),
              null === r ? (e.effects = [h]) : r.push(h));
          } else
            (y = {
              eventTime: y,
              lane: r,
              tag: h.tag,
              payload: h.payload,
              callback: h.callback,
              next: null,
            }),
              null === m ? ((l = m = y), (k = q)) : (m = m.next = y),
              (g |= r);
          h = h.next;
          if (null === h)
            if (((h = e.shared.pending), null === h)) break;
            else
              (r = h),
                (h = r.next),
                (r.next = null),
                (e.lastBaseUpdate = r),
                (e.shared.pending = null);
        } while (1);
        null === m && (k = q);
        e.baseState = k;
        e.firstBaseUpdate = l;
        e.lastBaseUpdate = m;
        b = e.shared.interleaved;
        if (null !== b) {
          e = b;
          do (g |= e.lane), (e = e.next);
          while (e !== b);
        } else null === f && (e.shared.lanes = 0);
        hh |= g;
        a.lanes = g;
        a.memoizedState = q;
      }
    }
    function ih(a, b, c) {
      a = b.effects;
      b.effects = null;
      if (null !== a)
        for (b = 0; b < a.length; b++) {
          var d = a[b],
            e = d.callback;
          if (null !== e) {
            d.callback = null;
            d = c;
            if ("function" !== typeof e) throw Error(p(191, e));
            e.call(d);
          }
        }
    }
    var jh = new aa.Component().refs;
    function kh(a, b, c, d) {
      b = a.memoizedState;
      c = c(d, b);
      c = null === c || void 0 === c ? b : A({}, b, c);
      a.memoizedState = c;
      0 === a.lanes && (a.updateQueue.baseState = c);
    }
    var nh = {
      isMounted: function (a) {
        return (a = a._reactInternals) ? Vb(a) === a : false;
      },
      enqueueSetState: function (a, b, c) {
        a = a._reactInternals;
        var d = L(),
          e = lh(a),
          f = ch(d, e);
        f.payload = b;
        void 0 !== c && null !== c && (f.callback = c);
        b = dh(a, f, e);
        null !== b && (mh(b, a, e, d), eh(b, a, e));
      },
      enqueueReplaceState: function (a, b, c) {
        a = a._reactInternals;
        var d = L(),
          e = lh(a),
          f = ch(d, e);
        f.tag = 1;
        f.payload = b;
        void 0 !== c && null !== c && (f.callback = c);
        b = dh(a, f, e);
        null !== b && (mh(b, a, e, d), eh(b, a, e));
      },
      enqueueForceUpdate: function (a, b) {
        a = a._reactInternals;
        var c = L(),
          d = lh(a),
          e = ch(c, d);
        e.tag = 2;
        void 0 !== b && null !== b && (e.callback = b);
        b = dh(a, e, d);
        null !== b && (mh(b, a, d, c), eh(b, a, d));
      },
    };
    function oh(a, b, c, d, e, f, g) {
      a = a.stateNode;
      return "function" === typeof a.shouldComponentUpdate
        ? a.shouldComponentUpdate(d, f, g)
        : b.prototype && b.prototype.isPureReactComponent
        ? !Ie(c, d) || !Ie(e, f)
        : true;
    }
    function ph(a, b, c) {
      var d = false,
        e = Vf;
      var f = b.contextType;
      "object" === typeof f && null !== f
        ? (f = Vg(f))
        : ((e = Zf(b) ? Xf : H.current),
          (d = b.contextTypes),
          (f = (d = null !== d && void 0 !== d) ? Yf(a, e) : Vf));
      b = new b(c, f);
      a.memoizedState = null !== b.state && void 0 !== b.state ? b.state : null;
      b.updater = nh;
      a.stateNode = b;
      b._reactInternals = a;
      d &&
        ((a = a.stateNode),
        (a.__reactInternalMemoizedUnmaskedChildContext = e),
        (a.__reactInternalMemoizedMaskedChildContext = f));
      return b;
    }
    function qh(a, b, c, d) {
      a = b.state;
      "function" === typeof b.componentWillReceiveProps &&
        b.componentWillReceiveProps(c, d);
      "function" === typeof b.UNSAFE_componentWillReceiveProps &&
        b.UNSAFE_componentWillReceiveProps(c, d);
      b.state !== a && nh.enqueueReplaceState(b, b.state, null);
    }
    function rh(a, b, c, d) {
      var e = a.stateNode;
      e.props = c;
      e.state = a.memoizedState;
      e.refs = jh;
      ah(a);
      var f = b.contextType;
      "object" === typeof f && null !== f
        ? (e.context = Vg(f))
        : ((f = Zf(b) ? Xf : H.current), (e.context = Yf(a, f)));
      e.state = a.memoizedState;
      f = b.getDerivedStateFromProps;
      "function" === typeof f && (kh(a, b, f, c), (e.state = a.memoizedState));
      "function" === typeof b.getDerivedStateFromProps ||
        "function" === typeof e.getSnapshotBeforeUpdate ||
        ("function" !== typeof e.UNSAFE_componentWillMount &&
          "function" !== typeof e.componentWillMount) ||
        ((b = e.state),
        "function" === typeof e.componentWillMount && e.componentWillMount(),
        "function" === typeof e.UNSAFE_componentWillMount &&
          e.UNSAFE_componentWillMount(),
        b !== e.state && nh.enqueueReplaceState(e, e.state, null),
        gh(a, c, e, d),
        (e.state = a.memoizedState));
      "function" === typeof e.componentDidMount && (a.flags |= 4194308);
    }
    function sh(a, b, c) {
      a = c.ref;
      if (null !== a && "function" !== typeof a && "object" !== typeof a) {
        if (c._owner) {
          c = c._owner;
          if (c) {
            if (1 !== c.tag) throw Error(p(309));
            var d = c.stateNode;
          }
          if (!d) throw Error(p(147, a));
          var e = d,
            f = "" + a;
          if (
            null !== b &&
            null !== b.ref &&
            "function" === typeof b.ref &&
            b.ref._stringRef === f
          )
            return b.ref;
          b = function (a2) {
            var b2 = e.refs;
            b2 === jh && (b2 = e.refs = {});
            null === a2 ? delete b2[f] : (b2[f] = a2);
          };
          b._stringRef = f;
          return b;
        }
        if ("string" !== typeof a) throw Error(p(284));
        if (!c._owner) throw Error(p(290, a));
      }
      return a;
    }
    function th(a, b) {
      a = Object.prototype.toString.call(b);
      throw Error(
        p(
          31,
          "[object Object]" === a
            ? "object with keys {" + Object.keys(b).join(", ") + "}"
            : a
        )
      );
    }
    function uh(a) {
      var b = a._init;
      return b(a._payload);
    }
    function vh(a) {
      function b(b2, c2) {
        if (a) {
          var d2 = b2.deletions;
          null === d2 ? ((b2.deletions = [c2]), (b2.flags |= 16)) : d2.push(c2);
        }
      }
      function c(c2, d2) {
        if (!a) return null;
        for (; null !== d2; ) b(c2, d2), (d2 = d2.sibling);
        return null;
      }
      function d(a2, b2) {
        for (a2 = /* @__PURE__ */ new Map(); null !== b2; )
          null !== b2.key ? a2.set(b2.key, b2) : a2.set(b2.index, b2),
            (b2 = b2.sibling);
        return a2;
      }
      function e(a2, b2) {
        a2 = wh(a2, b2);
        a2.index = 0;
        a2.sibling = null;
        return a2;
      }
      function f(b2, c2, d2) {
        b2.index = d2;
        if (!a) return (b2.flags |= 1048576), c2;
        d2 = b2.alternate;
        if (null !== d2)
          return (d2 = d2.index), d2 < c2 ? ((b2.flags |= 2), c2) : d2;
        b2.flags |= 2;
        return c2;
      }
      function g(b2) {
        a && null === b2.alternate && (b2.flags |= 2);
        return b2;
      }
      function h(a2, b2, c2, d2) {
        if (null === b2 || 6 !== b2.tag)
          return (b2 = xh(c2, a2.mode, d2)), (b2.return = a2), b2;
        b2 = e(b2, c2);
        b2.return = a2;
        return b2;
      }
      function k(a2, b2, c2, d2) {
        var f2 = c2.type;
        if (f2 === ya) return m(a2, b2, c2.props.children, d2, c2.key);
        if (
          null !== b2 &&
          (b2.elementType === f2 ||
            ("object" === typeof f2 &&
              null !== f2 &&
              f2.$$typeof === Ha &&
              uh(f2) === b2.type))
        )
          return (
            (d2 = e(b2, c2.props)),
            (d2.ref = sh(a2, b2, c2)),
            (d2.return = a2),
            d2
          );
        d2 = yh(c2.type, c2.key, c2.props, null, a2.mode, d2);
        d2.ref = sh(a2, b2, c2);
        d2.return = a2;
        return d2;
      }
      function l(a2, b2, c2, d2) {
        if (
          null === b2 ||
          4 !== b2.tag ||
          b2.stateNode.containerInfo !== c2.containerInfo ||
          b2.stateNode.implementation !== c2.implementation
        )
          return (b2 = zh(c2, a2.mode, d2)), (b2.return = a2), b2;
        b2 = e(b2, c2.children || []);
        b2.return = a2;
        return b2;
      }
      function m(a2, b2, c2, d2, f2) {
        if (null === b2 || 7 !== b2.tag)
          return (b2 = Ah(c2, a2.mode, d2, f2)), (b2.return = a2), b2;
        b2 = e(b2, c2);
        b2.return = a2;
        return b2;
      }
      function q(a2, b2, c2) {
        if (("string" === typeof b2 && "" !== b2) || "number" === typeof b2)
          return (b2 = xh("" + b2, a2.mode, c2)), (b2.return = a2), b2;
        if ("object" === typeof b2 && null !== b2) {
          switch (b2.$$typeof) {
            case va:
              return (
                (c2 = yh(b2.type, b2.key, b2.props, null, a2.mode, c2)),
                (c2.ref = sh(a2, null, b2)),
                (c2.return = a2),
                c2
              );
            case wa:
              return (b2 = zh(b2, a2.mode, c2)), (b2.return = a2), b2;
            case Ha:
              var d2 = b2._init;
              return q(a2, d2(b2._payload), c2);
          }
          if (eb(b2) || Ka(b2))
            return (b2 = Ah(b2, a2.mode, c2, null)), (b2.return = a2), b2;
          th(a2, b2);
        }
        return null;
      }
      function r(a2, b2, c2, d2) {
        var e2 = null !== b2 ? b2.key : null;
        if (("string" === typeof c2 && "" !== c2) || "number" === typeof c2)
          return null !== e2 ? null : h(a2, b2, "" + c2, d2);
        if ("object" === typeof c2 && null !== c2) {
          switch (c2.$$typeof) {
            case va:
              return c2.key === e2 ? k(a2, b2, c2, d2) : null;
            case wa:
              return c2.key === e2 ? l(a2, b2, c2, d2) : null;
            case Ha:
              return (e2 = c2._init), r(a2, b2, e2(c2._payload), d2);
          }
          if (eb(c2) || Ka(c2))
            return null !== e2 ? null : m(a2, b2, c2, d2, null);
          th(a2, c2);
        }
        return null;
      }
      function y(a2, b2, c2, d2, e2) {
        if (("string" === typeof d2 && "" !== d2) || "number" === typeof d2)
          return (a2 = a2.get(c2) || null), h(b2, a2, "" + d2, e2);
        if ("object" === typeof d2 && null !== d2) {
          switch (d2.$$typeof) {
            case va:
              return (
                (a2 = a2.get(null === d2.key ? c2 : d2.key) || null),
                k(b2, a2, d2, e2)
              );
            case wa:
              return (
                (a2 = a2.get(null === d2.key ? c2 : d2.key) || null),
                l(b2, a2, d2, e2)
              );
            case Ha:
              var f2 = d2._init;
              return y(a2, b2, c2, f2(d2._payload), e2);
          }
          if (eb(d2) || Ka(d2))
            return (a2 = a2.get(c2) || null), m(b2, a2, d2, e2, null);
          th(b2, d2);
        }
        return null;
      }
      function n(e2, g2, h2, k2) {
        for (
          var l2 = null, m2 = null, u = g2, w = (g2 = 0), x = null;
          null !== u && w < h2.length;
          w++
        ) {
          u.index > w ? ((x = u), (u = null)) : (x = u.sibling);
          var n2 = r(e2, u, h2[w], k2);
          if (null === n2) {
            null === u && (u = x);
            break;
          }
          a && u && null === n2.alternate && b(e2, u);
          g2 = f(n2, g2, w);
          null === m2 ? (l2 = n2) : (m2.sibling = n2);
          m2 = n2;
          u = x;
        }
        if (w === h2.length) return c(e2, u), I && tg(e2, w), l2;
        if (null === u) {
          for (; w < h2.length; w++)
            (u = q(e2, h2[w], k2)),
              null !== u &&
                ((g2 = f(u, g2, w)),
                null === m2 ? (l2 = u) : (m2.sibling = u),
                (m2 = u));
          I && tg(e2, w);
          return l2;
        }
        for (u = d(e2, u); w < h2.length; w++)
          (x = y(u, e2, w, h2[w], k2)),
            null !== x &&
              (a &&
                null !== x.alternate &&
                u.delete(null === x.key ? w : x.key),
              (g2 = f(x, g2, w)),
              null === m2 ? (l2 = x) : (m2.sibling = x),
              (m2 = x));
        a &&
          u.forEach(function (a2) {
            return b(e2, a2);
          });
        I && tg(e2, w);
        return l2;
      }
      function t(e2, g2, h2, k2) {
        var l2 = Ka(h2);
        if ("function" !== typeof l2) throw Error(p(150));
        h2 = l2.call(h2);
        if (null == h2) throw Error(p(151));
        for (
          var u = (l2 = null), m2 = g2, w = (g2 = 0), x = null, n2 = h2.next();
          null !== m2 && !n2.done;
          w++, n2 = h2.next()
        ) {
          m2.index > w ? ((x = m2), (m2 = null)) : (x = m2.sibling);
          var t2 = r(e2, m2, n2.value, k2);
          if (null === t2) {
            null === m2 && (m2 = x);
            break;
          }
          a && m2 && null === t2.alternate && b(e2, m2);
          g2 = f(t2, g2, w);
          null === u ? (l2 = t2) : (u.sibling = t2);
          u = t2;
          m2 = x;
        }
        if (n2.done) return c(e2, m2), I && tg(e2, w), l2;
        if (null === m2) {
          for (; !n2.done; w++, n2 = h2.next())
            (n2 = q(e2, n2.value, k2)),
              null !== n2 &&
                ((g2 = f(n2, g2, w)),
                null === u ? (l2 = n2) : (u.sibling = n2),
                (u = n2));
          I && tg(e2, w);
          return l2;
        }
        for (m2 = d(e2, m2); !n2.done; w++, n2 = h2.next())
          (n2 = y(m2, e2, w, n2.value, k2)),
            null !== n2 &&
              (a &&
                null !== n2.alternate &&
                m2.delete(null === n2.key ? w : n2.key),
              (g2 = f(n2, g2, w)),
              null === u ? (l2 = n2) : (u.sibling = n2),
              (u = n2));
        a &&
          m2.forEach(function (a2) {
            return b(e2, a2);
          });
        I && tg(e2, w);
        return l2;
      }
      function J(a2, d2, f2, h2) {
        "object" === typeof f2 &&
          null !== f2 &&
          f2.type === ya &&
          null === f2.key &&
          (f2 = f2.props.children);
        if ("object" === typeof f2 && null !== f2) {
          switch (f2.$$typeof) {
            case va:
              a: {
                for (var k2 = f2.key, l2 = d2; null !== l2; ) {
                  if (l2.key === k2) {
                    k2 = f2.type;
                    if (k2 === ya) {
                      if (7 === l2.tag) {
                        c(a2, l2.sibling);
                        d2 = e(l2, f2.props.children);
                        d2.return = a2;
                        a2 = d2;
                        break a;
                      }
                    } else if (
                      l2.elementType === k2 ||
                      ("object" === typeof k2 &&
                        null !== k2 &&
                        k2.$$typeof === Ha &&
                        uh(k2) === l2.type)
                    ) {
                      c(a2, l2.sibling);
                      d2 = e(l2, f2.props);
                      d2.ref = sh(a2, l2, f2);
                      d2.return = a2;
                      a2 = d2;
                      break a;
                    }
                    c(a2, l2);
                    break;
                  } else b(a2, l2);
                  l2 = l2.sibling;
                }
                f2.type === ya
                  ? ((d2 = Ah(f2.props.children, a2.mode, h2, f2.key)),
                    (d2.return = a2),
                    (a2 = d2))
                  : ((h2 = yh(f2.type, f2.key, f2.props, null, a2.mode, h2)),
                    (h2.ref = sh(a2, d2, f2)),
                    (h2.return = a2),
                    (a2 = h2));
              }
              return g(a2);
            case wa:
              a: {
                for (l2 = f2.key; null !== d2; ) {
                  if (d2.key === l2)
                    if (
                      4 === d2.tag &&
                      d2.stateNode.containerInfo === f2.containerInfo &&
                      d2.stateNode.implementation === f2.implementation
                    ) {
                      c(a2, d2.sibling);
                      d2 = e(d2, f2.children || []);
                      d2.return = a2;
                      a2 = d2;
                      break a;
                    } else {
                      c(a2, d2);
                      break;
                    }
                  else b(a2, d2);
                  d2 = d2.sibling;
                }
                d2 = zh(f2, a2.mode, h2);
                d2.return = a2;
                a2 = d2;
              }
              return g(a2);
            case Ha:
              return (l2 = f2._init), J(a2, d2, l2(f2._payload), h2);
          }
          if (eb(f2)) return n(a2, d2, f2, h2);
          if (Ka(f2)) return t(a2, d2, f2, h2);
          th(a2, f2);
        }
        return ("string" === typeof f2 && "" !== f2) || "number" === typeof f2
          ? ((f2 = "" + f2),
            null !== d2 && 6 === d2.tag
              ? (c(a2, d2.sibling),
                (d2 = e(d2, f2)),
                (d2.return = a2),
                (a2 = d2))
              : (c(a2, d2),
                (d2 = xh(f2, a2.mode, h2)),
                (d2.return = a2),
                (a2 = d2)),
            g(a2))
          : c(a2, d2);
      }
      return J;
    }
    var Bh = vh(true);
    var Ch = vh(false);
    var Dh = {};
    var Eh = Uf(Dh);
    var Fh = Uf(Dh);
    var Gh = Uf(Dh);
    function Hh(a) {
      if (a === Dh) throw Error(p(174));
      return a;
    }
    function Ih(a, b) {
      G(Gh, b);
      G(Fh, a);
      G(Eh, Dh);
      a = b.nodeType;
      switch (a) {
        case 9:
        case 11:
          b = (b = b.documentElement) ? b.namespaceURI : lb(null, "");
          break;
        default:
          (a = 8 === a ? b.parentNode : b),
            (b = a.namespaceURI || null),
            (a = a.tagName),
            (b = lb(b, a));
      }
      E(Eh);
      G(Eh, b);
    }
    function Jh() {
      E(Eh);
      E(Fh);
      E(Gh);
    }
    function Kh(a) {
      Hh(Gh.current);
      var b = Hh(Eh.current);
      var c = lb(b, a.type);
      b !== c && (G(Fh, a), G(Eh, c));
    }
    function Lh(a) {
      Fh.current === a && (E(Eh), E(Fh));
    }
    var M = Uf(0);
    function Mh(a) {
      for (var b = a; null !== b; ) {
        if (13 === b.tag) {
          var c = b.memoizedState;
          if (
            null !== c &&
            ((c = c.dehydrated),
            null === c || "$?" === c.data || "$!" === c.data)
          )
            return b;
        } else if (19 === b.tag && void 0 !== b.memoizedProps.revealOrder) {
          if (0 !== (b.flags & 128)) return b;
        } else if (null !== b.child) {
          b.child.return = b;
          b = b.child;
          continue;
        }
        if (b === a) break;
        for (; null === b.sibling; ) {
          if (null === b.return || b.return === a) return null;
          b = b.return;
        }
        b.sibling.return = b.return;
        b = b.sibling;
      }
      return null;
    }
    var Nh = [];
    function Oh() {
      for (var a = 0; a < Nh.length; a++)
        Nh[a]._workInProgressVersionPrimary = null;
      Nh.length = 0;
    }
    var Ph = ua.ReactCurrentDispatcher;
    var Qh = ua.ReactCurrentBatchConfig;
    var Rh = 0;
    var N = null;
    var O = null;
    var P = null;
    var Sh = false;
    var Th = false;
    var Uh = 0;
    var Vh = 0;
    function Q() {
      throw Error(p(321));
    }
    function Wh(a, b) {
      if (null === b) return false;
      for (var c = 0; c < b.length && c < a.length; c++)
        if (!He(a[c], b[c])) return false;
      return true;
    }
    function Xh(a, b, c, d, e, f) {
      Rh = f;
      N = b;
      b.memoizedState = null;
      b.updateQueue = null;
      b.lanes = 0;
      Ph.current = null === a || null === a.memoizedState ? Yh : Zh;
      a = c(d, e);
      if (Th) {
        f = 0;
        do {
          Th = false;
          Uh = 0;
          if (25 <= f) throw Error(p(301));
          f += 1;
          P = O = null;
          b.updateQueue = null;
          Ph.current = $h;
          a = c(d, e);
        } while (Th);
      }
      Ph.current = ai;
      b = null !== O && null !== O.next;
      Rh = 0;
      P = O = N = null;
      Sh = false;
      if (b) throw Error(p(300));
      return a;
    }
    function bi() {
      var a = 0 !== Uh;
      Uh = 0;
      return a;
    }
    function ci() {
      var a = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null,
      };
      null === P ? (N.memoizedState = P = a) : (P = P.next = a);
      return P;
    }
    function di() {
      if (null === O) {
        var a = N.alternate;
        a = null !== a ? a.memoizedState : null;
      } else a = O.next;
      var b = null === P ? N.memoizedState : P.next;
      if (null !== b) (P = b), (O = a);
      else {
        if (null === a) throw Error(p(310));
        O = a;
        a = {
          memoizedState: O.memoizedState,
          baseState: O.baseState,
          baseQueue: O.baseQueue,
          queue: O.queue,
          next: null,
        };
        null === P ? (N.memoizedState = P = a) : (P = P.next = a);
      }
      return P;
    }
    function ei(a, b) {
      return "function" === typeof b ? b(a) : b;
    }
    function fi(a) {
      var b = di(),
        c = b.queue;
      if (null === c) throw Error(p(311));
      c.lastRenderedReducer = a;
      var d = O,
        e = d.baseQueue,
        f = c.pending;
      if (null !== f) {
        if (null !== e) {
          var g = e.next;
          e.next = f.next;
          f.next = g;
        }
        d.baseQueue = e = f;
        c.pending = null;
      }
      if (null !== e) {
        f = e.next;
        d = d.baseState;
        var h = (g = null),
          k = null,
          l = f;
        do {
          var m = l.lane;
          if ((Rh & m) === m)
            null !== k &&
              (k = k.next =
                {
                  lane: 0,
                  action: l.action,
                  hasEagerState: l.hasEagerState,
                  eagerState: l.eagerState,
                  next: null,
                }),
              (d = l.hasEagerState ? l.eagerState : a(d, l.action));
          else {
            var q = {
              lane: m,
              action: l.action,
              hasEagerState: l.hasEagerState,
              eagerState: l.eagerState,
              next: null,
            };
            null === k ? ((h = k = q), (g = d)) : (k = k.next = q);
            N.lanes |= m;
            hh |= m;
          }
          l = l.next;
        } while (null !== l && l !== f);
        null === k ? (g = d) : (k.next = h);
        He(d, b.memoizedState) || (Ug = true);
        b.memoizedState = d;
        b.baseState = g;
        b.baseQueue = k;
        c.lastRenderedState = d;
      }
      a = c.interleaved;
      if (null !== a) {
        e = a;
        do (f = e.lane), (N.lanes |= f), (hh |= f), (e = e.next);
        while (e !== a);
      } else null === e && (c.lanes = 0);
      return [b.memoizedState, c.dispatch];
    }
    function gi(a) {
      var b = di(),
        c = b.queue;
      if (null === c) throw Error(p(311));
      c.lastRenderedReducer = a;
      var d = c.dispatch,
        e = c.pending,
        f = b.memoizedState;
      if (null !== e) {
        c.pending = null;
        var g = (e = e.next);
        do (f = a(f, g.action)), (g = g.next);
        while (g !== e);
        He(f, b.memoizedState) || (Ug = true);
        b.memoizedState = f;
        null === b.baseQueue && (b.baseState = f);
        c.lastRenderedState = f;
      }
      return [f, d];
    }
    function hi() {}
    function ii(a, b) {
      var c = N,
        d = di(),
        e = b(),
        f = !He(d.memoizedState, e);
      f && ((d.memoizedState = e), (Ug = true));
      d = d.queue;
      ji(ki.bind(null, c, d, a), [a]);
      if (d.getSnapshot !== b || f || (null !== P && P.memoizedState.tag & 1)) {
        c.flags |= 2048;
        li(9, mi.bind(null, c, d, e, b), void 0, null);
        if (null === R) throw Error(p(349));
        0 !== (Rh & 30) || ni(c, b, e);
      }
      return e;
    }
    function ni(a, b, c) {
      a.flags |= 16384;
      a = { getSnapshot: b, value: c };
      b = N.updateQueue;
      null === b
        ? ((b = { lastEffect: null, stores: null }),
          (N.updateQueue = b),
          (b.stores = [a]))
        : ((c = b.stores), null === c ? (b.stores = [a]) : c.push(a));
    }
    function mi(a, b, c, d) {
      b.value = c;
      b.getSnapshot = d;
      oi(b) && pi(a);
    }
    function ki(a, b, c) {
      return c(function () {
        oi(b) && pi(a);
      });
    }
    function oi(a) {
      var b = a.getSnapshot;
      a = a.value;
      try {
        var c = b();
        return !He(a, c);
      } catch (d) {
        return true;
      }
    }
    function pi(a) {
      var b = Zg(a, 1);
      null !== b && mh(b, a, 1, -1);
    }
    function qi(a) {
      var b = ci();
      "function" === typeof a && (a = a());
      b.memoizedState = b.baseState = a;
      a = {
        pending: null,
        interleaved: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: ei,
        lastRenderedState: a,
      };
      b.queue = a;
      a = a.dispatch = ri.bind(null, N, a);
      return [b.memoizedState, a];
    }
    function li(a, b, c, d) {
      a = { tag: a, create: b, destroy: c, deps: d, next: null };
      b = N.updateQueue;
      null === b
        ? ((b = { lastEffect: null, stores: null }),
          (N.updateQueue = b),
          (b.lastEffect = a.next = a))
        : ((c = b.lastEffect),
          null === c
            ? (b.lastEffect = a.next = a)
            : ((d = c.next), (c.next = a), (a.next = d), (b.lastEffect = a)));
      return a;
    }
    function si() {
      return di().memoizedState;
    }
    function ti(a, b, c, d) {
      var e = ci();
      N.flags |= a;
      e.memoizedState = li(1 | b, c, void 0, void 0 === d ? null : d);
    }
    function ui(a, b, c, d) {
      var e = di();
      d = void 0 === d ? null : d;
      var f = void 0;
      if (null !== O) {
        var g = O.memoizedState;
        f = g.destroy;
        if (null !== d && Wh(d, g.deps)) {
          e.memoizedState = li(b, c, f, d);
          return;
        }
      }
      N.flags |= a;
      e.memoizedState = li(1 | b, c, f, d);
    }
    function vi(a, b) {
      return ti(8390656, 8, a, b);
    }
    function ji(a, b) {
      return ui(2048, 8, a, b);
    }
    function wi(a, b) {
      return ui(4, 2, a, b);
    }
    function xi(a, b) {
      return ui(4, 4, a, b);
    }
    function yi(a, b) {
      if ("function" === typeof b)
        return (
          (a = a()),
          b(a),
          function () {
            b(null);
          }
        );
      if (null !== b && void 0 !== b)
        return (
          (a = a()),
          (b.current = a),
          function () {
            b.current = null;
          }
        );
    }
    function zi(a, b, c) {
      c = null !== c && void 0 !== c ? c.concat([a]) : null;
      return ui(4, 4, yi.bind(null, b, a), c);
    }
    function Ai() {}
    function Bi(a, b) {
      var c = di();
      b = void 0 === b ? null : b;
      var d = c.memoizedState;
      if (null !== d && null !== b && Wh(b, d[1])) return d[0];
      c.memoizedState = [a, b];
      return a;
    }
    function Ci(a, b) {
      var c = di();
      b = void 0 === b ? null : b;
      var d = c.memoizedState;
      if (null !== d && null !== b && Wh(b, d[1])) return d[0];
      a = a();
      c.memoizedState = [a, b];
      return a;
    }
    function Di(a, b, c) {
      if (0 === (Rh & 21))
        return (
          a.baseState && ((a.baseState = false), (Ug = true)),
          (a.memoizedState = c)
        );
      He(c, b) || ((c = yc()), (N.lanes |= c), (hh |= c), (a.baseState = true));
      return b;
    }
    function Ei(a, b) {
      var c = C;
      C = 0 !== c && 4 > c ? c : 4;
      a(true);
      var d = Qh.transition;
      Qh.transition = {};
      try {
        a(false), b();
      } finally {
        (C = c), (Qh.transition = d);
      }
    }
    function Fi() {
      return di().memoizedState;
    }
    function Gi(a, b, c) {
      var d = lh(a);
      c = {
        lane: d,
        action: c,
        hasEagerState: false,
        eagerState: null,
        next: null,
      };
      if (Hi(a)) Ii(b, c);
      else if (((c = Yg(a, b, c, d)), null !== c)) {
        var e = L();
        mh(c, a, d, e);
        Ji(c, b, d);
      }
    }
    function ri(a, b, c) {
      var d = lh(a),
        e = {
          lane: d,
          action: c,
          hasEagerState: false,
          eagerState: null,
          next: null,
        };
      if (Hi(a)) Ii(b, e);
      else {
        var f = a.alternate;
        if (
          0 === a.lanes &&
          (null === f || 0 === f.lanes) &&
          ((f = b.lastRenderedReducer), null !== f)
        )
          try {
            var g = b.lastRenderedState,
              h = f(g, c);
            e.hasEagerState = true;
            e.eagerState = h;
            if (He(h, g)) {
              var k = b.interleaved;
              null === k
                ? ((e.next = e), Xg(b))
                : ((e.next = k.next), (k.next = e));
              b.interleaved = e;
              return;
            }
          } catch (l) {
          } finally {
          }
        c = Yg(a, b, e, d);
        null !== c && ((e = L()), mh(c, a, d, e), Ji(c, b, d));
      }
    }
    function Hi(a) {
      var b = a.alternate;
      return a === N || (null !== b && b === N);
    }
    function Ii(a, b) {
      Th = Sh = true;
      var c = a.pending;
      null === c ? (b.next = b) : ((b.next = c.next), (c.next = b));
      a.pending = b;
    }
    function Ji(a, b, c) {
      if (0 !== (c & 4194240)) {
        var d = b.lanes;
        d &= a.pendingLanes;
        c |= d;
        b.lanes = c;
        Cc(a, c);
      }
    }
    var ai = {
      readContext: Vg,
      useCallback: Q,
      useContext: Q,
      useEffect: Q,
      useImperativeHandle: Q,
      useInsertionEffect: Q,
      useLayoutEffect: Q,
      useMemo: Q,
      useReducer: Q,
      useRef: Q,
      useState: Q,
      useDebugValue: Q,
      useDeferredValue: Q,
      useTransition: Q,
      useMutableSource: Q,
      useSyncExternalStore: Q,
      useId: Q,
      unstable_isNewReconciler: false,
    };
    var Yh = {
      readContext: Vg,
      useCallback: function (a, b) {
        ci().memoizedState = [a, void 0 === b ? null : b];
        return a;
      },
      useContext: Vg,
      useEffect: vi,
      useImperativeHandle: function (a, b, c) {
        c = null !== c && void 0 !== c ? c.concat([a]) : null;
        return ti(4194308, 4, yi.bind(null, b, a), c);
      },
      useLayoutEffect: function (a, b) {
        return ti(4194308, 4, a, b);
      },
      useInsertionEffect: function (a, b) {
        return ti(4, 2, a, b);
      },
      useMemo: function (a, b) {
        var c = ci();
        b = void 0 === b ? null : b;
        a = a();
        c.memoizedState = [a, b];
        return a;
      },
      useReducer: function (a, b, c) {
        var d = ci();
        b = void 0 !== c ? c(b) : b;
        d.memoizedState = d.baseState = b;
        a = {
          pending: null,
          interleaved: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: a,
          lastRenderedState: b,
        };
        d.queue = a;
        a = a.dispatch = Gi.bind(null, N, a);
        return [d.memoizedState, a];
      },
      useRef: function (a) {
        var b = ci();
        a = { current: a };
        return (b.memoizedState = a);
      },
      useState: qi,
      useDebugValue: Ai,
      useDeferredValue: function (a) {
        return (ci().memoizedState = a);
      },
      useTransition: function () {
        var a = qi(false),
          b = a[0];
        a = Ei.bind(null, a[1]);
        ci().memoizedState = a;
        return [b, a];
      },
      useMutableSource: function () {},
      useSyncExternalStore: function (a, b, c) {
        var d = N,
          e = ci();
        if (I) {
          if (void 0 === c) throw Error(p(407));
          c = c();
        } else {
          c = b();
          if (null === R) throw Error(p(349));
          0 !== (Rh & 30) || ni(d, b, c);
        }
        e.memoizedState = c;
        var f = { value: c, getSnapshot: b };
        e.queue = f;
        vi(ki.bind(null, d, f, a), [a]);
        d.flags |= 2048;
        li(9, mi.bind(null, d, f, c, b), void 0, null);
        return c;
      },
      useId: function () {
        var a = ci(),
          b = R.identifierPrefix;
        if (I) {
          var c = sg;
          var d = rg;
          c = (d & ~(1 << (32 - oc(d) - 1))).toString(32) + c;
          b = ":" + b + "R" + c;
          c = Uh++;
          0 < c && (b += "H" + c.toString(32));
          b += ":";
        } else (c = Vh++), (b = ":" + b + "r" + c.toString(32) + ":");
        return (a.memoizedState = b);
      },
      unstable_isNewReconciler: false,
    };
    var Zh = {
      readContext: Vg,
      useCallback: Bi,
      useContext: Vg,
      useEffect: ji,
      useImperativeHandle: zi,
      useInsertionEffect: wi,
      useLayoutEffect: xi,
      useMemo: Ci,
      useReducer: fi,
      useRef: si,
      useState: function () {
        return fi(ei);
      },
      useDebugValue: Ai,
      useDeferredValue: function (a) {
        var b = di();
        return Di(b, O.memoizedState, a);
      },
      useTransition: function () {
        var a = fi(ei)[0],
          b = di().memoizedState;
        return [a, b];
      },
      useMutableSource: hi,
      useSyncExternalStore: ii,
      useId: Fi,
      unstable_isNewReconciler: false,
    };
    var $h = {
      readContext: Vg,
      useCallback: Bi,
      useContext: Vg,
      useEffect: ji,
      useImperativeHandle: zi,
      useInsertionEffect: wi,
      useLayoutEffect: xi,
      useMemo: Ci,
      useReducer: gi,
      useRef: si,
      useState: function () {
        return gi(ei);
      },
      useDebugValue: Ai,
      useDeferredValue: function (a) {
        var b = di();
        return null === O ? (b.memoizedState = a) : Di(b, O.memoizedState, a);
      },
      useTransition: function () {
        var a = gi(ei)[0],
          b = di().memoizedState;
        return [a, b];
      },
      useMutableSource: hi,
      useSyncExternalStore: ii,
      useId: Fi,
      unstable_isNewReconciler: false,
    };
    function Ki(a, b) {
      try {
        var c = "",
          d = b;
        do (c += Pa(d)), (d = d.return);
        while (d);
        var e = c;
      } catch (f) {
        e = "\nError generating stack: " + f.message + "\n" + f.stack;
      }
      return { value: a, source: b, stack: e, digest: null };
    }
    function Li(a, b, c) {
      return {
        value: a,
        source: null,
        stack: null != c ? c : null,
        digest: null != b ? b : null,
      };
    }
    function Mi(a, b) {
      try {
        console.error(b.value);
      } catch (c) {
        setTimeout(function () {
          throw c;
        });
      }
    }
    var Ni = "function" === typeof WeakMap ? WeakMap : Map;
    function Oi(a, b, c) {
      c = ch(-1, c);
      c.tag = 3;
      c.payload = { element: null };
      var d = b.value;
      c.callback = function () {
        Pi || ((Pi = true), (Qi = d));
        Mi(a, b);
      };
      return c;
    }
    function Ri(a, b, c) {
      c = ch(-1, c);
      c.tag = 3;
      var d = a.type.getDerivedStateFromError;
      if ("function" === typeof d) {
        var e = b.value;
        c.payload = function () {
          return d(e);
        };
        c.callback = function () {
          Mi(a, b);
        };
      }
      var f = a.stateNode;
      null !== f &&
        "function" === typeof f.componentDidCatch &&
        (c.callback = function () {
          Mi(a, b);
          "function" !== typeof d &&
            (null === Si
              ? (Si = /* @__PURE__ */ new Set([this]))
              : Si.add(this));
          var c2 = b.stack;
          this.componentDidCatch(b.value, {
            componentStack: null !== c2 ? c2 : "",
          });
        });
      return c;
    }
    function Ti(a, b, c) {
      var d = a.pingCache;
      if (null === d) {
        d = a.pingCache = new Ni();
        var e = /* @__PURE__ */ new Set();
        d.set(b, e);
      } else
        (e = d.get(b)),
          void 0 === e && ((e = /* @__PURE__ */ new Set()), d.set(b, e));
      e.has(c) || (e.add(c), (a = Ui.bind(null, a, b, c)), b.then(a, a));
    }
    function Vi(a) {
      do {
        var b;
        if ((b = 13 === a.tag))
          (b = a.memoizedState),
            (b = null !== b ? (null !== b.dehydrated ? true : false) : true);
        if (b) return a;
        a = a.return;
      } while (null !== a);
      return null;
    }
    function Wi(a, b, c, d, e) {
      if (0 === (a.mode & 1))
        return (
          a === b
            ? (a.flags |= 65536)
            : ((a.flags |= 128),
              (c.flags |= 131072),
              (c.flags &= -52805),
              1 === c.tag &&
                (null === c.alternate
                  ? (c.tag = 17)
                  : ((b = ch(-1, 1)), (b.tag = 2), dh(c, b, 1))),
              (c.lanes |= 1)),
          a
        );
      a.flags |= 65536;
      a.lanes = e;
      return a;
    }
    var Xi = ua.ReactCurrentOwner;
    var Ug = false;
    function Yi(a, b, c, d) {
      b.child = null === a ? Ch(b, null, c, d) : Bh(b, a.child, c, d);
    }
    function Zi(a, b, c, d, e) {
      c = c.render;
      var f = b.ref;
      Tg(b, e);
      d = Xh(a, b, c, d, f, e);
      c = bi();
      if (null !== a && !Ug)
        return (
          (b.updateQueue = a.updateQueue),
          (b.flags &= -2053),
          (a.lanes &= ~e),
          $i(a, b, e)
        );
      I && c && vg(b);
      b.flags |= 1;
      Yi(a, b, d, e);
      return b.child;
    }
    function aj(a, b, c, d, e) {
      if (null === a) {
        var f = c.type;
        if (
          "function" === typeof f &&
          !bj(f) &&
          void 0 === f.defaultProps &&
          null === c.compare &&
          void 0 === c.defaultProps
        )
          return (b.tag = 15), (b.type = f), cj(a, b, f, d, e);
        a = yh(c.type, null, d, b, b.mode, e);
        a.ref = b.ref;
        a.return = b;
        return (b.child = a);
      }
      f = a.child;
      if (0 === (a.lanes & e)) {
        var g = f.memoizedProps;
        c = c.compare;
        c = null !== c ? c : Ie;
        if (c(g, d) && a.ref === b.ref) return $i(a, b, e);
      }
      b.flags |= 1;
      a = wh(f, d);
      a.ref = b.ref;
      a.return = b;
      return (b.child = a);
    }
    function cj(a, b, c, d, e) {
      if (null !== a) {
        var f = a.memoizedProps;
        if (Ie(f, d) && a.ref === b.ref)
          if (((Ug = false), (b.pendingProps = d = f), 0 !== (a.lanes & e)))
            0 !== (a.flags & 131072) && (Ug = true);
          else return (b.lanes = a.lanes), $i(a, b, e);
      }
      return dj(a, b, c, d, e);
    }
    function ej(a, b, c) {
      var d = b.pendingProps,
        e = d.children,
        f = null !== a ? a.memoizedState : null;
      if ("hidden" === d.mode)
        if (0 === (b.mode & 1))
          (b.memoizedState = {
            baseLanes: 0,
            cachePool: null,
            transitions: null,
          }),
            G(fj, gj),
            (gj |= c);
        else {
          if (0 === (c & 1073741824))
            return (
              (a = null !== f ? f.baseLanes | c : c),
              (b.lanes = b.childLanes = 1073741824),
              (b.memoizedState = {
                baseLanes: a,
                cachePool: null,
                transitions: null,
              }),
              (b.updateQueue = null),
              G(fj, gj),
              (gj |= a),
              null
            );
          b.memoizedState = {
            baseLanes: 0,
            cachePool: null,
            transitions: null,
          };
          d = null !== f ? f.baseLanes : c;
          G(fj, gj);
          gj |= d;
        }
      else
        null !== f
          ? ((d = f.baseLanes | c), (b.memoizedState = null))
          : (d = c),
          G(fj, gj),
          (gj |= d);
      Yi(a, b, e, c);
      return b.child;
    }
    function hj(a, b) {
      var c = b.ref;
      if ((null === a && null !== c) || (null !== a && a.ref !== c))
        (b.flags |= 512), (b.flags |= 2097152);
    }
    function dj(a, b, c, d, e) {
      var f = Zf(c) ? Xf : H.current;
      f = Yf(b, f);
      Tg(b, e);
      c = Xh(a, b, c, d, f, e);
      d = bi();
      if (null !== a && !Ug)
        return (
          (b.updateQueue = a.updateQueue),
          (b.flags &= -2053),
          (a.lanes &= ~e),
          $i(a, b, e)
        );
      I && d && vg(b);
      b.flags |= 1;
      Yi(a, b, c, e);
      return b.child;
    }
    function ij(a, b, c, d, e) {
      if (Zf(c)) {
        var f = true;
        cg(b);
      } else f = false;
      Tg(b, e);
      if (null === b.stateNode)
        jj(a, b), ph(b, c, d), rh(b, c, d, e), (d = true);
      else if (null === a) {
        var g = b.stateNode,
          h = b.memoizedProps;
        g.props = h;
        var k = g.context,
          l = c.contextType;
        "object" === typeof l && null !== l
          ? (l = Vg(l))
          : ((l = Zf(c) ? Xf : H.current), (l = Yf(b, l)));
        var m = c.getDerivedStateFromProps,
          q =
            "function" === typeof m ||
            "function" === typeof g.getSnapshotBeforeUpdate;
        q ||
          ("function" !== typeof g.UNSAFE_componentWillReceiveProps &&
            "function" !== typeof g.componentWillReceiveProps) ||
          ((h !== d || k !== l) && qh(b, g, d, l));
        $g = false;
        var r = b.memoizedState;
        g.state = r;
        gh(b, d, g, e);
        k = b.memoizedState;
        h !== d || r !== k || Wf.current || $g
          ? ("function" === typeof m && (kh(b, c, m, d), (k = b.memoizedState)),
            (h = $g || oh(b, c, h, d, r, k, l))
              ? (q ||
                  ("function" !== typeof g.UNSAFE_componentWillMount &&
                    "function" !== typeof g.componentWillMount) ||
                  ("function" === typeof g.componentWillMount &&
                    g.componentWillMount(),
                  "function" === typeof g.UNSAFE_componentWillMount &&
                    g.UNSAFE_componentWillMount()),
                "function" === typeof g.componentDidMount &&
                  (b.flags |= 4194308))
              : ("function" === typeof g.componentDidMount &&
                  (b.flags |= 4194308),
                (b.memoizedProps = d),
                (b.memoizedState = k)),
            (g.props = d),
            (g.state = k),
            (g.context = l),
            (d = h))
          : ("function" === typeof g.componentDidMount && (b.flags |= 4194308),
            (d = false));
      } else {
        g = b.stateNode;
        bh(a, b);
        h = b.memoizedProps;
        l = b.type === b.elementType ? h : Lg(b.type, h);
        g.props = l;
        q = b.pendingProps;
        r = g.context;
        k = c.contextType;
        "object" === typeof k && null !== k
          ? (k = Vg(k))
          : ((k = Zf(c) ? Xf : H.current), (k = Yf(b, k)));
        var y = c.getDerivedStateFromProps;
        (m =
          "function" === typeof y ||
          "function" === typeof g.getSnapshotBeforeUpdate) ||
          ("function" !== typeof g.UNSAFE_componentWillReceiveProps &&
            "function" !== typeof g.componentWillReceiveProps) ||
          ((h !== q || r !== k) && qh(b, g, d, k));
        $g = false;
        r = b.memoizedState;
        g.state = r;
        gh(b, d, g, e);
        var n = b.memoizedState;
        h !== q || r !== n || Wf.current || $g
          ? ("function" === typeof y && (kh(b, c, y, d), (n = b.memoizedState)),
            (l = $g || oh(b, c, l, d, r, n, k) || false)
              ? (m ||
                  ("function" !== typeof g.UNSAFE_componentWillUpdate &&
                    "function" !== typeof g.componentWillUpdate) ||
                  ("function" === typeof g.componentWillUpdate &&
                    g.componentWillUpdate(d, n, k),
                  "function" === typeof g.UNSAFE_componentWillUpdate &&
                    g.UNSAFE_componentWillUpdate(d, n, k)),
                "function" === typeof g.componentDidUpdate && (b.flags |= 4),
                "function" === typeof g.getSnapshotBeforeUpdate &&
                  (b.flags |= 1024))
              : ("function" !== typeof g.componentDidUpdate ||
                  (h === a.memoizedProps && r === a.memoizedState) ||
                  (b.flags |= 4),
                "function" !== typeof g.getSnapshotBeforeUpdate ||
                  (h === a.memoizedProps && r === a.memoizedState) ||
                  (b.flags |= 1024),
                (b.memoizedProps = d),
                (b.memoizedState = n)),
            (g.props = d),
            (g.state = n),
            (g.context = k),
            (d = l))
          : ("function" !== typeof g.componentDidUpdate ||
              (h === a.memoizedProps && r === a.memoizedState) ||
              (b.flags |= 4),
            "function" !== typeof g.getSnapshotBeforeUpdate ||
              (h === a.memoizedProps && r === a.memoizedState) ||
              (b.flags |= 1024),
            (d = false));
      }
      return kj(a, b, c, d, f, e);
    }
    function kj(a, b, c, d, e, f) {
      hj(a, b);
      var g = 0 !== (b.flags & 128);
      if (!d && !g) return e && dg(b, c, false), $i(a, b, f);
      d = b.stateNode;
      Xi.current = b;
      var h =
        g && "function" !== typeof c.getDerivedStateFromError
          ? null
          : d.render();
      b.flags |= 1;
      null !== a && g
        ? ((b.child = Bh(b, a.child, null, f)), (b.child = Bh(b, null, h, f)))
        : Yi(a, b, h, f);
      b.memoizedState = d.state;
      e && dg(b, c, true);
      return b.child;
    }
    function lj(a) {
      var b = a.stateNode;
      b.pendingContext
        ? ag(a, b.pendingContext, b.pendingContext !== b.context)
        : b.context && ag(a, b.context, false);
      Ih(a, b.containerInfo);
    }
    function mj(a, b, c, d, e) {
      Ig();
      Jg(e);
      b.flags |= 256;
      Yi(a, b, c, d);
      return b.child;
    }
    var nj = { dehydrated: null, treeContext: null, retryLane: 0 };
    function oj(a) {
      return { baseLanes: a, cachePool: null, transitions: null };
    }
    function pj(a, b, c) {
      var d = b.pendingProps,
        e = M.current,
        f = false,
        g = 0 !== (b.flags & 128),
        h;
      (h = g) ||
        (h = null !== a && null === a.memoizedState ? false : 0 !== (e & 2));
      if (h) (f = true), (b.flags &= -129);
      else if (null === a || null !== a.memoizedState) e |= 1;
      G(M, e & 1);
      if (null === a) {
        Eg(b);
        a = b.memoizedState;
        if (null !== a && ((a = a.dehydrated), null !== a))
          return (
            0 === (b.mode & 1)
              ? (b.lanes = 1)
              : "$!" === a.data
              ? (b.lanes = 8)
              : (b.lanes = 1073741824),
            null
          );
        g = d.children;
        a = d.fallback;
        return f
          ? ((d = b.mode),
            (f = b.child),
            (g = { mode: "hidden", children: g }),
            0 === (d & 1) && null !== f
              ? ((f.childLanes = 0), (f.pendingProps = g))
              : (f = qj(g, d, 0, null)),
            (a = Ah(a, d, c, null)),
            (f.return = b),
            (a.return = b),
            (f.sibling = a),
            (b.child = f),
            (b.child.memoizedState = oj(c)),
            (b.memoizedState = nj),
            a)
          : rj(b, g);
      }
      e = a.memoizedState;
      if (null !== e && ((h = e.dehydrated), null !== h))
        return sj(a, b, g, d, h, e, c);
      if (f) {
        f = d.fallback;
        g = b.mode;
        e = a.child;
        h = e.sibling;
        var k = { mode: "hidden", children: d.children };
        0 === (g & 1) && b.child !== e
          ? ((d = b.child),
            (d.childLanes = 0),
            (d.pendingProps = k),
            (b.deletions = null))
          : ((d = wh(e, k)), (d.subtreeFlags = e.subtreeFlags & 14680064));
        null !== h ? (f = wh(h, f)) : ((f = Ah(f, g, c, null)), (f.flags |= 2));
        f.return = b;
        d.return = b;
        d.sibling = f;
        b.child = d;
        d = f;
        f = b.child;
        g = a.child.memoizedState;
        g =
          null === g
            ? oj(c)
            : {
                baseLanes: g.baseLanes | c,
                cachePool: null,
                transitions: g.transitions,
              };
        f.memoizedState = g;
        f.childLanes = a.childLanes & ~c;
        b.memoizedState = nj;
        return d;
      }
      f = a.child;
      a = f.sibling;
      d = wh(f, { mode: "visible", children: d.children });
      0 === (b.mode & 1) && (d.lanes = c);
      d.return = b;
      d.sibling = null;
      null !== a &&
        ((c = b.deletions),
        null === c ? ((b.deletions = [a]), (b.flags |= 16)) : c.push(a));
      b.child = d;
      b.memoizedState = null;
      return d;
    }
    function rj(a, b) {
      b = qj({ mode: "visible", children: b }, a.mode, 0, null);
      b.return = a;
      return (a.child = b);
    }
    function tj(a, b, c, d) {
      null !== d && Jg(d);
      Bh(b, a.child, null, c);
      a = rj(b, b.pendingProps.children);
      a.flags |= 2;
      b.memoizedState = null;
      return a;
    }
    function sj(a, b, c, d, e, f, g) {
      if (c) {
        if (b.flags & 256)
          return (b.flags &= -257), (d = Li(Error(p(422)))), tj(a, b, g, d);
        if (null !== b.memoizedState)
          return (b.child = a.child), (b.flags |= 128), null;
        f = d.fallback;
        e = b.mode;
        d = qj({ mode: "visible", children: d.children }, e, 0, null);
        f = Ah(f, e, g, null);
        f.flags |= 2;
        d.return = b;
        f.return = b;
        d.sibling = f;
        b.child = d;
        0 !== (b.mode & 1) && Bh(b, a.child, null, g);
        b.child.memoizedState = oj(g);
        b.memoizedState = nj;
        return f;
      }
      if (0 === (b.mode & 1)) return tj(a, b, g, null);
      if ("$!" === e.data) {
        d = e.nextSibling && e.nextSibling.dataset;
        if (d) var h = d.dgst;
        d = h;
        f = Error(p(419));
        d = Li(f, d, void 0);
        return tj(a, b, g, d);
      }
      h = 0 !== (g & a.childLanes);
      if (Ug || h) {
        d = R;
        if (null !== d) {
          switch (g & -g) {
            case 4:
              e = 2;
              break;
            case 16:
              e = 8;
              break;
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
            case 67108864:
              e = 32;
              break;
            case 536870912:
              e = 268435456;
              break;
            default:
              e = 0;
          }
          e = 0 !== (e & (d.suspendedLanes | g)) ? 0 : e;
          0 !== e &&
            e !== f.retryLane &&
            ((f.retryLane = e), Zg(a, e), mh(d, a, e, -1));
        }
        uj();
        d = Li(Error(p(421)));
        return tj(a, b, g, d);
      }
      if ("$?" === e.data)
        return (
          (b.flags |= 128),
          (b.child = a.child),
          (b = vj.bind(null, a)),
          (e._reactRetry = b),
          null
        );
      a = f.treeContext;
      yg = Lf(e.nextSibling);
      xg = b;
      I = true;
      zg = null;
      null !== a &&
        ((og[pg++] = rg),
        (og[pg++] = sg),
        (og[pg++] = qg),
        (rg = a.id),
        (sg = a.overflow),
        (qg = b));
      b = rj(b, d.children);
      b.flags |= 4096;
      return b;
    }
    function wj(a, b, c) {
      a.lanes |= b;
      var d = a.alternate;
      null !== d && (d.lanes |= b);
      Sg(a.return, b, c);
    }
    function xj(a, b, c, d, e) {
      var f = a.memoizedState;
      null === f
        ? (a.memoizedState = {
            isBackwards: b,
            rendering: null,
            renderingStartTime: 0,
            last: d,
            tail: c,
            tailMode: e,
          })
        : ((f.isBackwards = b),
          (f.rendering = null),
          (f.renderingStartTime = 0),
          (f.last = d),
          (f.tail = c),
          (f.tailMode = e));
    }
    function yj(a, b, c) {
      var d = b.pendingProps,
        e = d.revealOrder,
        f = d.tail;
      Yi(a, b, d.children, c);
      d = M.current;
      if (0 !== (d & 2)) (d = (d & 1) | 2), (b.flags |= 128);
      else {
        if (null !== a && 0 !== (a.flags & 128))
          a: for (a = b.child; null !== a; ) {
            if (13 === a.tag) null !== a.memoizedState && wj(a, c, b);
            else if (19 === a.tag) wj(a, c, b);
            else if (null !== a.child) {
              a.child.return = a;
              a = a.child;
              continue;
            }
            if (a === b) break a;
            for (; null === a.sibling; ) {
              if (null === a.return || a.return === b) break a;
              a = a.return;
            }
            a.sibling.return = a.return;
            a = a.sibling;
          }
        d &= 1;
      }
      G(M, d);
      if (0 === (b.mode & 1)) b.memoizedState = null;
      else
        switch (e) {
          case "forwards":
            c = b.child;
            for (e = null; null !== c; )
              (a = c.alternate),
                null !== a && null === Mh(a) && (e = c),
                (c = c.sibling);
            c = e;
            null === c
              ? ((e = b.child), (b.child = null))
              : ((e = c.sibling), (c.sibling = null));
            xj(b, false, e, c, f);
            break;
          case "backwards":
            c = null;
            e = b.child;
            for (b.child = null; null !== e; ) {
              a = e.alternate;
              if (null !== a && null === Mh(a)) {
                b.child = e;
                break;
              }
              a = e.sibling;
              e.sibling = c;
              c = e;
              e = a;
            }
            xj(b, true, c, null, f);
            break;
          case "together":
            xj(b, false, null, null, void 0);
            break;
          default:
            b.memoizedState = null;
        }
      return b.child;
    }
    function jj(a, b) {
      0 === (b.mode & 1) &&
        null !== a &&
        ((a.alternate = null), (b.alternate = null), (b.flags |= 2));
    }
    function $i(a, b, c) {
      null !== a && (b.dependencies = a.dependencies);
      hh |= b.lanes;
      if (0 === (c & b.childLanes)) return null;
      if (null !== a && b.child !== a.child) throw Error(p(153));
      if (null !== b.child) {
        a = b.child;
        c = wh(a, a.pendingProps);
        b.child = c;
        for (c.return = b; null !== a.sibling; )
          (a = a.sibling),
            (c = c.sibling = wh(a, a.pendingProps)),
            (c.return = b);
        c.sibling = null;
      }
      return b.child;
    }
    function zj(a, b, c) {
      switch (b.tag) {
        case 3:
          lj(b);
          Ig();
          break;
        case 5:
          Kh(b);
          break;
        case 1:
          Zf(b.type) && cg(b);
          break;
        case 4:
          Ih(b, b.stateNode.containerInfo);
          break;
        case 10:
          var d = b.type._context,
            e = b.memoizedProps.value;
          G(Mg, d._currentValue);
          d._currentValue = e;
          break;
        case 13:
          d = b.memoizedState;
          if (null !== d) {
            if (null !== d.dehydrated)
              return G(M, M.current & 1), (b.flags |= 128), null;
            if (0 !== (c & b.child.childLanes)) return pj(a, b, c);
            G(M, M.current & 1);
            a = $i(a, b, c);
            return null !== a ? a.sibling : null;
          }
          G(M, M.current & 1);
          break;
        case 19:
          d = 0 !== (c & b.childLanes);
          if (0 !== (a.flags & 128)) {
            if (d) return yj(a, b, c);
            b.flags |= 128;
          }
          e = b.memoizedState;
          null !== e &&
            ((e.rendering = null), (e.tail = null), (e.lastEffect = null));
          G(M, M.current);
          if (d) break;
          else return null;
        case 22:
        case 23:
          return (b.lanes = 0), ej(a, b, c);
      }
      return $i(a, b, c);
    }
    var Aj;
    var Bj;
    var Cj;
    var Dj;
    Aj = function (a, b) {
      for (var c = b.child; null !== c; ) {
        if (5 === c.tag || 6 === c.tag) a.appendChild(c.stateNode);
        else if (4 !== c.tag && null !== c.child) {
          c.child.return = c;
          c = c.child;
          continue;
        }
        if (c === b) break;
        for (; null === c.sibling; ) {
          if (null === c.return || c.return === b) return;
          c = c.return;
        }
        c.sibling.return = c.return;
        c = c.sibling;
      }
    };
    Bj = function () {};
    Cj = function (a, b, c, d) {
      var e = a.memoizedProps;
      if (e !== d) {
        a = b.stateNode;
        Hh(Eh.current);
        var f = null;
        switch (c) {
          case "input":
            e = Ya(a, e);
            d = Ya(a, d);
            f = [];
            break;
          case "select":
            e = A({}, e, { value: void 0 });
            d = A({}, d, { value: void 0 });
            f = [];
            break;
          case "textarea":
            e = gb(a, e);
            d = gb(a, d);
            f = [];
            break;
          default:
            "function" !== typeof e.onClick &&
              "function" === typeof d.onClick &&
              (a.onclick = Bf);
        }
        ub(c, d);
        var g;
        c = null;
        for (l in e)
          if (!d.hasOwnProperty(l) && e.hasOwnProperty(l) && null != e[l])
            if ("style" === l) {
              var h = e[l];
              for (g in h) h.hasOwnProperty(g) && (c || (c = {}), (c[g] = ""));
            } else
              "dangerouslySetInnerHTML" !== l &&
                "children" !== l &&
                "suppressContentEditableWarning" !== l &&
                "suppressHydrationWarning" !== l &&
                "autoFocus" !== l &&
                (ea.hasOwnProperty(l)
                  ? f || (f = [])
                  : (f = f || []).push(l, null));
        for (l in d) {
          var k = d[l];
          h = null != e ? e[l] : void 0;
          if (d.hasOwnProperty(l) && k !== h && (null != k || null != h))
            if ("style" === l)
              if (h) {
                for (g in h)
                  !h.hasOwnProperty(g) ||
                    (k && k.hasOwnProperty(g)) ||
                    (c || (c = {}), (c[g] = ""));
                for (g in k)
                  k.hasOwnProperty(g) &&
                    h[g] !== k[g] &&
                    (c || (c = {}), (c[g] = k[g]));
              } else c || (f || (f = []), f.push(l, c)), (c = k);
            else
              "dangerouslySetInnerHTML" === l
                ? ((k = k ? k.__html : void 0),
                  (h = h ? h.__html : void 0),
                  null != k && h !== k && (f = f || []).push(l, k))
                : "children" === l
                ? ("string" !== typeof k && "number" !== typeof k) ||
                  (f = f || []).push(l, "" + k)
                : "suppressContentEditableWarning" !== l &&
                  "suppressHydrationWarning" !== l &&
                  (ea.hasOwnProperty(l)
                    ? (null != k && "onScroll" === l && D("scroll", a),
                      f || h === k || (f = []))
                    : (f = f || []).push(l, k));
        }
        c && (f = f || []).push("style", c);
        var l = f;
        if ((b.updateQueue = l)) b.flags |= 4;
      }
    };
    Dj = function (a, b, c, d) {
      c !== d && (b.flags |= 4);
    };
    function Ej(a, b) {
      if (!I)
        switch (a.tailMode) {
          case "hidden":
            b = a.tail;
            for (var c = null; null !== b; )
              null !== b.alternate && (c = b), (b = b.sibling);
            null === c ? (a.tail = null) : (c.sibling = null);
            break;
          case "collapsed":
            c = a.tail;
            for (var d = null; null !== c; )
              null !== c.alternate && (d = c), (c = c.sibling);
            null === d
              ? b || null === a.tail
                ? (a.tail = null)
                : (a.tail.sibling = null)
              : (d.sibling = null);
        }
    }
    function S(a) {
      var b = null !== a.alternate && a.alternate.child === a.child,
        c = 0,
        d = 0;
      if (b)
        for (var e = a.child; null !== e; )
          (c |= e.lanes | e.childLanes),
            (d |= e.subtreeFlags & 14680064),
            (d |= e.flags & 14680064),
            (e.return = a),
            (e = e.sibling);
      else
        for (e = a.child; null !== e; )
          (c |= e.lanes | e.childLanes),
            (d |= e.subtreeFlags),
            (d |= e.flags),
            (e.return = a),
            (e = e.sibling);
      a.subtreeFlags |= d;
      a.childLanes = c;
      return b;
    }
    function Fj(a, b, c) {
      var d = b.pendingProps;
      wg(b);
      switch (b.tag) {
        case 2:
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
          return S(b), null;
        case 1:
          return Zf(b.type) && $f(), S(b), null;
        case 3:
          d = b.stateNode;
          Jh();
          E(Wf);
          E(H);
          Oh();
          d.pendingContext &&
            ((d.context = d.pendingContext), (d.pendingContext = null));
          if (null === a || null === a.child)
            Gg(b)
              ? (b.flags |= 4)
              : null === a ||
                (a.memoizedState.isDehydrated && 0 === (b.flags & 256)) ||
                ((b.flags |= 1024), null !== zg && (Gj(zg), (zg = null)));
          Bj(a, b);
          S(b);
          return null;
        case 5:
          Lh(b);
          var e = Hh(Gh.current);
          c = b.type;
          if (null !== a && null != b.stateNode)
            Cj(a, b, c, d, e),
              a.ref !== b.ref && ((b.flags |= 512), (b.flags |= 2097152));
          else {
            if (!d) {
              if (null === b.stateNode) throw Error(p(166));
              S(b);
              return null;
            }
            a = Hh(Eh.current);
            if (Gg(b)) {
              d = b.stateNode;
              c = b.type;
              var f = b.memoizedProps;
              d[Of] = b;
              d[Pf] = f;
              a = 0 !== (b.mode & 1);
              switch (c) {
                case "dialog":
                  D("cancel", d);
                  D("close", d);
                  break;
                case "iframe":
                case "object":
                case "embed":
                  D("load", d);
                  break;
                case "video":
                case "audio":
                  for (e = 0; e < lf.length; e++) D(lf[e], d);
                  break;
                case "source":
                  D("error", d);
                  break;
                case "img":
                case "image":
                case "link":
                  D("error", d);
                  D("load", d);
                  break;
                case "details":
                  D("toggle", d);
                  break;
                case "input":
                  Za(d, f);
                  D("invalid", d);
                  break;
                case "select":
                  d._wrapperState = { wasMultiple: !!f.multiple };
                  D("invalid", d);
                  break;
                case "textarea":
                  hb(d, f), D("invalid", d);
              }
              ub(c, f);
              e = null;
              for (var g in f)
                if (f.hasOwnProperty(g)) {
                  var h = f[g];
                  "children" === g
                    ? "string" === typeof h
                      ? d.textContent !== h &&
                        (true !== f.suppressHydrationWarning &&
                          Af(d.textContent, h, a),
                        (e = ["children", h]))
                      : "number" === typeof h &&
                        d.textContent !== "" + h &&
                        (true !== f.suppressHydrationWarning &&
                          Af(d.textContent, h, a),
                        (e = ["children", "" + h]))
                    : ea.hasOwnProperty(g) &&
                      null != h &&
                      "onScroll" === g &&
                      D("scroll", d);
                }
              switch (c) {
                case "input":
                  Va(d);
                  db(d, f, true);
                  break;
                case "textarea":
                  Va(d);
                  jb(d);
                  break;
                case "select":
                case "option":
                  break;
                default:
                  "function" === typeof f.onClick && (d.onclick = Bf);
              }
              d = e;
              b.updateQueue = d;
              null !== d && (b.flags |= 4);
            } else {
              g = 9 === e.nodeType ? e : e.ownerDocument;
              "http://www.w3.org/1999/xhtml" === a && (a = kb(c));
              "http://www.w3.org/1999/xhtml" === a
                ? "script" === c
                  ? ((a = g.createElement("div")),
                    (a.innerHTML = "<script></script>"),
                    (a = a.removeChild(a.firstChild)))
                  : "string" === typeof d.is
                  ? (a = g.createElement(c, { is: d.is }))
                  : ((a = g.createElement(c)),
                    "select" === c &&
                      ((g = a),
                      d.multiple
                        ? (g.multiple = true)
                        : d.size && (g.size = d.size)))
                : (a = g.createElementNS(a, c));
              a[Of] = b;
              a[Pf] = d;
              Aj(a, b, false, false);
              b.stateNode = a;
              a: {
                g = vb(c, d);
                switch (c) {
                  case "dialog":
                    D("cancel", a);
                    D("close", a);
                    e = d;
                    break;
                  case "iframe":
                  case "object":
                  case "embed":
                    D("load", a);
                    e = d;
                    break;
                  case "video":
                  case "audio":
                    for (e = 0; e < lf.length; e++) D(lf[e], a);
                    e = d;
                    break;
                  case "source":
                    D("error", a);
                    e = d;
                    break;
                  case "img":
                  case "image":
                  case "link":
                    D("error", a);
                    D("load", a);
                    e = d;
                    break;
                  case "details":
                    D("toggle", a);
                    e = d;
                    break;
                  case "input":
                    Za(a, d);
                    e = Ya(a, d);
                    D("invalid", a);
                    break;
                  case "option":
                    e = d;
                    break;
                  case "select":
                    a._wrapperState = { wasMultiple: !!d.multiple };
                    e = A({}, d, { value: void 0 });
                    D("invalid", a);
                    break;
                  case "textarea":
                    hb(a, d);
                    e = gb(a, d);
                    D("invalid", a);
                    break;
                  default:
                    e = d;
                }
                ub(c, e);
                h = e;
                for (f in h)
                  if (h.hasOwnProperty(f)) {
                    var k = h[f];
                    "style" === f
                      ? sb(a, k)
                      : "dangerouslySetInnerHTML" === f
                      ? ((k = k ? k.__html : void 0), null != k && nb(a, k))
                      : "children" === f
                      ? "string" === typeof k
                        ? ("textarea" !== c || "" !== k) && ob(a, k)
                        : "number" === typeof k && ob(a, "" + k)
                      : "suppressContentEditableWarning" !== f &&
                        "suppressHydrationWarning" !== f &&
                        "autoFocus" !== f &&
                        (ea.hasOwnProperty(f)
                          ? null != k && "onScroll" === f && D("scroll", a)
                          : null != k && ta(a, f, k, g));
                  }
                switch (c) {
                  case "input":
                    Va(a);
                    db(a, d, false);
                    break;
                  case "textarea":
                    Va(a);
                    jb(a);
                    break;
                  case "option":
                    null != d.value &&
                      a.setAttribute("value", "" + Sa(d.value));
                    break;
                  case "select":
                    a.multiple = !!d.multiple;
                    f = d.value;
                    null != f
                      ? fb(a, !!d.multiple, f, false)
                      : null != d.defaultValue &&
                        fb(a, !!d.multiple, d.defaultValue, true);
                    break;
                  default:
                    "function" === typeof e.onClick && (a.onclick = Bf);
                }
                switch (c) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    d = !!d.autoFocus;
                    break a;
                  case "img":
                    d = true;
                    break a;
                  default:
                    d = false;
                }
              }
              d && (b.flags |= 4);
            }
            null !== b.ref && ((b.flags |= 512), (b.flags |= 2097152));
          }
          S(b);
          return null;
        case 6:
          if (a && null != b.stateNode) Dj(a, b, a.memoizedProps, d);
          else {
            if ("string" !== typeof d && null === b.stateNode)
              throw Error(p(166));
            c = Hh(Gh.current);
            Hh(Eh.current);
            if (Gg(b)) {
              d = b.stateNode;
              c = b.memoizedProps;
              d[Of] = b;
              if ((f = d.nodeValue !== c)) {
                if (((a = xg), null !== a))
                  switch (a.tag) {
                    case 3:
                      Af(d.nodeValue, c, 0 !== (a.mode & 1));
                      break;
                    case 5:
                      true !== a.memoizedProps.suppressHydrationWarning &&
                        Af(d.nodeValue, c, 0 !== (a.mode & 1));
                  }
              }
              f && (b.flags |= 4);
            } else
              (d = (9 === c.nodeType ? c : c.ownerDocument).createTextNode(d)),
                (d[Of] = b),
                (b.stateNode = d);
          }
          S(b);
          return null;
        case 13:
          E(M);
          d = b.memoizedState;
          if (
            null === a ||
            (null !== a.memoizedState && null !== a.memoizedState.dehydrated)
          ) {
            if (I && null !== yg && 0 !== (b.mode & 1) && 0 === (b.flags & 128))
              Hg(), Ig(), (b.flags |= 98560), (f = false);
            else if (((f = Gg(b)), null !== d && null !== d.dehydrated)) {
              if (null === a) {
                if (!f) throw Error(p(318));
                f = b.memoizedState;
                f = null !== f ? f.dehydrated : null;
                if (!f) throw Error(p(317));
                f[Of] = b;
              } else
                Ig(),
                  0 === (b.flags & 128) && (b.memoizedState = null),
                  (b.flags |= 4);
              S(b);
              f = false;
            } else null !== zg && (Gj(zg), (zg = null)), (f = true);
            if (!f) return b.flags & 65536 ? b : null;
          }
          if (0 !== (b.flags & 128)) return (b.lanes = c), b;
          d = null !== d;
          d !== (null !== a && null !== a.memoizedState) &&
            d &&
            ((b.child.flags |= 8192),
            0 !== (b.mode & 1) &&
              (null === a || 0 !== (M.current & 1)
                ? 0 === T && (T = 3)
                : uj()));
          null !== b.updateQueue && (b.flags |= 4);
          S(b);
          return null;
        case 4:
          return (
            Jh(),
            Bj(a, b),
            null === a && sf(b.stateNode.containerInfo),
            S(b),
            null
          );
        case 10:
          return Rg(b.type._context), S(b), null;
        case 17:
          return Zf(b.type) && $f(), S(b), null;
        case 19:
          E(M);
          f = b.memoizedState;
          if (null === f) return S(b), null;
          d = 0 !== (b.flags & 128);
          g = f.rendering;
          if (null === g)
            if (d) Ej(f, false);
            else {
              if (0 !== T || (null !== a && 0 !== (a.flags & 128)))
                for (a = b.child; null !== a; ) {
                  g = Mh(a);
                  if (null !== g) {
                    b.flags |= 128;
                    Ej(f, false);
                    d = g.updateQueue;
                    null !== d && ((b.updateQueue = d), (b.flags |= 4));
                    b.subtreeFlags = 0;
                    d = c;
                    for (c = b.child; null !== c; )
                      (f = c),
                        (a = d),
                        (f.flags &= 14680066),
                        (g = f.alternate),
                        null === g
                          ? ((f.childLanes = 0),
                            (f.lanes = a),
                            (f.child = null),
                            (f.subtreeFlags = 0),
                            (f.memoizedProps = null),
                            (f.memoizedState = null),
                            (f.updateQueue = null),
                            (f.dependencies = null),
                            (f.stateNode = null))
                          : ((f.childLanes = g.childLanes),
                            (f.lanes = g.lanes),
                            (f.child = g.child),
                            (f.subtreeFlags = 0),
                            (f.deletions = null),
                            (f.memoizedProps = g.memoizedProps),
                            (f.memoizedState = g.memoizedState),
                            (f.updateQueue = g.updateQueue),
                            (f.type = g.type),
                            (a = g.dependencies),
                            (f.dependencies =
                              null === a
                                ? null
                                : {
                                    lanes: a.lanes,
                                    firstContext: a.firstContext,
                                  })),
                        (c = c.sibling);
                    G(M, (M.current & 1) | 2);
                    return b.child;
                  }
                  a = a.sibling;
                }
              null !== f.tail &&
                B() > Hj &&
                ((b.flags |= 128),
                (d = true),
                Ej(f, false),
                (b.lanes = 4194304));
            }
          else {
            if (!d)
              if (((a = Mh(g)), null !== a)) {
                if (
                  ((b.flags |= 128),
                  (d = true),
                  (c = a.updateQueue),
                  null !== c && ((b.updateQueue = c), (b.flags |= 4)),
                  Ej(f, true),
                  null === f.tail &&
                    "hidden" === f.tailMode &&
                    !g.alternate &&
                    !I)
                )
                  return S(b), null;
              } else
                2 * B() - f.renderingStartTime > Hj &&
                  1073741824 !== c &&
                  ((b.flags |= 128),
                  (d = true),
                  Ej(f, false),
                  (b.lanes = 4194304));
            f.isBackwards
              ? ((g.sibling = b.child), (b.child = g))
              : ((c = f.last),
                null !== c ? (c.sibling = g) : (b.child = g),
                (f.last = g));
          }
          if (null !== f.tail)
            return (
              (b = f.tail),
              (f.rendering = b),
              (f.tail = b.sibling),
              (f.renderingStartTime = B()),
              (b.sibling = null),
              (c = M.current),
              G(M, d ? (c & 1) | 2 : c & 1),
              b
            );
          S(b);
          return null;
        case 22:
        case 23:
          return (
            Ij(),
            (d = null !== b.memoizedState),
            null !== a && (null !== a.memoizedState) !== d && (b.flags |= 8192),
            d && 0 !== (b.mode & 1)
              ? 0 !== (gj & 1073741824) &&
                (S(b), b.subtreeFlags & 6 && (b.flags |= 8192))
              : S(b),
            null
          );
        case 24:
          return null;
        case 25:
          return null;
      }
      throw Error(p(156, b.tag));
    }
    function Jj(a, b) {
      wg(b);
      switch (b.tag) {
        case 1:
          return (
            Zf(b.type) && $f(),
            (a = b.flags),
            a & 65536 ? ((b.flags = (a & -65537) | 128), b) : null
          );
        case 3:
          return (
            Jh(),
            E(Wf),
            E(H),
            Oh(),
            (a = b.flags),
            0 !== (a & 65536) && 0 === (a & 128)
              ? ((b.flags = (a & -65537) | 128), b)
              : null
          );
        case 5:
          return Lh(b), null;
        case 13:
          E(M);
          a = b.memoizedState;
          if (null !== a && null !== a.dehydrated) {
            if (null === b.alternate) throw Error(p(340));
            Ig();
          }
          a = b.flags;
          return a & 65536 ? ((b.flags = (a & -65537) | 128), b) : null;
        case 19:
          return E(M), null;
        case 4:
          return Jh(), null;
        case 10:
          return Rg(b.type._context), null;
        case 22:
        case 23:
          return Ij(), null;
        case 24:
          return null;
        default:
          return null;
      }
    }
    var Kj = false;
    var U = false;
    var Lj = "function" === typeof WeakSet ? WeakSet : Set;
    var V = null;
    function Mj(a, b) {
      var c = a.ref;
      if (null !== c)
        if ("function" === typeof c)
          try {
            c(null);
          } catch (d) {
            W(a, b, d);
          }
        else c.current = null;
    }
    function Nj(a, b, c) {
      try {
        c();
      } catch (d) {
        W(a, b, d);
      }
    }
    var Oj = false;
    function Pj(a, b) {
      Cf = dd;
      a = Me();
      if (Ne(a)) {
        if ("selectionStart" in a)
          var c = { start: a.selectionStart, end: a.selectionEnd };
        else
          a: {
            c = ((c = a.ownerDocument) && c.defaultView) || window;
            var d = c.getSelection && c.getSelection();
            if (d && 0 !== d.rangeCount) {
              c = d.anchorNode;
              var e = d.anchorOffset,
                f = d.focusNode;
              d = d.focusOffset;
              try {
                c.nodeType, f.nodeType;
              } catch (F) {
                c = null;
                break a;
              }
              var g = 0,
                h = -1,
                k = -1,
                l = 0,
                m = 0,
                q = a,
                r = null;
              b: for (;;) {
                for (var y; ; ) {
                  q !== c || (0 !== e && 3 !== q.nodeType) || (h = g + e);
                  q !== f || (0 !== d && 3 !== q.nodeType) || (k = g + d);
                  3 === q.nodeType && (g += q.nodeValue.length);
                  if (null === (y = q.firstChild)) break;
                  r = q;
                  q = y;
                }
                for (;;) {
                  if (q === a) break b;
                  r === c && ++l === e && (h = g);
                  r === f && ++m === d && (k = g);
                  if (null !== (y = q.nextSibling)) break;
                  q = r;
                  r = q.parentNode;
                }
                q = y;
              }
              c = -1 === h || -1 === k ? null : { start: h, end: k };
            } else c = null;
          }
        c = c || { start: 0, end: 0 };
      } else c = null;
      Df = { focusedElem: a, selectionRange: c };
      dd = false;
      for (V = b; null !== V; )
        if (
          ((b = V), (a = b.child), 0 !== (b.subtreeFlags & 1028) && null !== a)
        )
          (a.return = b), (V = a);
        else
          for (; null !== V; ) {
            b = V;
            try {
              var n = b.alternate;
              if (0 !== (b.flags & 1024))
                switch (b.tag) {
                  case 0:
                  case 11:
                  case 15:
                    break;
                  case 1:
                    if (null !== n) {
                      var t = n.memoizedProps,
                        J = n.memoizedState,
                        x = b.stateNode,
                        w = x.getSnapshotBeforeUpdate(
                          b.elementType === b.type ? t : Lg(b.type, t),
                          J
                        );
                      x.__reactInternalSnapshotBeforeUpdate = w;
                    }
                    break;
                  case 3:
                    var u = b.stateNode.containerInfo;
                    1 === u.nodeType
                      ? (u.textContent = "")
                      : 9 === u.nodeType &&
                        u.documentElement &&
                        u.removeChild(u.documentElement);
                    break;
                  case 5:
                  case 6:
                  case 4:
                  case 17:
                    break;
                  default:
                    throw Error(p(163));
                }
            } catch (F) {
              W(b, b.return, F);
            }
            a = b.sibling;
            if (null !== a) {
              a.return = b.return;
              V = a;
              break;
            }
            V = b.return;
          }
      n = Oj;
      Oj = false;
      return n;
    }
    function Qj(a, b, c) {
      var d = b.updateQueue;
      d = null !== d ? d.lastEffect : null;
      if (null !== d) {
        var e = (d = d.next);
        do {
          if ((e.tag & a) === a) {
            var f = e.destroy;
            e.destroy = void 0;
            void 0 !== f && Nj(b, c, f);
          }
          e = e.next;
        } while (e !== d);
      }
    }
    function Rj(a, b) {
      b = b.updateQueue;
      b = null !== b ? b.lastEffect : null;
      if (null !== b) {
        var c = (b = b.next);
        do {
          if ((c.tag & a) === a) {
            var d = c.create;
            c.destroy = d();
          }
          c = c.next;
        } while (c !== b);
      }
    }
    function Sj(a) {
      var b = a.ref;
      if (null !== b) {
        var c = a.stateNode;
        switch (a.tag) {
          case 5:
            a = c;
            break;
          default:
            a = c;
        }
        "function" === typeof b ? b(a) : (b.current = a);
      }
    }
    function Tj(a) {
      var b = a.alternate;
      null !== b && ((a.alternate = null), Tj(b));
      a.child = null;
      a.deletions = null;
      a.sibling = null;
      5 === a.tag &&
        ((b = a.stateNode),
        null !== b &&
          (delete b[Of],
          delete b[Pf],
          delete b[of],
          delete b[Qf],
          delete b[Rf]));
      a.stateNode = null;
      a.return = null;
      a.dependencies = null;
      a.memoizedProps = null;
      a.memoizedState = null;
      a.pendingProps = null;
      a.stateNode = null;
      a.updateQueue = null;
    }
    function Uj(a) {
      return 5 === a.tag || 3 === a.tag || 4 === a.tag;
    }
    function Vj(a) {
      a: for (;;) {
        for (; null === a.sibling; ) {
          if (null === a.return || Uj(a.return)) return null;
          a = a.return;
        }
        a.sibling.return = a.return;
        for (a = a.sibling; 5 !== a.tag && 6 !== a.tag && 18 !== a.tag; ) {
          if (a.flags & 2) continue a;
          if (null === a.child || 4 === a.tag) continue a;
          else (a.child.return = a), (a = a.child);
        }
        if (!(a.flags & 2)) return a.stateNode;
      }
    }
    function Wj(a, b, c) {
      var d = a.tag;
      if (5 === d || 6 === d)
        (a = a.stateNode),
          b
            ? 8 === c.nodeType
              ? c.parentNode.insertBefore(a, b)
              : c.insertBefore(a, b)
            : (8 === c.nodeType
                ? ((b = c.parentNode), b.insertBefore(a, c))
                : ((b = c), b.appendChild(a)),
              (c = c._reactRootContainer),
              (null !== c && void 0 !== c) ||
                null !== b.onclick ||
                (b.onclick = Bf));
      else if (4 !== d && ((a = a.child), null !== a))
        for (Wj(a, b, c), a = a.sibling; null !== a; )
          Wj(a, b, c), (a = a.sibling);
    }
    function Xj(a, b, c) {
      var d = a.tag;
      if (5 === d || 6 === d)
        (a = a.stateNode), b ? c.insertBefore(a, b) : c.appendChild(a);
      else if (4 !== d && ((a = a.child), null !== a))
        for (Xj(a, b, c), a = a.sibling; null !== a; )
          Xj(a, b, c), (a = a.sibling);
    }
    var X = null;
    var Yj = false;
    function Zj(a, b, c) {
      for (c = c.child; null !== c; ) ak(a, b, c), (c = c.sibling);
    }
    function ak(a, b, c) {
      if (lc && "function" === typeof lc.onCommitFiberUnmount)
        try {
          lc.onCommitFiberUnmount(kc, c);
        } catch (h) {}
      switch (c.tag) {
        case 5:
          U || Mj(c, b);
        case 6:
          var d = X,
            e = Yj;
          X = null;
          Zj(a, b, c);
          X = d;
          Yj = e;
          null !== X &&
            (Yj
              ? ((a = X),
                (c = c.stateNode),
                8 === a.nodeType
                  ? a.parentNode.removeChild(c)
                  : a.removeChild(c))
              : X.removeChild(c.stateNode));
          break;
        case 18:
          null !== X &&
            (Yj
              ? ((a = X),
                (c = c.stateNode),
                8 === a.nodeType
                  ? Kf(a.parentNode, c)
                  : 1 === a.nodeType && Kf(a, c),
                bd(a))
              : Kf(X, c.stateNode));
          break;
        case 4:
          d = X;
          e = Yj;
          X = c.stateNode.containerInfo;
          Yj = true;
          Zj(a, b, c);
          X = d;
          Yj = e;
          break;
        case 0:
        case 11:
        case 14:
        case 15:
          if (
            !U &&
            ((d = c.updateQueue),
            null !== d && ((d = d.lastEffect), null !== d))
          ) {
            e = d = d.next;
            do {
              var f = e,
                g = f.destroy;
              f = f.tag;
              void 0 !== g &&
                (0 !== (f & 2) ? Nj(c, b, g) : 0 !== (f & 4) && Nj(c, b, g));
              e = e.next;
            } while (e !== d);
          }
          Zj(a, b, c);
          break;
        case 1:
          if (
            !U &&
            (Mj(c, b),
            (d = c.stateNode),
            "function" === typeof d.componentWillUnmount)
          )
            try {
              (d.props = c.memoizedProps),
                (d.state = c.memoizedState),
                d.componentWillUnmount();
            } catch (h) {
              W(c, b, h);
            }
          Zj(a, b, c);
          break;
        case 21:
          Zj(a, b, c);
          break;
        case 22:
          c.mode & 1
            ? ((U = (d = U) || null !== c.memoizedState), Zj(a, b, c), (U = d))
            : Zj(a, b, c);
          break;
        default:
          Zj(a, b, c);
      }
    }
    function bk(a) {
      var b = a.updateQueue;
      if (null !== b) {
        a.updateQueue = null;
        var c = a.stateNode;
        null === c && (c = a.stateNode = new Lj());
        b.forEach(function (b2) {
          var d = ck.bind(null, a, b2);
          c.has(b2) || (c.add(b2), b2.then(d, d));
        });
      }
    }
    function dk(a, b) {
      var c = b.deletions;
      if (null !== c)
        for (var d = 0; d < c.length; d++) {
          var e = c[d];
          try {
            var f = a,
              g = b,
              h = g;
            a: for (; null !== h; ) {
              switch (h.tag) {
                case 5:
                  X = h.stateNode;
                  Yj = false;
                  break a;
                case 3:
                  X = h.stateNode.containerInfo;
                  Yj = true;
                  break a;
                case 4:
                  X = h.stateNode.containerInfo;
                  Yj = true;
                  break a;
              }
              h = h.return;
            }
            if (null === X) throw Error(p(160));
            ak(f, g, e);
            X = null;
            Yj = false;
            var k = e.alternate;
            null !== k && (k.return = null);
            e.return = null;
          } catch (l) {
            W(e, b, l);
          }
        }
      if (b.subtreeFlags & 12854)
        for (b = b.child; null !== b; ) ek(b, a), (b = b.sibling);
    }
    function ek(a, b) {
      var c = a.alternate,
        d = a.flags;
      switch (a.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          dk(b, a);
          fk(a);
          if (d & 4) {
            try {
              Qj(3, a, a.return), Rj(3, a);
            } catch (t) {
              W(a, a.return, t);
            }
            try {
              Qj(5, a, a.return);
            } catch (t) {
              W(a, a.return, t);
            }
          }
          break;
        case 1:
          dk(b, a);
          fk(a);
          d & 512 && null !== c && Mj(c, c.return);
          break;
        case 5:
          dk(b, a);
          fk(a);
          d & 512 && null !== c && Mj(c, c.return);
          if (a.flags & 32) {
            var e = a.stateNode;
            try {
              ob(e, "");
            } catch (t) {
              W(a, a.return, t);
            }
          }
          if (d & 4 && ((e = a.stateNode), null != e)) {
            var f = a.memoizedProps,
              g = null !== c ? c.memoizedProps : f,
              h = a.type,
              k = a.updateQueue;
            a.updateQueue = null;
            if (null !== k)
              try {
                "input" === h &&
                  "radio" === f.type &&
                  null != f.name &&
                  ab(e, f);
                vb(h, g);
                var l = vb(h, f);
                for (g = 0; g < k.length; g += 2) {
                  var m = k[g],
                    q = k[g + 1];
                  "style" === m
                    ? sb(e, q)
                    : "dangerouslySetInnerHTML" === m
                    ? nb(e, q)
                    : "children" === m
                    ? ob(e, q)
                    : ta(e, m, q, l);
                }
                switch (h) {
                  case "input":
                    bb(e, f);
                    break;
                  case "textarea":
                    ib(e, f);
                    break;
                  case "select":
                    var r = e._wrapperState.wasMultiple;
                    e._wrapperState.wasMultiple = !!f.multiple;
                    var y = f.value;
                    null != y
                      ? fb(e, !!f.multiple, y, false)
                      : r !== !!f.multiple &&
                        (null != f.defaultValue
                          ? fb(e, !!f.multiple, f.defaultValue, true)
                          : fb(e, !!f.multiple, f.multiple ? [] : "", false));
                }
                e[Pf] = f;
              } catch (t) {
                W(a, a.return, t);
              }
          }
          break;
        case 6:
          dk(b, a);
          fk(a);
          if (d & 4) {
            if (null === a.stateNode) throw Error(p(162));
            e = a.stateNode;
            f = a.memoizedProps;
            try {
              e.nodeValue = f;
            } catch (t) {
              W(a, a.return, t);
            }
          }
          break;
        case 3:
          dk(b, a);
          fk(a);
          if (d & 4 && null !== c && c.memoizedState.isDehydrated)
            try {
              bd(b.containerInfo);
            } catch (t) {
              W(a, a.return, t);
            }
          break;
        case 4:
          dk(b, a);
          fk(a);
          break;
        case 13:
          dk(b, a);
          fk(a);
          e = a.child;
          e.flags & 8192 &&
            ((f = null !== e.memoizedState),
            (e.stateNode.isHidden = f),
            !f ||
              (null !== e.alternate && null !== e.alternate.memoizedState) ||
              (gk = B()));
          d & 4 && bk(a);
          break;
        case 22:
          m = null !== c && null !== c.memoizedState;
          a.mode & 1 ? ((U = (l = U) || m), dk(b, a), (U = l)) : dk(b, a);
          fk(a);
          if (d & 8192) {
            l = null !== a.memoizedState;
            if ((a.stateNode.isHidden = l) && !m && 0 !== (a.mode & 1))
              for (V = a, m = a.child; null !== m; ) {
                for (q = V = m; null !== V; ) {
                  r = V;
                  y = r.child;
                  switch (r.tag) {
                    case 0:
                    case 11:
                    case 14:
                    case 15:
                      Qj(4, r, r.return);
                      break;
                    case 1:
                      Mj(r, r.return);
                      var n = r.stateNode;
                      if ("function" === typeof n.componentWillUnmount) {
                        d = r;
                        c = r.return;
                        try {
                          (b = d),
                            (n.props = b.memoizedProps),
                            (n.state = b.memoizedState),
                            n.componentWillUnmount();
                        } catch (t) {
                          W(d, c, t);
                        }
                      }
                      break;
                    case 5:
                      Mj(r, r.return);
                      break;
                    case 22:
                      if (null !== r.memoizedState) {
                        hk(q);
                        continue;
                      }
                  }
                  null !== y ? ((y.return = r), (V = y)) : hk(q);
                }
                m = m.sibling;
              }
            a: for (m = null, q = a; ; ) {
              if (5 === q.tag) {
                if (null === m) {
                  m = q;
                  try {
                    (e = q.stateNode),
                      l
                        ? ((f = e.style),
                          "function" === typeof f.setProperty
                            ? f.setProperty("display", "none", "important")
                            : (f.display = "none"))
                        : ((h = q.stateNode),
                          (k = q.memoizedProps.style),
                          (g =
                            void 0 !== k &&
                            null !== k &&
                            k.hasOwnProperty("display")
                              ? k.display
                              : null),
                          (h.style.display = rb("display", g)));
                  } catch (t) {
                    W(a, a.return, t);
                  }
                }
              } else if (6 === q.tag) {
                if (null === m)
                  try {
                    q.stateNode.nodeValue = l ? "" : q.memoizedProps;
                  } catch (t) {
                    W(a, a.return, t);
                  }
              } else if (
                ((22 !== q.tag && 23 !== q.tag) ||
                  null === q.memoizedState ||
                  q === a) &&
                null !== q.child
              ) {
                q.child.return = q;
                q = q.child;
                continue;
              }
              if (q === a) break a;
              for (; null === q.sibling; ) {
                if (null === q.return || q.return === a) break a;
                m === q && (m = null);
                q = q.return;
              }
              m === q && (m = null);
              q.sibling.return = q.return;
              q = q.sibling;
            }
          }
          break;
        case 19:
          dk(b, a);
          fk(a);
          d & 4 && bk(a);
          break;
        case 21:
          break;
        default:
          dk(b, a), fk(a);
      }
    }
    function fk(a) {
      var b = a.flags;
      if (b & 2) {
        try {
          a: {
            for (var c = a.return; null !== c; ) {
              if (Uj(c)) {
                var d = c;
                break a;
              }
              c = c.return;
            }
            throw Error(p(160));
          }
          switch (d.tag) {
            case 5:
              var e = d.stateNode;
              d.flags & 32 && (ob(e, ""), (d.flags &= -33));
              var f = Vj(a);
              Xj(a, f, e);
              break;
            case 3:
            case 4:
              var g = d.stateNode.containerInfo,
                h = Vj(a);
              Wj(a, h, g);
              break;
            default:
              throw Error(p(161));
          }
        } catch (k) {
          W(a, a.return, k);
        }
        a.flags &= -3;
      }
      b & 4096 && (a.flags &= -4097);
    }
    function ik(a, b, c) {
      V = a;
      jk(a);
    }
    function jk(a, b, c) {
      for (var d = 0 !== (a.mode & 1); null !== V; ) {
        var e = V,
          f = e.child;
        if (22 === e.tag && d) {
          var g = null !== e.memoizedState || Kj;
          if (!g) {
            var h = e.alternate,
              k = (null !== h && null !== h.memoizedState) || U;
            h = Kj;
            var l = U;
            Kj = g;
            if ((U = k) && !l)
              for (V = e; null !== V; )
                (g = V),
                  (k = g.child),
                  22 === g.tag && null !== g.memoizedState
                    ? kk(e)
                    : null !== k
                    ? ((k.return = g), (V = k))
                    : kk(e);
            for (; null !== f; ) (V = f), jk(f), (f = f.sibling);
            V = e;
            Kj = h;
            U = l;
          }
          lk(a);
        } else
          0 !== (e.subtreeFlags & 8772) && null !== f
            ? ((f.return = e), (V = f))
            : lk(a);
      }
    }
    function lk(a) {
      for (; null !== V; ) {
        var b = V;
        if (0 !== (b.flags & 8772)) {
          var c = b.alternate;
          try {
            if (0 !== (b.flags & 8772))
              switch (b.tag) {
                case 0:
                case 11:
                case 15:
                  U || Rj(5, b);
                  break;
                case 1:
                  var d = b.stateNode;
                  if (b.flags & 4 && !U)
                    if (null === c) d.componentDidMount();
                    else {
                      var e =
                        b.elementType === b.type
                          ? c.memoizedProps
                          : Lg(b.type, c.memoizedProps);
                      d.componentDidUpdate(
                        e,
                        c.memoizedState,
                        d.__reactInternalSnapshotBeforeUpdate
                      );
                    }
                  var f = b.updateQueue;
                  null !== f && ih(b, f, d);
                  break;
                case 3:
                  var g = b.updateQueue;
                  if (null !== g) {
                    c = null;
                    if (null !== b.child)
                      switch (b.child.tag) {
                        case 5:
                          c = b.child.stateNode;
                          break;
                        case 1:
                          c = b.child.stateNode;
                      }
                    ih(b, g, c);
                  }
                  break;
                case 5:
                  var h = b.stateNode;
                  if (null === c && b.flags & 4) {
                    c = h;
                    var k = b.memoizedProps;
                    switch (b.type) {
                      case "button":
                      case "input":
                      case "select":
                      case "textarea":
                        k.autoFocus && c.focus();
                        break;
                      case "img":
                        k.src && (c.src = k.src);
                    }
                  }
                  break;
                case 6:
                  break;
                case 4:
                  break;
                case 12:
                  break;
                case 13:
                  if (null === b.memoizedState) {
                    var l = b.alternate;
                    if (null !== l) {
                      var m = l.memoizedState;
                      if (null !== m) {
                        var q = m.dehydrated;
                        null !== q && bd(q);
                      }
                    }
                  }
                  break;
                case 19:
                case 17:
                case 21:
                case 22:
                case 23:
                case 25:
                  break;
                default:
                  throw Error(p(163));
              }
            U || (b.flags & 512 && Sj(b));
          } catch (r) {
            W(b, b.return, r);
          }
        }
        if (b === a) {
          V = null;
          break;
        }
        c = b.sibling;
        if (null !== c) {
          c.return = b.return;
          V = c;
          break;
        }
        V = b.return;
      }
    }
    function hk(a) {
      for (; null !== V; ) {
        var b = V;
        if (b === a) {
          V = null;
          break;
        }
        var c = b.sibling;
        if (null !== c) {
          c.return = b.return;
          V = c;
          break;
        }
        V = b.return;
      }
    }
    function kk(a) {
      for (; null !== V; ) {
        var b = V;
        try {
          switch (b.tag) {
            case 0:
            case 11:
            case 15:
              var c = b.return;
              try {
                Rj(4, b);
              } catch (k) {
                W(b, c, k);
              }
              break;
            case 1:
              var d = b.stateNode;
              if ("function" === typeof d.componentDidMount) {
                var e = b.return;
                try {
                  d.componentDidMount();
                } catch (k) {
                  W(b, e, k);
                }
              }
              var f = b.return;
              try {
                Sj(b);
              } catch (k) {
                W(b, f, k);
              }
              break;
            case 5:
              var g = b.return;
              try {
                Sj(b);
              } catch (k) {
                W(b, g, k);
              }
          }
        } catch (k) {
          W(b, b.return, k);
        }
        if (b === a) {
          V = null;
          break;
        }
        var h = b.sibling;
        if (null !== h) {
          h.return = b.return;
          V = h;
          break;
        }
        V = b.return;
      }
    }
    var mk = Math.ceil;
    var nk = ua.ReactCurrentDispatcher;
    var ok = ua.ReactCurrentOwner;
    var pk = ua.ReactCurrentBatchConfig;
    var K = 0;
    var R = null;
    var Y = null;
    var Z = 0;
    var gj = 0;
    var fj = Uf(0);
    var T = 0;
    var qk = null;
    var hh = 0;
    var rk = 0;
    var sk = 0;
    var tk = null;
    var uk = null;
    var gk = 0;
    var Hj = Infinity;
    var vk = null;
    var Pi = false;
    var Qi = null;
    var Si = null;
    var wk = false;
    var xk = null;
    var yk = 0;
    var zk = 0;
    var Ak = null;
    var Bk = -1;
    var Ck = 0;
    function L() {
      return 0 !== (K & 6) ? B() : -1 !== Bk ? Bk : (Bk = B());
    }
    function lh(a) {
      if (0 === (a.mode & 1)) return 1;
      if (0 !== (K & 2) && 0 !== Z) return Z & -Z;
      if (null !== Kg.transition) return 0 === Ck && (Ck = yc()), Ck;
      a = C;
      if (0 !== a) return a;
      a = window.event;
      a = void 0 === a ? 16 : jd(a.type);
      return a;
    }
    function mh(a, b, c, d) {
      if (50 < zk) throw ((zk = 0), (Ak = null), Error(p(185)));
      Ac(a, c, d);
      if (0 === (K & 2) || a !== R)
        a === R && (0 === (K & 2) && (rk |= c), 4 === T && Dk(a, Z)),
          Ek(a, d),
          1 === c &&
            0 === K &&
            0 === (b.mode & 1) &&
            ((Hj = B() + 500), fg && jg());
    }
    function Ek(a, b) {
      var c = a.callbackNode;
      wc(a, b);
      var d = uc(a, a === R ? Z : 0);
      if (0 === d)
        null !== c && bc(c), (a.callbackNode = null), (a.callbackPriority = 0);
      else if (((b = d & -d), a.callbackPriority !== b)) {
        null != c && bc(c);
        if (1 === b)
          0 === a.tag ? ig(Fk.bind(null, a)) : hg(Fk.bind(null, a)),
            Jf(function () {
              0 === (K & 6) && jg();
            }),
            (c = null);
        else {
          switch (Dc(d)) {
            case 1:
              c = fc;
              break;
            case 4:
              c = gc;
              break;
            case 16:
              c = hc;
              break;
            case 536870912:
              c = jc;
              break;
            default:
              c = hc;
          }
          c = Gk(c, Hk.bind(null, a));
        }
        a.callbackPriority = b;
        a.callbackNode = c;
      }
    }
    function Hk(a, b) {
      Bk = -1;
      Ck = 0;
      if (0 !== (K & 6)) throw Error(p(327));
      var c = a.callbackNode;
      if (Ik() && a.callbackNode !== c) return null;
      var d = uc(a, a === R ? Z : 0);
      if (0 === d) return null;
      if (0 !== (d & 30) || 0 !== (d & a.expiredLanes) || b) b = Jk(a, d);
      else {
        b = d;
        var e = K;
        K |= 2;
        var f = Kk();
        if (R !== a || Z !== b) (vk = null), (Hj = B() + 500), Lk(a, b);
        do
          try {
            Mk();
            break;
          } catch (h) {
            Nk(a, h);
          }
        while (1);
        Qg();
        nk.current = f;
        K = e;
        null !== Y ? (b = 0) : ((R = null), (Z = 0), (b = T));
      }
      if (0 !== b) {
        2 === b && ((e = xc(a)), 0 !== e && ((d = e), (b = Ok(a, e))));
        if (1 === b) throw ((c = qk), Lk(a, 0), Dk(a, d), Ek(a, B()), c);
        if (6 === b) Dk(a, d);
        else {
          e = a.current.alternate;
          if (
            0 === (d & 30) &&
            !Pk(e) &&
            ((b = Jk(a, d)),
            2 === b && ((f = xc(a)), 0 !== f && ((d = f), (b = Ok(a, f)))),
            1 === b)
          )
            throw ((c = qk), Lk(a, 0), Dk(a, d), Ek(a, B()), c);
          a.finishedWork = e;
          a.finishedLanes = d;
          switch (b) {
            case 0:
            case 1:
              throw Error(p(345));
            case 2:
              Qk(a, uk, vk);
              break;
            case 3:
              Dk(a, d);
              if ((d & 130023424) === d && ((b = gk + 500 - B()), 10 < b)) {
                if (0 !== uc(a, 0)) break;
                e = a.suspendedLanes;
                if ((e & d) !== d) {
                  L();
                  a.pingedLanes |= a.suspendedLanes & e;
                  break;
                }
                a.timeoutHandle = Ff(Qk.bind(null, a, uk, vk), b);
                break;
              }
              Qk(a, uk, vk);
              break;
            case 4:
              Dk(a, d);
              if ((d & 4194240) === d) break;
              b = a.eventTimes;
              for (e = -1; 0 < d; ) {
                var g = 31 - oc(d);
                f = 1 << g;
                g = b[g];
                g > e && (e = g);
                d &= ~f;
              }
              d = e;
              d = B() - d;
              d =
                (120 > d
                  ? 120
                  : 480 > d
                  ? 480
                  : 1080 > d
                  ? 1080
                  : 1920 > d
                  ? 1920
                  : 3e3 > d
                  ? 3e3
                  : 4320 > d
                  ? 4320
                  : 1960 * mk(d / 1960)) - d;
              if (10 < d) {
                a.timeoutHandle = Ff(Qk.bind(null, a, uk, vk), d);
                break;
              }
              Qk(a, uk, vk);
              break;
            case 5:
              Qk(a, uk, vk);
              break;
            default:
              throw Error(p(329));
          }
        }
      }
      Ek(a, B());
      return a.callbackNode === c ? Hk.bind(null, a) : null;
    }
    function Ok(a, b) {
      var c = tk;
      a.current.memoizedState.isDehydrated && (Lk(a, b).flags |= 256);
      a = Jk(a, b);
      2 !== a && ((b = uk), (uk = c), null !== b && Gj(b));
      return a;
    }
    function Gj(a) {
      null === uk ? (uk = a) : uk.push.apply(uk, a);
    }
    function Pk(a) {
      for (var b = a; ; ) {
        if (b.flags & 16384) {
          var c = b.updateQueue;
          if (null !== c && ((c = c.stores), null !== c))
            for (var d = 0; d < c.length; d++) {
              var e = c[d],
                f = e.getSnapshot;
              e = e.value;
              try {
                if (!He(f(), e)) return false;
              } catch (g) {
                return false;
              }
            }
        }
        c = b.child;
        if (b.subtreeFlags & 16384 && null !== c) (c.return = b), (b = c);
        else {
          if (b === a) break;
          for (; null === b.sibling; ) {
            if (null === b.return || b.return === a) return true;
            b = b.return;
          }
          b.sibling.return = b.return;
          b = b.sibling;
        }
      }
      return true;
    }
    function Dk(a, b) {
      b &= ~sk;
      b &= ~rk;
      a.suspendedLanes |= b;
      a.pingedLanes &= ~b;
      for (a = a.expirationTimes; 0 < b; ) {
        var c = 31 - oc(b),
          d = 1 << c;
        a[c] = -1;
        b &= ~d;
      }
    }
    function Fk(a) {
      if (0 !== (K & 6)) throw Error(p(327));
      Ik();
      var b = uc(a, 0);
      if (0 === (b & 1)) return Ek(a, B()), null;
      var c = Jk(a, b);
      if (0 !== a.tag && 2 === c) {
        var d = xc(a);
        0 !== d && ((b = d), (c = Ok(a, d)));
      }
      if (1 === c) throw ((c = qk), Lk(a, 0), Dk(a, b), Ek(a, B()), c);
      if (6 === c) throw Error(p(345));
      a.finishedWork = a.current.alternate;
      a.finishedLanes = b;
      Qk(a, uk, vk);
      Ek(a, B());
      return null;
    }
    function Rk(a, b) {
      var c = K;
      K |= 1;
      try {
        return a(b);
      } finally {
        (K = c), 0 === K && ((Hj = B() + 500), fg && jg());
      }
    }
    function Sk(a) {
      null !== xk && 0 === xk.tag && 0 === (K & 6) && Ik();
      var b = K;
      K |= 1;
      var c = pk.transition,
        d = C;
      try {
        if (((pk.transition = null), (C = 1), a)) return a();
      } finally {
        (C = d), (pk.transition = c), (K = b), 0 === (K & 6) && jg();
      }
    }
    function Ij() {
      gj = fj.current;
      E(fj);
    }
    function Lk(a, b) {
      a.finishedWork = null;
      a.finishedLanes = 0;
      var c = a.timeoutHandle;
      -1 !== c && ((a.timeoutHandle = -1), Gf(c));
      if (null !== Y)
        for (c = Y.return; null !== c; ) {
          var d = c;
          wg(d);
          switch (d.tag) {
            case 1:
              d = d.type.childContextTypes;
              null !== d && void 0 !== d && $f();
              break;
            case 3:
              Jh();
              E(Wf);
              E(H);
              Oh();
              break;
            case 5:
              Lh(d);
              break;
            case 4:
              Jh();
              break;
            case 13:
              E(M);
              break;
            case 19:
              E(M);
              break;
            case 10:
              Rg(d.type._context);
              break;
            case 22:
            case 23:
              Ij();
          }
          c = c.return;
        }
      R = a;
      Y = a = wh(a.current, null);
      Z = gj = b;
      T = 0;
      qk = null;
      sk = rk = hh = 0;
      uk = tk = null;
      if (null !== Wg) {
        for (b = 0; b < Wg.length; b++)
          if (((c = Wg[b]), (d = c.interleaved), null !== d)) {
            c.interleaved = null;
            var e = d.next,
              f = c.pending;
            if (null !== f) {
              var g = f.next;
              f.next = e;
              d.next = g;
            }
            c.pending = d;
          }
        Wg = null;
      }
      return a;
    }
    function Nk(a, b) {
      do {
        var c = Y;
        try {
          Qg();
          Ph.current = ai;
          if (Sh) {
            for (var d = N.memoizedState; null !== d; ) {
              var e = d.queue;
              null !== e && (e.pending = null);
              d = d.next;
            }
            Sh = false;
          }
          Rh = 0;
          P = O = N = null;
          Th = false;
          Uh = 0;
          ok.current = null;
          if (null === c || null === c.return) {
            T = 1;
            qk = b;
            Y = null;
            break;
          }
          a: {
            var f = a,
              g = c.return,
              h = c,
              k = b;
            b = Z;
            h.flags |= 32768;
            if (
              null !== k &&
              "object" === typeof k &&
              "function" === typeof k.then
            ) {
              var l = k,
                m = h,
                q = m.tag;
              if (0 === (m.mode & 1) && (0 === q || 11 === q || 15 === q)) {
                var r = m.alternate;
                r
                  ? ((m.updateQueue = r.updateQueue),
                    (m.memoizedState = r.memoizedState),
                    (m.lanes = r.lanes))
                  : ((m.updateQueue = null), (m.memoizedState = null));
              }
              var y = Vi(g);
              if (null !== y) {
                y.flags &= -257;
                Wi(y, g, h, f, b);
                y.mode & 1 && Ti(f, l, b);
                b = y;
                k = l;
                var n = b.updateQueue;
                if (null === n) {
                  var t = new Set();
                  t.add(k);
                  b.updateQueue = t;
                } else n.add(k);
                break a;
              } else {
                if (0 === (b & 1)) {
                  Ti(f, l, b);
                  uj();
                  break a;
                }
                k = Error(p(426));
              }
            } else if (I && h.mode & 1) {
              var J = Vi(g);
              if (null !== J) {
                0 === (J.flags & 65536) && (J.flags |= 256);
                Wi(J, g, h, f, b);
                Jg(Ki(k, h));
                break a;
              }
            }
            f = k = Ki(k, h);
            4 !== T && (T = 2);
            null === tk ? (tk = [f]) : tk.push(f);
            f = g;
            do {
              switch (f.tag) {
                case 3:
                  f.flags |= 65536;
                  b &= -b;
                  f.lanes |= b;
                  var x = Oi(f, k, b);
                  fh(f, x);
                  break a;
                case 1:
                  h = k;
                  var w = f.type,
                    u = f.stateNode;
                  if (
                    0 === (f.flags & 128) &&
                    ("function" === typeof w.getDerivedStateFromError ||
                      (null !== u &&
                        "function" === typeof u.componentDidCatch &&
                        (null === Si || !Si.has(u))))
                  ) {
                    f.flags |= 65536;
                    b &= -b;
                    f.lanes |= b;
                    var F = Ri(f, h, b);
                    fh(f, F);
                    break a;
                  }
              }
              f = f.return;
            } while (null !== f);
          }
          Tk(c);
        } catch (na) {
          b = na;
          Y === c && null !== c && (Y = c = c.return);
          continue;
        }
        break;
      } while (1);
    }
    function Kk() {
      var a = nk.current;
      nk.current = ai;
      return null === a ? ai : a;
    }
    function uj() {
      if (0 === T || 3 === T || 2 === T) T = 4;
      null === R ||
        (0 === (hh & 268435455) && 0 === (rk & 268435455)) ||
        Dk(R, Z);
    }
    function Jk(a, b) {
      var c = K;
      K |= 2;
      var d = Kk();
      if (R !== a || Z !== b) (vk = null), Lk(a, b);
      do
        try {
          Uk();
          break;
        } catch (e) {
          Nk(a, e);
        }
      while (1);
      Qg();
      K = c;
      nk.current = d;
      if (null !== Y) throw Error(p(261));
      R = null;
      Z = 0;
      return T;
    }
    function Uk() {
      for (; null !== Y; ) Vk(Y);
    }
    function Mk() {
      for (; null !== Y && !cc(); ) Vk(Y);
    }
    function Vk(a) {
      var b = Wk(a.alternate, a, gj);
      a.memoizedProps = a.pendingProps;
      null === b ? Tk(a) : (Y = b);
      ok.current = null;
    }
    function Tk(a) {
      var b = a;
      do {
        var c = b.alternate;
        a = b.return;
        if (0 === (b.flags & 32768)) {
          if (((c = Fj(c, b, gj)), null !== c)) {
            Y = c;
            return;
          }
        } else {
          c = Jj(c, b);
          if (null !== c) {
            c.flags &= 32767;
            Y = c;
            return;
          }
          if (null !== a)
            (a.flags |= 32768), (a.subtreeFlags = 0), (a.deletions = null);
          else {
            T = 6;
            Y = null;
            return;
          }
        }
        b = b.sibling;
        if (null !== b) {
          Y = b;
          return;
        }
        Y = b = a;
      } while (null !== b);
      0 === T && (T = 5);
    }
    function Qk(a, b, c) {
      var d = C,
        e = pk.transition;
      try {
        (pk.transition = null), (C = 1), Xk(a, b, c, d);
      } finally {
        (pk.transition = e), (C = d);
      }
      return null;
    }
    function Xk(a, b, c, d) {
      do Ik();
      while (null !== xk);
      if (0 !== (K & 6)) throw Error(p(327));
      c = a.finishedWork;
      var e = a.finishedLanes;
      if (null === c) return null;
      a.finishedWork = null;
      a.finishedLanes = 0;
      if (c === a.current) throw Error(p(177));
      a.callbackNode = null;
      a.callbackPriority = 0;
      var f = c.lanes | c.childLanes;
      Bc(a, f);
      a === R && ((Y = R = null), (Z = 0));
      (0 === (c.subtreeFlags & 2064) && 0 === (c.flags & 2064)) ||
        wk ||
        ((wk = true),
        Gk(hc, function () {
          Ik();
          return null;
        }));
      f = 0 !== (c.flags & 15990);
      if (0 !== (c.subtreeFlags & 15990) || f) {
        f = pk.transition;
        pk.transition = null;
        var g = C;
        C = 1;
        var h = K;
        K |= 4;
        ok.current = null;
        Pj(a, c);
        ek(c, a);
        Oe(Df);
        dd = !!Cf;
        Df = Cf = null;
        a.current = c;
        ik(c);
        dc();
        K = h;
        C = g;
        pk.transition = f;
      } else a.current = c;
      wk && ((wk = false), (xk = a), (yk = e));
      f = a.pendingLanes;
      0 === f && (Si = null);
      mc(c.stateNode);
      Ek(a, B());
      if (null !== b)
        for (d = a.onRecoverableError, c = 0; c < b.length; c++)
          (e = b[c]), d(e.value, { componentStack: e.stack, digest: e.digest });
      if (Pi) throw ((Pi = false), (a = Qi), (Qi = null), a);
      0 !== (yk & 1) && 0 !== a.tag && Ik();
      f = a.pendingLanes;
      0 !== (f & 1) ? (a === Ak ? zk++ : ((zk = 0), (Ak = a))) : (zk = 0);
      jg();
      return null;
    }
    function Ik() {
      if (null !== xk) {
        var a = Dc(yk),
          b = pk.transition,
          c = C;
        try {
          pk.transition = null;
          C = 16 > a ? 16 : a;
          if (null === xk) var d = false;
          else {
            a = xk;
            xk = null;
            yk = 0;
            if (0 !== (K & 6)) throw Error(p(331));
            var e = K;
            K |= 4;
            for (V = a.current; null !== V; ) {
              var f = V,
                g = f.child;
              if (0 !== (V.flags & 16)) {
                var h = f.deletions;
                if (null !== h) {
                  for (var k = 0; k < h.length; k++) {
                    var l = h[k];
                    for (V = l; null !== V; ) {
                      var m = V;
                      switch (m.tag) {
                        case 0:
                        case 11:
                        case 15:
                          Qj(8, m, f);
                      }
                      var q = m.child;
                      if (null !== q) (q.return = m), (V = q);
                      else
                        for (; null !== V; ) {
                          m = V;
                          var r = m.sibling,
                            y = m.return;
                          Tj(m);
                          if (m === l) {
                            V = null;
                            break;
                          }
                          if (null !== r) {
                            r.return = y;
                            V = r;
                            break;
                          }
                          V = y;
                        }
                    }
                  }
                  var n = f.alternate;
                  if (null !== n) {
                    var t = n.child;
                    if (null !== t) {
                      n.child = null;
                      do {
                        var J = t.sibling;
                        t.sibling = null;
                        t = J;
                      } while (null !== t);
                    }
                  }
                  V = f;
                }
              }
              if (0 !== (f.subtreeFlags & 2064) && null !== g)
                (g.return = f), (V = g);
              else
                b: for (; null !== V; ) {
                  f = V;
                  if (0 !== (f.flags & 2048))
                    switch (f.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Qj(9, f, f.return);
                    }
                  var x = f.sibling;
                  if (null !== x) {
                    x.return = f.return;
                    V = x;
                    break b;
                  }
                  V = f.return;
                }
            }
            var w = a.current;
            for (V = w; null !== V; ) {
              g = V;
              var u = g.child;
              if (0 !== (g.subtreeFlags & 2064) && null !== u)
                (u.return = g), (V = u);
              else
                b: for (g = w; null !== V; ) {
                  h = V;
                  if (0 !== (h.flags & 2048))
                    try {
                      switch (h.tag) {
                        case 0:
                        case 11:
                        case 15:
                          Rj(9, h);
                      }
                    } catch (na) {
                      W(h, h.return, na);
                    }
                  if (h === g) {
                    V = null;
                    break b;
                  }
                  var F = h.sibling;
                  if (null !== F) {
                    F.return = h.return;
                    V = F;
                    break b;
                  }
                  V = h.return;
                }
            }
            K = e;
            jg();
            if (lc && "function" === typeof lc.onPostCommitFiberRoot)
              try {
                lc.onPostCommitFiberRoot(kc, a);
              } catch (na) {}
            d = true;
          }
          return d;
        } finally {
          (C = c), (pk.transition = b);
        }
      }
      return false;
    }
    function Yk(a, b, c) {
      b = Ki(c, b);
      b = Oi(a, b, 1);
      a = dh(a, b, 1);
      b = L();
      null !== a && (Ac(a, 1, b), Ek(a, b));
    }
    function W(a, b, c) {
      if (3 === a.tag) Yk(a, a, c);
      else
        for (; null !== b; ) {
          if (3 === b.tag) {
            Yk(b, a, c);
            break;
          } else if (1 === b.tag) {
            var d = b.stateNode;
            if (
              "function" === typeof b.type.getDerivedStateFromError ||
              ("function" === typeof d.componentDidCatch &&
                (null === Si || !Si.has(d)))
            ) {
              a = Ki(c, a);
              a = Ri(b, a, 1);
              b = dh(b, a, 1);
              a = L();
              null !== b && (Ac(b, 1, a), Ek(b, a));
              break;
            }
          }
          b = b.return;
        }
    }
    function Ui(a, b, c) {
      var d = a.pingCache;
      null !== d && d.delete(b);
      b = L();
      a.pingedLanes |= a.suspendedLanes & c;
      R === a &&
        (Z & c) === c &&
        (4 === T || (3 === T && (Z & 130023424) === Z && 500 > B() - gk)
          ? Lk(a, 0)
          : (sk |= c));
      Ek(a, b);
    }
    function Zk(a, b) {
      0 === b &&
        (0 === (a.mode & 1)
          ? (b = 1)
          : ((b = sc), (sc <<= 1), 0 === (sc & 130023424) && (sc = 4194304)));
      var c = L();
      a = Zg(a, b);
      null !== a && (Ac(a, b, c), Ek(a, c));
    }
    function vj(a) {
      var b = a.memoizedState,
        c = 0;
      null !== b && (c = b.retryLane);
      Zk(a, c);
    }
    function ck(a, b) {
      var c = 0;
      switch (a.tag) {
        case 13:
          var d = a.stateNode;
          var e = a.memoizedState;
          null !== e && (c = e.retryLane);
          break;
        case 19:
          d = a.stateNode;
          break;
        default:
          throw Error(p(314));
      }
      null !== d && d.delete(b);
      Zk(a, c);
    }
    var Wk;
    Wk = function (a, b, c) {
      if (null !== a)
        if (a.memoizedProps !== b.pendingProps || Wf.current) Ug = true;
        else {
          if (0 === (a.lanes & c) && 0 === (b.flags & 128))
            return (Ug = false), zj(a, b, c);
          Ug = 0 !== (a.flags & 131072) ? true : false;
        }
      else (Ug = false), I && 0 !== (b.flags & 1048576) && ug(b, ng, b.index);
      b.lanes = 0;
      switch (b.tag) {
        case 2:
          var d = b.type;
          jj(a, b);
          a = b.pendingProps;
          var e = Yf(b, H.current);
          Tg(b, c);
          e = Xh(null, b, d, a, e, c);
          var f = bi();
          b.flags |= 1;
          "object" === typeof e &&
          null !== e &&
          "function" === typeof e.render &&
          void 0 === e.$$typeof
            ? ((b.tag = 1),
              (b.memoizedState = null),
              (b.updateQueue = null),
              Zf(d) ? ((f = true), cg(b)) : (f = false),
              (b.memoizedState =
                null !== e.state && void 0 !== e.state ? e.state : null),
              ah(b),
              (e.updater = nh),
              (b.stateNode = e),
              (e._reactInternals = b),
              rh(b, d, a, c),
              (b = kj(null, b, d, true, f, c)))
            : ((b.tag = 0), I && f && vg(b), Yi(null, b, e, c), (b = b.child));
          return b;
        case 16:
          d = b.elementType;
          a: {
            jj(a, b);
            a = b.pendingProps;
            e = d._init;
            d = e(d._payload);
            b.type = d;
            e = b.tag = $k(d);
            a = Lg(d, a);
            switch (e) {
              case 0:
                b = dj(null, b, d, a, c);
                break a;
              case 1:
                b = ij(null, b, d, a, c);
                break a;
              case 11:
                b = Zi(null, b, d, a, c);
                break a;
              case 14:
                b = aj(null, b, d, Lg(d.type, a), c);
                break a;
            }
            throw Error(p(306, d, ""));
          }
          return b;
        case 0:
          return (
            (d = b.type),
            (e = b.pendingProps),
            (e = b.elementType === d ? e : Lg(d, e)),
            dj(a, b, d, e, c)
          );
        case 1:
          return (
            (d = b.type),
            (e = b.pendingProps),
            (e = b.elementType === d ? e : Lg(d, e)),
            ij(a, b, d, e, c)
          );
        case 3:
          a: {
            lj(b);
            if (null === a) throw Error(p(387));
            d = b.pendingProps;
            f = b.memoizedState;
            e = f.element;
            bh(a, b);
            gh(b, d, null, c);
            var g = b.memoizedState;
            d = g.element;
            if (f.isDehydrated)
              if (
                ((f = {
                  element: d,
                  isDehydrated: false,
                  cache: g.cache,
                  pendingSuspenseBoundaries: g.pendingSuspenseBoundaries,
                  transitions: g.transitions,
                }),
                (b.updateQueue.baseState = f),
                (b.memoizedState = f),
                b.flags & 256)
              ) {
                e = Ki(Error(p(423)), b);
                b = mj(a, b, d, c, e);
                break a;
              } else if (d !== e) {
                e = Ki(Error(p(424)), b);
                b = mj(a, b, d, c, e);
                break a;
              } else
                for (
                  yg = Lf(b.stateNode.containerInfo.firstChild),
                    xg = b,
                    I = true,
                    zg = null,
                    c = Ch(b, null, d, c),
                    b.child = c;
                  c;

                )
                  (c.flags = (c.flags & -3) | 4096), (c = c.sibling);
            else {
              Ig();
              if (d === e) {
                b = $i(a, b, c);
                break a;
              }
              Yi(a, b, d, c);
            }
            b = b.child;
          }
          return b;
        case 5:
          return (
            Kh(b),
            null === a && Eg(b),
            (d = b.type),
            (e = b.pendingProps),
            (f = null !== a ? a.memoizedProps : null),
            (g = e.children),
            Ef(d, e) ? (g = null) : null !== f && Ef(d, f) && (b.flags |= 32),
            hj(a, b),
            Yi(a, b, g, c),
            b.child
          );
        case 6:
          return null === a && Eg(b), null;
        case 13:
          return pj(a, b, c);
        case 4:
          return (
            Ih(b, b.stateNode.containerInfo),
            (d = b.pendingProps),
            null === a ? (b.child = Bh(b, null, d, c)) : Yi(a, b, d, c),
            b.child
          );
        case 11:
          return (
            (d = b.type),
            (e = b.pendingProps),
            (e = b.elementType === d ? e : Lg(d, e)),
            Zi(a, b, d, e, c)
          );
        case 7:
          return Yi(a, b, b.pendingProps, c), b.child;
        case 8:
          return Yi(a, b, b.pendingProps.children, c), b.child;
        case 12:
          return Yi(a, b, b.pendingProps.children, c), b.child;
        case 10:
          a: {
            d = b.type._context;
            e = b.pendingProps;
            f = b.memoizedProps;
            g = e.value;
            G(Mg, d._currentValue);
            d._currentValue = g;
            if (null !== f)
              if (He(f.value, g)) {
                if (f.children === e.children && !Wf.current) {
                  b = $i(a, b, c);
                  break a;
                }
              } else
                for (f = b.child, null !== f && (f.return = b); null !== f; ) {
                  var h = f.dependencies;
                  if (null !== h) {
                    g = f.child;
                    for (var k = h.firstContext; null !== k; ) {
                      if (k.context === d) {
                        if (1 === f.tag) {
                          k = ch(-1, c & -c);
                          k.tag = 2;
                          var l = f.updateQueue;
                          if (null !== l) {
                            l = l.shared;
                            var m = l.pending;
                            null === m
                              ? (k.next = k)
                              : ((k.next = m.next), (m.next = k));
                            l.pending = k;
                          }
                        }
                        f.lanes |= c;
                        k = f.alternate;
                        null !== k && (k.lanes |= c);
                        Sg(f.return, c, b);
                        h.lanes |= c;
                        break;
                      }
                      k = k.next;
                    }
                  } else if (10 === f.tag)
                    g = f.type === b.type ? null : f.child;
                  else if (18 === f.tag) {
                    g = f.return;
                    if (null === g) throw Error(p(341));
                    g.lanes |= c;
                    h = g.alternate;
                    null !== h && (h.lanes |= c);
                    Sg(g, c, b);
                    g = f.sibling;
                  } else g = f.child;
                  if (null !== g) g.return = f;
                  else
                    for (g = f; null !== g; ) {
                      if (g === b) {
                        g = null;
                        break;
                      }
                      f = g.sibling;
                      if (null !== f) {
                        f.return = g.return;
                        g = f;
                        break;
                      }
                      g = g.return;
                    }
                  f = g;
                }
            Yi(a, b, e.children, c);
            b = b.child;
          }
          return b;
        case 9:
          return (
            (e = b.type),
            (d = b.pendingProps.children),
            Tg(b, c),
            (e = Vg(e)),
            (d = d(e)),
            (b.flags |= 1),
            Yi(a, b, d, c),
            b.child
          );
        case 14:
          return (
            (d = b.type),
            (e = Lg(d, b.pendingProps)),
            (e = Lg(d.type, e)),
            aj(a, b, d, e, c)
          );
        case 15:
          return cj(a, b, b.type, b.pendingProps, c);
        case 17:
          return (
            (d = b.type),
            (e = b.pendingProps),
            (e = b.elementType === d ? e : Lg(d, e)),
            jj(a, b),
            (b.tag = 1),
            Zf(d) ? ((a = true), cg(b)) : (a = false),
            Tg(b, c),
            ph(b, d, e),
            rh(b, d, e, c),
            kj(null, b, d, true, a, c)
          );
        case 19:
          return yj(a, b, c);
        case 22:
          return ej(a, b, c);
      }
      throw Error(p(156, b.tag));
    };
    function Gk(a, b) {
      return ac(a, b);
    }
    function al(a, b, c, d) {
      this.tag = a;
      this.key = c;
      this.sibling =
        this.child =
        this.return =
        this.stateNode =
        this.type =
        this.elementType =
          null;
      this.index = 0;
      this.ref = null;
      this.pendingProps = b;
      this.dependencies =
        this.memoizedState =
        this.updateQueue =
        this.memoizedProps =
          null;
      this.mode = d;
      this.subtreeFlags = this.flags = 0;
      this.deletions = null;
      this.childLanes = this.lanes = 0;
      this.alternate = null;
    }
    function Bg(a, b, c, d) {
      return new al(a, b, c, d);
    }
    function bj(a) {
      a = a.prototype;
      return !(!a || !a.isReactComponent);
    }
    function $k(a) {
      if ("function" === typeof a) return bj(a) ? 1 : 0;
      if (void 0 !== a && null !== a) {
        a = a.$$typeof;
        if (a === Da) return 11;
        if (a === Ga) return 14;
      }
      return 2;
    }
    function wh(a, b) {
      var c = a.alternate;
      null === c
        ? ((c = Bg(a.tag, b, a.key, a.mode)),
          (c.elementType = a.elementType),
          (c.type = a.type),
          (c.stateNode = a.stateNode),
          (c.alternate = a),
          (a.alternate = c))
        : ((c.pendingProps = b),
          (c.type = a.type),
          (c.flags = 0),
          (c.subtreeFlags = 0),
          (c.deletions = null));
      c.flags = a.flags & 14680064;
      c.childLanes = a.childLanes;
      c.lanes = a.lanes;
      c.child = a.child;
      c.memoizedProps = a.memoizedProps;
      c.memoizedState = a.memoizedState;
      c.updateQueue = a.updateQueue;
      b = a.dependencies;
      c.dependencies =
        null === b ? null : { lanes: b.lanes, firstContext: b.firstContext };
      c.sibling = a.sibling;
      c.index = a.index;
      c.ref = a.ref;
      return c;
    }
    function yh(a, b, c, d, e, f) {
      var g = 2;
      d = a;
      if ("function" === typeof a) bj(a) && (g = 1);
      else if ("string" === typeof a) g = 5;
      else
        a: switch (a) {
          case ya:
            return Ah(c.children, e, f, b);
          case za:
            g = 8;
            e |= 8;
            break;
          case Aa:
            return (
              (a = Bg(12, c, b, e | 2)), (a.elementType = Aa), (a.lanes = f), a
            );
          case Ea:
            return (
              (a = Bg(13, c, b, e)), (a.elementType = Ea), (a.lanes = f), a
            );
          case Fa:
            return (
              (a = Bg(19, c, b, e)), (a.elementType = Fa), (a.lanes = f), a
            );
          case Ia:
            return qj(c, e, f, b);
          default:
            if ("object" === typeof a && null !== a)
              switch (a.$$typeof) {
                case Ba:
                  g = 10;
                  break a;
                case Ca:
                  g = 9;
                  break a;
                case Da:
                  g = 11;
                  break a;
                case Ga:
                  g = 14;
                  break a;
                case Ha:
                  g = 16;
                  d = null;
                  break a;
              }
            throw Error(p(130, null == a ? a : typeof a, ""));
        }
      b = Bg(g, c, b, e);
      b.elementType = a;
      b.type = d;
      b.lanes = f;
      return b;
    }
    function Ah(a, b, c, d) {
      a = Bg(7, a, d, b);
      a.lanes = c;
      return a;
    }
    function qj(a, b, c, d) {
      a = Bg(22, a, d, b);
      a.elementType = Ia;
      a.lanes = c;
      a.stateNode = { isHidden: false };
      return a;
    }
    function xh(a, b, c) {
      a = Bg(6, a, null, b);
      a.lanes = c;
      return a;
    }
    function zh(a, b, c) {
      b = Bg(4, null !== a.children ? a.children : [], a.key, b);
      b.lanes = c;
      b.stateNode = {
        containerInfo: a.containerInfo,
        pendingChildren: null,
        implementation: a.implementation,
      };
      return b;
    }
    function bl(a, b, c, d, e) {
      this.tag = b;
      this.containerInfo = a;
      this.finishedWork =
        this.pingCache =
        this.current =
        this.pendingChildren =
          null;
      this.timeoutHandle = -1;
      this.callbackNode = this.pendingContext = this.context = null;
      this.callbackPriority = 0;
      this.eventTimes = zc(0);
      this.expirationTimes = zc(-1);
      this.entangledLanes =
        this.finishedLanes =
        this.mutableReadLanes =
        this.expiredLanes =
        this.pingedLanes =
        this.suspendedLanes =
        this.pendingLanes =
          0;
      this.entanglements = zc(0);
      this.identifierPrefix = d;
      this.onRecoverableError = e;
      this.mutableSourceEagerHydrationData = null;
    }
    function cl(a, b, c, d, e, f, g, h, k) {
      a = new bl(a, b, c, h, k);
      1 === b ? ((b = 1), true === f && (b |= 8)) : (b = 0);
      f = Bg(3, null, null, b);
      a.current = f;
      f.stateNode = a;
      f.memoizedState = {
        element: d,
        isDehydrated: c,
        cache: null,
        transitions: null,
        pendingSuspenseBoundaries: null,
      };
      ah(f);
      return a;
    }
    function dl(a, b, c) {
      var d =
        3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
      return {
        $$typeof: wa,
        key: null == d ? null : "" + d,
        children: a,
        containerInfo: b,
        implementation: c,
      };
    }
    function el(a) {
      if (!a) return Vf;
      a = a._reactInternals;
      a: {
        if (Vb(a) !== a || 1 !== a.tag) throw Error(p(170));
        var b = a;
        do {
          switch (b.tag) {
            case 3:
              b = b.stateNode.context;
              break a;
            case 1:
              if (Zf(b.type)) {
                b = b.stateNode.__reactInternalMemoizedMergedChildContext;
                break a;
              }
          }
          b = b.return;
        } while (null !== b);
        throw Error(p(171));
      }
      if (1 === a.tag) {
        var c = a.type;
        if (Zf(c)) return bg(a, c, b);
      }
      return b;
    }
    function fl(a, b, c, d, e, f, g, h, k) {
      a = cl(c, d, true, a, e, f, g, h, k);
      a.context = el(null);
      c = a.current;
      d = L();
      e = lh(c);
      f = ch(d, e);
      f.callback = void 0 !== b && null !== b ? b : null;
      dh(c, f, e);
      a.current.lanes = e;
      Ac(a, e, d);
      Ek(a, d);
      return a;
    }
    function gl(a, b, c, d) {
      var e = b.current,
        f = L(),
        g = lh(e);
      c = el(c);
      null === b.context ? (b.context = c) : (b.pendingContext = c);
      b = ch(f, g);
      b.payload = { element: a };
      d = void 0 === d ? null : d;
      null !== d && (b.callback = d);
      a = dh(e, b, g);
      null !== a && (mh(a, e, g, f), eh(a, e, g));
      return g;
    }
    function hl(a) {
      a = a.current;
      if (!a.child) return null;
      switch (a.child.tag) {
        case 5:
          return a.child.stateNode;
        default:
          return a.child.stateNode;
      }
    }
    function il(a, b) {
      a = a.memoizedState;
      if (null !== a && null !== a.dehydrated) {
        var c = a.retryLane;
        a.retryLane = 0 !== c && c < b ? c : b;
      }
    }
    function jl(a, b) {
      il(a, b);
      (a = a.alternate) && il(a, b);
    }
    function kl() {
      return null;
    }
    var ll =
      "function" === typeof reportError
        ? reportError
        : function (a) {
            console.error(a);
          };
    function ml(a) {
      this._internalRoot = a;
    }
    nl.prototype.render = ml.prototype.render = function (a) {
      var b = this._internalRoot;
      if (null === b) throw Error(p(409));
      gl(a, b, null, null);
    };
    nl.prototype.unmount = ml.prototype.unmount = function () {
      var a = this._internalRoot;
      if (null !== a) {
        this._internalRoot = null;
        var b = a.containerInfo;
        Sk(function () {
          gl(null, a, null, null);
        });
        b[uf] = null;
      }
    };
    function nl(a) {
      this._internalRoot = a;
    }
    nl.prototype.unstable_scheduleHydration = function (a) {
      if (a) {
        var b = Hc();
        a = { blockedOn: null, target: a, priority: b };
        for (var c = 0; c < Qc.length && 0 !== b && b < Qc[c].priority; c++);
        Qc.splice(c, 0, a);
        0 === c && Vc(a);
      }
    };
    function ol(a) {
      return !(
        !a ||
        (1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType)
      );
    }
    function pl(a) {
      return !(
        !a ||
        (1 !== a.nodeType &&
          9 !== a.nodeType &&
          11 !== a.nodeType &&
          (8 !== a.nodeType || " react-mount-point-unstable " !== a.nodeValue))
      );
    }
    function ql() {}
    function rl(a, b, c, d, e) {
      if (e) {
        if ("function" === typeof d) {
          var f = d;
          d = function () {
            var a2 = hl(g);
            f.call(a2);
          };
        }
        var g = fl(b, d, a, 0, null, false, false, "", ql);
        a._reactRootContainer = g;
        a[uf] = g.current;
        sf(8 === a.nodeType ? a.parentNode : a);
        Sk();
        return g;
      }
      for (; (e = a.lastChild); ) a.removeChild(e);
      if ("function" === typeof d) {
        var h = d;
        d = function () {
          var a2 = hl(k);
          h.call(a2);
        };
      }
      var k = cl(a, 0, false, null, null, false, false, "", ql);
      a._reactRootContainer = k;
      a[uf] = k.current;
      sf(8 === a.nodeType ? a.parentNode : a);
      Sk(function () {
        gl(b, k, c, d);
      });
      return k;
    }
    function sl(a, b, c, d, e) {
      var f = c._reactRootContainer;
      if (f) {
        var g = f;
        if ("function" === typeof e) {
          var h = e;
          e = function () {
            var a2 = hl(g);
            h.call(a2);
          };
        }
        gl(b, g, a, e);
      } else g = rl(c, b, a, e, d);
      return hl(g);
    }
    Ec = function (a) {
      switch (a.tag) {
        case 3:
          var b = a.stateNode;
          if (b.current.memoizedState.isDehydrated) {
            var c = tc(b.pendingLanes);
            0 !== c &&
              (Cc(b, c | 1),
              Ek(b, B()),
              0 === (K & 6) && ((Hj = B() + 500), jg()));
          }
          break;
        case 13:
          Sk(function () {
            var b2 = Zg(a, 1);
            if (null !== b2) {
              var c2 = L();
              mh(b2, a, 1, c2);
            }
          }),
            jl(a, 1);
      }
    };
    Fc = function (a) {
      if (13 === a.tag) {
        var b = Zg(a, 134217728);
        if (null !== b) {
          var c = L();
          mh(b, a, 134217728, c);
        }
        jl(a, 134217728);
      }
    };
    Gc = function (a) {
      if (13 === a.tag) {
        var b = lh(a),
          c = Zg(a, b);
        if (null !== c) {
          var d = L();
          mh(c, a, b, d);
        }
        jl(a, b);
      }
    };
    Hc = function () {
      return C;
    };
    Ic = function (a, b) {
      var c = C;
      try {
        return (C = a), b();
      } finally {
        C = c;
      }
    };
    yb = function (a, b, c) {
      switch (b) {
        case "input":
          bb(a, c);
          b = c.name;
          if ("radio" === c.type && null != b) {
            for (c = a; c.parentNode; ) c = c.parentNode;
            c = c.querySelectorAll(
              "input[name=" + JSON.stringify("" + b) + '][type="radio"]'
            );
            for (b = 0; b < c.length; b++) {
              var d = c[b];
              if (d !== a && d.form === a.form) {
                var e = Db(d);
                if (!e) throw Error(p(90));
                Wa(d);
                bb(d, e);
              }
            }
          }
          break;
        case "textarea":
          ib(a, c);
          break;
        case "select":
          (b = c.value), null != b && fb(a, !!c.multiple, b, false);
      }
    };
    Gb = Rk;
    Hb = Sk;
    var tl = { usingClientEntryPoint: false, Events: [Cb, ue, Db, Eb, Fb, Rk] };
    var ul = {
      findFiberByHostInstance: Wc,
      bundleType: 0,
      version: "18.2.0",
      rendererPackageName: "react-dom",
    };
    var vl = {
      bundleType: ul.bundleType,
      version: ul.version,
      rendererPackageName: ul.rendererPackageName,
      rendererConfig: ul.rendererConfig,
      overrideHookState: null,
      overrideHookStateDeletePath: null,
      overrideHookStateRenamePath: null,
      overrideProps: null,
      overridePropsDeletePath: null,
      overridePropsRenamePath: null,
      setErrorHandler: null,
      setSuspenseHandler: null,
      scheduleUpdate: null,
      currentDispatcherRef: ua.ReactCurrentDispatcher,
      findHostInstanceByFiber: function (a) {
        a = Zb(a);
        return null === a ? null : a.stateNode;
      },
      findFiberByHostInstance: ul.findFiberByHostInstance || kl,
      findHostInstancesForRefresh: null,
      scheduleRefresh: null,
      scheduleRoot: null,
      setRefreshHandler: null,
      getCurrentFiber: null,
      reconcilerVersion: "18.2.0-next-9e3b772b8-20220608",
    };
    if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
      wl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (!wl.isDisabled && wl.supportsFiber)
        try {
          (kc = wl.inject(vl)), (lc = wl);
        } catch (a) {}
    }
    var wl;
    exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = tl;
    exports.createPortal = function (a, b) {
      var c =
        2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
      if (!ol(b)) throw Error(p(200));
      return dl(a, b, null, c);
    };
    exports.createRoot = function (a, b) {
      if (!ol(a)) throw Error(p(299));
      var c = false,
        d = "",
        e = ll;
      null !== b &&
        void 0 !== b &&
        (true === b.unstable_strictMode && (c = true),
        void 0 !== b.identifierPrefix && (d = b.identifierPrefix),
        void 0 !== b.onRecoverableError && (e = b.onRecoverableError));
      b = cl(a, 1, false, null, null, c, false, d, e);
      a[uf] = b.current;
      sf(8 === a.nodeType ? a.parentNode : a);
      return new ml(b);
    };
    exports.findDOMNode = function (a) {
      if (null == a) return null;
      if (1 === a.nodeType) return a;
      var b = a._reactInternals;
      if (void 0 === b) {
        if ("function" === typeof a.render) throw Error(p(188));
        a = Object.keys(a).join(",");
        throw Error(p(268, a));
      }
      a = Zb(b);
      a = null === a ? null : a.stateNode;
      return a;
    };
    exports.flushSync = function (a) {
      return Sk(a);
    };
    exports.hydrate = function (a, b, c) {
      if (!pl(b)) throw Error(p(200));
      return sl(null, a, b, true, c);
    };
    exports.hydrateRoot = function (a, b, c) {
      if (!ol(a)) throw Error(p(405));
      var d = (null != c && c.hydratedSources) || null,
        e = false,
        f = "",
        g = ll;
      null !== c &&
        void 0 !== c &&
        (true === c.unstable_strictMode && (e = true),
        void 0 !== c.identifierPrefix && (f = c.identifierPrefix),
        void 0 !== c.onRecoverableError && (g = c.onRecoverableError));
      b = fl(b, null, a, 1, null != c ? c : null, e, false, f, g);
      a[uf] = b.current;
      sf(a);
      if (d)
        for (a = 0; a < d.length; a++)
          (c = d[a]),
            (e = c._getVersion),
            (e = e(c._source)),
            null == b.mutableSourceEagerHydrationData
              ? (b.mutableSourceEagerHydrationData = [c, e])
              : b.mutableSourceEagerHydrationData.push(c, e);
      return new nl(b);
    };
    exports.render = function (a, b, c) {
      if (!pl(b)) throw Error(p(200));
      return sl(null, a, b, false, c);
    };
    exports.unmountComponentAtNode = function (a) {
      if (!pl(a)) throw Error(p(40));
      return a._reactRootContainer
        ? (Sk(function () {
            sl(null, null, a, false, function () {
              a._reactRootContainer = null;
              a[uf] = null;
            });
          }),
          true)
        : false;
    };
    exports.unstable_batchedUpdates = Rk;
    exports.unstable_renderSubtreeIntoContainer = function (a, b, c, d) {
      if (!pl(c)) throw Error(p(200));
      if (null == a || void 0 === a._reactInternals) throw Error(p(38));
      return sl(a, b, c, false, d);
    };
    exports.version = "18.2.0-next-9e3b772b8-20220608";
  },
});

// node_modules/react-dom/index.js
var require_react_dom = __commonJS({
  "node_modules/react-dom/index.js"(exports, module) {
    function checkDCE() {
      if (
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" ||
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function"
      ) {
        return;
      }
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
      } catch (err) {
        console.error(err);
      }
    }
    {
      checkDCE();
      module.exports = require_react_dom_production_min();
    }
  },
});

// node_modules/react-dom/client.js
var require_client = __commonJS({
  "node_modules/react-dom/client.js"(exports) {
    var m = require_react_dom();
    {
      exports.createRoot = m.createRoot;
      exports.hydrateRoot = m.hydrateRoot;
    }
  },
});

// node_modules/qrcode/lib/can-promise.js
var require_can_promise = __commonJS({
  "node_modules/qrcode/lib/can-promise.js"(exports, module) {
    module.exports = function () {
      return (
        typeof Promise === "function" &&
        Promise.prototype &&
        Promise.prototype.then
      );
    };
  },
});

// node_modules/qrcode/lib/core/utils.js
var require_utils = __commonJS({
  "node_modules/qrcode/lib/core/utils.js"(exports) {
    var toSJISFunction;
    var CODEWORDS_COUNT = [
      0,
      // Not used
      26, 44, 70, 100, 134, 172, 196, 242, 292, 346, 404, 466, 532, 581, 655,
      733, 815, 901, 991, 1085, 1156, 1258, 1364, 1474, 1588, 1706, 1828, 1921,
      2051, 2185, 2323, 2465, 2611, 2761, 2876, 3034, 3196, 3362, 3532, 3706,
    ];
    exports.getSymbolSize = function getSymbolSize(version2) {
      if (!version2) throw new Error('"version" cannot be null or undefined');
      if (version2 < 1 || version2 > 40)
        throw new Error('"version" should be in range from 1 to 40');
      return version2 * 4 + 17;
    };
    exports.getSymbolTotalCodewords = function getSymbolTotalCodewords(
      version2
    ) {
      return CODEWORDS_COUNT[version2];
    };
    exports.getBCHDigit = function (data2) {
      let digit = 0;
      while (data2 !== 0) {
        digit++;
        data2 >>>= 1;
      }
      return digit;
    };
    exports.setToSJISFunction = function setToSJISFunction(f) {
      if (typeof f !== "function") {
        throw new Error('"toSJISFunc" is not a valid function.');
      }
      toSJISFunction = f;
    };
    exports.isKanjiModeEnabled = function () {
      return typeof toSJISFunction !== "undefined";
    };
    exports.toSJIS = function toSJIS(kanji) {
      return toSJISFunction(kanji);
    };
  },
});

// node_modules/qrcode/lib/core/error-correction-level.js
var require_error_correction_level = __commonJS({
  "node_modules/qrcode/lib/core/error-correction-level.js"(exports) {
    exports.L = { bit: 1 };
    exports.M = { bit: 0 };
    exports.Q = { bit: 3 };
    exports.H = { bit: 2 };
    function fromString(string) {
      if (typeof string !== "string") {
        throw new Error("Param is not a string");
      }
      const lcStr = string.toLowerCase();
      switch (lcStr) {
        case "l":
        case "low":
          return exports.L;
        case "m":
        case "medium":
          return exports.M;
        case "q":
        case "quartile":
          return exports.Q;
        case "h":
        case "high":
          return exports.H;
        default:
          throw new Error("Unknown EC Level: " + string);
      }
    }
    exports.isValid = function isValid(level) {
      return (
        level &&
        typeof level.bit !== "undefined" &&
        level.bit >= 0 &&
        level.bit < 4
      );
    };
    exports.from = function from(value, defaultValue) {
      if (exports.isValid(value)) {
        return value;
      }
      try {
        return fromString(value);
      } catch (e) {
        return defaultValue;
      }
    };
  },
});

// node_modules/qrcode/lib/core/bit-buffer.js
var require_bit_buffer = __commonJS({
  "node_modules/qrcode/lib/core/bit-buffer.js"(exports, module) {
    function BitBuffer() {
      this.buffer = [];
      this.length = 0;
    }
    BitBuffer.prototype = {
      get: function (index) {
        const bufIndex = Math.floor(index / 8);
        return ((this.buffer[bufIndex] >>> (7 - (index % 8))) & 1) === 1;
      },
      put: function (num, length) {
        for (let i = 0; i < length; i++) {
          this.putBit(((num >>> (length - i - 1)) & 1) === 1);
        }
      },
      getLengthInBits: function () {
        return this.length;
      },
      putBit: function (bit) {
        const bufIndex = Math.floor(this.length / 8);
        if (this.buffer.length <= bufIndex) {
          this.buffer.push(0);
        }
        if (bit) {
          this.buffer[bufIndex] |= 128 >>> this.length % 8;
        }
        this.length++;
      },
    };
    module.exports = BitBuffer;
  },
});

// node_modules/qrcode/lib/core/bit-matrix.js
var require_bit_matrix = __commonJS({
  "node_modules/qrcode/lib/core/bit-matrix.js"(exports, module) {
    function BitMatrix(size) {
      if (!size || size < 1) {
        throw new Error("BitMatrix size must be defined and greater than 0");
      }
      this.size = size;
      this.data = new Uint8Array(size * size);
      this.reservedBit = new Uint8Array(size * size);
    }
    BitMatrix.prototype.set = function (row, col, value, reserved) {
      const index = row * this.size + col;
      this.data[index] = value;
      if (reserved) this.reservedBit[index] = true;
    };
    BitMatrix.prototype.get = function (row, col) {
      return this.data[row * this.size + col];
    };
    BitMatrix.prototype.xor = function (row, col, value) {
      this.data[row * this.size + col] ^= value;
    };
    BitMatrix.prototype.isReserved = function (row, col) {
      return this.reservedBit[row * this.size + col];
    };
    module.exports = BitMatrix;
  },
});

// node_modules/qrcode/lib/core/alignment-pattern.js
var require_alignment_pattern = __commonJS({
  "node_modules/qrcode/lib/core/alignment-pattern.js"(exports) {
    var getSymbolSize = require_utils().getSymbolSize;
    exports.getRowColCoords = function getRowColCoords(version2) {
      if (version2 === 1) return [];
      const posCount = Math.floor(version2 / 7) + 2;
      const size = getSymbolSize(version2);
      const intervals =
        size === 145 ? 26 : Math.ceil((size - 13) / (2 * posCount - 2)) * 2;
      const positions = [size - 7];
      for (let i = 1; i < posCount - 1; i++) {
        positions[i] = positions[i - 1] - intervals;
      }
      positions.push(6);
      return positions.reverse();
    };
    exports.getPositions = function getPositions(version2) {
      const coords = [];
      const pos = exports.getRowColCoords(version2);
      const posLength = pos.length;
      for (let i = 0; i < posLength; i++) {
        for (let j = 0; j < posLength; j++) {
          if (
            (i === 0 && j === 0) || // top-left
            (i === 0 && j === posLength - 1) || // bottom-left
            (i === posLength - 1 && j === 0)
          ) {
            continue;
          }
          coords.push([pos[i], pos[j]]);
        }
      }
      return coords;
    };
  },
});

// node_modules/qrcode/lib/core/finder-pattern.js
var require_finder_pattern = __commonJS({
  "node_modules/qrcode/lib/core/finder-pattern.js"(exports) {
    var getSymbolSize = require_utils().getSymbolSize;
    var FINDER_PATTERN_SIZE = 7;
    exports.getPositions = function getPositions(version2) {
      const size = getSymbolSize(version2);
      return [
        // top-left
        [0, 0],
        // top-right
        [size - FINDER_PATTERN_SIZE, 0],
        // bottom-left
        [0, size - FINDER_PATTERN_SIZE],
      ];
    };
  },
});

// node_modules/qrcode/lib/core/mask-pattern.js
var require_mask_pattern = __commonJS({
  "node_modules/qrcode/lib/core/mask-pattern.js"(exports) {
    exports.Patterns = {
      PATTERN000: 0,
      PATTERN001: 1,
      PATTERN010: 2,
      PATTERN011: 3,
      PATTERN100: 4,
      PATTERN101: 5,
      PATTERN110: 6,
      PATTERN111: 7,
    };
    var PenaltyScores = {
      N1: 3,
      N2: 3,
      N3: 40,
      N4: 10,
    };
    exports.isValid = function isValid(mask) {
      return (
        mask != null && mask !== "" && !isNaN(mask) && mask >= 0 && mask <= 7
      );
    };
    exports.from = function from(value) {
      return exports.isValid(value) ? parseInt(value, 10) : void 0;
    };
    exports.getPenaltyN1 = function getPenaltyN1(data2) {
      const size = data2.size;
      let points = 0;
      let sameCountCol = 0;
      let sameCountRow = 0;
      let lastCol = null;
      let lastRow = null;
      for (let row = 0; row < size; row++) {
        sameCountCol = sameCountRow = 0;
        lastCol = lastRow = null;
        for (let col = 0; col < size; col++) {
          let module2 = data2.get(row, col);
          if (module2 === lastCol) {
            sameCountCol++;
          } else {
            if (sameCountCol >= 5)
              points += PenaltyScores.N1 + (sameCountCol - 5);
            lastCol = module2;
            sameCountCol = 1;
          }
          module2 = data2.get(col, row);
          if (module2 === lastRow) {
            sameCountRow++;
          } else {
            if (sameCountRow >= 5)
              points += PenaltyScores.N1 + (sameCountRow - 5);
            lastRow = module2;
            sameCountRow = 1;
          }
        }
        if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5);
        if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5);
      }
      return points;
    };
    exports.getPenaltyN2 = function getPenaltyN2(data2) {
      const size = data2.size;
      let points = 0;
      for (let row = 0; row < size - 1; row++) {
        for (let col = 0; col < size - 1; col++) {
          const last2 =
            data2.get(row, col) +
            data2.get(row, col + 1) +
            data2.get(row + 1, col) +
            data2.get(row + 1, col + 1);
          if (last2 === 4 || last2 === 0) points++;
        }
      }
      return points * PenaltyScores.N2;
    };
    exports.getPenaltyN3 = function getPenaltyN3(data2) {
      const size = data2.size;
      let points = 0;
      let bitsCol = 0;
      let bitsRow = 0;
      for (let row = 0; row < size; row++) {
        bitsCol = bitsRow = 0;
        for (let col = 0; col < size; col++) {
          bitsCol = ((bitsCol << 1) & 2047) | data2.get(row, col);
          if (col >= 10 && (bitsCol === 1488 || bitsCol === 93)) points++;
          bitsRow = ((bitsRow << 1) & 2047) | data2.get(col, row);
          if (col >= 10 && (bitsRow === 1488 || bitsRow === 93)) points++;
        }
      }
      return points * PenaltyScores.N3;
    };
    exports.getPenaltyN4 = function getPenaltyN4(data2) {
      let darkCount = 0;
      const modulesCount = data2.data.length;
      for (let i = 0; i < modulesCount; i++) darkCount += data2.data[i];
      const k = Math.abs(Math.ceil((darkCount * 100) / modulesCount / 5) - 10);
      return k * PenaltyScores.N4;
    };
    function getMaskAt(maskPattern, i, j) {
      switch (maskPattern) {
        case exports.Patterns.PATTERN000:
          return (i + j) % 2 === 0;
        case exports.Patterns.PATTERN001:
          return i % 2 === 0;
        case exports.Patterns.PATTERN010:
          return j % 3 === 0;
        case exports.Patterns.PATTERN011:
          return (i + j) % 3 === 0;
        case exports.Patterns.PATTERN100:
          return (Math.floor(i / 2) + Math.floor(j / 3)) % 2 === 0;
        case exports.Patterns.PATTERN101:
          return ((i * j) % 2) + ((i * j) % 3) === 0;
        case exports.Patterns.PATTERN110:
          return (((i * j) % 2) + ((i * j) % 3)) % 2 === 0;
        case exports.Patterns.PATTERN111:
          return (((i * j) % 3) + ((i + j) % 2)) % 2 === 0;
        default:
          throw new Error("bad maskPattern:" + maskPattern);
      }
    }
    exports.applyMask = function applyMask(pattern, data2) {
      const size = data2.size;
      for (let col = 0; col < size; col++) {
        for (let row = 0; row < size; row++) {
          if (data2.isReserved(row, col)) continue;
          data2.xor(row, col, getMaskAt(pattern, row, col));
        }
      }
    };
    exports.getBestMask = function getBestMask(data2, setupFormatFunc) {
      const numPatterns = Object.keys(exports.Patterns).length;
      let bestPattern = 0;
      let lowerPenalty = Infinity;
      for (let p = 0; p < numPatterns; p++) {
        setupFormatFunc(p);
        exports.applyMask(p, data2);
        const penalty =
          exports.getPenaltyN1(data2) +
          exports.getPenaltyN2(data2) +
          exports.getPenaltyN3(data2) +
          exports.getPenaltyN4(data2);
        exports.applyMask(p, data2);
        if (penalty < lowerPenalty) {
          lowerPenalty = penalty;
          bestPattern = p;
        }
      }
      return bestPattern;
    };
  },
});

// node_modules/qrcode/lib/core/error-correction-code.js
var require_error_correction_code = __commonJS({
  "node_modules/qrcode/lib/core/error-correction-code.js"(exports) {
    var ECLevel = require_error_correction_level();
    var EC_BLOCKS_TABLE = [
      // L  M  Q  H
      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 2, 2, 4, 1, 2, 4, 4, 2, 4, 4, 4, 2,
      4, 6, 5, 2, 4, 6, 6, 2, 5, 8, 8, 4, 5, 8, 8, 4, 5, 8, 11, 4, 8, 10, 11, 4,
      9, 12, 16, 4, 9, 16, 16, 6, 10, 12, 18, 6, 10, 17, 16, 6, 11, 16, 19, 6,
      13, 18, 21, 7, 14, 21, 25, 8, 16, 20, 25, 8, 17, 23, 25, 9, 17, 23, 34, 9,
      18, 25, 30, 10, 20, 27, 32, 12, 21, 29, 35, 12, 23, 34, 37, 12, 25, 34,
      40, 13, 26, 35, 42, 14, 28, 38, 45, 15, 29, 40, 48, 16, 31, 43, 51, 17,
      33, 45, 54, 18, 35, 48, 57, 19, 37, 51, 60, 19, 38, 53, 63, 20, 40, 56,
      66, 21, 43, 59, 70, 22, 45, 62, 74, 24, 47, 65, 77, 25, 49, 68, 81,
    ];
    var EC_CODEWORDS_TABLE = [
      // L  M  Q  H
      7, 10, 13, 17, 10, 16, 22, 28, 15, 26, 36, 44, 20, 36, 52, 64, 26, 48, 72,
      88, 36, 64, 96, 112, 40, 72, 108, 130, 48, 88, 132, 156, 60, 110, 160,
      192, 72, 130, 192, 224, 80, 150, 224, 264, 96, 176, 260, 308, 104, 198,
      288, 352, 120, 216, 320, 384, 132, 240, 360, 432, 144, 280, 408, 480, 168,
      308, 448, 532, 180, 338, 504, 588, 196, 364, 546, 650, 224, 416, 600, 700,
      224, 442, 644, 750, 252, 476, 690, 816, 270, 504, 750, 900, 300, 560, 810,
      960, 312, 588, 870, 1050, 336, 644, 952, 1110, 360, 700, 1020, 1200, 390,
      728, 1050, 1260, 420, 784, 1140, 1350, 450, 812, 1200, 1440, 480, 868,
      1290, 1530, 510, 924, 1350, 1620, 540, 980, 1440, 1710, 570, 1036, 1530,
      1800, 570, 1064, 1590, 1890, 600, 1120, 1680, 1980, 630, 1204, 1770, 2100,
      660, 1260, 1860, 2220, 720, 1316, 1950, 2310, 750, 1372, 2040, 2430,
    ];
    exports.getBlocksCount = function getBlocksCount(
      version2,
      errorCorrectionLevel
    ) {
      switch (errorCorrectionLevel) {
        case ECLevel.L:
          return EC_BLOCKS_TABLE[(version2 - 1) * 4 + 0];
        case ECLevel.M:
          return EC_BLOCKS_TABLE[(version2 - 1) * 4 + 1];
        case ECLevel.Q:
          return EC_BLOCKS_TABLE[(version2 - 1) * 4 + 2];
        case ECLevel.H:
          return EC_BLOCKS_TABLE[(version2 - 1) * 4 + 3];
        default:
          return void 0;
      }
    };
    exports.getTotalCodewordsCount = function getTotalCodewordsCount(
      version2,
      errorCorrectionLevel
    ) {
      switch (errorCorrectionLevel) {
        case ECLevel.L:
          return EC_CODEWORDS_TABLE[(version2 - 1) * 4 + 0];
        case ECLevel.M:
          return EC_CODEWORDS_TABLE[(version2 - 1) * 4 + 1];
        case ECLevel.Q:
          return EC_CODEWORDS_TABLE[(version2 - 1) * 4 + 2];
        case ECLevel.H:
          return EC_CODEWORDS_TABLE[(version2 - 1) * 4 + 3];
        default:
          return void 0;
      }
    };
  },
});

// node_modules/qrcode/lib/core/galois-field.js
var require_galois_field = __commonJS({
  "node_modules/qrcode/lib/core/galois-field.js"(exports) {
    var EXP_TABLE = new Uint8Array(512);
    var LOG_TABLE = new Uint8Array(256);
    (function initTables() {
      let x = 1;
      for (let i = 0; i < 255; i++) {
        EXP_TABLE[i] = x;
        LOG_TABLE[x] = i;
        x <<= 1;
        if (x & 256) {
          x ^= 285;
        }
      }
      for (let i = 255; i < 512; i++) {
        EXP_TABLE[i] = EXP_TABLE[i - 255];
      }
    })();
    exports.log = function log(n) {
      if (n < 1) throw new Error("log(" + n + ")");
      return LOG_TABLE[n];
    };
    exports.exp = function exp(n) {
      return EXP_TABLE[n];
    };
    exports.mul = function mul(x, y) {
      if (x === 0 || y === 0) return 0;
      return EXP_TABLE[LOG_TABLE[x] + LOG_TABLE[y]];
    };
  },
});

// node_modules/qrcode/lib/core/polynomial.js
var require_polynomial = __commonJS({
  "node_modules/qrcode/lib/core/polynomial.js"(exports) {
    var GF = require_galois_field();
    exports.mul = function mul(p1, p2) {
      const coeff = new Uint8Array(p1.length + p2.length - 1);
      for (let i = 0; i < p1.length; i++) {
        for (let j = 0; j < p2.length; j++) {
          coeff[i + j] ^= GF.mul(p1[i], p2[j]);
        }
      }
      return coeff;
    };
    exports.mod = function mod(divident, divisor) {
      let result = new Uint8Array(divident);
      while (result.length - divisor.length >= 0) {
        const coeff = result[0];
        for (let i = 0; i < divisor.length; i++) {
          result[i] ^= GF.mul(divisor[i], coeff);
        }
        let offset = 0;
        while (offset < result.length && result[offset] === 0) offset++;
        result = result.slice(offset);
      }
      return result;
    };
    exports.generateECPolynomial = function generateECPolynomial(degree) {
      let poly = new Uint8Array([1]);
      for (let i = 0; i < degree; i++) {
        poly = exports.mul(poly, new Uint8Array([1, GF.exp(i)]));
      }
      return poly;
    };
  },
});

// node_modules/qrcode/lib/core/reed-solomon-encoder.js
var require_reed_solomon_encoder = __commonJS({
  "node_modules/qrcode/lib/core/reed-solomon-encoder.js"(exports, module) {
    var Polynomial = require_polynomial();
    function ReedSolomonEncoder(degree) {
      this.genPoly = void 0;
      this.degree = degree;
      if (this.degree) this.initialize(this.degree);
    }
    ReedSolomonEncoder.prototype.initialize = function initialize(degree) {
      this.degree = degree;
      this.genPoly = Polynomial.generateECPolynomial(this.degree);
    };
    ReedSolomonEncoder.prototype.encode = function encode(data2) {
      if (!this.genPoly) {
        throw new Error("Encoder not initialized");
      }
      const paddedData = new Uint8Array(data2.length + this.degree);
      paddedData.set(data2);
      const remainder = Polynomial.mod(paddedData, this.genPoly);
      const start = this.degree - remainder.length;
      if (start > 0) {
        const buff = new Uint8Array(this.degree);
        buff.set(remainder, start);
        return buff;
      }
      return remainder;
    };
    module.exports = ReedSolomonEncoder;
  },
});

// node_modules/qrcode/lib/core/version-check.js
var require_version_check = __commonJS({
  "node_modules/qrcode/lib/core/version-check.js"(exports) {
    exports.isValid = function isValid(version2) {
      return !isNaN(version2) && version2 >= 1 && version2 <= 40;
    };
  },
});

// node_modules/qrcode/lib/core/regex.js
var require_regex = __commonJS({
  "node_modules/qrcode/lib/core/regex.js"(exports) {
    var numeric = "[0-9]+";
    var alphanumeric = "[A-Z $%*+\\-./:]+";
    var kanji =
      "(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+";
    kanji = kanji.replace(/u/g, "\\u");
    var byte = "(?:(?![A-Z0-9 $%*+\\-./:]|" + kanji + ")(?:.|[\r\n]))+";
    exports.KANJI = new RegExp(kanji, "g");
    exports.BYTE_KANJI = new RegExp("[^A-Z0-9 $%*+\\-./:]+", "g");
    exports.BYTE = new RegExp(byte, "g");
    exports.NUMERIC = new RegExp(numeric, "g");
    exports.ALPHANUMERIC = new RegExp(alphanumeric, "g");
    var TEST_KANJI = new RegExp("^" + kanji + "$");
    var TEST_NUMERIC = new RegExp("^" + numeric + "$");
    var TEST_ALPHANUMERIC = new RegExp("^[A-Z0-9 $%*+\\-./:]+$");
    exports.testKanji = function testKanji(str) {
      return TEST_KANJI.test(str);
    };
    exports.testNumeric = function testNumeric(str) {
      return TEST_NUMERIC.test(str);
    };
    exports.testAlphanumeric = function testAlphanumeric(str) {
      return TEST_ALPHANUMERIC.test(str);
    };
  },
});

// node_modules/qrcode/lib/core/mode.js
var require_mode = __commonJS({
  "node_modules/qrcode/lib/core/mode.js"(exports) {
    var VersionCheck = require_version_check();
    var Regex = require_regex();
    exports.NUMERIC = {
      id: "Numeric",
      bit: 1 << 0,
      ccBits: [10, 12, 14],
    };
    exports.ALPHANUMERIC = {
      id: "Alphanumeric",
      bit: 1 << 1,
      ccBits: [9, 11, 13],
    };
    exports.BYTE = {
      id: "Byte",
      bit: 1 << 2,
      ccBits: [8, 16, 16],
    };
    exports.KANJI = {
      id: "Kanji",
      bit: 1 << 3,
      ccBits: [8, 10, 12],
    };
    exports.MIXED = {
      bit: -1,
    };
    exports.getCharCountIndicator = function getCharCountIndicator(
      mode,
      version2
    ) {
      if (!mode.ccBits) throw new Error("Invalid mode: " + mode);
      if (!VersionCheck.isValid(version2)) {
        throw new Error("Invalid version: " + version2);
      }
      if (version2 >= 1 && version2 < 10) return mode.ccBits[0];
      else if (version2 < 27) return mode.ccBits[1];
      return mode.ccBits[2];
    };
    exports.getBestModeForData = function getBestModeForData(dataStr) {
      if (Regex.testNumeric(dataStr)) return exports.NUMERIC;
      else if (Regex.testAlphanumeric(dataStr)) return exports.ALPHANUMERIC;
      else if (Regex.testKanji(dataStr)) return exports.KANJI;
      else return exports.BYTE;
    };
    exports.toString = function toString3(mode) {
      if (mode && mode.id) return mode.id;
      throw new Error("Invalid mode");
    };
    exports.isValid = function isValid(mode) {
      return mode && mode.bit && mode.ccBits;
    };
    function fromString(string) {
      if (typeof string !== "string") {
        throw new Error("Param is not a string");
      }
      const lcStr = string.toLowerCase();
      switch (lcStr) {
        case "numeric":
          return exports.NUMERIC;
        case "alphanumeric":
          return exports.ALPHANUMERIC;
        case "kanji":
          return exports.KANJI;
        case "byte":
          return exports.BYTE;
        default:
          throw new Error("Unknown mode: " + string);
      }
    }
    exports.from = function from(value, defaultValue) {
      if (exports.isValid(value)) {
        return value;
      }
      try {
        return fromString(value);
      } catch (e) {
        return defaultValue;
      }
    };
  },
});

// node_modules/qrcode/lib/core/version.js
var require_version = __commonJS({
  "node_modules/qrcode/lib/core/version.js"(exports) {
    var Utils = require_utils();
    var ECCode = require_error_correction_code();
    var ECLevel = require_error_correction_level();
    var Mode = require_mode();
    var VersionCheck = require_version_check();
    var G18 =
      (1 << 12) |
      (1 << 11) |
      (1 << 10) |
      (1 << 9) |
      (1 << 8) |
      (1 << 5) |
      (1 << 2) |
      (1 << 0);
    var G18_BCH = Utils.getBCHDigit(G18);
    function getBestVersionForDataLength(mode, length, errorCorrectionLevel) {
      for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {
        if (
          length <=
          exports.getCapacity(currentVersion, errorCorrectionLevel, mode)
        ) {
          return currentVersion;
        }
      }
      return void 0;
    }
    function getReservedBitsCount(mode, version2) {
      return Mode.getCharCountIndicator(mode, version2) + 4;
    }
    function getTotalBitsFromDataArray(segments, version2) {
      let totalBits = 0;
      segments.forEach(function (data2) {
        const reservedBits = getReservedBitsCount(data2.mode, version2);
        totalBits += reservedBits + data2.getBitsLength();
      });
      return totalBits;
    }
    function getBestVersionForMixedData(segments, errorCorrectionLevel) {
      for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {
        const length = getTotalBitsFromDataArray(segments, currentVersion);
        if (
          length <=
          exports.getCapacity(currentVersion, errorCorrectionLevel, Mode.MIXED)
        ) {
          return currentVersion;
        }
      }
      return void 0;
    }
    exports.from = function from(value, defaultValue) {
      if (VersionCheck.isValid(value)) {
        return parseInt(value, 10);
      }
      return defaultValue;
    };
    exports.getCapacity = function getCapacity(
      version2,
      errorCorrectionLevel,
      mode
    ) {
      if (!VersionCheck.isValid(version2)) {
        throw new Error("Invalid QR Code version");
      }
      if (typeof mode === "undefined") mode = Mode.BYTE;
      const totalCodewords = Utils.getSymbolTotalCodewords(version2);
      const ecTotalCodewords = ECCode.getTotalCodewordsCount(
        version2,
        errorCorrectionLevel
      );
      const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
      if (mode === Mode.MIXED) return dataTotalCodewordsBits;
      const usableBits =
        dataTotalCodewordsBits - getReservedBitsCount(mode, version2);
      switch (mode) {
        case Mode.NUMERIC:
          return Math.floor((usableBits / 10) * 3);
        case Mode.ALPHANUMERIC:
          return Math.floor((usableBits / 11) * 2);
        case Mode.KANJI:
          return Math.floor(usableBits / 13);
        case Mode.BYTE:
        default:
          return Math.floor(usableBits / 8);
      }
    };
    exports.getBestVersionForData = function getBestVersionForData(
      data2,
      errorCorrectionLevel
    ) {
      let seg;
      const ecl = ECLevel.from(errorCorrectionLevel, ECLevel.M);
      if (Array.isArray(data2)) {
        if (data2.length > 1) {
          return getBestVersionForMixedData(data2, ecl);
        }
        if (data2.length === 0) {
          return 1;
        }
        seg = data2[0];
      } else {
        seg = data2;
      }
      return getBestVersionForDataLength(seg.mode, seg.getLength(), ecl);
    };
    exports.getEncodedBits = function getEncodedBits(version2) {
      if (!VersionCheck.isValid(version2) || version2 < 7) {
        throw new Error("Invalid QR Code version");
      }
      let d = version2 << 12;
      while (Utils.getBCHDigit(d) - G18_BCH >= 0) {
        d ^= G18 << (Utils.getBCHDigit(d) - G18_BCH);
      }
      return (version2 << 12) | d;
    };
  },
});

// node_modules/qrcode/lib/core/format-info.js
var require_format_info = __commonJS({
  "node_modules/qrcode/lib/core/format-info.js"(exports) {
    var Utils = require_utils();
    var G15 =
      (1 << 10) |
      (1 << 8) |
      (1 << 5) |
      (1 << 4) |
      (1 << 2) |
      (1 << 1) |
      (1 << 0);
    var G15_MASK = (1 << 14) | (1 << 12) | (1 << 10) | (1 << 4) | (1 << 1);
    var G15_BCH = Utils.getBCHDigit(G15);
    exports.getEncodedBits = function getEncodedBits(
      errorCorrectionLevel,
      mask
    ) {
      const data2 = (errorCorrectionLevel.bit << 3) | mask;
      let d = data2 << 10;
      while (Utils.getBCHDigit(d) - G15_BCH >= 0) {
        d ^= G15 << (Utils.getBCHDigit(d) - G15_BCH);
      }
      return ((data2 << 10) | d) ^ G15_MASK;
    };
  },
});

// node_modules/qrcode/lib/core/numeric-data.js
var require_numeric_data = __commonJS({
  "node_modules/qrcode/lib/core/numeric-data.js"(exports, module) {
    var Mode = require_mode();
    function NumericData(data2) {
      this.mode = Mode.NUMERIC;
      this.data = data2.toString();
    }
    NumericData.getBitsLength = function getBitsLength(length) {
      return (
        10 * Math.floor(length / 3) + (length % 3 ? (length % 3) * 3 + 1 : 0)
      );
    };
    NumericData.prototype.getLength = function getLength() {
      return this.data.length;
    };
    NumericData.prototype.getBitsLength = function getBitsLength() {
      return NumericData.getBitsLength(this.data.length);
    };
    NumericData.prototype.write = function write(bitBuffer) {
      let i, group, value;
      for (i = 0; i + 3 <= this.data.length; i += 3) {
        group = this.data.substr(i, 3);
        value = parseInt(group, 10);
        bitBuffer.put(value, 10);
      }
      const remainingNum = this.data.length - i;
      if (remainingNum > 0) {
        group = this.data.substr(i);
        value = parseInt(group, 10);
        bitBuffer.put(value, remainingNum * 3 + 1);
      }
    };
    module.exports = NumericData;
  },
});

// node_modules/qrcode/lib/core/alphanumeric-data.js
var require_alphanumeric_data = __commonJS({
  "node_modules/qrcode/lib/core/alphanumeric-data.js"(exports, module) {
    var Mode = require_mode();
    var ALPHA_NUM_CHARS = [
      "0",
      "1",
      "2",
      "3",
      "4",
      "5",
      "6",
      "7",
      "8",
      "9",
      "A",
      "B",
      "C",
      "D",
      "E",
      "F",
      "G",
      "H",
      "I",
      "J",
      "K",
      "L",
      "M",
      "N",
      "O",
      "P",
      "Q",
      "R",
      "S",
      "T",
      "U",
      "V",
      "W",
      "X",
      "Y",
      "Z",
      " ",
      "$",
      "%",
      "*",
      "+",
      "-",
      ".",
      "/",
      ":",
    ];
    function AlphanumericData(data2) {
      this.mode = Mode.ALPHANUMERIC;
      this.data = data2;
    }
    AlphanumericData.getBitsLength = function getBitsLength(length) {
      return 11 * Math.floor(length / 2) + 6 * (length % 2);
    };
    AlphanumericData.prototype.getLength = function getLength() {
      return this.data.length;
    };
    AlphanumericData.prototype.getBitsLength = function getBitsLength() {
      return AlphanumericData.getBitsLength(this.data.length);
    };
    AlphanumericData.prototype.write = function write(bitBuffer) {
      let i;
      for (i = 0; i + 2 <= this.data.length; i += 2) {
        let value = ALPHA_NUM_CHARS.indexOf(this.data[i]) * 45;
        value += ALPHA_NUM_CHARS.indexOf(this.data[i + 1]);
        bitBuffer.put(value, 11);
      }
      if (this.data.length % 2) {
        bitBuffer.put(ALPHA_NUM_CHARS.indexOf(this.data[i]), 6);
      }
    };
    module.exports = AlphanumericData;
  },
});

// node_modules/encode-utf8/index.js
var require_encode_utf8 = __commonJS({
  "node_modules/encode-utf8/index.js"(exports, module) {
    module.exports = function encodeUtf8(input) {
      var result = [];
      var size = input.length;
      for (var index = 0; index < size; index++) {
        var point = input.charCodeAt(index);
        if (point >= 55296 && point <= 56319 && size > index + 1) {
          var second = input.charCodeAt(index + 1);
          if (second >= 56320 && second <= 57343) {
            point = (point - 55296) * 1024 + second - 56320 + 65536;
            index += 1;
          }
        }
        if (point < 128) {
          result.push(point);
          continue;
        }
        if (point < 2048) {
          result.push((point >> 6) | 192);
          result.push((point & 63) | 128);
          continue;
        }
        if (point < 55296 || (point >= 57344 && point < 65536)) {
          result.push((point >> 12) | 224);
          result.push(((point >> 6) & 63) | 128);
          result.push((point & 63) | 128);
          continue;
        }
        if (point >= 65536 && point <= 1114111) {
          result.push((point >> 18) | 240);
          result.push(((point >> 12) & 63) | 128);
          result.push(((point >> 6) & 63) | 128);
          result.push((point & 63) | 128);
          continue;
        }
        result.push(239, 191, 189);
      }
      return new Uint8Array(result).buffer;
    };
  },
});

// node_modules/qrcode/lib/core/byte-data.js
var require_byte_data = __commonJS({
  "node_modules/qrcode/lib/core/byte-data.js"(exports, module) {
    var encodeUtf8 = require_encode_utf8();
    var Mode = require_mode();
    function ByteData(data2) {
      this.mode = Mode.BYTE;
      if (typeof data2 === "string") {
        data2 = encodeUtf8(data2);
      }
      this.data = new Uint8Array(data2);
    }
    ByteData.getBitsLength = function getBitsLength(length) {
      return length * 8;
    };
    ByteData.prototype.getLength = function getLength() {
      return this.data.length;
    };
    ByteData.prototype.getBitsLength = function getBitsLength() {
      return ByteData.getBitsLength(this.data.length);
    };
    ByteData.prototype.write = function (bitBuffer) {
      for (let i = 0, l = this.data.length; i < l; i++) {
        bitBuffer.put(this.data[i], 8);
      }
    };
    module.exports = ByteData;
  },
});

// node_modules/qrcode/lib/core/kanji-data.js
var require_kanji_data = __commonJS({
  "node_modules/qrcode/lib/core/kanji-data.js"(exports, module) {
    var Mode = require_mode();
    var Utils = require_utils();
    function KanjiData(data2) {
      this.mode = Mode.KANJI;
      this.data = data2;
    }
    KanjiData.getBitsLength = function getBitsLength(length) {
      return length * 13;
    };
    KanjiData.prototype.getLength = function getLength() {
      return this.data.length;
    };
    KanjiData.prototype.getBitsLength = function getBitsLength() {
      return KanjiData.getBitsLength(this.data.length);
    };
    KanjiData.prototype.write = function (bitBuffer) {
      let i;
      for (i = 0; i < this.data.length; i++) {
        let value = Utils.toSJIS(this.data[i]);
        if (value >= 33088 && value <= 40956) {
          value -= 33088;
        } else if (value >= 57408 && value <= 60351) {
          value -= 49472;
        } else {
          throw new Error(
            "Invalid SJIS character: " +
              this.data[i] +
              "\nMake sure your charset is UTF-8"
          );
        }
        value = ((value >>> 8) & 255) * 192 + (value & 255);
        bitBuffer.put(value, 13);
      }
    };
    module.exports = KanjiData;
  },
});

// node_modules/dijkstrajs/dijkstra.js
var require_dijkstra = __commonJS({
  "node_modules/dijkstrajs/dijkstra.js"(exports, module) {
    var dijkstra = {
      single_source_shortest_paths: function (graph, s, d) {
        var predecessors = {};
        var costs = {};
        costs[s] = 0;
        var open = dijkstra.PriorityQueue.make();
        open.push(s, 0);
        var closest,
          u,
          v,
          cost_of_s_to_u,
          adjacent_nodes,
          cost_of_e,
          cost_of_s_to_u_plus_cost_of_e,
          cost_of_s_to_v,
          first_visit;
        while (!open.empty()) {
          closest = open.pop();
          u = closest.value;
          cost_of_s_to_u = closest.cost;
          adjacent_nodes = graph[u] || {};
          for (v in adjacent_nodes) {
            if (adjacent_nodes.hasOwnProperty(v)) {
              cost_of_e = adjacent_nodes[v];
              cost_of_s_to_u_plus_cost_of_e = cost_of_s_to_u + cost_of_e;
              cost_of_s_to_v = costs[v];
              first_visit = typeof costs[v] === "undefined";
              if (
                first_visit ||
                cost_of_s_to_v > cost_of_s_to_u_plus_cost_of_e
              ) {
                costs[v] = cost_of_s_to_u_plus_cost_of_e;
                open.push(v, cost_of_s_to_u_plus_cost_of_e);
                predecessors[v] = u;
              }
            }
          }
        }
        if (typeof d !== "undefined" && typeof costs[d] === "undefined") {
          var msg = ["Could not find a path from ", s, " to ", d, "."].join("");
          throw new Error(msg);
        }
        return predecessors;
      },
      extract_shortest_path_from_predecessor_list: function (predecessors, d) {
        var nodes = [];
        var u = d;
        while (u) {
          nodes.push(u);
          predecessors[u];
          u = predecessors[u];
        }
        nodes.reverse();
        return nodes;
      },
      find_path: function (graph, s, d) {
        var predecessors = dijkstra.single_source_shortest_paths(graph, s, d);
        return dijkstra.extract_shortest_path_from_predecessor_list(
          predecessors,
          d
        );
      },
      /**
       * A very naive priority queue implementation.
       */
      PriorityQueue: {
        make: function (opts) {
          var T = dijkstra.PriorityQueue,
            t = {},
            key;
          opts = opts || {};
          for (key in T) {
            if (T.hasOwnProperty(key)) {
              t[key] = T[key];
            }
          }
          t.queue = [];
          t.sorter = opts.sorter || T.default_sorter;
          return t;
        },
        default_sorter: function (a, b) {
          return a.cost - b.cost;
        },
        /**
         * Add a new item to the queue and ensure the highest priority element
         * is at the front of the queue.
         */
        push: function (value, cost) {
          var item = { value, cost };
          this.queue.push(item);
          this.queue.sort(this.sorter);
        },
        /**
         * Return the highest priority element in the queue.
         */
        pop: function () {
          return this.queue.shift();
        },
        empty: function () {
          return this.queue.length === 0;
        },
      },
    };
    if (typeof module !== "undefined") {
      module.exports = dijkstra;
    }
  },
});

// node_modules/qrcode/lib/core/segments.js
var require_segments = __commonJS({
  "node_modules/qrcode/lib/core/segments.js"(exports) {
    var Mode = require_mode();
    var NumericData = require_numeric_data();
    var AlphanumericData = require_alphanumeric_data();
    var ByteData = require_byte_data();
    var KanjiData = require_kanji_data();
    var Regex = require_regex();
    var Utils = require_utils();
    var dijkstra = require_dijkstra();
    function getStringByteLength(str) {
      return unescape(encodeURIComponent(str)).length;
    }
    function getSegments(regex, mode, str) {
      const segments = [];
      let result;
      while ((result = regex.exec(str)) !== null) {
        segments.push({
          data: result[0],
          index: result.index,
          mode,
          length: result[0].length,
        });
      }
      return segments;
    }
    function getSegmentsFromString(dataStr) {
      const numSegs = getSegments(Regex.NUMERIC, Mode.NUMERIC, dataStr);
      const alphaNumSegs = getSegments(
        Regex.ALPHANUMERIC,
        Mode.ALPHANUMERIC,
        dataStr
      );
      let byteSegs;
      let kanjiSegs;
      if (Utils.isKanjiModeEnabled()) {
        byteSegs = getSegments(Regex.BYTE, Mode.BYTE, dataStr);
        kanjiSegs = getSegments(Regex.KANJI, Mode.KANJI, dataStr);
      } else {
        byteSegs = getSegments(Regex.BYTE_KANJI, Mode.BYTE, dataStr);
        kanjiSegs = [];
      }
      const segs = numSegs.concat(alphaNumSegs, byteSegs, kanjiSegs);
      return segs
        .sort(function (s1, s2) {
          return s1.index - s2.index;
        })
        .map(function (obj) {
          return {
            data: obj.data,
            mode: obj.mode,
            length: obj.length,
          };
        });
    }
    function getSegmentBitsLength(length, mode) {
      switch (mode) {
        case Mode.NUMERIC:
          return NumericData.getBitsLength(length);
        case Mode.ALPHANUMERIC:
          return AlphanumericData.getBitsLength(length);
        case Mode.KANJI:
          return KanjiData.getBitsLength(length);
        case Mode.BYTE:
          return ByteData.getBitsLength(length);
      }
    }
    function mergeSegments(segs) {
      return segs.reduce(function (acc, curr) {
        const prevSeg = acc.length - 1 >= 0 ? acc[acc.length - 1] : null;
        if (prevSeg && prevSeg.mode === curr.mode) {
          acc[acc.length - 1].data += curr.data;
          return acc;
        }
        acc.push(curr);
        return acc;
      }, []);
    }
    function buildNodes(segs) {
      const nodes = [];
      for (let i = 0; i < segs.length; i++) {
        const seg = segs[i];
        switch (seg.mode) {
          case Mode.NUMERIC:
            nodes.push([
              seg,
              { data: seg.data, mode: Mode.ALPHANUMERIC, length: seg.length },
              { data: seg.data, mode: Mode.BYTE, length: seg.length },
            ]);
            break;
          case Mode.ALPHANUMERIC:
            nodes.push([
              seg,
              { data: seg.data, mode: Mode.BYTE, length: seg.length },
            ]);
            break;
          case Mode.KANJI:
            nodes.push([
              seg,
              {
                data: seg.data,
                mode: Mode.BYTE,
                length: getStringByteLength(seg.data),
              },
            ]);
            break;
          case Mode.BYTE:
            nodes.push([
              {
                data: seg.data,
                mode: Mode.BYTE,
                length: getStringByteLength(seg.data),
              },
            ]);
        }
      }
      return nodes;
    }
    function buildGraph(nodes, version2) {
      const table = {};
      const graph = { start: {} };
      let prevNodeIds = ["start"];
      for (let i = 0; i < nodes.length; i++) {
        const nodeGroup = nodes[i];
        const currentNodeIds = [];
        for (let j = 0; j < nodeGroup.length; j++) {
          const node2 = nodeGroup[j];
          const key = "" + i + j;
          currentNodeIds.push(key);
          table[key] = { node: node2, lastCount: 0 };
          graph[key] = {};
          for (let n = 0; n < prevNodeIds.length; n++) {
            const prevNodeId = prevNodeIds[n];
            if (
              table[prevNodeId] &&
              table[prevNodeId].node.mode === node2.mode
            ) {
              graph[prevNodeId][key] =
                getSegmentBitsLength(
                  table[prevNodeId].lastCount + node2.length,
                  node2.mode
                ) -
                getSegmentBitsLength(table[prevNodeId].lastCount, node2.mode);
              table[prevNodeId].lastCount += node2.length;
            } else {
              if (table[prevNodeId]) table[prevNodeId].lastCount = node2.length;
              graph[prevNodeId][key] =
                getSegmentBitsLength(node2.length, node2.mode) +
                4 +
                Mode.getCharCountIndicator(node2.mode, version2);
            }
          }
        }
        prevNodeIds = currentNodeIds;
      }
      for (let n = 0; n < prevNodeIds.length; n++) {
        graph[prevNodeIds[n]].end = 0;
      }
      return { map: graph, table };
    }
    function buildSingleSegment(data2, modesHint) {
      let mode;
      const bestMode = Mode.getBestModeForData(data2);
      mode = Mode.from(modesHint, bestMode);
      if (mode !== Mode.BYTE && mode.bit < bestMode.bit) {
        throw new Error(
          '"' +
            data2 +
            '" cannot be encoded with mode ' +
            Mode.toString(mode) +
            ".\n Suggested mode is: " +
            Mode.toString(bestMode)
        );
      }
      if (mode === Mode.KANJI && !Utils.isKanjiModeEnabled()) {
        mode = Mode.BYTE;
      }
      switch (mode) {
        case Mode.NUMERIC:
          return new NumericData(data2);
        case Mode.ALPHANUMERIC:
          return new AlphanumericData(data2);
        case Mode.KANJI:
          return new KanjiData(data2);
        case Mode.BYTE:
          return new ByteData(data2);
      }
    }
    exports.fromArray = function fromArray(array) {
      return array.reduce(function (acc, seg) {
        if (typeof seg === "string") {
          acc.push(buildSingleSegment(seg, null));
        } else if (seg.data) {
          acc.push(buildSingleSegment(seg.data, seg.mode));
        }
        return acc;
      }, []);
    };
    exports.fromString = function fromString(data2, version2) {
      const segs = getSegmentsFromString(data2, Utils.isKanjiModeEnabled());
      const nodes = buildNodes(segs);
      const graph = buildGraph(nodes, version2);
      const path = dijkstra.find_path(graph.map, "start", "end");
      const optimizedSegs = [];
      for (let i = 1; i < path.length - 1; i++) {
        optimizedSegs.push(graph.table[path[i]].node);
      }
      return exports.fromArray(mergeSegments(optimizedSegs));
    };
    exports.rawSplit = function rawSplit(data2) {
      return exports.fromArray(
        getSegmentsFromString(data2, Utils.isKanjiModeEnabled())
      );
    };
  },
});

// node_modules/qrcode/lib/core/qrcode.js
var require_qrcode = __commonJS({
  "node_modules/qrcode/lib/core/qrcode.js"(exports) {
    var Utils = require_utils();
    var ECLevel = require_error_correction_level();
    var BitBuffer = require_bit_buffer();
    var BitMatrix = require_bit_matrix();
    var AlignmentPattern = require_alignment_pattern();
    var FinderPattern = require_finder_pattern();
    var MaskPattern = require_mask_pattern();
    var ECCode = require_error_correction_code();
    var ReedSolomonEncoder = require_reed_solomon_encoder();
    var Version = require_version();
    var FormatInfo = require_format_info();
    var Mode = require_mode();
    var Segments = require_segments();
    function setupFinderPattern(matrix, version2) {
      const size = matrix.size;
      const pos = FinderPattern.getPositions(version2);
      for (let i = 0; i < pos.length; i++) {
        const row = pos[i][0];
        const col = pos[i][1];
        for (let r = -1; r <= 7; r++) {
          if (row + r <= -1 || size <= row + r) continue;
          for (let c = -1; c <= 7; c++) {
            if (col + c <= -1 || size <= col + c) continue;
            if (
              (r >= 0 && r <= 6 && (c === 0 || c === 6)) ||
              (c >= 0 && c <= 6 && (r === 0 || r === 6)) ||
              (r >= 2 && r <= 4 && c >= 2 && c <= 4)
            ) {
              matrix.set(row + r, col + c, true, true);
            } else {
              matrix.set(row + r, col + c, false, true);
            }
          }
        }
      }
    }
    function setupTimingPattern(matrix) {
      const size = matrix.size;
      for (let r = 8; r < size - 8; r++) {
        const value = r % 2 === 0;
        matrix.set(r, 6, value, true);
        matrix.set(6, r, value, true);
      }
    }
    function setupAlignmentPattern(matrix, version2) {
      const pos = AlignmentPattern.getPositions(version2);
      for (let i = 0; i < pos.length; i++) {
        const row = pos[i][0];
        const col = pos[i][1];
        for (let r = -2; r <= 2; r++) {
          for (let c = -2; c <= 2; c++) {
            if (
              r === -2 ||
              r === 2 ||
              c === -2 ||
              c === 2 ||
              (r === 0 && c === 0)
            ) {
              matrix.set(row + r, col + c, true, true);
            } else {
              matrix.set(row + r, col + c, false, true);
            }
          }
        }
      }
    }
    function setupVersionInfo(matrix, version2) {
      const size = matrix.size;
      const bits = Version.getEncodedBits(version2);
      let row, col, mod;
      for (let i = 0; i < 18; i++) {
        row = Math.floor(i / 3);
        col = (i % 3) + size - 8 - 3;
        mod = ((bits >> i) & 1) === 1;
        matrix.set(row, col, mod, true);
        matrix.set(col, row, mod, true);
      }
    }
    function setupFormatInfo(matrix, errorCorrectionLevel, maskPattern) {
      const size = matrix.size;
      const bits = FormatInfo.getEncodedBits(errorCorrectionLevel, maskPattern);
      let i, mod;
      for (i = 0; i < 15; i++) {
        mod = ((bits >> i) & 1) === 1;
        if (i < 6) {
          matrix.set(i, 8, mod, true);
        } else if (i < 8) {
          matrix.set(i + 1, 8, mod, true);
        } else {
          matrix.set(size - 15 + i, 8, mod, true);
        }
        if (i < 8) {
          matrix.set(8, size - i - 1, mod, true);
        } else if (i < 9) {
          matrix.set(8, 15 - i - 1 + 1, mod, true);
        } else {
          matrix.set(8, 15 - i - 1, mod, true);
        }
      }
      matrix.set(size - 8, 8, 1, true);
    }
    function setupData(matrix, data2) {
      const size = matrix.size;
      let inc = -1;
      let row = size - 1;
      let bitIndex = 7;
      let byteIndex = 0;
      for (let col = size - 1; col > 0; col -= 2) {
        if (col === 6) col--;
        while (true) {
          for (let c = 0; c < 2; c++) {
            if (!matrix.isReserved(row, col - c)) {
              let dark = false;
              if (byteIndex < data2.length) {
                dark = ((data2[byteIndex] >>> bitIndex) & 1) === 1;
              }
              matrix.set(row, col - c, dark);
              bitIndex--;
              if (bitIndex === -1) {
                byteIndex++;
                bitIndex = 7;
              }
            }
          }
          row += inc;
          if (row < 0 || size <= row) {
            row -= inc;
            inc = -inc;
            break;
          }
        }
      }
    }
    function createData(version2, errorCorrectionLevel, segments) {
      const buffer = new BitBuffer();
      segments.forEach(function (data2) {
        buffer.put(data2.mode.bit, 4);
        buffer.put(
          data2.getLength(),
          Mode.getCharCountIndicator(data2.mode, version2)
        );
        data2.write(buffer);
      });
      const totalCodewords = Utils.getSymbolTotalCodewords(version2);
      const ecTotalCodewords = ECCode.getTotalCodewordsCount(
        version2,
        errorCorrectionLevel
      );
      const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
      if (buffer.getLengthInBits() + 4 <= dataTotalCodewordsBits) {
        buffer.put(0, 4);
      }
      while (buffer.getLengthInBits() % 8 !== 0) {
        buffer.putBit(0);
      }
      const remainingByte =
        (dataTotalCodewordsBits - buffer.getLengthInBits()) / 8;
      for (let i = 0; i < remainingByte; i++) {
        buffer.put(i % 2 ? 17 : 236, 8);
      }
      return createCodewords(buffer, version2, errorCorrectionLevel);
    }
    function createCodewords(bitBuffer, version2, errorCorrectionLevel) {
      const totalCodewords = Utils.getSymbolTotalCodewords(version2);
      const ecTotalCodewords = ECCode.getTotalCodewordsCount(
        version2,
        errorCorrectionLevel
      );
      const dataTotalCodewords = totalCodewords - ecTotalCodewords;
      const ecTotalBlocks = ECCode.getBlocksCount(
        version2,
        errorCorrectionLevel
      );
      const blocksInGroup2 = totalCodewords % ecTotalBlocks;
      const blocksInGroup1 = ecTotalBlocks - blocksInGroup2;
      const totalCodewordsInGroup1 = Math.floor(totalCodewords / ecTotalBlocks);
      const dataCodewordsInGroup1 = Math.floor(
        dataTotalCodewords / ecTotalBlocks
      );
      const dataCodewordsInGroup2 = dataCodewordsInGroup1 + 1;
      const ecCount = totalCodewordsInGroup1 - dataCodewordsInGroup1;
      const rs = new ReedSolomonEncoder(ecCount);
      let offset = 0;
      const dcData = new Array(ecTotalBlocks);
      const ecData = new Array(ecTotalBlocks);
      let maxDataSize = 0;
      const buffer = new Uint8Array(bitBuffer.buffer);
      for (let b = 0; b < ecTotalBlocks; b++) {
        const dataSize =
          b < blocksInGroup1 ? dataCodewordsInGroup1 : dataCodewordsInGroup2;
        dcData[b] = buffer.slice(offset, offset + dataSize);
        ecData[b] = rs.encode(dcData[b]);
        offset += dataSize;
        maxDataSize = Math.max(maxDataSize, dataSize);
      }
      const data2 = new Uint8Array(totalCodewords);
      let index = 0;
      let i, r;
      for (i = 0; i < maxDataSize; i++) {
        for (r = 0; r < ecTotalBlocks; r++) {
          if (i < dcData[r].length) {
            data2[index++] = dcData[r][i];
          }
        }
      }
      for (i = 0; i < ecCount; i++) {
        for (r = 0; r < ecTotalBlocks; r++) {
          data2[index++] = ecData[r][i];
        }
      }
      return data2;
    }
    function createSymbol(data2, version2, errorCorrectionLevel, maskPattern) {
      let segments;
      if (Array.isArray(data2)) {
        segments = Segments.fromArray(data2);
      } else if (typeof data2 === "string") {
        let estimatedVersion = version2;
        if (!estimatedVersion) {
          const rawSegments = Segments.rawSplit(data2);
          estimatedVersion = Version.getBestVersionForData(
            rawSegments,
            errorCorrectionLevel
          );
        }
        segments = Segments.fromString(data2, estimatedVersion || 40);
      } else {
        throw new Error("Invalid data");
      }
      const bestVersion = Version.getBestVersionForData(
        segments,
        errorCorrectionLevel
      );
      if (!bestVersion) {
        throw new Error(
          "The amount of data is too big to be stored in a QR Code"
        );
      }
      if (!version2) {
        version2 = bestVersion;
      } else if (version2 < bestVersion) {
        throw new Error(
          "\nThe chosen QR Code version cannot contain this amount of data.\nMinimum version required to store current data is: " +
            bestVersion +
            ".\n"
        );
      }
      const dataBits = createData(version2, errorCorrectionLevel, segments);
      const moduleCount = Utils.getSymbolSize(version2);
      const modules = new BitMatrix(moduleCount);
      setupFinderPattern(modules, version2);
      setupTimingPattern(modules);
      setupAlignmentPattern(modules, version2);
      setupFormatInfo(modules, errorCorrectionLevel, 0);
      if (version2 >= 7) {
        setupVersionInfo(modules, version2);
      }
      setupData(modules, dataBits);
      if (isNaN(maskPattern)) {
        maskPattern = MaskPattern.getBestMask(
          modules,
          setupFormatInfo.bind(null, modules, errorCorrectionLevel)
        );
      }
      MaskPattern.applyMask(maskPattern, modules);
      setupFormatInfo(modules, errorCorrectionLevel, maskPattern);
      return {
        modules,
        version: version2,
        errorCorrectionLevel,
        maskPattern,
        segments,
      };
    }
    exports.create = function create3(data2, options) {
      if (typeof data2 === "undefined" || data2 === "") {
        throw new Error("No input text");
      }
      let errorCorrectionLevel = ECLevel.M;
      let version2;
      let mask;
      if (typeof options !== "undefined") {
        errorCorrectionLevel = ECLevel.from(
          options.errorCorrectionLevel,
          ECLevel.M
        );
        version2 = Version.from(options.version);
        mask = MaskPattern.from(options.maskPattern);
        if (options.toSJISFunc) {
          Utils.setToSJISFunction(options.toSJISFunc);
        }
      }
      return createSymbol(data2, version2, errorCorrectionLevel, mask);
    };
  },
});

// node_modules/qrcode/lib/renderer/utils.js
var require_utils2 = __commonJS({
  "node_modules/qrcode/lib/renderer/utils.js"(exports) {
    function hex2rgba(hex) {
      if (typeof hex === "number") {
        hex = hex.toString();
      }
      if (typeof hex !== "string") {
        throw new Error("Color should be defined as hex string");
      }
      let hexCode = hex.slice().replace("#", "").split("");
      if (hexCode.length < 3 || hexCode.length === 5 || hexCode.length > 8) {
        throw new Error("Invalid hex color: " + hex);
      }
      if (hexCode.length === 3 || hexCode.length === 4) {
        hexCode = Array.prototype.concat.apply(
          [],
          hexCode.map(function (c) {
            return [c, c];
          })
        );
      }
      if (hexCode.length === 6) hexCode.push("F", "F");
      const hexValue = parseInt(hexCode.join(""), 16);
      return {
        r: (hexValue >> 24) & 255,
        g: (hexValue >> 16) & 255,
        b: (hexValue >> 8) & 255,
        a: hexValue & 255,
        hex: "#" + hexCode.slice(0, 6).join(""),
      };
    }
    exports.getOptions = function getOptions(options) {
      if (!options) options = {};
      if (!options.color) options.color = {};
      const margin =
        typeof options.margin === "undefined" ||
        options.margin === null ||
        options.margin < 0
          ? 4
          : options.margin;
      const width =
        options.width && options.width >= 21 ? options.width : void 0;
      const scale = options.scale || 4;
      return {
        width,
        scale: width ? 4 : scale,
        margin,
        color: {
          dark: hex2rgba(options.color.dark || "#000000ff"),
          light: hex2rgba(options.color.light || "#ffffffff"),
        },
        type: options.type,
        rendererOpts: options.rendererOpts || {},
      };
    };
    exports.getScale = function getScale(qrSize, opts) {
      return opts.width && opts.width >= qrSize + opts.margin * 2
        ? opts.width / (qrSize + opts.margin * 2)
        : opts.scale;
    };
    exports.getImageWidth = function getImageWidth(qrSize, opts) {
      const scale = exports.getScale(qrSize, opts);
      return Math.floor((qrSize + opts.margin * 2) * scale);
    };
    exports.qrToImageData = function qrToImageData(imgData, qr, opts) {
      const size = qr.modules.size;
      const data2 = qr.modules.data;
      const scale = exports.getScale(size, opts);
      const symbolSize = Math.floor((size + opts.margin * 2) * scale);
      const scaledMargin = opts.margin * scale;
      const palette = [opts.color.light, opts.color.dark];
      for (let i = 0; i < symbolSize; i++) {
        for (let j = 0; j < symbolSize; j++) {
          let posDst = (i * symbolSize + j) * 4;
          let pxColor = opts.color.light;
          if (
            i >= scaledMargin &&
            j >= scaledMargin &&
            i < symbolSize - scaledMargin &&
            j < symbolSize - scaledMargin
          ) {
            const iSrc = Math.floor((i - scaledMargin) / scale);
            const jSrc = Math.floor((j - scaledMargin) / scale);
            pxColor = palette[data2[iSrc * size + jSrc] ? 1 : 0];
          }
          imgData[posDst++] = pxColor.r;
          imgData[posDst++] = pxColor.g;
          imgData[posDst++] = pxColor.b;
          imgData[posDst] = pxColor.a;
        }
      }
    };
  },
});

// node_modules/qrcode/lib/renderer/canvas.js
var require_canvas = __commonJS({
  "node_modules/qrcode/lib/renderer/canvas.js"(exports) {
    var Utils = require_utils2();
    function clearCanvas(ctx, canvas, size) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (!canvas.style) canvas.style = {};
      canvas.height = size;
      canvas.width = size;
      canvas.style.height = size + "px";
      canvas.style.width = size + "px";
    }
    function getCanvasElement() {
      try {
        return document.createElement("canvas");
      } catch (e) {
        throw new Error("You need to specify a canvas element");
      }
    }
    exports.render = function render(qrData, canvas, options) {
      let opts = options;
      let canvasEl = canvas;
      if (typeof opts === "undefined" && (!canvas || !canvas.getContext)) {
        opts = canvas;
        canvas = void 0;
      }
      if (!canvas) {
        canvasEl = getCanvasElement();
      }
      opts = Utils.getOptions(opts);
      const size = Utils.getImageWidth(qrData.modules.size, opts);
      const ctx = canvasEl.getContext("2d");
      const image = ctx.createImageData(size, size);
      Utils.qrToImageData(image.data, qrData, opts);
      clearCanvas(ctx, canvasEl, size);
      ctx.putImageData(image, 0, 0);
      return canvasEl;
    };
    exports.renderToDataURL = function renderToDataURL(
      qrData,
      canvas,
      options
    ) {
      let opts = options;
      if (typeof opts === "undefined" && (!canvas || !canvas.getContext)) {
        opts = canvas;
        canvas = void 0;
      }
      if (!opts) opts = {};
      const canvasEl = exports.render(qrData, canvas, opts);
      const type = opts.type || "image/png";
      const rendererOpts = opts.rendererOpts || {};
      return canvasEl.toDataURL(type, rendererOpts.quality);
    };
  },
});

// node_modules/qrcode/lib/renderer/svg-tag.js
var require_svg_tag = __commonJS({
  "node_modules/qrcode/lib/renderer/svg-tag.js"(exports) {
    var Utils = require_utils2();
    function getColorAttrib(color, attrib) {
      const alpha = color.a / 255;
      const str = attrib + '="' + color.hex + '"';
      return alpha < 1
        ? str + " " + attrib + '-opacity="' + alpha.toFixed(2).slice(1) + '"'
        : str;
    }
    function svgCmd(cmd, x, y) {
      let str = cmd + x;
      if (typeof y !== "undefined") str += " " + y;
      return str;
    }
    function qrToPath(data2, size, margin) {
      let path = "";
      let moveBy = 0;
      let newRow = false;
      let lineLength = 0;
      for (let i = 0; i < data2.length; i++) {
        const col = Math.floor(i % size);
        const row = Math.floor(i / size);
        if (!col && !newRow) newRow = true;
        if (data2[i]) {
          lineLength++;
          if (!(i > 0 && col > 0 && data2[i - 1])) {
            path += newRow
              ? svgCmd("M", col + margin, 0.5 + row + margin)
              : svgCmd("m", moveBy, 0);
            moveBy = 0;
            newRow = false;
          }
          if (!(col + 1 < size && data2[i + 1])) {
            path += svgCmd("h", lineLength);
            lineLength = 0;
          }
        } else {
          moveBy++;
        }
      }
      return path;
    }
    exports.render = function render(qrData, options, cb) {
      const opts = Utils.getOptions(options);
      const size = qrData.modules.size;
      const data2 = qrData.modules.data;
      const qrcodesize = size + opts.margin * 2;
      const bg = !opts.color.light.a
        ? ""
        : "<path " +
          getColorAttrib(opts.color.light, "fill") +
          ' d="M0 0h' +
          qrcodesize +
          "v" +
          qrcodesize +
          'H0z"/>';
      const path =
        "<path " +
        getColorAttrib(opts.color.dark, "stroke") +
        ' d="' +
        qrToPath(data2, size, opts.margin) +
        '"/>';
      const viewBox = 'viewBox="0 0 ' + qrcodesize + " " + qrcodesize + '"';
      const width = !opts.width
        ? ""
        : 'width="' + opts.width + '" height="' + opts.width + '" ';
      const svgTag =
        '<svg xmlns="http://www.w3.org/2000/svg" ' +
        width +
        viewBox +
        ' shape-rendering="crispEdges">' +
        bg +
        path +
        "</svg>\n";
      if (typeof cb === "function") {
        cb(null, svgTag);
      }
      return svgTag;
    };
  },
});

// node_modules/qrcode/lib/browser.js
var require_browser = __commonJS({
  "node_modules/qrcode/lib/browser.js"(exports) {
    var canPromise = require_can_promise();
    var QRCode2 = require_qrcode();
    var CanvasRenderer = require_canvas();
    var SvgRenderer = require_svg_tag();
    function renderCanvas(renderFunc, canvas, text, opts, cb) {
      const args = [].slice.call(arguments, 1);
      const argsNum = args.length;
      const isLastArgCb = typeof args[argsNum - 1] === "function";
      if (!isLastArgCb && !canPromise()) {
        throw new Error("Callback required as last argument");
      }
      if (isLastArgCb) {
        if (argsNum < 2) {
          throw new Error("Too few arguments provided");
        }
        if (argsNum === 2) {
          cb = text;
          text = canvas;
          canvas = opts = void 0;
        } else if (argsNum === 3) {
          if (canvas.getContext && typeof cb === "undefined") {
            cb = opts;
            opts = void 0;
          } else {
            cb = opts;
            opts = text;
            text = canvas;
            canvas = void 0;
          }
        }
      } else {
        if (argsNum < 1) {
          throw new Error("Too few arguments provided");
        }
        if (argsNum === 1) {
          text = canvas;
          canvas = opts = void 0;
        } else if (argsNum === 2 && !canvas.getContext) {
          opts = text;
          text = canvas;
          canvas = void 0;
        }
        return new Promise(function (resolve2, reject2) {
          try {
            const data2 = QRCode2.create(text, opts);
            resolve2(renderFunc(data2, canvas, opts));
          } catch (e) {
            reject2(e);
          }
        });
      }
      try {
        const data2 = QRCode2.create(text, opts);
        cb(null, renderFunc(data2, canvas, opts));
      } catch (e) {
        cb(e);
      }
    }
    exports.create = QRCode2.create;
    exports.toCanvas = renderCanvas.bind(null, CanvasRenderer.render);
    exports.toDataURL = renderCanvas.bind(null, CanvasRenderer.renderToDataURL);
    exports.toString = renderCanvas.bind(null, function (data2, _, opts) {
      return SvgRenderer.render(data2, opts);
    });
  },
});

// node_modules/toggle-selection/index.js
var require_toggle_selection = __commonJS({
  "node_modules/toggle-selection/index.js"(exports, module) {
    module.exports = function () {
      var selection = document.getSelection();
      if (!selection.rangeCount) {
        return function () {};
      }
      var active = document.activeElement;
      var ranges = [];
      for (var i = 0; i < selection.rangeCount; i++) {
        ranges.push(selection.getRangeAt(i));
      }
      switch (active.tagName.toUpperCase()) {
        case "INPUT":
        case "TEXTAREA":
          active.blur();
          break;
        default:
          active = null;
          break;
      }
      selection.removeAllRanges();
      return function () {
        selection.type === "Caret" && selection.removeAllRanges();
        if (!selection.rangeCount) {
          ranges.forEach(function (range) {
            selection.addRange(range);
          });
        }
        active && active.focus();
      };
    };
  },
});

// node_modules/copy-to-clipboard/index.js
var require_copy_to_clipboard = __commonJS({
  "node_modules/copy-to-clipboard/index.js"(exports, module) {
    var deselectCurrent = require_toggle_selection();
    var clipboardToIE11Formatting = {
      "text/plain": "Text",
      "text/html": "Url",
      default: "Text",
    };
    var defaultMessage = "Copy to clipboard: #{key}, Enter";
    function format(message) {
      var copyKey =
        (/mac os x/i.test(navigator.userAgent) ? "" : "Ctrl") + "+C";
      return message.replace(/#{\s*key\s*}/g, copyKey);
    }
    function copy2(text, options) {
      var debug,
        message,
        reselectPrevious,
        range,
        selection,
        mark,
        success = false;
      if (!options) {
        options = {};
      }
      debug = options.debug || false;
      try {
        reselectPrevious = deselectCurrent();
        range = document.createRange();
        selection = document.getSelection();
        mark = document.createElement("span");
        mark.textContent = text;
        mark.ariaHidden = "true";
        mark.style.all = "unset";
        mark.style.position = "fixed";
        mark.style.top = 0;
        mark.style.clip = "rect(0, 0, 0, 0)";
        mark.style.whiteSpace = "pre";
        mark.style.webkitUserSelect = "text";
        mark.style.MozUserSelect = "text";
        mark.style.msUserSelect = "text";
        mark.style.userSelect = "text";
        mark.addEventListener("copy", function (e) {
          e.stopPropagation();
          if (options.format) {
            e.preventDefault();
            if (typeof e.clipboardData === "undefined") {
              debug && console.warn("unable to use e.clipboardData");
              debug && console.warn("trying IE specific stuff");
              window.clipboardData.clearData();
              var format2 =
                clipboardToIE11Formatting[options.format] ||
                clipboardToIE11Formatting["default"];
              window.clipboardData.setData(format2, text);
            } else {
              e.clipboardData.clearData();
              e.clipboardData.setData(options.format, text);
            }
          }
          if (options.onCopy) {
            e.preventDefault();
            options.onCopy(e.clipboardData);
          }
        });
        document.body.appendChild(mark);
        range.selectNodeContents(mark);
        selection.addRange(range);
        var successful = document.execCommand("copy");
        if (!successful) {
          throw new Error("copy command was unsuccessful");
        }
        success = true;
      } catch (err) {
        debug && console.error("unable to copy using execCommand: ", err);
        debug && console.warn("trying IE specific stuff");
        try {
          window.clipboardData.setData(options.format || "text", text);
          options.onCopy && options.onCopy(window.clipboardData);
          success = true;
        } catch (err2) {
          debug && console.error("unable to copy using clipboardData: ", err2);
          debug && console.error("falling back to prompt");
          message = format(
            "message" in options ? options.message : defaultMessage
          );
          window.prompt(message, text);
        }
      } finally {
        if (selection) {
          if (typeof selection.removeRange == "function") {
            selection.removeRange(range);
          } else {
            selection.removeAllRanges();
          }
        }
        if (mark) {
          document.body.removeChild(mark);
        }
        reselectPrevious();
      }
      return success;
    }
    module.exports = copy2;
  },
});

// node_modules/@near-wallet-selector/modal-ui/index.js
var import_jsx_runtime = __toESM(require_jsx_runtime());
var import_client = __toESM(require_client());
var import_react = __toESM(require_react());
var import_qrcode = __toESM(require_browser());
var import_copy_to_clipboard = __toESM(require_copy_to_clipboard());
var commonjsGlobal$2 =
  typeof globalThis !== "undefined"
    ? globalThis
    : typeof window !== "undefined"
    ? window
    : typeof global !== "undefined"
    ? global
    : typeof self !== "undefined"
    ? self
    : {};
var fails$h = function (exec2) {
  try {
    return !!exec2();
  } catch (error) {
    return true;
  }
};
var fails$g = fails$h;
var functionBindNative$2 = !fails$g(function () {
  var test2 = function () {}.bind();
  return typeof test2 != "function" || test2.hasOwnProperty("prototype");
});
var NATIVE_BIND$3$1 = functionBindNative$2;
var FunctionPrototype$2$1 = Function.prototype;
var bind$5$1 = FunctionPrototype$2$1.bind;
var call$f$2 = FunctionPrototype$2$1.call;
var uncurryThis$h = NATIVE_BIND$3$1 && bind$5$1.bind(call$f$2, call$f$2);
var functionUncurryThis$2 = NATIVE_BIND$3$1
  ? function (fn) {
      return fn && uncurryThis$h(fn);
    }
  : function (fn) {
      return (
        fn &&
        function () {
          return call$f$2.apply(fn, arguments);
        }
      );
    };
var uncurryThis$g = functionUncurryThis$2;
var toString$5 = uncurryThis$g({}.toString);
var stringSlice$1$1 = uncurryThis$g("".slice);
var classofRaw$1$1 = function (it) {
  return stringSlice$1$1(toString$5(it), 8, -1);
};
var uncurryThis$f = functionUncurryThis$2;
var fails$f = fails$h;
var classof$6$1 = classofRaw$1$1;
var $Object$4$1 = Object;
var split$2 = uncurryThis$f("".split);
var indexedObject$2 = fails$f(function () {
  return !$Object$4$1("z").propertyIsEnumerable(0);
})
  ? function (it) {
      return classof$6$1(it) == "String" ? split$2(it, "") : $Object$4$1(it);
    }
  : $Object$4$1;
var $TypeError$e = TypeError;
var requireObjectCoercible$3$1 = function (it) {
  if (it == void 0) throw $TypeError$e("Can't call method on " + it);
  return it;
};
var IndexedObject$2$1 = indexedObject$2;
var requireObjectCoercible$2$2 = requireObjectCoercible$3$1;
var toIndexedObject$5$1 = function (it) {
  return IndexedObject$2$1(requireObjectCoercible$2$2(it));
};
var check$2 = function (it) {
  return it && it.Math == Math && it;
};
var global$k =
  // eslint-disable-next-line es-x/no-global-this -- safe
  check$2(typeof globalThis == "object" && globalThis) ||
  check$2(typeof window == "object" && window) || // eslint-disable-next-line no-restricted-globals -- safe
  check$2(typeof self == "object" && self) ||
  check$2(typeof commonjsGlobal$2 == "object" && commonjsGlobal$2) || // eslint-disable-next-line no-new-func -- fallback
  (function () {
    return this;
  })() ||
  Function("return this")();
var shared$3$2 = { exports: {} };
var global$j$1 = global$k;
var defineProperty$6 = Object.defineProperty;
var defineGlobalProperty$3$2 = function (key, value) {
  try {
    defineProperty$6(global$j$1, key, {
      value,
      configurable: true,
      writable: true,
    });
  } catch (error) {
    global$j$1[key] = value;
  }
  return value;
};
var global$i$1 = global$k;
var defineGlobalProperty$2$2 = defineGlobalProperty$3$2;
var SHARED$2 = "__core-js_shared__";
var store$3$2 = global$i$1[SHARED$2] || defineGlobalProperty$2$2(SHARED$2, {});
var sharedStore$2 = store$3$2;
var store$2$2 = sharedStore$2;
(shared$3$2.exports = function (key, value) {
  return store$2$2[key] || (store$2$2[key] = value !== void 0 ? value : {});
})("versions", []).push({
  version: "3.23.3",
  mode: "global",
  copyright: " 2014-2022 Denis Pushkarev (zloirock.ru)",
  license: "https://github.com/zloirock/core-js/blob/v3.23.3/LICENSE",
  source: "https://github.com/zloirock/core-js",
});
var requireObjectCoercible$1$2 = requireObjectCoercible$3$1;
var $Object$3$1 = Object;
var toObject$5 = function (argument) {
  return $Object$3$1(requireObjectCoercible$1$2(argument));
};
var uncurryThis$e$2 = functionUncurryThis$2;
var toObject$4 = toObject$5;
var hasOwnProperty$2 = uncurryThis$e$2({}.hasOwnProperty);
var hasOwnProperty_1$2 =
  Object.hasOwn ||
  function hasOwn(it, key) {
    return hasOwnProperty$2(toObject$4(it), key);
  };
var uncurryThis$d$1 = functionUncurryThis$2;
var id$2 = 0;
var postfix$2 = Math.random();
var toString$4 = uncurryThis$d$1((1).toString);
var uid$2$2 = function (key) {
  return (
    "Symbol(" +
    (key === void 0 ? "" : key) +
    ")_" +
    toString$4(++id$2 + postfix$2, 36)
  );
};
var isCallable$l$1 = function (argument) {
  return typeof argument == "function";
};
var global$h$1 = global$k;
var isCallable$k$1 = isCallable$l$1;
var aFunction$2 = function (argument) {
  return isCallable$k$1(argument) ? argument : void 0;
};
var getBuiltIn$8$1 = function (namespace, method) {
  return arguments.length < 2
    ? aFunction$2(global$h$1[namespace])
    : global$h$1[namespace] && global$h$1[namespace][method];
};
var getBuiltIn$7$1 = getBuiltIn$8$1;
var engineUserAgent$2 = getBuiltIn$7$1("navigator", "userAgent") || "";
var global$g$1 = global$k;
var userAgent$5 = engineUserAgent$2;
var process$3$1 = global$g$1.process;
var Deno$1$2 = global$g$1.Deno;
var versions$2 =
  (process$3$1 && process$3$1.versions) || (Deno$1$2 && Deno$1$2.version);
var v8$2 = versions$2 && versions$2.v8;
var match$2;
var version$2;
if (v8$2) {
  match$2 = v8$2.split(".");
  version$2 = match$2[0] > 0 && match$2[0] < 4 ? 1 : +(match$2[0] + match$2[1]);
}
if (!version$2 && userAgent$5) {
  match$2 = userAgent$5.match(/Edge\/(\d+)/);
  if (!match$2 || match$2[1] >= 74) {
    match$2 = userAgent$5.match(/Chrome\/(\d+)/);
    if (match$2) version$2 = +match$2[1];
  }
}
var engineV8Version$2 = version$2;
var V8_VERSION$1$1 = engineV8Version$2;
var fails$e$2 = fails$h;
var nativeSymbol$2 =
  !!Object.getOwnPropertySymbols &&
  !fails$e$2(function () {
    var symbol = Symbol();
    return (
      !String(symbol) ||
      !(Object(symbol) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
      (!Symbol.sham && V8_VERSION$1$1 && V8_VERSION$1$1 < 41)
    );
  });
var NATIVE_SYMBOL$2$1 = nativeSymbol$2;
var useSymbolAsUid$2 =
  NATIVE_SYMBOL$2$1 && !Symbol.sham && typeof Symbol.iterator == "symbol";
var global$f$1 = global$k;
var shared$2$2 = shared$3$2.exports;
var hasOwn$b = hasOwnProperty_1$2;
var uid$1$2 = uid$2$2;
var NATIVE_SYMBOL$1$2 = nativeSymbol$2;
var USE_SYMBOL_AS_UID$1$2 = useSymbolAsUid$2;
var WellKnownSymbolsStore$2 = shared$2$2("wks");
var Symbol$1$2 = global$f$1.Symbol;
var symbolFor$2 = Symbol$1$2 && Symbol$1$2["for"];
var createWellKnownSymbol$2 = USE_SYMBOL_AS_UID$1$2
  ? Symbol$1$2
  : (Symbol$1$2 && Symbol$1$2.withoutSetter) || uid$1$2;
var wellKnownSymbol$g = function (name) {
  if (
    !hasOwn$b(WellKnownSymbolsStore$2, name) ||
    !(NATIVE_SYMBOL$1$2 || typeof WellKnownSymbolsStore$2[name] == "string")
  ) {
    var description = "Symbol." + name;
    if (NATIVE_SYMBOL$1$2 && hasOwn$b(Symbol$1$2, name)) {
      WellKnownSymbolsStore$2[name] = Symbol$1$2[name];
    } else if (USE_SYMBOL_AS_UID$1$2 && symbolFor$2) {
      WellKnownSymbolsStore$2[name] = symbolFor$2(description);
    } else {
      WellKnownSymbolsStore$2[name] = createWellKnownSymbol$2(description);
    }
  }
  return WellKnownSymbolsStore$2[name];
};
var isCallable$j$1 = isCallable$l$1;
var isObject$8$1 = function (it) {
  return typeof it == "object" ? it !== null : isCallable$j$1(it);
};
var isObject$7$1 = isObject$8$1;
var $String$3$1 = String;
var $TypeError$d = TypeError;
var anObject$c$1 = function (argument) {
  if (isObject$7$1(argument)) return argument;
  throw $TypeError$d($String$3$1(argument) + " is not an object");
};
var objectDefineProperties$1 = {};
var fails$d$1 = fails$h;
var descriptors$2 = !fails$d$1(function () {
  return (
    Object.defineProperty({}, 1, {
      get: function () {
        return 7;
      },
    })[1] != 7
  );
});
var DESCRIPTORS$b = descriptors$2;
var fails$c$1 = fails$h;
var v8PrototypeDefineBug$2 =
  DESCRIPTORS$b &&
  fails$c$1(function () {
    return (
      Object.defineProperty(function () {}, "prototype", {
        value: 42,
        writable: false,
      }).prototype != 42
    );
  });
var objectDefineProperty$2 = {};
var global$e$1 = global$k;
var isObject$6$1 = isObject$8$1;
var document$3$1 = global$e$1.document;
var EXISTS$1$2 =
  isObject$6$1(document$3$1) && isObject$6$1(document$3$1.createElement);
var documentCreateElement$2$1 = function (it) {
  return EXISTS$1$2 ? document$3$1.createElement(it) : {};
};
var DESCRIPTORS$a$2 = descriptors$2;
var fails$b$1 = fails$h;
var createElement$1$1 = documentCreateElement$2$1;
var ie8DomDefine$2 =
  !DESCRIPTORS$a$2 &&
  !fails$b$1(function () {
    return (
      Object.defineProperty(createElement$1$1("div"), "a", {
        get: function () {
          return 7;
        },
      }).a != 7
    );
  });
var NATIVE_BIND$2$1 = functionBindNative$2;
var call$e$1 = Function.prototype.call;
var functionCall$2 = NATIVE_BIND$2$1
  ? call$e$1.bind(call$e$1)
  : function () {
      return call$e$1.apply(call$e$1, arguments);
    };
var uncurryThis$c$1 = functionUncurryThis$2;
var objectIsPrototypeOf$2 = uncurryThis$c$1({}.isPrototypeOf);
var getBuiltIn$6$1 = getBuiltIn$8$1;
var isCallable$i$1 = isCallable$l$1;
var isPrototypeOf$4$1 = objectIsPrototypeOf$2;
var USE_SYMBOL_AS_UID$3 = useSymbolAsUid$2;
var $Object$2$2 = Object;
var isSymbol$2$2 = USE_SYMBOL_AS_UID$3
  ? function (it) {
      return typeof it == "symbol";
    }
  : function (it) {
      var $Symbol = getBuiltIn$6$1("Symbol");
      return (
        isCallable$i$1($Symbol) &&
        isPrototypeOf$4$1($Symbol.prototype, $Object$2$2(it))
      );
    };
var $String$2$1 = String;
var tryToString$5$1 = function (argument) {
  try {
    return $String$2$1(argument);
  } catch (error) {
    return "Object";
  }
};
var isCallable$h$1 = isCallable$l$1;
var tryToString$4$1 = tryToString$5$1;
var $TypeError$c$1 = TypeError;
var aCallable$9 = function (argument) {
  if (isCallable$h$1(argument)) return argument;
  throw $TypeError$c$1(tryToString$4$1(argument) + " is not a function");
};
var aCallable$8$1 = aCallable$9;
var getMethod$3$1 = function (V, P) {
  var func = V[P];
  return func == null ? void 0 : aCallable$8$1(func);
};
var call$d$1 = functionCall$2;
var isCallable$g$1 = isCallable$l$1;
var isObject$5$2 = isObject$8$1;
var $TypeError$b$1 = TypeError;
var ordinaryToPrimitive$1$2 = function (input, pref) {
  var fn, val;
  if (
    pref === "string" &&
    isCallable$g$1((fn = input.toString)) &&
    !isObject$5$2((val = call$d$1(fn, input)))
  )
    return val;
  if (
    isCallable$g$1((fn = input.valueOf)) &&
    !isObject$5$2((val = call$d$1(fn, input)))
  )
    return val;
  if (
    pref !== "string" &&
    isCallable$g$1((fn = input.toString)) &&
    !isObject$5$2((val = call$d$1(fn, input)))
  )
    return val;
  throw $TypeError$b$1("Can't convert object to primitive value");
};
var call$c$1 = functionCall$2;
var isObject$4$2 = isObject$8$1;
var isSymbol$1$2 = isSymbol$2$2;
var getMethod$2$1 = getMethod$3$1;
var ordinaryToPrimitive$3 = ordinaryToPrimitive$1$2;
var wellKnownSymbol$f$1 = wellKnownSymbol$g;
var $TypeError$a$1 = TypeError;
var TO_PRIMITIVE$2 = wellKnownSymbol$f$1("toPrimitive");
var toPrimitive$1$2 = function (input, pref) {
  if (!isObject$4$2(input) || isSymbol$1$2(input)) return input;
  var exoticToPrim = getMethod$2$1(input, TO_PRIMITIVE$2);
  var result;
  if (exoticToPrim) {
    if (pref === void 0) pref = "default";
    result = call$c$1(exoticToPrim, input, pref);
    if (!isObject$4$2(result) || isSymbol$1$2(result)) return result;
    throw $TypeError$a$1("Can't convert object to primitive value");
  }
  if (pref === void 0) pref = "number";
  return ordinaryToPrimitive$3(input, pref);
};
var toPrimitive$3 = toPrimitive$1$2;
var isSymbol$4 = isSymbol$2$2;
var toPropertyKey$3$1 = function (argument) {
  var key = toPrimitive$3(argument, "string");
  return isSymbol$4(key) ? key : key + "";
};
var DESCRIPTORS$9$1 = descriptors$2;
var IE8_DOM_DEFINE$1$2 = ie8DomDefine$2;
var V8_PROTOTYPE_DEFINE_BUG$1$1 = v8PrototypeDefineBug$2;
var anObject$b$1 = anObject$c$1;
var toPropertyKey$2$2 = toPropertyKey$3$1;
var $TypeError$9$1 = TypeError;
var $defineProperty$2 = Object.defineProperty;
var $getOwnPropertyDescriptor$1$2 = Object.getOwnPropertyDescriptor;
var ENUMERABLE$2 = "enumerable";
var CONFIGURABLE$1$2 = "configurable";
var WRITABLE$2 = "writable";
objectDefineProperty$2.f = DESCRIPTORS$9$1
  ? V8_PROTOTYPE_DEFINE_BUG$1$1
    ? function defineProperty(O, P, Attributes) {
        anObject$b$1(O);
        P = toPropertyKey$2$2(P);
        anObject$b$1(Attributes);
        if (
          typeof O === "function" &&
          P === "prototype" &&
          "value" in Attributes &&
          WRITABLE$2 in Attributes &&
          !Attributes[WRITABLE$2]
        ) {
          var current = $getOwnPropertyDescriptor$1$2(O, P);
          if (current && current[WRITABLE$2]) {
            O[P] = Attributes.value;
            Attributes = {
              configurable:
                CONFIGURABLE$1$2 in Attributes
                  ? Attributes[CONFIGURABLE$1$2]
                  : current[CONFIGURABLE$1$2],
              enumerable:
                ENUMERABLE$2 in Attributes
                  ? Attributes[ENUMERABLE$2]
                  : current[ENUMERABLE$2],
              writable: false,
            };
          }
        }
        return $defineProperty$2(O, P, Attributes);
      }
    : $defineProperty$2
  : function defineProperty2(O, P, Attributes) {
      anObject$b$1(O);
      P = toPropertyKey$2$2(P);
      anObject$b$1(Attributes);
      if (IE8_DOM_DEFINE$1$2)
        try {
          return $defineProperty$2(O, P, Attributes);
        } catch (error) {}
      if ("get" in Attributes || "set" in Attributes)
        throw $TypeError$9$1("Accessors not supported");
      if ("value" in Attributes) O[P] = Attributes.value;
      return O;
    };
var ceil$2 = Math.ceil;
var floor$1$1 = Math.floor;
var mathTrunc$2 =
  Math.trunc ||
  function trunc(x) {
    var n = +x;
    return (n > 0 ? floor$1$1 : ceil$2)(n);
  };
var trunc2$2 = mathTrunc$2;
var toIntegerOrInfinity$2$2 = function (argument) {
  var number = +argument;
  return number !== number || number === 0 ? 0 : trunc2$2(number);
};
var toIntegerOrInfinity$1$2 = toIntegerOrInfinity$2$2;
var max$1$1 = Math.max;
var min$1$2 = Math.min;
var toAbsoluteIndex$2$1 = function (index, length) {
  var integer = toIntegerOrInfinity$1$2(index);
  return integer < 0 ? max$1$1(integer + length, 0) : min$1$2(integer, length);
};
var toIntegerOrInfinity$4 = toIntegerOrInfinity$2$2;
var min$3 = Math.min;
var toLength$1$2 = function (argument) {
  return argument > 0
    ? min$3(toIntegerOrInfinity$4(argument), 9007199254740991)
    : 0;
};
var toLength$3 = toLength$1$2;
var lengthOfArrayLike$5 = function (obj) {
  return toLength$3(obj.length);
};
var toIndexedObject$4$1 = toIndexedObject$5$1;
var toAbsoluteIndex$1$2 = toAbsoluteIndex$2$1;
var lengthOfArrayLike$4 = lengthOfArrayLike$5;
var createMethod$1$1 = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIndexedObject$4$1($this);
    var length = lengthOfArrayLike$4(O);
    var index = toAbsoluteIndex$1$2(fromIndex, length);
    var value;
    if (IS_INCLUDES && el != el)
      while (length > index) {
        value = O[index++];
        if (value != value) return true;
      }
    else
      for (; length > index; index++) {
        if ((IS_INCLUDES || index in O) && O[index] === el)
          return IS_INCLUDES || index || 0;
      }
    return !IS_INCLUDES && -1;
  };
};
var arrayIncludes$2 = {
  // `Array.prototype.includes` method
  // https://tc39.es/ecma262/#sec-array.prototype.includes
  includes: createMethod$1$1(true),
  // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof
  indexOf: createMethod$1$1(false),
};
var hiddenKeys$4$1 = {};
var uncurryThis$b$1 = functionUncurryThis$2;
var hasOwn$a$1 = hasOwnProperty_1$2;
var toIndexedObject$3$2 = toIndexedObject$5$1;
var indexOf$2 = arrayIncludes$2.indexOf;
var hiddenKeys$3$2 = hiddenKeys$4$1;
var push$1$1 = uncurryThis$b$1([].push);
var objectKeysInternal$2 = function (object, names) {
  var O = toIndexedObject$3$2(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O)
    !hasOwn$a$1(hiddenKeys$3$2, key) &&
      hasOwn$a$1(O, key) &&
      push$1$1(result, key);
  while (names.length > i)
    if (hasOwn$a$1(O, (key = names[i++]))) {
      ~indexOf$2(result, key) || push$1$1(result, key);
    }
  return result;
};
var enumBugKeys$3$1 = [
  "constructor",
  "hasOwnProperty",
  "isPrototypeOf",
  "propertyIsEnumerable",
  "toLocaleString",
  "toString",
  "valueOf",
];
var internalObjectKeys$1$2 = objectKeysInternal$2;
var enumBugKeys$2$2 = enumBugKeys$3$1;
var objectKeys$2$2 =
  Object.keys ||
  function keys(O) {
    return internalObjectKeys$1$2(O, enumBugKeys$2$2);
  };
var DESCRIPTORS$8$1 = descriptors$2;
var V8_PROTOTYPE_DEFINE_BUG$3 = v8PrototypeDefineBug$2;
var definePropertyModule$5$1 = objectDefineProperty$2;
var anObject$a$1 = anObject$c$1;
var toIndexedObject$2$2 = toIndexedObject$5$1;
var objectKeys$1$2 = objectKeys$2$2;
objectDefineProperties$1.f =
  DESCRIPTORS$8$1 && !V8_PROTOTYPE_DEFINE_BUG$3
    ? Object.defineProperties
    : function defineProperties(O, Properties) {
        anObject$a$1(O);
        var props = toIndexedObject$2$2(Properties);
        var keys3 = objectKeys$1$2(Properties);
        var length = keys3.length;
        var index = 0;
        var key;
        while (length > index)
          definePropertyModule$5$1.f(O, (key = keys3[index++]), props[key]);
        return O;
      };
var getBuiltIn$5$1 = getBuiltIn$8$1;
var html$2$1 = getBuiltIn$5$1("document", "documentElement");
var shared$1$2 = shared$3$2.exports;
var uid$4 = uid$2$2;
var keys2$1 = shared$1$2("keys");
var sharedKey$3$1 = function (key) {
  return keys2$1[key] || (keys2$1[key] = uid$4(key));
};
var anObject$9$1 = anObject$c$1;
var definePropertiesModule$1 = objectDefineProperties$1;
var enumBugKeys$1$2 = enumBugKeys$3$1;
var hiddenKeys$2$2 = hiddenKeys$4$1;
var html$1$1 = html$2$1;
var documentCreateElement$1$1 = documentCreateElement$2$1;
var sharedKey$2$1 = sharedKey$3$1;
var GT$1 = ">";
var LT$1 = "<";
var PROTOTYPE$1 = "prototype";
var SCRIPT$1 = "script";
var IE_PROTO$1$1 = sharedKey$2$1("IE_PROTO");
var EmptyConstructor$1 = function () {};
var scriptTag$1 = function (content) {
  return LT$1 + SCRIPT$1 + GT$1 + content + LT$1 + "/" + SCRIPT$1 + GT$1;
};
var NullProtoObjectViaActiveX$1 = function (activeXDocument2) {
  activeXDocument2.write(scriptTag$1(""));
  activeXDocument2.close();
  var temp = activeXDocument2.parentWindow.Object;
  activeXDocument2 = null;
  return temp;
};
var NullProtoObjectViaIFrame$1 = function () {
  var iframe = documentCreateElement$1$1("iframe");
  var JS = "java" + SCRIPT$1 + ":";
  var iframeDocument;
  iframe.style.display = "none";
  html$1$1.appendChild(iframe);
  iframe.src = String(JS);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(scriptTag$1("document.F=Object"));
  iframeDocument.close();
  return iframeDocument.F;
};
var activeXDocument$1;
var NullProtoObject$1 = function () {
  try {
    activeXDocument$1 = new ActiveXObject("htmlfile");
  } catch (error) {}
  NullProtoObject$1 =
    typeof document != "undefined"
      ? document.domain && activeXDocument$1
        ? NullProtoObjectViaActiveX$1(activeXDocument$1)
        : NullProtoObjectViaIFrame$1()
      : NullProtoObjectViaActiveX$1(activeXDocument$1);
  var length = enumBugKeys$1$2.length;
  while (length--)
    delete NullProtoObject$1[PROTOTYPE$1][enumBugKeys$1$2[length]];
  return NullProtoObject$1();
};
hiddenKeys$2$2[IE_PROTO$1$1] = true;
var objectCreate$1 =
  Object.create ||
  function create(O, Properties) {
    var result;
    if (O !== null) {
      EmptyConstructor$1[PROTOTYPE$1] = anObject$9$1(O);
      result = new EmptyConstructor$1();
      EmptyConstructor$1[PROTOTYPE$1] = null;
      result[IE_PROTO$1$1] = O;
    } else result = NullProtoObject$1();
    return Properties === void 0
      ? result
      : definePropertiesModule$1.f(result, Properties);
  };
var wellKnownSymbol$e$1 = wellKnownSymbol$g;
var create$1$1 = objectCreate$1;
var defineProperty$5$1 = objectDefineProperty$2.f;
var UNSCOPABLES$1 = wellKnownSymbol$e$1("unscopables");
var ArrayPrototype$1$1 = Array.prototype;
if (ArrayPrototype$1$1[UNSCOPABLES$1] == void 0) {
  defineProperty$5$1(ArrayPrototype$1$1, UNSCOPABLES$1, {
    configurable: true,
    value: create$1$1(null),
  });
}
var addToUnscopables$2 = function (key) {
  ArrayPrototype$1$1[UNSCOPABLES$1][key] = true;
};
var iterators$1 = {};
var uncurryThis$a$2 = functionUncurryThis$2;
var isCallable$f$1 = isCallable$l$1;
var store$1$2 = sharedStore$2;
var functionToString$2 = uncurryThis$a$2(Function.toString);
if (!isCallable$f$1(store$1$2.inspectSource)) {
  store$1$2.inspectSource = function (it) {
    return functionToString$2(it);
  };
}
var inspectSource$4$1 = store$1$2.inspectSource;
var global$d$1 = global$k;
var isCallable$e$1 = isCallable$l$1;
var inspectSource$3$1 = inspectSource$4$1;
var WeakMap$1$2 = global$d$1.WeakMap;
var nativeWeakMap$2 =
  isCallable$e$1(WeakMap$1$2) &&
  /native code/.test(inspectSource$3$1(WeakMap$1$2));
var createPropertyDescriptor$4$1 = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value,
  };
};
var DESCRIPTORS$7$2 = descriptors$2;
var definePropertyModule$4$1 = objectDefineProperty$2;
var createPropertyDescriptor$3$1 = createPropertyDescriptor$4$1;
var createNonEnumerableProperty$4$1 = DESCRIPTORS$7$2
  ? function (object, key, value) {
      return definePropertyModule$4$1.f(
        object,
        key,
        createPropertyDescriptor$3$1(1, value)
      );
    }
  : function (object, key, value) {
      object[key] = value;
      return object;
    };
var NATIVE_WEAK_MAP$2 = nativeWeakMap$2;
var global$c$1 = global$k;
var uncurryThis$9$2 = functionUncurryThis$2;
var isObject$3$2 = isObject$8$1;
var createNonEnumerableProperty$3$1 = createNonEnumerableProperty$4$1;
var hasOwn$9$1 = hasOwnProperty_1$2;
var shared$5 = sharedStore$2;
var sharedKey$1$2 = sharedKey$3$1;
var hiddenKeys$1$2 = hiddenKeys$4$1;
var OBJECT_ALREADY_INITIALIZED$2 = "Object already initialized";
var TypeError$2$1 = global$c$1.TypeError;
var WeakMap2$1 = global$c$1.WeakMap;
var set$1$1;
var get$2;
var has$2;
var enforce$2 = function (it) {
  return has$2(it) ? get$2(it) : set$1$1(it, {});
};
var getterFor$2 = function (TYPE) {
  return function (it) {
    var state;
    if (!isObject$3$2(it) || (state = get$2(it)).type !== TYPE) {
      throw TypeError$2$1("Incompatible receiver, " + TYPE + " required");
    }
    return state;
  };
};
if (NATIVE_WEAK_MAP$2 || shared$5.state) {
  store$5 = shared$5.state || (shared$5.state = new WeakMap2$1());
  wmget$2 = uncurryThis$9$2(store$5.get);
  wmhas$2 = uncurryThis$9$2(store$5.has);
  wmset$2 = uncurryThis$9$2(store$5.set);
  set$1$1 = function (it, metadata) {
    if (wmhas$2(store$5, it))
      throw new TypeError$2$1(OBJECT_ALREADY_INITIALIZED$2);
    metadata.facade = it;
    wmset$2(store$5, it, metadata);
    return metadata;
  };
  get$2 = function (it) {
    return wmget$2(store$5, it) || {};
  };
  has$2 = function (it) {
    return wmhas$2(store$5, it);
  };
} else {
  STATE$2 = sharedKey$1$2("state");
  hiddenKeys$1$2[STATE$2] = true;
  set$1$1 = function (it, metadata) {
    if (hasOwn$9$1(it, STATE$2))
      throw new TypeError$2$1(OBJECT_ALREADY_INITIALIZED$2);
    metadata.facade = it;
    createNonEnumerableProperty$3$1(it, STATE$2, metadata);
    return metadata;
  };
  get$2 = function (it) {
    return hasOwn$9$1(it, STATE$2) ? it[STATE$2] : {};
  };
  has$2 = function (it) {
    return hasOwn$9$1(it, STATE$2);
  };
}
var store$5;
var wmget$2;
var wmhas$2;
var wmset$2;
var STATE$2;
var internalState$2 = {
  set: set$1$1,
  get: get$2,
  has: has$2,
  enforce: enforce$2,
  getterFor: getterFor$2,
};
var objectGetOwnPropertyDescriptor$2 = {};
var objectPropertyIsEnumerable$2 = {};
var $propertyIsEnumerable$2 = {}.propertyIsEnumerable;
var getOwnPropertyDescriptor$2$1 = Object.getOwnPropertyDescriptor;
var NASHORN_BUG$2 =
  getOwnPropertyDescriptor$2$1 && !$propertyIsEnumerable$2.call({ 1: 2 }, 1);
objectPropertyIsEnumerable$2.f = NASHORN_BUG$2
  ? function propertyIsEnumerable(V) {
      var descriptor = getOwnPropertyDescriptor$2$1(this, V);
      return !!descriptor && descriptor.enumerable;
    }
  : $propertyIsEnumerable$2;
var DESCRIPTORS$6$2 = descriptors$2;
var call$b$1 = functionCall$2;
var propertyIsEnumerableModule$1$2 = objectPropertyIsEnumerable$2;
var createPropertyDescriptor$2$2 = createPropertyDescriptor$4$1;
var toIndexedObject$1$2 = toIndexedObject$5$1;
var toPropertyKey$1$2 = toPropertyKey$3$1;
var hasOwn$8$1 = hasOwnProperty_1$2;
var IE8_DOM_DEFINE$3 = ie8DomDefine$2;
var $getOwnPropertyDescriptor$3 = Object.getOwnPropertyDescriptor;
objectGetOwnPropertyDescriptor$2.f = DESCRIPTORS$6$2
  ? $getOwnPropertyDescriptor$3
  : function getOwnPropertyDescriptor(O, P) {
      O = toIndexedObject$1$2(O);
      P = toPropertyKey$1$2(P);
      if (IE8_DOM_DEFINE$3)
        try {
          return $getOwnPropertyDescriptor$3(O, P);
        } catch (error) {}
      if (hasOwn$8$1(O, P))
        return createPropertyDescriptor$2$2(
          !call$b$1(propertyIsEnumerableModule$1$2.f, O, P),
          O[P]
        );
    };
var makeBuiltIn$2$2 = { exports: {} };
var DESCRIPTORS$5$2 = descriptors$2;
var hasOwn$7$1 = hasOwnProperty_1$2;
var FunctionPrototype$1$2 = Function.prototype;
var getDescriptor$2 = DESCRIPTORS$5$2 && Object.getOwnPropertyDescriptor;
var EXISTS$3 = hasOwn$7$1(FunctionPrototype$1$2, "name");
var PROPER$2 = EXISTS$3 && function something() {}.name === "something";
var CONFIGURABLE$3 =
  EXISTS$3 &&
  (!DESCRIPTORS$5$2 ||
    (DESCRIPTORS$5$2 &&
      getDescriptor$2(FunctionPrototype$1$2, "name").configurable));
var functionName$2 = {
  EXISTS: EXISTS$3,
  PROPER: PROPER$2,
  CONFIGURABLE: CONFIGURABLE$3,
};
var fails$a$1 = fails$h;
var isCallable$d$1 = isCallable$l$1;
var hasOwn$6$2 = hasOwnProperty_1$2;
var DESCRIPTORS$4$2 = descriptors$2;
var CONFIGURABLE_FUNCTION_NAME$1$1 = functionName$2.CONFIGURABLE;
var inspectSource$2$2 = inspectSource$4$1;
var InternalStateModule$2$1 = internalState$2;
var enforceInternalState$2 = InternalStateModule$2$1.enforce;
var getInternalState$1$1 = InternalStateModule$2$1.get;
var defineProperty$4$1 = Object.defineProperty;
var CONFIGURABLE_LENGTH$2 =
  DESCRIPTORS$4$2 &&
  !fails$a$1(function () {
    return (
      defineProperty$4$1(function () {}, "length", { value: 8 }).length !== 8
    );
  });
var TEMPLATE$2 = String(String).split("String");
var makeBuiltIn$1$2 = (makeBuiltIn$2$2.exports = function (
  value,
  name,
  options
) {
  if (String(name).slice(0, 7) === "Symbol(") {
    name = "[" + String(name).replace(/^Symbol\(([^)]*)\)/, "$1") + "]";
  }
  if (options && options.getter) name = "get " + name;
  if (options && options.setter) name = "set " + name;
  if (
    !hasOwn$6$2(value, "name") ||
    (CONFIGURABLE_FUNCTION_NAME$1$1 && value.name !== name)
  ) {
    if (DESCRIPTORS$4$2)
      defineProperty$4$1(value, "name", { value: name, configurable: true });
    else value.name = name;
  }
  if (
    CONFIGURABLE_LENGTH$2 &&
    options &&
    hasOwn$6$2(options, "arity") &&
    value.length !== options.arity
  ) {
    defineProperty$4$1(value, "length", { value: options.arity });
  }
  try {
    if (options && hasOwn$6$2(options, "constructor") && options.constructor) {
      if (DESCRIPTORS$4$2)
        defineProperty$4$1(value, "prototype", { writable: false });
    } else if (value.prototype) value.prototype = void 0;
  } catch (error) {}
  var state = enforceInternalState$2(value);
  if (!hasOwn$6$2(state, "source")) {
    state.source = TEMPLATE$2.join(typeof name == "string" ? name : "");
  }
  return value;
});
Function.prototype.toString = makeBuiltIn$1$2(function toString() {
  return (
    (isCallable$d$1(this) && getInternalState$1$1(this).source) ||
    inspectSource$2$2(this)
  );
}, "toString");
var isCallable$c$1 = isCallable$l$1;
var definePropertyModule$3$1 = objectDefineProperty$2;
var makeBuiltIn$4 = makeBuiltIn$2$2.exports;
var defineGlobalProperty$1$2 = defineGlobalProperty$3$2;
var defineBuiltIn$6$1 = function (O, key, value, options) {
  if (!options) options = {};
  var simple = options.enumerable;
  var name = options.name !== void 0 ? options.name : key;
  if (isCallable$c$1(value)) makeBuiltIn$4(value, name, options);
  if (options.global) {
    if (simple) O[key] = value;
    else defineGlobalProperty$1$2(key, value);
  } else {
    try {
      if (!options.unsafe) delete O[key];
      else if (O[key]) simple = true;
    } catch (error) {}
    if (simple) O[key] = value;
    else
      definePropertyModule$3$1.f(O, key, {
        value,
        enumerable: false,
        configurable: !options.nonConfigurable,
        writable: !options.nonWritable,
      });
  }
  return O;
};
var objectGetOwnPropertyNames$2 = {};
var internalObjectKeys$3 = objectKeysInternal$2;
var enumBugKeys$5 = enumBugKeys$3$1;
var hiddenKeys$6 = enumBugKeys$5.concat("length", "prototype");
objectGetOwnPropertyNames$2.f =
  Object.getOwnPropertyNames ||
  function getOwnPropertyNames(O) {
    return internalObjectKeys$3(O, hiddenKeys$6);
  };
var objectGetOwnPropertySymbols$2 = {};
objectGetOwnPropertySymbols$2.f = Object.getOwnPropertySymbols;
var getBuiltIn$4$1 = getBuiltIn$8$1;
var uncurryThis$8$2 = functionUncurryThis$2;
var getOwnPropertyNamesModule$2 = objectGetOwnPropertyNames$2;
var getOwnPropertySymbolsModule$1$2 = objectGetOwnPropertySymbols$2;
var anObject$8$1 = anObject$c$1;
var concat$1$2 = uncurryThis$8$2([].concat);
var ownKeys$1$2 =
  getBuiltIn$4$1("Reflect", "ownKeys") ||
  function ownKeys(it) {
    var keys3 = getOwnPropertyNamesModule$2.f(anObject$8$1(it));
    var getOwnPropertySymbols = getOwnPropertySymbolsModule$1$2.f;
    return getOwnPropertySymbols
      ? concat$1$2(keys3, getOwnPropertySymbols(it))
      : keys3;
  };
var hasOwn$5$2 = hasOwnProperty_1$2;
var ownKeys2$2 = ownKeys$1$2;
var getOwnPropertyDescriptorModule$2 = objectGetOwnPropertyDescriptor$2;
var definePropertyModule$2$2 = objectDefineProperty$2;
var copyConstructorProperties$2$1 = function (target, source, exceptions) {
  var keys3 = ownKeys2$2(source);
  var defineProperty4 = definePropertyModule$2$2.f;
  var getOwnPropertyDescriptor3 = getOwnPropertyDescriptorModule$2.f;
  for (var i = 0; i < keys3.length; i++) {
    var key = keys3[i];
    if (
      !hasOwn$5$2(target, key) &&
      !(exceptions && hasOwn$5$2(exceptions, key))
    ) {
      defineProperty4(target, key, getOwnPropertyDescriptor3(source, key));
    }
  }
};
var fails$9$2 = fails$h;
var isCallable$b$1 = isCallable$l$1;
var replacement$2 = /#|\.prototype\./;
var isForced$2$1 = function (feature, detection) {
  var value = data$2[normalize$2(feature)];
  return value == POLYFILL$2
    ? true
    : value == NATIVE$2
    ? false
    : isCallable$b$1(detection)
    ? fails$9$2(detection)
    : !!detection;
};
var normalize$2 = (isForced$2$1.normalize = function (string) {
  return String(string).replace(replacement$2, ".").toLowerCase();
});
var data$2 = (isForced$2$1.data = {});
var NATIVE$2 = (isForced$2$1.NATIVE = "N");
var POLYFILL$2 = (isForced$2$1.POLYFILL = "P");
var isForced_1$2 = isForced$2$1;
var global$b$1 = global$k;
var getOwnPropertyDescriptor$1$2 = objectGetOwnPropertyDescriptor$2.f;
var createNonEnumerableProperty$2$2 = createNonEnumerableProperty$4$1;
var defineBuiltIn$5$1 = defineBuiltIn$6$1;
var defineGlobalProperty$5 = defineGlobalProperty$3$2;
var copyConstructorProperties$1$2 = copyConstructorProperties$2$1;
var isForced$1$2 = isForced_1$2;
var _export$2 = function (options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var FORCED2, target, key, targetProperty, sourceProperty, descriptor;
  if (GLOBAL) {
    target = global$b$1;
  } else if (STATIC) {
    target = global$b$1[TARGET] || defineGlobalProperty$5(TARGET, {});
  } else {
    target = (global$b$1[TARGET] || {}).prototype;
  }
  if (target)
    for (key in source) {
      sourceProperty = source[key];
      if (options.dontCallGetSet) {
        descriptor = getOwnPropertyDescriptor$1$2(target, key);
        targetProperty = descriptor && descriptor.value;
      } else targetProperty = target[key];
      FORCED2 = isForced$1$2(
        GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key,
        options.forced
      );
      if (!FORCED2 && targetProperty !== void 0) {
        if (typeof sourceProperty == typeof targetProperty) continue;
        copyConstructorProperties$1$2(sourceProperty, targetProperty);
      }
      if (options.sham || (targetProperty && targetProperty.sham)) {
        createNonEnumerableProperty$2$2(sourceProperty, "sham", true);
      }
      defineBuiltIn$5$1(target, key, sourceProperty, options);
    }
};
var fails$8$2 = fails$h;
var correctPrototypeGetter$1 = !fails$8$2(function () {
  function F() {}
  F.prototype.constructor = null;
  return Object.getPrototypeOf(new F()) !== F.prototype;
});
var hasOwn$4$2 = hasOwnProperty_1$2;
var isCallable$a$2 = isCallable$l$1;
var toObject$3$2 = toObject$5;
var sharedKey$5 = sharedKey$3$1;
var CORRECT_PROTOTYPE_GETTER$1 = correctPrototypeGetter$1;
var IE_PROTO$2 = sharedKey$5("IE_PROTO");
var $Object$1$2 = Object;
var ObjectPrototype$1 = $Object$1$2.prototype;
var objectGetPrototypeOf$1 = CORRECT_PROTOTYPE_GETTER$1
  ? $Object$1$2.getPrototypeOf
  : function (O) {
      var object = toObject$3$2(O);
      if (hasOwn$4$2(object, IE_PROTO$2)) return object[IE_PROTO$2];
      var constructor = object.constructor;
      if (isCallable$a$2(constructor) && object instanceof constructor) {
        return constructor.prototype;
      }
      return object instanceof $Object$1$2 ? ObjectPrototype$1 : null;
    };
var fails$7$2 = fails$h;
var isCallable$9$2 = isCallable$l$1;
var getPrototypeOf$1$1 = objectGetPrototypeOf$1;
var defineBuiltIn$4$1 = defineBuiltIn$6$1;
var wellKnownSymbol$d$1 = wellKnownSymbol$g;
var ITERATOR$5$1 = wellKnownSymbol$d$1("iterator");
var BUGGY_SAFARI_ITERATORS$1$1 = false;
var IteratorPrototype$2$1;
var PrototypeOfArrayIteratorPrototype$1;
var arrayIterator$1;
if ([].keys) {
  arrayIterator$1 = [].keys();
  if (!("next" in arrayIterator$1)) BUGGY_SAFARI_ITERATORS$1$1 = true;
  else {
    PrototypeOfArrayIteratorPrototype$1 = getPrototypeOf$1$1(
      getPrototypeOf$1$1(arrayIterator$1)
    );
    if (PrototypeOfArrayIteratorPrototype$1 !== Object.prototype)
      IteratorPrototype$2$1 = PrototypeOfArrayIteratorPrototype$1;
  }
}
var NEW_ITERATOR_PROTOTYPE$1 =
  IteratorPrototype$2$1 == void 0 ||
  fails$7$2(function () {
    var test2 = {};
    return IteratorPrototype$2$1[ITERATOR$5$1].call(test2) !== test2;
  });
if (NEW_ITERATOR_PROTOTYPE$1) IteratorPrototype$2$1 = {};
if (!isCallable$9$2(IteratorPrototype$2$1[ITERATOR$5$1])) {
  defineBuiltIn$4$1(IteratorPrototype$2$1, ITERATOR$5$1, function () {
    return this;
  });
}
var iteratorsCore$1 = {
  IteratorPrototype: IteratorPrototype$2$1,
  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS$1$1,
};
var defineProperty$3$1 = objectDefineProperty$2.f;
var hasOwn$3$2 = hasOwnProperty_1$2;
var wellKnownSymbol$c$1 = wellKnownSymbol$g;
var TO_STRING_TAG$3$1 = wellKnownSymbol$c$1("toStringTag");
var setToStringTag$3$1 = function (target, TAG, STATIC) {
  if (target && !STATIC) target = target.prototype;
  if (target && !hasOwn$3$2(target, TO_STRING_TAG$3$1)) {
    defineProperty$3$1(target, TO_STRING_TAG$3$1, {
      configurable: true,
      value: TAG,
    });
  }
};
var IteratorPrototype$1$1 = iteratorsCore$1.IteratorPrototype;
var create2$1 = objectCreate$1;
var createPropertyDescriptor$1$2 = createPropertyDescriptor$4$1;
var setToStringTag$2$1 = setToStringTag$3$1;
var Iterators$4$1 = iterators$1;
var returnThis$1$1 = function () {
  return this;
};
var createIteratorConstructor$1$1 = function (
  IteratorConstructor,
  NAME,
  next,
  ENUMERABLE_NEXT
) {
  var TO_STRING_TAG2 = NAME + " Iterator";
  IteratorConstructor.prototype = create2$1(IteratorPrototype$1$1, {
    next: createPropertyDescriptor$1$2(+!ENUMERABLE_NEXT, next),
  });
  setToStringTag$2$1(IteratorConstructor, TO_STRING_TAG2, false);
  Iterators$4$1[TO_STRING_TAG2] = returnThis$1$1;
  return IteratorConstructor;
};
var isCallable$8$2 = isCallable$l$1;
var $String$1$2 = String;
var $TypeError$8$1 = TypeError;
var aPossiblePrototype$1$1 = function (argument) {
  if (typeof argument == "object" || isCallable$8$2(argument)) return argument;
  throw $TypeError$8$1(
    "Can't set " + $String$1$2(argument) + " as a prototype"
  );
};
var uncurryThis$7$2 = functionUncurryThis$2;
var anObject$7$1 = anObject$c$1;
var aPossiblePrototype$2 = aPossiblePrototype$1$1;
var objectSetPrototypeOf$1 =
  Object.setPrototypeOf ||
  ("__proto__" in {}
    ? (function () {
        var CORRECT_SETTER = false;
        var test2 = {};
        var setter;
        try {
          setter = uncurryThis$7$2(
            Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set
          );
          setter(test2, []);
          CORRECT_SETTER = test2 instanceof Array;
        } catch (error) {}
        return function setPrototypeOf2(O, proto) {
          anObject$7$1(O);
          aPossiblePrototype$2(proto);
          if (CORRECT_SETTER) setter(O, proto);
          else O.__proto__ = proto;
          return O;
        };
      })()
    : void 0);
var $$c = _export$2;
var call$a$1 = functionCall$2;
var FunctionName$1 = functionName$2;
var isCallable$7$2 = isCallable$l$1;
var createIteratorConstructor$2 = createIteratorConstructor$1$1;
var getPrototypeOf$2 = objectGetPrototypeOf$1;
var setPrototypeOf$1$1 = objectSetPrototypeOf$1;
var setToStringTag$1$1 = setToStringTag$3$1;
var createNonEnumerableProperty$1$2 = createNonEnumerableProperty$4$1;
var defineBuiltIn$3$1 = defineBuiltIn$6$1;
var wellKnownSymbol$b$1 = wellKnownSymbol$g;
var Iterators$3$1 = iterators$1;
var IteratorsCore$1 = iteratorsCore$1;
var PROPER_FUNCTION_NAME$1$1 = FunctionName$1.PROPER;
var CONFIGURABLE_FUNCTION_NAME$3 = FunctionName$1.CONFIGURABLE;
var IteratorPrototype$3 = IteratorsCore$1.IteratorPrototype;
var BUGGY_SAFARI_ITERATORS$2 = IteratorsCore$1.BUGGY_SAFARI_ITERATORS;
var ITERATOR$4$1 = wellKnownSymbol$b$1("iterator");
var KEYS$1 = "keys";
var VALUES$1 = "values";
var ENTRIES$1 = "entries";
var returnThis$2 = function () {
  return this;
};
var defineIterator$1$1 = function (
  Iterable,
  NAME,
  IteratorConstructor,
  next,
  DEFAULT,
  IS_SET,
  FORCED2
) {
  createIteratorConstructor$2(IteratorConstructor, NAME, next);
  var getIterationMethod = function (KIND) {
    if (KIND === DEFAULT && defaultIterator) return defaultIterator;
    if (!BUGGY_SAFARI_ITERATORS$2 && KIND in IterablePrototype)
      return IterablePrototype[KIND];
    switch (KIND) {
      case KEYS$1:
        return function keys3() {
          return new IteratorConstructor(this, KIND);
        };
      case VALUES$1:
        return function values2() {
          return new IteratorConstructor(this, KIND);
        };
      case ENTRIES$1:
        return function entries() {
          return new IteratorConstructor(this, KIND);
        };
    }
    return function () {
      return new IteratorConstructor(this);
    };
  };
  var TO_STRING_TAG2 = NAME + " Iterator";
  var INCORRECT_VALUES_NAME = false;
  var IterablePrototype = Iterable.prototype;
  var nativeIterator =
    IterablePrototype[ITERATOR$4$1] ||
    IterablePrototype["@@iterator"] ||
    (DEFAULT && IterablePrototype[DEFAULT]);
  var defaultIterator =
    (!BUGGY_SAFARI_ITERATORS$2 && nativeIterator) ||
    getIterationMethod(DEFAULT);
  var anyNativeIterator =
    NAME == "Array"
      ? IterablePrototype.entries || nativeIterator
      : nativeIterator;
  var CurrentIteratorPrototype, methods, KEY;
  if (anyNativeIterator) {
    CurrentIteratorPrototype = getPrototypeOf$2(
      anyNativeIterator.call(new Iterable())
    );
    if (
      CurrentIteratorPrototype !== Object.prototype &&
      CurrentIteratorPrototype.next
    ) {
      if (getPrototypeOf$2(CurrentIteratorPrototype) !== IteratorPrototype$3) {
        if (setPrototypeOf$1$1) {
          setPrototypeOf$1$1(CurrentIteratorPrototype, IteratorPrototype$3);
        } else if (!isCallable$7$2(CurrentIteratorPrototype[ITERATOR$4$1])) {
          defineBuiltIn$3$1(
            CurrentIteratorPrototype,
            ITERATOR$4$1,
            returnThis$2
          );
        }
      }
      setToStringTag$1$1(CurrentIteratorPrototype, TO_STRING_TAG2, true);
    }
  }
  if (
    PROPER_FUNCTION_NAME$1$1 &&
    DEFAULT == VALUES$1 &&
    nativeIterator &&
    nativeIterator.name !== VALUES$1
  ) {
    if (CONFIGURABLE_FUNCTION_NAME$3) {
      createNonEnumerableProperty$1$2(IterablePrototype, "name", VALUES$1);
    } else {
      INCORRECT_VALUES_NAME = true;
      defaultIterator = function values2() {
        return call$a$1(nativeIterator, this);
      };
    }
  }
  if (DEFAULT) {
    methods = {
      values: getIterationMethod(VALUES$1),
      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS$1),
      entries: getIterationMethod(ENTRIES$1),
    };
    if (FORCED2)
      for (KEY in methods) {
        if (
          BUGGY_SAFARI_ITERATORS$2 ||
          INCORRECT_VALUES_NAME ||
          !(KEY in IterablePrototype)
        ) {
          defineBuiltIn$3$1(IterablePrototype, KEY, methods[KEY]);
        }
      }
    else
      $$c(
        {
          target: NAME,
          proto: true,
          forced: BUGGY_SAFARI_ITERATORS$2 || INCORRECT_VALUES_NAME,
        },
        methods
      );
  }
  if (IterablePrototype[ITERATOR$4$1] !== defaultIterator) {
    defineBuiltIn$3$1(IterablePrototype, ITERATOR$4$1, defaultIterator, {
      name: DEFAULT,
    });
  }
  Iterators$3$1[NAME] = defaultIterator;
  return methods;
};
var toIndexedObject$7 = toIndexedObject$5$1;
var addToUnscopables$1$1 = addToUnscopables$2;
var Iterators$2$1 = iterators$1;
var InternalStateModule$1$1 = internalState$2;
var defineProperty$2$2 = objectDefineProperty$2.f;
var defineIterator$2 = defineIterator$1$1;
var DESCRIPTORS$3$2 = descriptors$2;
var ARRAY_ITERATOR$1 = "Array Iterator";
var setInternalState$1$1 = InternalStateModule$1$1.set;
var getInternalState$3 = InternalStateModule$1$1.getterFor(ARRAY_ITERATOR$1);
var es_array_iterator$1 = defineIterator$2(
  Array,
  "Array",
  function (iterated, kind) {
    setInternalState$1$1(this, {
      type: ARRAY_ITERATOR$1,
      target: toIndexedObject$7(iterated),
      // target
      index: 0,
      // next index
      kind,
      // kind
    });
  },
  function () {
    var state = getInternalState$3(this);
    var target = state.target;
    var kind = state.kind;
    var index = state.index++;
    if (!target || index >= target.length) {
      state.target = void 0;
      return { value: void 0, done: true };
    }
    if (kind == "keys") return { value: index, done: false };
    if (kind == "values") return { value: target[index], done: false };
    return { value: [index, target[index]], done: false };
  },
  "values"
);
var values$1 = (Iterators$2$1.Arguments = Iterators$2$1.Array);
addToUnscopables$1$1("keys");
addToUnscopables$1$1("values");
addToUnscopables$1$1("entries");
if (DESCRIPTORS$3$2 && values$1.name !== "values")
  try {
    defineProperty$2$2(values$1, "name", { value: "values" });
  } catch (error) {}
var domIterables$1 = {
  CSSRuleList: 0,
  CSSStyleDeclaration: 0,
  CSSValueList: 0,
  ClientRectList: 0,
  DOMRectList: 0,
  DOMStringList: 0,
  DOMTokenList: 1,
  DataTransferItemList: 0,
  FileList: 0,
  HTMLAllCollection: 0,
  HTMLCollection: 0,
  HTMLFormElement: 0,
  HTMLSelectElement: 0,
  MediaList: 0,
  MimeTypeArray: 0,
  NamedNodeMap: 0,
  NodeList: 1,
  PaintRequestList: 0,
  Plugin: 0,
  PluginArray: 0,
  SVGLengthList: 0,
  SVGNumberList: 0,
  SVGPathSegList: 0,
  SVGPointList: 0,
  SVGStringList: 0,
  SVGTransformList: 0,
  SourceBufferList: 0,
  StyleSheetList: 0,
  TextTrackCueList: 0,
  TextTrackList: 0,
  TouchList: 0,
};
var documentCreateElement$4 = documentCreateElement$2$1;
var classList$1 = documentCreateElement$4("span").classList;
var DOMTokenListPrototype$1$1 =
  classList$1 && classList$1.constructor && classList$1.constructor.prototype;
var domTokenListPrototype$1 =
  DOMTokenListPrototype$1$1 === Object.prototype
    ? void 0
    : DOMTokenListPrototype$1$1;
var global$a$2 = global$k;
var DOMIterables$1 = domIterables$1;
var DOMTokenListPrototype$2 = domTokenListPrototype$1;
var ArrayIteratorMethods$1 = es_array_iterator$1;
var createNonEnumerableProperty$6 = createNonEnumerableProperty$4$1;
var wellKnownSymbol$a$1 = wellKnownSymbol$g;
var ITERATOR$3$1 = wellKnownSymbol$a$1("iterator");
var TO_STRING_TAG$2$1 = wellKnownSymbol$a$1("toStringTag");
var ArrayValues$1 = ArrayIteratorMethods$1.values;
var handlePrototype$1 = function (CollectionPrototype, COLLECTION_NAME) {
  if (CollectionPrototype) {
    if (CollectionPrototype[ITERATOR$3$1] !== ArrayValues$1)
      try {
        createNonEnumerableProperty$6(
          CollectionPrototype,
          ITERATOR$3$1,
          ArrayValues$1
        );
      } catch (error) {
        CollectionPrototype[ITERATOR$3$1] = ArrayValues$1;
      }
    if (!CollectionPrototype[TO_STRING_TAG$2$1]) {
      createNonEnumerableProperty$6(
        CollectionPrototype,
        TO_STRING_TAG$2$1,
        COLLECTION_NAME
      );
    }
    if (DOMIterables$1[COLLECTION_NAME])
      for (var METHOD_NAME in ArrayIteratorMethods$1) {
        if (
          CollectionPrototype[METHOD_NAME] !==
          ArrayIteratorMethods$1[METHOD_NAME]
        )
          try {
            createNonEnumerableProperty$6(
              CollectionPrototype,
              METHOD_NAME,
              ArrayIteratorMethods$1[METHOD_NAME]
            );
          } catch (error) {
            CollectionPrototype[METHOD_NAME] =
              ArrayIteratorMethods$1[METHOD_NAME];
          }
      }
  }
};
for (COLLECTION_NAME$1 in DOMIterables$1) {
  handlePrototype$1(
    global$a$2[COLLECTION_NAME$1] && global$a$2[COLLECTION_NAME$1].prototype,
    COLLECTION_NAME$1
  );
}
var COLLECTION_NAME$1;
handlePrototype$1(DOMTokenListPrototype$2, "DOMTokenList");
var DESCRIPTORS$2$2 = descriptors$2;
var uncurryThis$6$2 = functionUncurryThis$2;
var call$9$1 = functionCall$2;
var fails$6$2 = fails$h;
var objectKeys$3 = objectKeys$2$2;
var getOwnPropertySymbolsModule$3 = objectGetOwnPropertySymbols$2;
var propertyIsEnumerableModule$3 = objectPropertyIsEnumerable$2;
var toObject$2$2 = toObject$5;
var IndexedObject$1$2 = indexedObject$2;
var $assign$2 = Object.assign;
var defineProperty$1$2 = Object.defineProperty;
var concat$3 = uncurryThis$6$2([].concat);
var objectAssign$2 =
  !$assign$2 ||
  fails$6$2(function () {
    if (
      DESCRIPTORS$2$2 &&
      $assign$2(
        { b: 1 },
        $assign$2(
          defineProperty$1$2({}, "a", {
            enumerable: true,
            get: function () {
              defineProperty$1$2(this, "b", {
                value: 3,
                enumerable: false,
              });
            },
          }),
          { b: 2 }
        )
      ).b !== 1
    )
      return true;
    var A = {};
    var B = {};
    var symbol = Symbol();
    var alphabet = "abcdefghijklmnopqrst";
    A[symbol] = 7;
    alphabet.split("").forEach(function (chr) {
      B[chr] = chr;
    });
    return (
      $assign$2({}, A)[symbol] != 7 ||
      objectKeys$3($assign$2({}, B)).join("") != alphabet
    );
  })
    ? function assign(target, source) {
        var T = toObject$2$2(target);
        var argumentsLength = arguments.length;
        var index = 1;
        var getOwnPropertySymbols = getOwnPropertySymbolsModule$3.f;
        var propertyIsEnumerable2 = propertyIsEnumerableModule$3.f;
        while (argumentsLength > index) {
          var S = IndexedObject$1$2(arguments[index++]);
          var keys3 = getOwnPropertySymbols
            ? concat$3(objectKeys$3(S), getOwnPropertySymbols(S))
            : objectKeys$3(S);
          var length = keys3.length;
          var j = 0;
          var key;
          while (length > j) {
            key = keys3[j++];
            if (!DESCRIPTORS$2$2 || call$9$1(propertyIsEnumerable2, S, key))
              T[key] = S[key];
          }
        }
        return T;
      }
    : $assign$2;
var $$b = _export$2;
var assign2$2 = objectAssign$2;
$$b(
  {
    target: "Object",
    stat: true,
    arity: 2,
    forced: Object.assign !== assign2$2,
  },
  {
    assign: assign2$2,
  }
);
function __awaiter$2(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P
      ? value
      : new P(function (resolve2) {
          resolve2(value);
        });
  }
  return new (P || (P = Promise))(function (resolve2, reject2) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject2(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject2(e);
      }
    }
    function step(result) {
      result.done
        ? resolve2(result.value)
        : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
var CloseIcon = () => {
  return (0, import_jsx_runtime.jsxs)(
    "svg",
    Object.assign(
      {
        xmlns: "http://www.w3.org/2000/svg",
        height: "24",
        viewBox: "0 0 24 24",
        width: "24",
        fill: "#C1C1C1",
      },
      {
        children: [
          (0, import_jsx_runtime.jsx)("path", {
            d: "M0 0h24v24H0z",
            fill: "none",
          }),
          (0, import_jsx_runtime.jsx)("path", {
            d: "M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z",
          }),
        ],
      }
    )
  );
};
var CloseButton = ({ onClick }) => {
  return (0, import_jsx_runtime.jsx)(
    "button",
    Object.assign(
      {
        onClick,
        className: "close-button",
      },
      {
        children: (0, import_jsx_runtime.jsx)(CloseIcon, {}),
      }
    )
  );
};
var ModalHeader = ({ title, onCloseModal }) => {
  const additionalClasses = title === "Get a Wallet" ? " -open" : "";
  return (0, import_jsx_runtime.jsxs)(
    "div",
    Object.assign(
      {
        className: "nws-modal-header",
      },
      {
        children: [
          (0, import_jsx_runtime.jsx)(
            "h3",
            Object.assign(
              {
                className: `middleTitle ${additionalClasses}`,
              },
              {
                children: title,
              }
            )
          ),
          (0, import_jsx_runtime.jsx)(CloseButton, {
            onClick: onCloseModal,
          }),
        ],
      }
    )
  );
};
var BackArrowIcon = () => {
  return (0, import_jsx_runtime.jsx)(
    "svg",
    Object.assign(
      {
        width: "8",
        height: "14",
        viewBox: "0 0 8 14",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
      },
      {
        children: (0, import_jsx_runtime.jsx)("path", {
          d: "M7 13L1 7L7 1",
          stroke: "#6494EE",
          strokeWidth: "1.5",
          strokeLinecap: "round",
          strokeLinejoin: "round",
        }),
      }
    )
  );
};
var BackArrow = ({ onClick }) => {
  return (0, import_jsx_runtime.jsx)(
    "button",
    Object.assign(
      {
        onClick,
        className: "back-button",
      },
      {
        children: (0, import_jsx_runtime.jsx)(BackArrowIcon, {}),
      }
    )
  );
};
var WalletNetworkChanged = ({ selector, onBack, onCloseModal }) => {
  return (0, import_jsx_runtime.jsxs)(import_react.Fragment, {
    children: [
      (0, import_jsx_runtime.jsxs)(
        "div",
        Object.assign(
          {
            className: "nws-modal-header-wrapper",
          },
          {
            children: [
              (0, import_jsx_runtime.jsx)(BackArrow, {
                onClick: onBack,
              }),
              (0, import_jsx_runtime.jsx)(ModalHeader, {
                title: "You Must Change the Network",
                onCloseModal,
              }),
            ],
          }
        )
      ),
      (0, import_jsx_runtime.jsx)(
        "div",
        Object.assign(
          {
            className: "switch-network-message-wrapper",
          },
          {
            children: (0, import_jsx_runtime.jsxs)(
              "div",
              Object.assign(
                {
                  className: "content",
                },
                {
                  children: [
                    (0, import_jsx_runtime.jsxs)("p", {
                      children: [
                        "We've detected that you need to change your wallet's network to",
                        (0, import_jsx_runtime.jsx)(
                          "strong",
                          Object.assign(
                            {
                              className: "network-id",
                            },
                            {
                              children: ` ${selector.options.network.networkId}`,
                            }
                          )
                        ),
                        " ",
                        "for this dApp.",
                      ],
                    }),
                    (0, import_jsx_runtime.jsx)("p", {
                      children:
                        "Some wallets may not support changing networks. If you can not change networks you may consider switching to another wallet.",
                    }),
                  ],
                }
              )
            ),
          }
        )
      ),
    ],
  });
};
var tryToString$3$1 = tryToString$5$1;
var $TypeError$7$1 = TypeError;
var deletePropertyOrThrow$1 = function (O, P) {
  if (!delete O[P])
    throw $TypeError$7$1(
      "Cannot delete property " +
        tryToString$3$1(P) +
        " of " +
        tryToString$3$1(O)
    );
};
var wellKnownSymbol$9$1 = wellKnownSymbol$g;
var TO_STRING_TAG$1$1 = wellKnownSymbol$9$1("toStringTag");
var test$1 = {};
test$1[TO_STRING_TAG$1$1] = "z";
var toStringTagSupport$1 = String(test$1) === "[object z]";
var TO_STRING_TAG_SUPPORT$1 = toStringTagSupport$1;
var isCallable$6$2 = isCallable$l$1;
var classofRaw$3 = classofRaw$1$1;
var wellKnownSymbol$8$1 = wellKnownSymbol$g;
var TO_STRING_TAG$4 = wellKnownSymbol$8$1("toStringTag");
var $Object$6 = Object;
var CORRECT_ARGUMENTS$1 =
  classofRaw$3(
    (function () {
      return arguments;
    })()
  ) == "Arguments";
var tryGet$1 = function (it, key) {
  try {
    return it[key];
  } catch (error) {}
};
var classof$5$1 = TO_STRING_TAG_SUPPORT$1
  ? classofRaw$3
  : function (it) {
      var O, tag, result;
      return it === void 0
        ? "Undefined"
        : it === null
        ? "Null"
        : typeof (tag = tryGet$1((O = $Object$6(it)), TO_STRING_TAG$4)) ==
          "string"
        ? tag
        : CORRECT_ARGUMENTS$1
        ? classofRaw$3(O)
        : (result = classofRaw$3(O)) == "Object" && isCallable$6$2(O.callee)
        ? "Arguments"
        : result;
    };
var classof$4$1 = classof$5$1;
var $String$5 = String;
var toString$3 = function (argument) {
  if (classof$4$1(argument) === "Symbol")
    throw TypeError("Cannot convert a Symbol value to a string");
  return $String$5(argument);
};
var toPropertyKey$4 = toPropertyKey$3$1;
var definePropertyModule$1$2 = objectDefineProperty$2;
var createPropertyDescriptor$5 = createPropertyDescriptor$4$1;
var createProperty$1 = function (object, key, value) {
  var propertyKey = toPropertyKey$4(key);
  if (propertyKey in object)
    definePropertyModule$1$2.f(
      object,
      propertyKey,
      createPropertyDescriptor$5(0, value)
    );
  else object[propertyKey] = value;
};
var toAbsoluteIndex$3 = toAbsoluteIndex$2$1;
var lengthOfArrayLike$3$1 = lengthOfArrayLike$5;
var createProperty = createProperty$1;
var $Array = Array;
var max$2 = Math.max;
var arraySliceSimple = function (O, start, end) {
  var length = lengthOfArrayLike$3$1(O);
  var k = toAbsoluteIndex$3(start, length);
  var fin = toAbsoluteIndex$3(end === void 0 ? length : end, length);
  var result = $Array(max$2(fin - k, 0));
  for (var n = 0; k < fin; k++, n++) createProperty(result, n, O[k]);
  result.length = n;
  return result;
};
var arraySlice$2 = arraySliceSimple;
var floor$2 = Math.floor;
var mergeSort = function (array, comparefn) {
  var length = array.length;
  var middle = floor$2(length / 2);
  return length < 8
    ? insertionSort(array, comparefn)
    : merge(
        array,
        mergeSort(arraySlice$2(array, 0, middle), comparefn),
        mergeSort(arraySlice$2(array, middle), comparefn),
        comparefn
      );
};
var insertionSort = function (array, comparefn) {
  var length = array.length;
  var i = 1;
  var element, j;
  while (i < length) {
    j = i;
    element = array[i];
    while (j && comparefn(array[j - 1], element) > 0) {
      array[j] = array[--j];
    }
    if (j !== i++) array[j] = element;
  }
  return array;
};
var merge = function (array, left, right, comparefn) {
  var llength = left.length;
  var rlength = right.length;
  var lindex = 0;
  var rindex = 0;
  while (lindex < llength || rindex < rlength) {
    array[lindex + rindex] =
      lindex < llength && rindex < rlength
        ? comparefn(left[lindex], right[rindex]) <= 0
          ? left[lindex++]
          : right[rindex++]
        : lindex < llength
        ? left[lindex++]
        : right[rindex++];
  }
  return array;
};
var arraySort = mergeSort;
var fails$5$2 = fails$h;
var arrayMethodIsStrict$2 = function (METHOD_NAME, argument) {
  var method = [][METHOD_NAME];
  return (
    !!method &&
    fails$5$2(function () {
      method.call(
        null,
        argument ||
          function () {
            return 1;
          },
        1
      );
    })
  );
};
var userAgent$4$1 = engineUserAgent$2;
var firefox = userAgent$4$1.match(/firefox\/(\d+)/i);
var engineFfVersion = !!firefox && +firefox[1];
var UA = engineUserAgent$2;
var engineIsIeOrEdge = /MSIE|Trident/.test(UA);
var userAgent$3$1 = engineUserAgent$2;
var webkit = userAgent$3$1.match(/AppleWebKit\/(\d+)\./);
var engineWebkitVersion = !!webkit && +webkit[1];
var $$a = _export$2;
var uncurryThis$5$2 = functionUncurryThis$2;
var aCallable$7$1 = aCallable$9;
var toObject$1$2 = toObject$5;
var lengthOfArrayLike$2$1 = lengthOfArrayLike$5;
var deletePropertyOrThrow = deletePropertyOrThrow$1;
var toString$2$1 = toString$3;
var fails$4$2 = fails$h;
var internalSort = arraySort;
var arrayMethodIsStrict$1 = arrayMethodIsStrict$2;
var FF = engineFfVersion;
var IE_OR_EDGE = engineIsIeOrEdge;
var V8 = engineV8Version$2;
var WEBKIT = engineWebkitVersion;
var test$2 = [];
var un$Sort = uncurryThis$5$2(test$2.sort);
var push$2 = uncurryThis$5$2(test$2.push);
var FAILS_ON_UNDEFINED = fails$4$2(function () {
  test$2.sort(void 0);
});
var FAILS_ON_NULL = fails$4$2(function () {
  test$2.sort(null);
});
var STRICT_METHOD$1 = arrayMethodIsStrict$1("sort");
var STABLE_SORT = !fails$4$2(function () {
  if (V8) return V8 < 70;
  if (FF && FF > 3) return;
  if (IE_OR_EDGE) return true;
  if (WEBKIT) return WEBKIT < 603;
  var result = "";
  var code, chr, value, index;
  for (code = 65; code < 76; code++) {
    chr = String.fromCharCode(code);
    switch (code) {
      case 66:
      case 69:
      case 70:
      case 72:
        value = 3;
        break;
      case 68:
      case 71:
        value = 4;
        break;
      default:
        value = 2;
    }
    for (index = 0; index < 47; index++) {
      test$2.push({ k: chr + index, v: value });
    }
  }
  test$2.sort(function (a, b) {
    return b.v - a.v;
  });
  for (index = 0; index < test$2.length; index++) {
    chr = test$2[index].k.charAt(0);
    if (result.charAt(result.length - 1) !== chr) result += chr;
  }
  return result !== "DGBEFHACIJK";
});
var FORCED =
  FAILS_ON_UNDEFINED || !FAILS_ON_NULL || !STRICT_METHOD$1 || !STABLE_SORT;
var getSortCompare = function (comparefn) {
  return function (x, y) {
    if (y === void 0) return -1;
    if (x === void 0) return 1;
    if (comparefn !== void 0) return +comparefn(x, y) || 0;
    return toString$2$1(x) > toString$2$1(y) ? 1 : -1;
  };
};
$$a(
  { target: "Array", proto: true, forced: FORCED },
  {
    sort: function sort(comparefn) {
      if (comparefn !== void 0) aCallable$7$1(comparefn);
      var array = toObject$1$2(this);
      if (STABLE_SORT)
        return comparefn === void 0
          ? un$Sort(array)
          : un$Sort(array, comparefn);
      var items = [];
      var arrayLength = lengthOfArrayLike$2$1(array);
      var itemsLength, index;
      for (index = 0; index < arrayLength; index++) {
        if (index in array) push$2(items, array[index]);
      }
      internalSort(items, getSortCompare(comparefn));
      itemsLength = items.length;
      index = 0;
      while (index < itemsLength) array[index] = items[index++];
      while (index < arrayLength) deletePropertyOrThrow(array, index++);
      return array;
    },
  }
);
var $$9 = _export$2;
var $includes = arrayIncludes$2.includes;
var fails$3$2 = fails$h;
var addToUnscopables$3 = addToUnscopables$2;
var BROKEN_ON_SPARSE = fails$3$2(function () {
  return !Array(1).includes();
});
$$9(
  { target: "Array", proto: true, forced: BROKEN_ON_SPARSE },
  {
    includes: function includes(el) {
      return $includes(this, el, arguments.length > 1 ? arguments[1] : void 0);
    },
  }
);
addToUnscopables$3("includes");
var isObject$2$2 = isObject$8$1;
var classof$3$1 = classofRaw$1$1;
var wellKnownSymbol$7$1 = wellKnownSymbol$g;
var MATCH$1 = wellKnownSymbol$7$1("match");
var isRegexp = function (it) {
  var isRegExp2;
  return (
    isObject$2$2(it) &&
    ((isRegExp2 = it[MATCH$1]) !== void 0
      ? !!isRegExp2
      : classof$3$1(it) == "RegExp")
  );
};
var isRegExp = isRegexp;
var $TypeError$6$1 = TypeError;
var notARegexp = function (it) {
  if (isRegExp(it)) {
    throw $TypeError$6$1("The method doesn't accept regular expressions");
  }
  return it;
};
var wellKnownSymbol$6$1 = wellKnownSymbol$g;
var MATCH = wellKnownSymbol$6$1("match");
var correctIsRegexpLogic = function (METHOD_NAME) {
  var regexp = /./;
  try {
    "/./"[METHOD_NAME](regexp);
  } catch (error1) {
    try {
      regexp[MATCH] = false;
      return "/./"[METHOD_NAME](regexp);
    } catch (error2) {}
  }
  return false;
};
var $$8 = _export$2;
var uncurryThis$4$2 = functionUncurryThis$2;
var notARegExp = notARegexp;
var requireObjectCoercible$4 = requireObjectCoercible$3$1;
var toString$1$2 = toString$3;
var correctIsRegExpLogic = correctIsRegexpLogic;
var stringIndexOf = uncurryThis$4$2("".indexOf);
$$8(
  { target: "String", proto: true, forced: !correctIsRegExpLogic("includes") },
  {
    includes: function includes2(searchString) {
      return !!~stringIndexOf(
        toString$1$2(requireObjectCoercible$4(this)),
        toString$1$2(notARegExp(searchString)),
        arguments.length > 1 ? arguments[1] : void 0
      );
    },
  }
);
var aCallable$6$1 = aCallable$9;
var toObject$6 = toObject$5;
var IndexedObject$3 = indexedObject$2;
var lengthOfArrayLike$1$2 = lengthOfArrayLike$5;
var $TypeError$5$2 = TypeError;
var createMethod$2 = function (IS_RIGHT) {
  return function (that, callbackfn, argumentsLength, memo) {
    aCallable$6$1(callbackfn);
    var O = toObject$6(that);
    var self2 = IndexedObject$3(O);
    var length = lengthOfArrayLike$1$2(O);
    var index = IS_RIGHT ? length - 1 : 0;
    var i = IS_RIGHT ? -1 : 1;
    if (argumentsLength < 2)
      while (true) {
        if (index in self2) {
          memo = self2[index];
          index += i;
          break;
        }
        index += i;
        if (IS_RIGHT ? index < 0 : length <= index) {
          throw $TypeError$5$2("Reduce of empty array with no initial value");
        }
      }
    for (; IS_RIGHT ? index >= 0 : length > index; index += i)
      if (index in self2) {
        memo = callbackfn(memo, self2[index], index, O);
      }
    return memo;
  };
};
var arrayReduce = {
  // `Array.prototype.reduce` method
  // https://tc39.es/ecma262/#sec-array.prototype.reduce
  left: createMethod$2(false),
  // `Array.prototype.reduceRight` method
  // https://tc39.es/ecma262/#sec-array.prototype.reduceright
  right: createMethod$2(true),
};
var classof$2$1 = classofRaw$1$1;
var global$9$2 = global$k;
var engineIsNode$1 = classof$2$1(global$9$2.process) == "process";
var $$7$2 = _export$2;
var $reduce = arrayReduce.left;
var arrayMethodIsStrict = arrayMethodIsStrict$2;
var CHROME_VERSION = engineV8Version$2;
var IS_NODE$3 = engineIsNode$1;
var STRICT_METHOD = arrayMethodIsStrict("reduce");
var CHROME_BUG = !IS_NODE$3 && CHROME_VERSION > 79 && CHROME_VERSION < 83;
$$7$2(
  { target: "Array", proto: true, forced: !STRICT_METHOD || CHROME_BUG },
  {
    reduce: function reduce(callbackfn) {
      var length = arguments.length;
      return $reduce(
        this,
        callbackfn,
        length,
        length > 1 ? arguments[1] : void 0
      );
    },
  }
);
var $$6$1 = _export$2;
var DESCRIPTORS$1$2 = descriptors$2;
var global$8$2 = global$k;
var uncurryThis$3$2 = functionUncurryThis$2;
var hasOwn$2$2 = hasOwnProperty_1$2;
var isCallable$5$2 = isCallable$l$1;
var isPrototypeOf$3$1 = objectIsPrototypeOf$2;
var toString2$1 = toString$3;
var defineProperty3$2 = objectDefineProperty$2.f;
var copyConstructorProperties$3 = copyConstructorProperties$2$1;
var NativeSymbol = global$8$2.Symbol;
var SymbolPrototype = NativeSymbol && NativeSymbol.prototype;
if (
  DESCRIPTORS$1$2 &&
  isCallable$5$2(NativeSymbol) &&
  (!("description" in SymbolPrototype) || // Safari 12 bug
    NativeSymbol().description !== void 0)
) {
  EmptyStringDescriptionStore = {};
  SymbolWrapper = function Symbol2() {
    var description =
      arguments.length < 1 || arguments[0] === void 0
        ? void 0
        : toString2$1(arguments[0]);
    var result = isPrototypeOf$3$1(SymbolPrototype, this)
      ? new NativeSymbol(description)
      : description === void 0
      ? NativeSymbol()
      : NativeSymbol(description);
    if (description === "") EmptyStringDescriptionStore[result] = true;
    return result;
  };
  copyConstructorProperties$3(SymbolWrapper, NativeSymbol);
  SymbolWrapper.prototype = SymbolPrototype;
  SymbolPrototype.constructor = SymbolWrapper;
  NATIVE_SYMBOL$3 = String(NativeSymbol("test")) == "Symbol(test)";
  symbolToString = uncurryThis$3$2(SymbolPrototype.toString);
  symbolValueOf = uncurryThis$3$2(SymbolPrototype.valueOf);
  regexp = /^Symbol\((.*)\)[^)]+$/;
  replace = uncurryThis$3$2("".replace);
  stringSlice$2 = uncurryThis$3$2("".slice);
  defineProperty3$2(SymbolPrototype, "description", {
    configurable: true,
    get: function description() {
      var symbol = symbolValueOf(this);
      var string = symbolToString(symbol);
      if (hasOwn$2$2(EmptyStringDescriptionStore, symbol)) return "";
      var desc = NATIVE_SYMBOL$3
        ? stringSlice$2(string, 7, -1)
        : replace(string, regexp, "$1");
      return desc === "" ? void 0 : desc;
    },
  });
  $$6$1(
    { global: true, constructor: true, forced: true },
    {
      Symbol: SymbolWrapper,
    }
  );
}
var EmptyStringDescriptionStore;
var SymbolWrapper;
var NATIVE_SYMBOL$3;
var symbolToString;
var symbolValueOf;
var regexp;
var replace;
var stringSlice$2;
var WarningIcon = () => {
  return (0, import_jsx_runtime.jsxs)(
    "svg",
    Object.assign(
      {
        width: "18",
        height: "18",
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
      },
      {
        children: [
          (0, import_jsx_runtime.jsx)("path", {
            d: "M4.95215 16.3536L10.2152 5.85657C10.9531 4.38481 13.0538 4.38519 13.7912 5.85723L19.0494 16.3543C19.7156 17.6841 18.7486 19.25 17.2612 19.25H6.74001C5.25228 19.25 4.28535 17.6835 4.95215 16.3536Z",
            stroke: "#E6B73E",
            strokeWidth: "1.5",
            strokeLinecap: "round",
            strokeLinejoin: "round",
          }),
          (0, import_jsx_runtime.jsx)("path", {
            d: "M12 10V12",
            stroke: "#E6B73E",
            strokeWidth: "2",
            strokeLinecap: "round",
            strokeLinejoin: "round",
          }),
          (0, import_jsx_runtime.jsx)("path", {
            d: "M12.5 16C12.5 16.2761 12.2761 16.5 12 16.5C11.7239 16.5 11.5 16.2761 11.5 16C11.5 15.7239 11.7239 15.5 12 15.5C12.2761 15.5 12.5 15.7239 12.5 16Z",
            stroke: "#E6B73E",
          }),
        ],
      }
    )
  );
};
var WalletOptions = ({ selector, handleWalletClick }) => {
  const [modules, setModules] = (0, import_react.useState)([]);
  const [recentModules, setRecentModules] = (0, import_react.useState)([]);
  const [moreModules, setMoreModules] = (0, import_react.useState)([]);
  const [activeWalletId, setActiveWalletId] = (0, import_react.useState)("");
  (0, import_react.useEffect)(() => {
    const subscription = selector.store.observable.subscribe((state) => {
      const { selectedWalletId } = selector.store.getState();
      if (selectedWalletId) {
        setActiveWalletId(selectedWalletId);
      }
      const wallets = state.modules.filter(
        (module) =>
          !(module.type === "instant-link" && selectedWalletId !== module.id)
      );
      if (selector.options.optimizeWalletOrder) {
        state.modules.sort((current, next) => {
          if (current.metadata.deprecated === next.metadata.deprecated) {
            return 0;
          }
          return current.metadata.deprecated ? 1 : -1;
        });
        state.modules.sort((current, next) => {
          if (next.metadata.available === current.metadata.available) {
            return 0;
          }
          return next.metadata.available ? 1 : -1;
        });
        const moreWallets = [];
        const recentlySignedInWallets = [];
        wallets.forEach((module) => {
          if (
            selector.store
              .getState()
              .recentlySignedInWallets.includes(module.id)
          ) {
            recentlySignedInWallets.push(module);
          } else {
            moreWallets.push(module);
          }
        });
        setRecentModules(recentlySignedInWallets);
        setMoreModules(moreWallets);
      }
      if (selector.options.randomizeWalletOrder) {
        setModules(wallets.sort(() => Math.random() - 0.5));
      } else {
        setModules(wallets);
      }
    });
    return () => subscription.unsubscribe();
  }, []);
  function renderOptionsList(modulesToRender) {
    return modulesToRender.reduce((result, module, index) => {
      const { selectedWalletId } = selector.store.getState();
      const { name, description, iconUrl, deprecated } = module.metadata;
      const selected = module.id === selectedWalletId;
      result.push(
        (0, import_jsx_runtime.jsxs)(
          "li",
          Object.assign(
            {
              tabIndex: 0,
              className: `single-wallet ${
                activeWalletId === module.id ? "selected-wallet" : ""
              } ${selected ? "connected-wallet" : ""} ${
                deprecated ? "deprecated-wallet" : ""
              } sidebar ${module.id}`,
              onClick: () => {
                if (module.id === modulesToRender[index].id) {
                  setActiveWalletId(module.id);
                }
                return handleWalletClick(module);
              },
            },
            {
              children: [
                (0, import_jsx_runtime.jsx)(
                  "div",
                  Object.assign(
                    {
                      className: "icon",
                    },
                    {
                      children: (0, import_jsx_runtime.jsx)("img", {
                        src: iconUrl,
                        alt: name,
                      }),
                    }
                  )
                ),
                (0, import_jsx_runtime.jsxs)(
                  "div",
                  Object.assign(
                    {
                      className: "content",
                    },
                    {
                      children: [
                        (0, import_jsx_runtime.jsx)(
                          "div",
                          Object.assign(
                            {
                              className: "title",
                            },
                            {
                              children: name,
                            }
                          )
                        ),
                        (0, import_jsx_runtime.jsx)(
                          "div",
                          Object.assign(
                            {
                              className: "description",
                            },
                            {
                              children: description,
                            }
                          )
                        ),
                      ],
                    }
                  )
                ),
                deprecated &&
                  (0, import_jsx_runtime.jsx)(
                    "div",
                    Object.assign(
                      {
                        className: "warning-triangle",
                      },
                      {
                        children: (0, import_jsx_runtime.jsx)(WarningIcon, {}),
                      }
                    )
                  ),
              ],
            }
          ),
          module.id
        )
      );
      return result;
    }, []);
  }
  return (0, import_jsx_runtime.jsx)("div", {
    children:
      selector.options.optimizeWalletOrder &&
      selector.store.getState().recentlySignedInWallets.length > 0
        ? (0, import_jsx_runtime.jsxs)(
            "div",
            Object.assign(
              {
                className: "wallet-options-wrapper",
              },
              {
                children: [
                  (0, import_jsx_runtime.jsxs)(
                    "div",
                    Object.assign(
                      {
                        className: "options-list-section",
                      },
                      {
                        children: [
                          (0, import_jsx_runtime.jsx)(
                            "div",
                            Object.assign(
                              {
                                className: "options-list-section-header",
                              },
                              {
                                children: "Recent",
                              }
                            )
                          ),
                          (0, import_jsx_runtime.jsx)(
                            "div",
                            Object.assign(
                              {
                                className:
                                  "options-list more-options-list-content",
                              },
                              {
                                children: renderOptionsList(recentModules),
                              }
                            )
                          ),
                        ],
                      }
                    )
                  ),
                  (0, import_jsx_runtime.jsxs)(
                    "div",
                    Object.assign(
                      {
                        className: "options-list-section",
                      },
                      {
                        children: [
                          (0, import_jsx_runtime.jsx)(
                            "div",
                            Object.assign(
                              {
                                className: "options-list-section-header",
                              },
                              {
                                children: "More",
                              }
                            )
                          ),
                          (0, import_jsx_runtime.jsx)(
                            "div",
                            Object.assign(
                              {
                                className:
                                  "options-list more-options-list-content",
                              },
                              {
                                children: renderOptionsList(moreModules),
                              }
                            )
                          ),
                        ],
                      }
                    )
                  ),
                ],
              }
            )
          )
        : (0, import_jsx_runtime.jsx)(
            "div",
            Object.assign(
              {
                className: "wallet-options-wrapper",
              },
              {
                children: (0, import_jsx_runtime.jsx)(
                  "div",
                  Object.assign(
                    {
                      className: "options-list",
                    },
                    {
                      children: renderOptionsList(modules),
                    }
                  )
                ),
              }
            )
          ),
  });
};
var ConnectionErrorIcon = () => {
  return (0, import_jsx_runtime.jsxs)(
    "svg",
    Object.assign(
      {
        width: "21",
        height: "20",
        viewBox: "0 0 21 20",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
      },
      {
        children: [
          (0, import_jsx_runtime.jsx)("path", {
            d: "M10.5001 18.3333C15.1025 18.3333 18.8334 14.6023 18.8334 9.99996C18.8334 5.39759 15.1025 1.66663 10.5001 1.66663C5.89771 1.66663 2.16675 5.39759 2.16675 9.99996C2.16675 14.6023 5.89771 18.3333 10.5001 18.3333Z",
            stroke: "#CE5A6F",
            strokeWidth: "2",
            strokeLinecap: "round",
            strokeLinejoin: "round",
          }),
          (0, import_jsx_runtime.jsx)("path", {
            d: "M13 7.5L8 12.5",
            stroke: "#CE5A6F",
            strokeWidth: "2",
            strokeLinecap: "round",
            strokeLinejoin: "round",
          }),
          (0, import_jsx_runtime.jsx)("path", {
            d: "M8 7.5L13 12.5",
            stroke: "#CE5A6F",
            strokeWidth: "2",
            strokeLinecap: "round",
            strokeLinejoin: "round",
          }),
        ],
      }
    )
  );
};
var ConnectionSuccessIcon = () => {
  return (0, import_jsx_runtime.jsxs)(
    "svg",
    Object.assign(
      {
        width: "21",
        height: "20",
        viewBox: "0 0 21 20",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
      },
      {
        children: [
          (0, import_jsx_runtime.jsx)("path", {
            d: "M18.8333 9.2333V9.99997C18.8323 11.797 18.2504 13.5455 17.1744 14.9848C16.0984 16.4241 14.586 17.477 12.8628 17.9866C11.1395 18.4961 9.29768 18.4349 7.61202 17.8121C5.92636 17.1894 4.48717 16.0384 3.50909 14.5309C2.53101 13.0233 2.06645 11.24 2.18469 9.4469C2.30293 7.65377 2.99763 5.94691 4.16519 4.58086C5.33275 3.21482 6.91061 2.26279 8.66345 1.86676C10.4163 1.47073 12.2502 1.65192 13.8916 2.3833",
            stroke: "#4FD98F",
            strokeWidth: "2",
            strokeLinecap: "round",
            strokeLinejoin: "round",
          }),
          (0, import_jsx_runtime.jsx)("path", {
            d: "M18.8333 3.33337L10.5 11.675L8 9.17504",
            stroke: "#4FD98F",
            strokeWidth: "2",
            strokeLinecap: "round",
            strokeLinejoin: "round",
          }),
        ],
      }
    )
  );
};
var ConnectionResult = ({ module, message, err, onRetry }) => {
  return (0, import_jsx_runtime.jsx)(
    "div",
    Object.assign(
      {
        className: "connection connecting-details",
      },
      {
        children: err
          ? (0, import_jsx_runtime.jsxs)(
              "div",
              Object.assign(
                {
                  className: "error-wrapper",
                },
                {
                  children: [
                    (0, import_jsx_runtime.jsxs)(
                      "div",
                      Object.assign(
                        {
                          className: "error",
                        },
                        {
                          children: [
                            (0, import_jsx_runtime.jsx)(
                              ConnectionErrorIcon,
                              {}
                            ),
                            translate("modal.wallet.connectionFailed"),
                          ],
                        }
                      )
                    ),
                    (0, import_jsx_runtime.jsx)("p", {
                      children: message,
                    }),
                    (module === null || module === void 0
                      ? void 0
                      : module.metadata.available) &&
                      (0, import_jsx_runtime.jsx)(
                        "button",
                        Object.assign(
                          {
                            onClick: onRetry,
                          },
                          {
                            children: translate("modal.ledger.retry"),
                          }
                        )
                      ),
                  ],
                }
              )
            )
          : (0, import_jsx_runtime.jsxs)(
              "div",
              Object.assign(
                {
                  className: "success",
                },
                {
                  children: [
                    (0, import_jsx_runtime.jsx)(ConnectionSuccessIcon, {}),
                    translate("modal.wallet.connectionSuccessful"),
                  ],
                }
              )
            ),
      }
    )
  );
};
var AlertMessage = ({ message, module, onBack, onCloseModal }) => {
  return (0, import_jsx_runtime.jsxs)(import_react.Fragment, {
    children: [
      (0, import_jsx_runtime.jsx)(ModalHeader, {
        title: "",
        onCloseModal,
      }),
      (0, import_jsx_runtime.jsx)(
        "div",
        Object.assign(
          {
            className:
              "alert-message connecting-wrapper connecting-wrapper-err",
          },
          {
            children: (0, import_jsx_runtime.jsxs)(
              "div",
              Object.assign(
                {
                  className: "content",
                },
                {
                  children: [
                    (0, import_jsx_runtime.jsx)(
                      "div",
                      Object.assign(
                        {
                          className: "icon",
                        },
                        {
                          children: (0, import_jsx_runtime.jsx)("img", {
                            src:
                              module === null || module === void 0
                                ? void 0
                                : module.metadata.iconUrl,
                            alt:
                              module === null || module === void 0
                                ? void 0
                                : module.metadata.name,
                          }),
                        }
                      )
                    ),
                    (0, import_jsx_runtime.jsx)(
                      "h3",
                      Object.assign(
                        {
                          className: "connecting-name",
                        },
                        {
                          children:
                            module === null || module === void 0
                              ? void 0
                              : module.metadata.name,
                        }
                      )
                    ),
                    (0, import_jsx_runtime.jsx)(ConnectionResult, {
                      module,
                      message,
                      err: message !== null,
                      onRetry: () => {
                        onBack(true);
                      },
                    }),
                  ],
                }
              )
            ),
          }
        )
      ),
    ],
  });
};
var getBuiltIn$3$2 = getBuiltIn$8$1;
var definePropertyModule$6 = objectDefineProperty$2;
var wellKnownSymbol$5$1 = wellKnownSymbol$g;
var DESCRIPTORS$c = descriptors$2;
var SPECIES$2$1 = wellKnownSymbol$5$1("species");
var setSpecies$1$1 = function (CONSTRUCTOR_NAME) {
  var Constructor = getBuiltIn$3$2(CONSTRUCTOR_NAME);
  var defineProperty4 = definePropertyModule$6.f;
  if (DESCRIPTORS$c && Constructor && !Constructor[SPECIES$2$1]) {
    defineProperty4(Constructor, SPECIES$2$1, {
      configurable: true,
      get: function () {
        return this;
      },
    });
  }
};
var isPrototypeOf$2$1 = objectIsPrototypeOf$2;
var $TypeError$4$2 = TypeError;
var anInstance$1$1 = function (it, Prototype) {
  if (isPrototypeOf$2$1(Prototype, it)) return it;
  throw $TypeError$4$2("Incorrect invocation");
};
var uncurryThis$2$2 = functionUncurryThis$2;
var fails$2$2 = fails$h;
var isCallable$4$2 = isCallable$l$1;
var classof$1$1 = classof$5$1;
var getBuiltIn$2$2 = getBuiltIn$8$1;
var inspectSource$1$2 = inspectSource$4$1;
var noop$1 = function () {};
var empty$1 = [];
var construct$1 = getBuiltIn$2$2("Reflect", "construct");
var constructorRegExp$1 = /^\s*(?:class|function)\b/;
var exec$1 = uncurryThis$2$2(constructorRegExp$1.exec);
var INCORRECT_TO_STRING$1 = !constructorRegExp$1.exec(noop$1);
var isConstructorModern$1 = function isConstructor(argument) {
  if (!isCallable$4$2(argument)) return false;
  try {
    construct$1(noop$1, empty$1, argument);
    return true;
  } catch (error) {
    return false;
  }
};
var isConstructorLegacy$1 = function isConstructor2(argument) {
  if (!isCallable$4$2(argument)) return false;
  switch (classof$1$1(argument)) {
    case "AsyncFunction":
    case "GeneratorFunction":
    case "AsyncGeneratorFunction":
      return false;
  }
  try {
    return (
      INCORRECT_TO_STRING$1 ||
      !!exec$1(constructorRegExp$1, inspectSource$1$2(argument))
    );
  } catch (error) {
    return true;
  }
};
isConstructorLegacy$1.sham = true;
var isConstructor$1$1 =
  !construct$1 ||
  fails$2$2(function () {
    var called;
    return (
      isConstructorModern$1(isConstructorModern$1.call) ||
      !isConstructorModern$1(Object) ||
      !isConstructorModern$1(function () {
        called = true;
      }) ||
      called
    );
  })
    ? isConstructorLegacy$1
    : isConstructorModern$1;
var isConstructor3$1 = isConstructor$1$1;
var tryToString$2$1 = tryToString$5$1;
var $TypeError$3$2 = TypeError;
var aConstructor$1$1 = function (argument) {
  if (isConstructor3$1(argument)) return argument;
  throw $TypeError$3$2(tryToString$2$1(argument) + " is not a constructor");
};
var anObject$6$1 = anObject$c$1;
var aConstructor$2 = aConstructor$1$1;
var wellKnownSymbol$4$1 = wellKnownSymbol$g;
var SPECIES$1$1 = wellKnownSymbol$4$1("species");
var speciesConstructor$1$1 = function (O, defaultConstructor) {
  var C = anObject$6$1(O).constructor;
  var S;
  return C === void 0 || (S = anObject$6$1(C)[SPECIES$1$1]) == void 0
    ? defaultConstructor
    : aConstructor$2(S);
};
var NATIVE_BIND$1$2 = functionBindNative$2;
var FunctionPrototype$4 = Function.prototype;
var apply$1$1 = FunctionPrototype$4.apply;
var call$8$1 = FunctionPrototype$4.call;
var functionApply$1 =
  (typeof Reflect == "object" && Reflect.apply) ||
  (NATIVE_BIND$1$2
    ? call$8$1.bind(apply$1$1)
    : function () {
        return call$8$1.apply(apply$1$1, arguments);
      });
var uncurryThis$1$2 = functionUncurryThis$2;
var aCallable$5$1 = aCallable$9;
var NATIVE_BIND$5 = functionBindNative$2;
var bind$4$1 = uncurryThis$1$2(uncurryThis$1$2.bind);
var functionBindContext$1 = function (fn, that) {
  aCallable$5$1(fn);
  return that === void 0
    ? fn
    : NATIVE_BIND$5
    ? bind$4$1(fn, that)
    : function () {
        return fn.apply(that, arguments);
      };
};
var uncurryThis$i = functionUncurryThis$2;
var arraySlice$1$1 = uncurryThis$i([].slice);
var $TypeError$2$2 = TypeError;
var validateArgumentsLength$1$1 = function (passed, required) {
  if (passed < required) throw $TypeError$2$2("Not enough arguments");
  return passed;
};
var userAgent$2$1 = engineUserAgent$2;
var engineIsIos$1 = /(?:ipad|iphone|ipod).*applewebkit/i.test(userAgent$2$1);
var global$7$2 = global$k;
var apply$2 = functionApply$1;
var bind$3$1 = functionBindContext$1;
var isCallable$3$2 = isCallable$l$1;
var hasOwn$1$2 = hasOwnProperty_1$2;
var fails$1$2 = fails$h;
var html$3 = html$2$1;
var arraySlice$3 = arraySlice$1$1;
var createElement$3 = documentCreateElement$2$1;
var validateArgumentsLength$2 = validateArgumentsLength$1$1;
var IS_IOS$1$1 = engineIsIos$1;
var IS_NODE$2$1 = engineIsNode$1;
var set$3 = global$7$2.setImmediate;
var clear$1 = global$7$2.clearImmediate;
var process$2$1 = global$7$2.process;
var Dispatch$1 = global$7$2.Dispatch;
var Function$1$1 = global$7$2.Function;
var MessageChannel2$1 = global$7$2.MessageChannel;
var String$1$1 = global$7$2.String;
var counter$1 = 0;
var queue$1$1 = {};
var ONREADYSTATECHANGE$1 = "onreadystatechange";
var location$2;
var defer$1;
var channel$1;
var port$1;
try {
  location$2 = global$7$2.location;
} catch (error) {}
var run$1 = function (id2) {
  if (hasOwn$1$2(queue$1$1, id2)) {
    var fn = queue$1$1[id2];
    delete queue$1$1[id2];
    fn();
  }
};
var runner$1 = function (id2) {
  return function () {
    run$1(id2);
  };
};
var listener$1 = function (event) {
  run$1(event.data);
};
var post$1 = function (id2) {
  global$7$2.postMessage(
    String$1$1(id2),
    location$2.protocol + "//" + location$2.host
  );
};
if (!set$3 || !clear$1) {
  set$3 = function setImmediate2(handler) {
    validateArgumentsLength$2(arguments.length, 1);
    var fn = isCallable$3$2(handler) ? handler : Function$1$1(handler);
    var args = arraySlice$3(arguments, 1);
    queue$1$1[++counter$1] = function () {
      apply$2(fn, void 0, args);
    };
    defer$1(counter$1);
    return counter$1;
  };
  clear$1 = function clearImmediate(id2) {
    delete queue$1$1[id2];
  };
  if (IS_NODE$2$1) {
    defer$1 = function (id2) {
      process$2$1.nextTick(runner$1(id2));
    };
  } else if (Dispatch$1 && Dispatch$1.now) {
    defer$1 = function (id2) {
      Dispatch$1.now(runner$1(id2));
    };
  } else if (MessageChannel2$1 && !IS_IOS$1$1) {
    channel$1 = new MessageChannel2$1();
    port$1 = channel$1.port2;
    channel$1.port1.onmessage = listener$1;
    defer$1 = bind$3$1(port$1.postMessage, port$1);
  } else if (
    global$7$2.addEventListener &&
    isCallable$3$2(global$7$2.postMessage) &&
    !global$7$2.importScripts &&
    location$2 &&
    location$2.protocol !== "file:" &&
    !fails$1$2(post$1)
  ) {
    defer$1 = post$1;
    global$7$2.addEventListener("message", listener$1, false);
  } else if (ONREADYSTATECHANGE$1 in createElement$3("script")) {
    defer$1 = function (id2) {
      html$3.appendChild(createElement$3("script"))[ONREADYSTATECHANGE$1] =
        function () {
          html$3.removeChild(this);
          run$1(id2);
        };
    };
  } else {
    defer$1 = function (id2) {
      setTimeout(runner$1(id2), 0);
    };
  }
}
var task$1$1 = {
  set: set$3,
  clear: clear$1,
};
var userAgent$1$1 = engineUserAgent$2;
var global$6$2 = global$k;
var engineIsIosPebble$1 =
  /ipad|iphone|ipod/i.test(userAgent$1$1) && global$6$2.Pebble !== void 0;
var userAgent$6 = engineUserAgent$2;
var engineIsWebosWebkit$1 = /web0s(?!.*chrome)/i.test(userAgent$6);
var global$5$2 = global$k;
var bind$2$1 = functionBindContext$1;
var getOwnPropertyDescriptor2$2 = objectGetOwnPropertyDescriptor$2.f;
var macrotask$1 = task$1$1.set;
var IS_IOS$2 = engineIsIos$1;
var IS_IOS_PEBBLE$1 = engineIsIosPebble$1;
var IS_WEBOS_WEBKIT$1 = engineIsWebosWebkit$1;
var IS_NODE$1$1 = engineIsNode$1;
var MutationObserver$2 =
  global$5$2.MutationObserver || global$5$2.WebKitMutationObserver;
var document$2$1 = global$5$2.document;
var process$1$2 = global$5$2.process;
var Promise$1$1 = global$5$2.Promise;
var queueMicrotaskDescriptor$1 = getOwnPropertyDescriptor2$2(
  global$5$2,
  "queueMicrotask"
);
var queueMicrotask2$1 =
  queueMicrotaskDescriptor$1 && queueMicrotaskDescriptor$1.value;
var flush$1;
var head$1;
var last$1;
var notify$1$1;
var toggle$1;
var node$1;
var promise$1;
var then$1;
if (!queueMicrotask2$1) {
  flush$1 = function () {
    var parent, fn;
    if (IS_NODE$1$1 && (parent = process$1$2.domain)) parent.exit();
    while (head$1) {
      fn = head$1.fn;
      head$1 = head$1.next;
      try {
        fn();
      } catch (error) {
        if (head$1) notify$1$1();
        else last$1 = void 0;
        throw error;
      }
    }
    last$1 = void 0;
    if (parent) parent.enter();
  };
  if (
    !IS_IOS$2 &&
    !IS_NODE$1$1 &&
    !IS_WEBOS_WEBKIT$1 &&
    MutationObserver$2 &&
    document$2$1
  ) {
    toggle$1 = true;
    node$1 = document$2$1.createTextNode("");
    new MutationObserver$2(flush$1).observe(node$1, { characterData: true });
    notify$1$1 = function () {
      node$1.data = toggle$1 = !toggle$1;
    };
  } else if (!IS_IOS_PEBBLE$1 && Promise$1$1 && Promise$1$1.resolve) {
    promise$1 = Promise$1$1.resolve(void 0);
    promise$1.constructor = Promise$1$1;
    then$1 = bind$2$1(promise$1.then, promise$1);
    notify$1$1 = function () {
      then$1(flush$1);
    };
  } else if (IS_NODE$1$1) {
    notify$1$1 = function () {
      process$1$2.nextTick(flush$1);
    };
  } else {
    macrotask$1 = bind$2$1(macrotask$1, global$5$2);
    notify$1$1 = function () {
      macrotask$1(flush$1);
    };
  }
}
var microtask$1$1 =
  queueMicrotask2$1 ||
  function (fn) {
    var task2 = { fn, next: void 0 };
    if (last$1) last$1.next = task2;
    if (!head$1) {
      head$1 = task2;
      notify$1$1();
    }
    last$1 = task2;
  };
var global$4$2 = global$k;
var hostReportErrors$1$1 = function (a, b) {
  var console2 = global$4$2.console;
  if (console2 && console2.error) {
    arguments.length == 1 ? console2.error(a) : console2.error(a, b);
  }
};
var perform$3$1 = function (exec2) {
  try {
    return { error: false, value: exec2() };
  } catch (error) {
    return { error: true, value: error };
  }
};
var Queue$1$1 = function () {
  this.head = null;
  this.tail = null;
};
Queue$1$1.prototype = {
  add: function (item) {
    var entry = { item, next: null };
    if (this.head) this.tail.next = entry;
    else this.head = entry;
    this.tail = entry;
  },
  get: function () {
    var entry = this.head;
    if (entry) {
      this.head = entry.next;
      if (this.tail === entry) this.tail = null;
      return entry.item;
    }
  },
};
var queue$2 = Queue$1$1;
var global$3$2 = global$k;
var promiseNativeConstructor$1 = global$3$2.Promise;
var engineIsBrowser$1 = typeof window == "object" && typeof Deno != "object";
var global$2$2 = global$k;
var NativePromiseConstructor$3$1 = promiseNativeConstructor$1;
var isCallable$2$2 = isCallable$l$1;
var isForced$4 = isForced_1$2;
var inspectSource$6 = inspectSource$4$1;
var wellKnownSymbol$3$1 = wellKnownSymbol$g;
var IS_BROWSER$1 = engineIsBrowser$1;
var V8_VERSION$3 = engineV8Version$2;
NativePromiseConstructor$3$1 && NativePromiseConstructor$3$1.prototype;
var SPECIES$3 = wellKnownSymbol$3$1("species");
var SUBCLASSING$1 = false;
var NATIVE_PROMISE_REJECTION_EVENT$1$1 = isCallable$2$2(
  global$2$2.PromiseRejectionEvent
);
var FORCED_PROMISE_CONSTRUCTOR$5$1 = isForced$4("Promise", function () {
  var PROMISE_CONSTRUCTOR_SOURCE = inspectSource$6(
    NativePromiseConstructor$3$1
  );
  var GLOBAL_CORE_JS_PROMISE =
    PROMISE_CONSTRUCTOR_SOURCE !== String(NativePromiseConstructor$3$1);
  if (!GLOBAL_CORE_JS_PROMISE && V8_VERSION$3 === 66) return true;
  if (V8_VERSION$3 >= 51 && /native code/.test(PROMISE_CONSTRUCTOR_SOURCE))
    return false;
  var promise2 = new NativePromiseConstructor$3$1(function (resolve2) {
    resolve2(1);
  });
  var FakePromise = function (exec2) {
    exec2(
      function () {},
      function () {}
    );
  };
  var constructor = (promise2.constructor = {});
  constructor[SPECIES$3] = FakePromise;
  SUBCLASSING$1 = promise2.then(function () {}) instanceof FakePromise;
  if (!SUBCLASSING$1) return true;
  return (
    !GLOBAL_CORE_JS_PROMISE &&
    IS_BROWSER$1 &&
    !NATIVE_PROMISE_REJECTION_EVENT$1$1
  );
});
var promiseConstructorDetection$1 = {
  CONSTRUCTOR: FORCED_PROMISE_CONSTRUCTOR$5$1,
  REJECTION_EVENT: NATIVE_PROMISE_REJECTION_EVENT$1$1,
  SUBCLASSING: SUBCLASSING$1,
};
var newPromiseCapability$2$1 = {};
var aCallable$4$1 = aCallable$9;
var PromiseCapability$1 = function (C) {
  var resolve2, reject2;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve2 !== void 0 || reject2 !== void 0)
      throw TypeError("Bad Promise constructor");
    resolve2 = $$resolve;
    reject2 = $$reject;
  });
  this.resolve = aCallable$4$1(resolve2);
  this.reject = aCallable$4$1(reject2);
};
newPromiseCapability$2$1.f = function (C) {
  return new PromiseCapability$1(C);
};
var $$5$1 = _export$2;
var IS_NODE$4 = engineIsNode$1;
var global$1$2 = global$k;
var call$7$1 = functionCall$2;
var defineBuiltIn$2$1 = defineBuiltIn$6$1;
var setPrototypeOf$2 = objectSetPrototypeOf$1;
var setToStringTag$4 = setToStringTag$3$1;
var setSpecies$2 = setSpecies$1$1;
var aCallable$3$1 = aCallable$9;
var isCallable$1$2 = isCallable$l$1;
var isObject$1$2 = isObject$8$1;
var anInstance$2 = anInstance$1$1;
var speciesConstructor$2 = speciesConstructor$1$1;
var task$2 = task$1$1.set;
var microtask$2 = microtask$1$1;
var hostReportErrors$2 = hostReportErrors$1$1;
var perform$2$1 = perform$3$1;
var Queue$2 = queue$2;
var InternalStateModule$4 = internalState$2;
var NativePromiseConstructor$2$1 = promiseNativeConstructor$1;
var PromiseConstructorDetection$1 = promiseConstructorDetection$1;
var newPromiseCapabilityModule$3$1 = newPromiseCapability$2$1;
var PROMISE$1 = "Promise";
var FORCED_PROMISE_CONSTRUCTOR$4$1 = PromiseConstructorDetection$1.CONSTRUCTOR;
var NATIVE_PROMISE_REJECTION_EVENT$2 =
  PromiseConstructorDetection$1.REJECTION_EVENT;
var NATIVE_PROMISE_SUBCLASSING$1 = PromiseConstructorDetection$1.SUBCLASSING;
var getInternalPromiseState$1 = InternalStateModule$4.getterFor(PROMISE$1);
var setInternalState$2 = InternalStateModule$4.set;
var NativePromisePrototype$1$1 =
  NativePromiseConstructor$2$1 && NativePromiseConstructor$2$1.prototype;
var PromiseConstructor$1 = NativePromiseConstructor$2$1;
var PromisePrototype$1 = NativePromisePrototype$1$1;
var TypeError$1$2 = global$1$2.TypeError;
var document$1$2 = global$1$2.document;
var process2$1 = global$1$2.process;
var newPromiseCapability$1$1 = newPromiseCapabilityModule$3$1.f;
var newGenericPromiseCapability$1 = newPromiseCapability$1$1;
var DISPATCH_EVENT$1 = !!(
  document$1$2 &&
  document$1$2.createEvent &&
  global$1$2.dispatchEvent
);
var UNHANDLED_REJECTION$1 = "unhandledrejection";
var REJECTION_HANDLED$1 = "rejectionhandled";
var PENDING$1 = 0;
var FULFILLED$1 = 1;
var REJECTED$1 = 2;
var HANDLED$1 = 1;
var UNHANDLED$1 = 2;
var Internal$1;
var OwnPromiseCapability$1;
var PromiseWrapper$1;
var nativeThen$1;
var isThenable$1 = function (it) {
  var then2;
  return isObject$1$2(it) && isCallable$1$2((then2 = it.then)) ? then2 : false;
};
var callReaction$1 = function (reaction, state) {
  var value = state.value;
  var ok = state.state == FULFILLED$1;
  var handler = ok ? reaction.ok : reaction.fail;
  var resolve2 = reaction.resolve;
  var reject2 = reaction.reject;
  var domain = reaction.domain;
  var result, then2, exited;
  try {
    if (handler) {
      if (!ok) {
        if (state.rejection === UNHANDLED$1) onHandleUnhandled$1(state);
        state.rejection = HANDLED$1;
      }
      if (handler === true) result = value;
      else {
        if (domain) domain.enter();
        result = handler(value);
        if (domain) {
          domain.exit();
          exited = true;
        }
      }
      if (result === reaction.promise) {
        reject2(TypeError$1$2("Promise-chain cycle"));
      } else if ((then2 = isThenable$1(result))) {
        call$7$1(then2, result, resolve2, reject2);
      } else resolve2(result);
    } else reject2(value);
  } catch (error) {
    if (domain && !exited) domain.exit();
    reject2(error);
  }
};
var notify$2 = function (state, isReject) {
  if (state.notified) return;
  state.notified = true;
  microtask$2(function () {
    var reactions = state.reactions;
    var reaction;
    while ((reaction = reactions.get())) {
      callReaction$1(reaction, state);
    }
    state.notified = false;
    if (isReject && !state.rejection) onUnhandled$1(state);
  });
};
var dispatchEvent$1 = function (name, promise2, reason) {
  var event, handler;
  if (DISPATCH_EVENT$1) {
    event = document$1$2.createEvent("Event");
    event.promise = promise2;
    event.reason = reason;
    event.initEvent(name, false, true);
    global$1$2.dispatchEvent(event);
  } else event = { promise: promise2, reason };
  if (!NATIVE_PROMISE_REJECTION_EVENT$2 && (handler = global$1$2["on" + name]))
    handler(event);
  else if (name === UNHANDLED_REJECTION$1)
    hostReportErrors$2("Unhandled promise rejection", reason);
};
var onUnhandled$1 = function (state) {
  call$7$1(task$2, global$1$2, function () {
    var promise2 = state.facade;
    var value = state.value;
    var IS_UNHANDLED = isUnhandled$1(state);
    var result;
    if (IS_UNHANDLED) {
      result = perform$2$1(function () {
        if (IS_NODE$4) {
          process2$1.emit("unhandledRejection", value, promise2);
        } else dispatchEvent$1(UNHANDLED_REJECTION$1, promise2, value);
      });
      state.rejection =
        IS_NODE$4 || isUnhandled$1(state) ? UNHANDLED$1 : HANDLED$1;
      if (result.error) throw result.value;
    }
  });
};
var isUnhandled$1 = function (state) {
  return state.rejection !== HANDLED$1 && !state.parent;
};
var onHandleUnhandled$1 = function (state) {
  call$7$1(task$2, global$1$2, function () {
    var promise2 = state.facade;
    if (IS_NODE$4) {
      process2$1.emit("rejectionHandled", promise2);
    } else dispatchEvent$1(REJECTION_HANDLED$1, promise2, state.value);
  });
};
var bind$1$1 = function (fn, state, unwrap) {
  return function (value) {
    fn(state, value, unwrap);
  };
};
var internalReject$1 = function (state, value, unwrap) {
  if (state.done) return;
  state.done = true;
  if (unwrap) state = unwrap;
  state.value = value;
  state.state = REJECTED$1;
  notify$2(state, true);
};
var internalResolve$1 = function (state, value, unwrap) {
  if (state.done) return;
  state.done = true;
  if (unwrap) state = unwrap;
  try {
    if (state.facade === value)
      throw TypeError$1$2("Promise can't be resolved itself");
    var then2 = isThenable$1(value);
    if (then2) {
      microtask$2(function () {
        var wrapper = { done: false };
        try {
          call$7$1(
            then2,
            value,
            bind$1$1(internalResolve$1, wrapper, state),
            bind$1$1(internalReject$1, wrapper, state)
          );
        } catch (error) {
          internalReject$1(wrapper, error, state);
        }
      });
    } else {
      state.value = value;
      state.state = FULFILLED$1;
      notify$2(state, false);
    }
  } catch (error) {
    internalReject$1({ done: false }, error, state);
  }
};
if (FORCED_PROMISE_CONSTRUCTOR$4$1) {
  PromiseConstructor$1 = function Promise2(executor) {
    anInstance$2(this, PromisePrototype$1);
    aCallable$3$1(executor);
    call$7$1(Internal$1, this);
    var state = getInternalPromiseState$1(this);
    try {
      executor(
        bind$1$1(internalResolve$1, state),
        bind$1$1(internalReject$1, state)
      );
    } catch (error) {
      internalReject$1(state, error);
    }
  };
  PromisePrototype$1 = PromiseConstructor$1.prototype;
  Internal$1 = function Promise2(executor) {
    setInternalState$2(this, {
      type: PROMISE$1,
      done: false,
      notified: false,
      parent: false,
      reactions: new Queue$2(),
      rejection: false,
      state: PENDING$1,
      value: void 0,
    });
  };
  Internal$1.prototype = defineBuiltIn$2$1(
    PromisePrototype$1,
    "then",
    function then2(onFulfilled, onRejected) {
      var state = getInternalPromiseState$1(this);
      var reaction = newPromiseCapability$1$1(
        speciesConstructor$2(this, PromiseConstructor$1)
      );
      state.parent = true;
      reaction.ok = isCallable$1$2(onFulfilled) ? onFulfilled : true;
      reaction.fail = isCallable$1$2(onRejected) && onRejected;
      reaction.domain = IS_NODE$4 ? process2$1.domain : void 0;
      if (state.state == PENDING$1) state.reactions.add(reaction);
      else
        microtask$2(function () {
          callReaction$1(reaction, state);
        });
      return reaction.promise;
    }
  );
  OwnPromiseCapability$1 = function () {
    var promise2 = new Internal$1();
    var state = getInternalPromiseState$1(promise2);
    this.promise = promise2;
    this.resolve = bind$1$1(internalResolve$1, state);
    this.reject = bind$1$1(internalReject$1, state);
  };
  newPromiseCapabilityModule$3$1.f = newPromiseCapability$1$1 = function (C) {
    return C === PromiseConstructor$1 || C === PromiseWrapper$1
      ? new OwnPromiseCapability$1(C)
      : newGenericPromiseCapability$1(C);
  };
  if (
    isCallable$1$2(NativePromiseConstructor$2$1) &&
    NativePromisePrototype$1$1 !== Object.prototype
  ) {
    nativeThen$1 = NativePromisePrototype$1$1.then;
    if (!NATIVE_PROMISE_SUBCLASSING$1) {
      defineBuiltIn$2$1(
        NativePromisePrototype$1$1,
        "then",
        function then2(onFulfilled, onRejected) {
          var that = this;
          return new PromiseConstructor$1(function (resolve2, reject2) {
            call$7$1(nativeThen$1, that, resolve2, reject2);
          }).then(onFulfilled, onRejected);
        },
        { unsafe: true }
      );
    }
    try {
      delete NativePromisePrototype$1$1.constructor;
    } catch (error) {}
    if (setPrototypeOf$2) {
      setPrototypeOf$2(NativePromisePrototype$1$1, PromisePrototype$1);
    }
  }
}
$$5$1(
  {
    global: true,
    constructor: true,
    wrap: true,
    forced: FORCED_PROMISE_CONSTRUCTOR$4$1,
  },
  {
    Promise: PromiseConstructor$1,
  }
);
setToStringTag$4(PromiseConstructor$1, PROMISE$1, false);
setSpecies$2(PROMISE$1);
var wellKnownSymbol$2$1 = wellKnownSymbol$g;
var Iterators$1$1 = iterators$1;
var ITERATOR$2$1 = wellKnownSymbol$2$1("iterator");
var ArrayPrototype$2 = Array.prototype;
var isArrayIteratorMethod$1$1 = function (it) {
  return (
    it !== void 0 &&
    (Iterators$1$1.Array === it || ArrayPrototype$2[ITERATOR$2$1] === it)
  );
};
var classof$7 = classof$5$1;
var getMethod$1$2 = getMethod$3$1;
var Iterators$5 = iterators$1;
var wellKnownSymbol$1$2 = wellKnownSymbol$g;
var ITERATOR$1$1 = wellKnownSymbol$1$2("iterator");
var getIteratorMethod$2$1 = function (it) {
  if (it != void 0)
    return (
      getMethod$1$2(it, ITERATOR$1$1) ||
      getMethod$1$2(it, "@@iterator") ||
      Iterators$5[classof$7(it)]
    );
};
var call$6$1 = functionCall$2;
var aCallable$2$1 = aCallable$9;
var anObject$5$1 = anObject$c$1;
var tryToString$1$2 = tryToString$5$1;
var getIteratorMethod$1$1 = getIteratorMethod$2$1;
var $TypeError$1$2 = TypeError;
var getIterator$1$1 = function (argument, usingIterator) {
  var iteratorMethod =
    arguments.length < 2 ? getIteratorMethod$1$1(argument) : usingIterator;
  if (aCallable$2$1(iteratorMethod))
    return anObject$5$1(call$6$1(iteratorMethod, argument));
  throw $TypeError$1$2(tryToString$1$2(argument) + " is not iterable");
};
var call$5$2 = functionCall$2;
var anObject$4$1 = anObject$c$1;
var getMethod$5 = getMethod$3$1;
var iteratorClose$1$1 = function (iterator, kind, value) {
  var innerResult, innerError;
  anObject$4$1(iterator);
  try {
    innerResult = getMethod$5(iterator, "return");
    if (!innerResult) {
      if (kind === "throw") throw value;
      return value;
    }
    innerResult = call$5$2(innerResult, iterator);
  } catch (error) {
    innerError = true;
    innerResult = error;
  }
  if (kind === "throw") throw value;
  if (innerError) throw innerResult;
  anObject$4$1(innerResult);
  return value;
};
var bind$7 = functionBindContext$1;
var call$4$2 = functionCall$2;
var anObject$3$1 = anObject$c$1;
var tryToString$6 = tryToString$5$1;
var isArrayIteratorMethod$2 = isArrayIteratorMethod$1$1;
var lengthOfArrayLike$6 = lengthOfArrayLike$5;
var isPrototypeOf$1$1 = objectIsPrototypeOf$2;
var getIterator$2 = getIterator$1$1;
var getIteratorMethod$3 = getIteratorMethod$2$1;
var iteratorClose$2 = iteratorClose$1$1;
var $TypeError$f = TypeError;
var Result$1 = function (stopped, result) {
  this.stopped = stopped;
  this.result = result;
};
var ResultPrototype$1 = Result$1.prototype;
var iterate$2$1 = function (iterable, unboundFunction, options) {
  var that = options && options.that;
  var AS_ENTRIES = !!(options && options.AS_ENTRIES);
  var IS_ITERATOR = !!(options && options.IS_ITERATOR);
  var INTERRUPTED = !!(options && options.INTERRUPTED);
  var fn = bind$7(unboundFunction, that);
  var iterator, iterFn, index, length, result, next, step;
  var stop = function (condition) {
    if (iterator) iteratorClose$2(iterator, "normal", condition);
    return new Result$1(true, condition);
  };
  var callFn = function (value) {
    if (AS_ENTRIES) {
      anObject$3$1(value);
      return INTERRUPTED
        ? fn(value[0], value[1], stop)
        : fn(value[0], value[1]);
    }
    return INTERRUPTED ? fn(value, stop) : fn(value);
  };
  if (IS_ITERATOR) {
    iterator = iterable;
  } else {
    iterFn = getIteratorMethod$3(iterable);
    if (!iterFn)
      throw $TypeError$f(tryToString$6(iterable) + " is not iterable");
    if (isArrayIteratorMethod$2(iterFn)) {
      for (
        index = 0, length = lengthOfArrayLike$6(iterable);
        length > index;
        index++
      ) {
        result = callFn(iterable[index]);
        if (result && isPrototypeOf$1$1(ResultPrototype$1, result))
          return result;
      }
      return new Result$1(false);
    }
    iterator = getIterator$2(iterable, iterFn);
  }
  next = iterator.next;
  while (!(step = call$4$2(next, iterator)).done) {
    try {
      result = callFn(step.value);
    } catch (error) {
      iteratorClose$2(iterator, "throw", error);
    }
    if (
      typeof result == "object" &&
      result &&
      isPrototypeOf$1$1(ResultPrototype$1, result)
    )
      return result;
  }
  return new Result$1(false);
};
var wellKnownSymbol$h = wellKnownSymbol$g;
var ITERATOR$6 = wellKnownSymbol$h("iterator");
var SAFE_CLOSING$1 = false;
try {
  called$1 = 0;
  iteratorWithReturn$1 = {
    next: function () {
      return { done: !!called$1++ };
    },
    return: function () {
      SAFE_CLOSING$1 = true;
    },
  };
  iteratorWithReturn$1[ITERATOR$6] = function () {
    return this;
  };
  Array.from(iteratorWithReturn$1, function () {
    throw 2;
  });
} catch (error) {}
var called$1;
var iteratorWithReturn$1;
var checkCorrectnessOfIteration$1$1 = function (exec2, SKIP_CLOSING) {
  if (!SKIP_CLOSING && !SAFE_CLOSING$1) return false;
  var ITERATION_SUPPORT = false;
  try {
    var object = {};
    object[ITERATOR$6] = function () {
      return {
        next: function () {
          return { done: (ITERATION_SUPPORT = true) };
        },
      };
    };
    exec2(object);
  } catch (error) {}
  return ITERATION_SUPPORT;
};
var NativePromiseConstructor$1$1 = promiseNativeConstructor$1;
var checkCorrectnessOfIteration$2 = checkCorrectnessOfIteration$1$1;
var FORCED_PROMISE_CONSTRUCTOR$3$1 = promiseConstructorDetection$1.CONSTRUCTOR;
var promiseStaticsIncorrectIteration$1 =
  FORCED_PROMISE_CONSTRUCTOR$3$1 ||
  !checkCorrectnessOfIteration$2(function (iterable) {
    NativePromiseConstructor$1$1.all(iterable).then(void 0, function () {});
  });
var $$4$1 = _export$2;
var call$3$2 = functionCall$2;
var aCallable$1$2 = aCallable$9;
var newPromiseCapabilityModule$2$1 = newPromiseCapability$2$1;
var perform$1$1 = perform$3$1;
var iterate$1$1 = iterate$2$1;
var PROMISE_STATICS_INCORRECT_ITERATION$1$1 =
  promiseStaticsIncorrectIteration$1;
$$4$1(
  {
    target: "Promise",
    stat: true,
    forced: PROMISE_STATICS_INCORRECT_ITERATION$1$1,
  },
  {
    all: function all(iterable) {
      var C = this;
      var capability = newPromiseCapabilityModule$2$1.f(C);
      var resolve2 = capability.resolve;
      var reject2 = capability.reject;
      var result = perform$1$1(function () {
        var $promiseResolve = aCallable$1$2(C.resolve);
        var values2 = [];
        var counter2 = 0;
        var remaining = 1;
        iterate$1$1(iterable, function (promise2) {
          var index = counter2++;
          var alreadyCalled = false;
          remaining++;
          call$3$2($promiseResolve, C, promise2).then(function (value) {
            if (alreadyCalled) return;
            alreadyCalled = true;
            values2[index] = value;
            --remaining || resolve2(values2);
          }, reject2);
        });
        --remaining || resolve2(values2);
      });
      if (result.error) reject2(result.value);
      return capability.promise;
    },
  }
);
var $$3$1 = _export$2;
var FORCED_PROMISE_CONSTRUCTOR$2$1 = promiseConstructorDetection$1.CONSTRUCTOR;
var NativePromiseConstructor$4 = promiseNativeConstructor$1;
var getBuiltIn$1$2 = getBuiltIn$8$1;
var isCallable$m = isCallable$l$1;
var defineBuiltIn$1$2 = defineBuiltIn$6$1;
var NativePromisePrototype$2 =
  NativePromiseConstructor$4 && NativePromiseConstructor$4.prototype;
$$3$1(
  {
    target: "Promise",
    proto: true,
    forced: FORCED_PROMISE_CONSTRUCTOR$2$1,
    real: true,
  },
  {
    catch: function (onRejected) {
      return this.then(void 0, onRejected);
    },
  }
);
if (isCallable$m(NativePromiseConstructor$4)) {
  method$1 = getBuiltIn$1$2("Promise").prototype["catch"];
  if (NativePromisePrototype$2["catch"] !== method$1) {
    defineBuiltIn$1$2(NativePromisePrototype$2, "catch", method$1, {
      unsafe: true,
    });
  }
}
var method$1;
var $$2$1 = _export$2;
var call$2$2 = functionCall$2;
var aCallable$a = aCallable$9;
var newPromiseCapabilityModule$1$1 = newPromiseCapability$2$1;
var perform$4 = perform$3$1;
var iterate$3 = iterate$2$1;
var PROMISE_STATICS_INCORRECT_ITERATION$2 = promiseStaticsIncorrectIteration$1;
$$2$1(
  {
    target: "Promise",
    stat: true,
    forced: PROMISE_STATICS_INCORRECT_ITERATION$2,
  },
  {
    race: function race(iterable) {
      var C = this;
      var capability = newPromiseCapabilityModule$1$1.f(C);
      var reject2 = capability.reject;
      var result = perform$4(function () {
        var $promiseResolve = aCallable$a(C.resolve);
        iterate$3(iterable, function (promise2) {
          call$2$2($promiseResolve, C, promise2).then(
            capability.resolve,
            reject2
          );
        });
      });
      if (result.error) reject2(result.value);
      return capability.promise;
    },
  }
);
var $$1$1 = _export$2;
var call$1$2 = functionCall$2;
var newPromiseCapabilityModule$4 = newPromiseCapability$2$1;
var FORCED_PROMISE_CONSTRUCTOR$1$1 = promiseConstructorDetection$1.CONSTRUCTOR;
$$1$1(
  { target: "Promise", stat: true, forced: FORCED_PROMISE_CONSTRUCTOR$1$1 },
  {
    reject: function reject(r) {
      var capability = newPromiseCapabilityModule$4.f(this);
      call$1$2(capability.reject, void 0, r);
      return capability.promise;
    },
  }
);
var anObject$2$2 = anObject$c$1;
var isObject$9 = isObject$8$1;
var newPromiseCapability$3 = newPromiseCapability$2$1;
var promiseResolve$1$1 = function (C, x) {
  anObject$2$2(C);
  if (isObject$9(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability$3.f(C);
  var resolve2 = promiseCapability.resolve;
  resolve2(x);
  return promiseCapability.promise;
};
var $$d = _export$2;
var getBuiltIn$a = getBuiltIn$8$1;
var FORCED_PROMISE_CONSTRUCTOR$6 = promiseConstructorDetection$1.CONSTRUCTOR;
var promiseResolve$2 = promiseResolve$1$1;
getBuiltIn$a("Promise");
$$d(
  { target: "Promise", stat: true, forced: FORCED_PROMISE_CONSTRUCTOR$6 },
  {
    resolve: function resolve(x) {
      return promiseResolve$2(this, x);
    },
  }
);
var HardwareWalletAccountsForm = ({
  accounts,
  onSelectedChanged,
  onSubmit,
  onChangeRoute,
}) => {
  return (0, import_jsx_runtime.jsxs)(
    "div",
    Object.assign(
      {
        className: "choose-ledger-account-form-wrapper",
      },
      {
        children: [
          (0, import_jsx_runtime.jsxs)("p", {
            children: [
              "We found ",
              accounts.length,
              " accounts on your device. Select the account(s) you wish to connect.",
            ],
          }),
          (0, import_jsx_runtime.jsx)(
            "div",
            Object.assign(
              {
                className: "button-wrapper",
              },
              {
                children: (0, import_jsx_runtime.jsx)(
                  "button",
                  Object.assign(
                    {
                      onClick: () => {
                        onChangeRoute("SpecifyHDPath");
                      },
                    },
                    {
                      children: "HD.../0",
                    }
                  )
                ),
              }
            )
          ),
          (0, import_jsx_runtime.jsx)(
            "form",
            Object.assign(
              {
                className: "form",
                onSubmit: (e) => {
                  onSubmit(accounts, e);
                },
              },
              {
                children: (0, import_jsx_runtime.jsxs)("div", {
                  children: [
                    (0, import_jsx_runtime.jsx)(
                      "div",
                      Object.assign(
                        {
                          className: "nws-form-control",
                        },
                        {
                          children: accounts.map((account, index) =>
                            (0, import_jsx_runtime.jsxs)(
                              "div",
                              Object.assign(
                                {
                                  className: "account",
                                },
                                {
                                  children: [
                                    (0, import_jsx_runtime.jsx)("input", {
                                      onChange: (e) => {
                                        onSelectedChanged(
                                          index,
                                          e.target.checked
                                        );
                                      },
                                      checked: account.selected,
                                      type: "checkbox",
                                      id: account.accountId,
                                      name: account.accountId,
                                      value: account.accountId,
                                    }),
                                    (0, import_jsx_runtime.jsxs)(
                                      "label",
                                      Object.assign(
                                        {
                                          htmlFor: account.accountId,
                                        },
                                        {
                                          children: [" ", account.accountId],
                                        }
                                      )
                                    ),
                                    (0, import_jsx_runtime.jsx)("br", {}),
                                  ],
                                }
                              ),
                              index
                            )
                          ),
                        }
                      )
                    ),
                    (0, import_jsx_runtime.jsx)(
                      "div",
                      Object.assign(
                        {
                          className: "action-buttons",
                        },
                        {
                          children: (0, import_jsx_runtime.jsx)(
                            "button",
                            Object.assign(
                              {
                                className: "middleButton",
                                type: "submit",
                                disabled: !accounts.some((x) => x.selected),
                              },
                              {
                                children: "Connect",
                              }
                            )
                          ),
                        }
                      )
                    ),
                  ],
                }),
              }
            )
          ),
        ],
      }
    )
  );
};
var img =
  "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAZCAYAAADE6YVjAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAR3SURBVHgBpVZ9aJVVGH+e55z33bi7zY9hMz+yMAeNoEIq6A9ZRKQWEsQNFIIpsf5Y9E+GsD9iBEEDMUkDa6ShRKKZYIWiRkaKaUGUGCKOTGMF84PNO99773vOefq9720yK5ZzD/dwPt/nd37P17lEk5Qnuz9roUkKT7T5bNe+QjTNLCHv24h1Xgh+OmtwQYPH2jUXwlnW9NRooqePfLS6MmmQ59cdeEGJlkJZA5MGVecoAwghBYZTVY9ftuaDSy8x8w9fbFl95JZAXuw9dmelkvRAyXxS7wMFryG4bIyWZiqzPgMhaFfGfn3NY3AZG9sPf/Dy8HidZvxkZc/h1pqnPlKey6yspMqUd9jVAEYY6RCGDQTwjGDwGTgAlbwRijV1C9vanz577tT+6r+YrOz5rlXFrQ/qZ+FbDxCfXS5oOgxln4v473f3rbgwdn7FK5/MCaH2eAg6X8g3K2iBMTiBkNJVKbod+ze9mgPZsY/UaicYzCE1HgpZc558olCTjTvWLxv9p1n3bV45iO7T5zq3TU9j9xTOLwQ5D9t48aEYrtGj2P/2BpNS78nZJoRdlDsYd8vphz273lqyhW5Rnlnz3hOe6SEwghvxPUMTVfYe2rpuUOqOkZeIxdSbsSJ8eTIAmXy5tftrMPkzi0C4B2ZDNHp+INvLQURkhYiJ6gDGko376DbEJ8k3mcnYBSeSM2ptL/XGsurNnxfnDIQNwCKADO1845Ef6Tbk0M51g4joMgncDyBmkrtsNEMQovcDxGYsGL2yDNAUxPv0VySs4yxhfeYbabJg0Awg+ILylEB6nKMpSOp0WCR1+QSuD4ELljNDEfyRrdXPCU1BTEgD7pyOzVmC2iBm0KgYAMCEeXovoClIjdKiVdQ3FYbzmatxWRqMPcNsDHyfNWskWk5TkJhNEwVyxA6hLL5clLJsW7voFxa6LiR5CCOeWzo3XFxKtyEdy3tnp7VahAoDp6PEVGvJye09l3P7K9k9WQijXBv4B6WG+0pvD0ybFEBHZ6OPh+/OGaBsIvNRAGp/ZHv1jJeon+omszBkFsr3FhsLB7rev3JLQKVSyfjmaW2BJSavDlqR7c5VrR+4AbLttbkXMehH7gjA8gZiD/tq+Or/ABZ3dUW/J62LcPUGcrW8pKSVFAg6cHz3O0l25qZHa/XGwWPg9aAwwzdZAaDX+7tbNsMYf5+bpaUS0dDQEF8rtsUxCbI5e5KRzGhBMiqNxllKju7d8NOYXjseRBytQngcVDL3wD9H+7vf3YS7mnnzqrZpwSxrwkh04cpM5NTMyJdHbIgaESyxJ6tZ5cDbw3qd0tqVCp25Se/4yYdr5/zm/ehjwvpxZHgN0Wlub0/Yt7awdykqRYFHy6NUQVrBd4o6p6ngrVL2Bo8ksuJqoXzq9Ln9m6rj9U74b6Wjo8OeP082aY5NUxRsYzwDkeFsU+MdUU3U4PG0QtbahqhadDMuHTy4fvS/9EwIUpdeuW/ZiShOipFxURRbNdWETFMRZrCFlEZGkuPHdycTafgLExNiI6YfUpcAAAAASUVORK5CYII=";
var WalletConnecting = ({ wallet, onCloseModal }) => {
  return (0, import_jsx_runtime.jsxs)(import_react.Fragment, {
    children: [
      (0, import_jsx_runtime.jsx)(ModalHeader, {
        title: "",
        onCloseModal,
      }),
      (0, import_jsx_runtime.jsx)(
        "div",
        Object.assign(
          {
            className: "connecting-wrapper",
          },
          {
            children: (0, import_jsx_runtime.jsxs)(
              "div",
              Object.assign(
                {
                  className: "content",
                },
                {
                  children: [
                    (0, import_jsx_runtime.jsx)(
                      "div",
                      Object.assign(
                        {
                          className: "icon",
                        },
                        {
                          children: (0, import_jsx_runtime.jsx)("img", {
                            src:
                              wallet === null || wallet === void 0
                                ? void 0
                                : wallet.metadata.iconUrl,
                            alt:
                              wallet === null || wallet === void 0
                                ? void 0
                                : wallet.metadata.name,
                          }),
                        }
                      )
                    ),
                    (0, import_jsx_runtime.jsx)(
                      "h3",
                      Object.assign(
                        {
                          className: "connecting-name",
                        },
                        {
                          children:
                            wallet === null || wallet === void 0
                              ? void 0
                              : wallet.metadata.name,
                        }
                      )
                    ),
                    (0, import_jsx_runtime.jsxs)(
                      "div",
                      Object.assign(
                        {
                          className: "connecting-details",
                        },
                        {
                          children: [
                            (0, import_jsx_runtime.jsx)(
                              "div",
                              Object.assign(
                                {
                                  className: "spinner",
                                },
                                {
                                  children: (0, import_jsx_runtime.jsx)("img", {
                                    src: img,
                                    alt: "loading-icon",
                                  }),
                                }
                              )
                            ),
                            (0, import_jsx_runtime.jsxs)("span", {
                              children: [
                                translate("modal.wallet.connectingTo"),
                                " ",
                                wallet === null || wallet === void 0
                                  ? void 0
                                  : wallet.metadata.name,
                                "...",
                              ],
                            }),
                          ],
                        }
                      )
                    ),
                    (0, import_jsx_runtime.jsx)(
                      "div",
                      Object.assign(
                        {
                          className: "connecting-message",
                        },
                        {
                          children: (0, import_jsx_runtime.jsx)("span", {
                            children: translate(
                              `modal.wallet.connectingMessage.${
                                wallet === null || wallet === void 0
                                  ? void 0
                                  : wallet.type
                              }`
                            ),
                          }),
                        }
                      )
                    ),
                  ],
                }
              )
            ),
          }
        )
      ),
    ],
  });
};
var LedgerDeviceIcon = () => {
  return (0, import_jsx_runtime.jsxs)(
    "svg",
    Object.assign(
      {
        width: "317",
        height: "157",
        viewBox: "0 0 317 157",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
      },
      {
        children: [
          (0, import_jsx_runtime.jsx)("path", {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M249.99 16.0994C270.063 -0.864155 289.788 1.58873 301.497 10.7365C307.402 15.3499 311.278 21.6575 312.267 28.1258C313.247 34.5412 311.413 41.2233 305.692 46.8044C297.366 54.9273 286.343 55.3362 273.015 51.5109C261.654 48.25 249.058 42.0377 235.726 35.4627L235.726 35.4626L235.717 35.458C233.367 34.2992 230.995 33.129 228.602 31.9618C212.742 24.2253 196.067 16.6575 179.842 13.8595C163.538 11.0479 147.552 13.0313 133.266 24.522C128.032 28.732 123.478 35.2086 121.716 44.8205C119.961 54.3947 120.992 66.9771 126.703 83.4311C135.432 108.583 132.899 126.677 123.575 138.063C114.217 149.491 97.5614 154.733 76.7887 153.121C55.0043 151.43 29.0621 142.206 3.29867 125.227L0.887817 127.942C27.2472 145.405 53.9251 154.952 76.5105 156.705C97.9028 158.365 115.96 153.035 126.356 140.341C136.785 127.606 139.045 108.029 130.099 82.2524C124.521 66.1801 123.642 54.2493 125.252 45.4687C126.854 36.7258 130.94 31.006 135.519 27.3232C148.794 16.6458 163.649 14.715 179.231 17.4021C194.891 20.1027 211.146 27.4463 227.026 35.1928C229.381 36.3415 231.729 37.5001 234.066 38.6531L234.073 38.6568C247.382 45.223 260.324 51.608 272.024 54.9662C285.819 58.9258 298.493 58.8501 308.202 49.3776C314.764 42.9759 316.974 35.1288 315.82 27.5826C314.675 20.0893 310.237 13.0029 303.71 7.90363C290.555 -2.37382 268.938 -4.62038 247.67 13.3537L249.99 16.0994Z",
            fill: "url(#paint0_linear_3_672)",
          }),
          (0, import_jsx_runtime.jsx)("path", {
            d: "M260.264 17.8767L177.605 89.4649L157.679 73.9664L239.23 3.85423L260.264 17.8767Z",
            fill: "#6A7075",
          }),
          (0, import_jsx_runtime.jsx)("path", {
            d: "M205.939 54.4577L199.764 50.2636L233.316 20.9053L239.907 25.8395L205.939 54.4577Z",
            fill: "#494E52",
          }),
          (0, import_jsx_runtime.jsx)("path", {
            d: "M260.264 17.8757L177.605 89.4639L182.033 98.3202L264.323 26.363L260.264 17.8757Z",
            fill: "#494E52",
          }),
          (0, import_jsx_runtime.jsx)("path", {
            d: "M177.236 89.4646L181.295 98.3209L165.059 85.7745L170.963 85.0365L177.236 89.4646Z",
            fill: "black",
          }),
          (0, import_jsx_runtime.jsx)("path", {
            d: "M93.4708 99.6384L91.9948 110.13L174.653 92.894L164.69 85.7749L93.4708 99.6384Z",
            fill: "#DCDADA",
          }),
          (0, import_jsx_runtime.jsx)("path", {
            d: "M93.1157 104.323L94.314 100.129L165.613 86.3483L169.208 89.344L93.1157 104.323Z",
            fill: "#C1C1C1",
          }),
          (0, import_jsx_runtime.jsx)("path", {
            d: "M94.2086 99.7963L86.0903 101.272L92.3635 110.129L94.2086 99.7963Z",
            fill: "#B3AAAA",
          }),
          (0, import_jsx_runtime.jsx)("path", {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M86.0903 100.907L89.0027 74.1304L178.455 55.2416C184.695 53.9962 195.766 54.7675 197.177 63.7058C198.284 70.717 195.506 73.9943 191.628 77.3592C188.495 80.0671 180.152 82.4646 178.343 82.8944C178.293 82.9064 178.241 82.9188 178.186 82.9319C177.38 83.1245 176.007 83.4525 170.644 84.5088C169.085 84.8158 167.382 85.1501 165.557 85.5078L164.933 85.63C146.312 89.2764 115.528 95.2297 93.9844 99.3849C91.1808 99.9257 88.5337 100.436 86.0903 100.907ZM185.076 75.554C190.748 73.3535 193.99 68.0745 192.318 63.7631C190.645 59.4517 184.691 57.7405 179.019 59.941C173.347 62.1416 170.105 67.4206 171.778 71.732C173.45 76.0434 179.404 77.7546 185.076 75.554Z",
            fill: "#F4F1E8",
          }),
          (0, import_jsx_runtime.jsx)("path", {
            d: "M199.764 50.3994L196.768 48.3043L232.194 18.0454L233.316 21.6403L199.764 50.3994Z",
            fill: "black",
          }),
          (0, import_jsx_runtime.jsx)("path", {
            d: "M239.968 25.9943L232.588 20.4592V17.5071L241.813 24.5183L239.968 25.9943Z",
            fill: "black",
          }),
          (0, import_jsx_runtime.jsx)("ellipse", {
            cx: "182.084",
            cy: "68.0811",
            rx: "10.242",
            ry: "7.46772",
            transform: "rotate(-23.7949 182.084 68.0811)",
            fill: "#494E52",
          }),
          (0, import_jsx_runtime.jsx)("ellipse", {
            cx: "182.084",
            cy: "68.0816",
            rx: "6.68462",
            ry: "4.87394",
            transform: "rotate(-23.7949 182.084 68.0816)",
            fill: "#494E52",
          }),
          (0, import_jsx_runtime.jsx)("path", {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M238.725 2.93094L260.368 17.2564L264.865 26.4556L181.615 99.0341L175.16 94.311L92.0028 110.947L85.3267 101.399L88.3269 73.8157L178.118 54.8553L238.725 2.93094ZM178.599 56.2622L89.6786 75.0388L86.9321 100.29C89.0979 99.8725 91.4124 99.4263 93.8446 98.9572C115.388 94.8019 146.171 88.8488 164.791 85.2026L165.415 85.0804C167.24 84.7228 168.943 84.3885 170.501 84.0816C175.853 83.0275 177.219 82.701 178.015 82.5107C178.07 82.4976 178.122 82.4852 178.173 82.4732C179.048 82.2652 181.558 81.5669 184.235 80.5851C186.742 79.6655 189.286 78.5354 190.802 77.3758L191.151 77.0922L191.644 76.6595C193.341 75.147 194.723 73.6739 195.61 71.871C196.571 69.916 196.982 67.5029 196.448 64.1178C195.8 60.0131 192.959 57.7574 189.408 56.6566C185.833 55.5483 181.637 55.6566 178.603 56.2615C178.601 56.2617 178.6 56.262 178.599 56.2622ZM192.631 77.7565L259.555 18.9531L263.042 26.0869L181.808 96.9078L178.132 89.5713L191.724 78.529C191.859 78.4249 191.988 78.32 192.11 78.2144L192.111 78.2136C192.286 78.0617 192.46 77.9094 192.631 77.7565ZM185.491 81.6908C185.24 81.7868 184.99 81.8802 184.743 81.9709C182.013 82.9723 179.447 83.6875 178.514 83.9093C178.463 83.9213 178.411 83.9338 178.356 83.9468C177.635 84.1192 176.472 84.3971 172.491 85.1919L177.172 88.4492L185.491 81.6908ZM176.631 89.8707L170.479 85.5903C169.306 85.8213 168.054 86.0673 166.731 86.3265L175.769 92.9276L179.548 95.6924L176.631 89.8707ZM164.758 86.7132C146.252 90.3362 116.027 96.1817 94.6324 100.308L93.2258 109.197L173.543 93.1293L164.758 86.7132ZM91.888 108.207L93.0909 100.606C91.0848 100.993 89.1642 101.363 87.3471 101.713L91.888 108.207ZM258.581 17.8436L197.306 71.6841C198.142 69.5779 198.41 67.0795 197.906 63.8876C197.143 59.0539 193.743 56.4549 189.845 55.2467C186.921 54.3402 183.662 54.1916 180.861 54.449L238.84 4.77668L258.581 17.8436ZM232.505 16.82L243.089 24.5643L205.915 56.5106L196.042 48.0665L232.505 16.82ZM232.118 19.096L198.312 48.0654L199.744 49.29L232.584 20.9424L232.118 19.096ZM233.456 22.1396L200.878 50.2604L205.913 54.5664L239.041 26.0969L233.456 22.1396ZM240.195 25.1054L240.717 24.6571L233.759 19.5663L234.06 20.7586L240.195 25.1054Z",
            fill: "black",
          }),
          (0, import_jsx_runtime.jsx)("path", {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M190.194 69.9744C191.32 68.1409 191.576 66.2271 190.942 64.5937C190.308 62.9603 188.829 61.7198 186.761 61.1254C184.691 60.5307 182.116 60.6196 179.553 61.6139C176.991 62.6081 175.029 64.2794 173.902 66.1141C172.776 67.9477 172.52 69.8614 173.154 71.4948C173.788 73.1282 175.267 74.3687 177.335 74.9631C179.405 75.5578 181.98 75.4689 184.543 74.4746C187.105 73.4804 189.067 71.8091 190.194 69.9744ZM185.077 75.8508C190.749 73.6502 193.991 68.3712 192.318 64.0598C190.645 59.7484 184.691 58.0372 179.019 60.2378C173.347 62.4383 170.105 67.7173 171.778 72.0287C173.451 76.3401 179.405 78.0513 185.077 75.8508Z",
            fill: "black",
          }),
          (0, import_jsx_runtime.jsx)("path", {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M187.391 69.169C188.127 67.9713 188.266 66.7721 187.881 65.7812C187.497 64.7903 186.586 63.9984 185.235 63.6102C183.883 63.2216 182.173 63.2741 180.456 63.9404C178.738 64.6068 177.441 65.7208 176.705 66.9196C175.969 68.1172 175.83 69.3165 176.215 70.3074C176.599 71.2983 177.511 72.0901 178.861 72.4783C180.214 72.8669 181.923 72.8144 183.64 72.1481C185.358 71.4818 186.655 70.3678 187.391 69.169ZM184.174 73.5242C188.156 71.9795 190.432 68.2738 189.257 65.2473C188.083 62.2208 183.904 61.0196 179.922 62.5643C175.94 64.1091 173.665 67.8148 174.839 70.8412C176.013 73.8677 180.193 75.0689 184.174 73.5242Z",
            fill: "black",
          }),
          (0, import_jsx_runtime.jsx)("path", {
            d: "M240.499 41.2441C239.744 40.3649 239.844 39.04 240.724 38.285L249.781 30.5067C250.66 29.7516 251.985 29.8523 252.74 30.7315V30.7315C253.495 31.6108 253.395 32.9356 252.516 33.6907L243.458 41.469C242.579 42.224 241.254 42.1234 240.499 41.2441V41.2441Z",
            fill: "black",
          }),
          (0, import_jsx_runtime.jsx)("path", {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M250.743 31.6265L241.685 39.4048C241.424 39.6287 241.395 40.0217 241.619 40.2825C241.842 40.5433 242.235 40.5731 242.496 40.3492L251.554 32.5709C251.815 32.3469 251.845 31.954 251.621 31.6932C251.397 31.4324 251.004 31.4025 250.743 31.6265ZM240.724 38.285C239.844 39.04 239.744 40.3649 240.499 41.2441C241.254 42.1234 242.579 42.224 243.458 41.469L252.516 33.6907C253.395 32.9356 253.495 31.6108 252.74 30.7315C251.985 29.8523 250.66 29.7516 249.781 30.5067L240.724 38.285Z",
            fill: "black",
          }),
          (0, import_jsx_runtime.jsx)("path", {
            d: "M205.779 71.4647C205.005 70.5642 205.108 69.2073 206.009 68.4339L214.989 60.7218C215.89 59.9485 217.247 60.0516 218.02 60.9521V60.9521C218.793 61.8526 218.69 63.2095 217.79 63.9829L208.809 71.695C207.909 72.4683 206.552 72.3652 205.779 71.4647V71.4647Z",
            fill: "black",
          }),
          (0, import_jsx_runtime.jsx)("path", {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M215.951 61.8416L206.97 69.5537C206.688 69.796 206.656 70.221 206.898 70.5031C207.141 70.7851 207.566 70.8174 207.848 70.5752L216.828 62.863C217.11 62.6208 217.143 62.1958 216.9 61.9137C216.658 61.6317 216.233 61.5994 215.951 61.8416ZM206.009 68.4339C205.108 69.2073 205.005 70.5642 205.779 71.4647C206.552 72.3652 207.909 72.4683 208.809 71.695L217.79 63.9829C218.69 63.2095 218.793 61.8526 218.02 60.9521C217.247 60.0516 215.89 59.9485 214.989 60.7218L206.009 68.4339Z",
            fill: "black",
          }),
          (0, import_jsx_runtime.jsx)("circle", {
            cx: "141.356",
            cy: "19.525",
            r: "10.1855",
            fill: "#FE89B4",
          }),
          (0, import_jsx_runtime.jsx)("ellipse", {
            cx: "139.062",
            cy: "14.7094",
            rx: "2.42519",
            ry: "1.94015",
            transform: "rotate(-34.544 139.062 14.7094)",
            fill: "#FDF7FF",
          }),
          (0, import_jsx_runtime.jsx)("circle", {
            cx: "252.489",
            cy: "79.7577",
            r: "7.78893",
            fill: "#EC5236",
          }),
          (0, import_jsx_runtime.jsx)("ellipse", {
            cx: "250.434",
            cy: "76.3701",
            rx: "2.61272",
            ry: "2.09018",
            transform: "rotate(-34.544 250.434 76.3701)",
            fill: "#EDB69D",
          }),
          (0, import_jsx_runtime.jsx)("path", {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M100.436 79.9254C100.461 79.6567 100.732 79.3897 101.042 79.329L106.657 78.2299C107.587 78.0478 108.281 78.5536 108.207 79.3596L107.759 84.2243C107.734 84.493 107.463 84.76 107.153 84.8207L100.416 86.1396C100.106 86.2003 99.8742 86.0317 99.899 85.7631L100.436 79.9254Z",
            fill: "#B3AAAA",
          }),
          (0, import_jsx_runtime.jsx)("path", {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M95.8553 81.7775C95.9294 80.9715 96.7437 80.1704 97.6739 79.9883L98.7968 79.7685C99.1069 79.7078 99.3382 79.8764 99.3135 80.1451L99.1344 82.091C99.1096 82.3597 98.8382 82.6267 98.5282 82.6874L96.2824 83.127C95.9723 83.1877 95.741 83.0191 95.7657 82.7505L95.8553 81.7775Z",
            fill: "#B3AAAA",
          }),
          (0, import_jsx_runtime.jsx)("path", {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M95.5865 84.6965C95.6112 84.4278 95.8826 84.1608 96.1927 84.1001L98.4385 83.6605C98.7486 83.5998 98.9799 83.7684 98.9552 84.037L98.7761 85.9829C98.7513 86.2516 98.4799 86.5186 98.1699 86.5793L95.9241 87.019C95.614 87.0797 95.3827 86.9111 95.4074 86.6424L95.5865 84.6965Z",
            fill: "#B3AAAA",
          }),
          (0, import_jsx_runtime.jsx)("path", {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M95.2282 88.5884C95.2529 88.3197 95.5244 88.0527 95.8344 87.992L98.0802 87.5524C98.3903 87.4917 98.6216 87.6603 98.5969 87.929L98.4178 89.8749C98.3931 90.1435 98.1216 90.4105 97.8116 90.4712L96.6887 90.6911C95.7584 90.8732 95.0645 90.3674 95.1387 89.5614L95.2282 88.5884Z",
            fill: "#B3AAAA",
          }),
          (0, import_jsx_runtime.jsx)("path", {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M99.7197 87.709C99.7444 87.4403 100.016 87.1733 100.326 87.1126L102.572 86.673C102.882 86.6123 103.113 86.7809 103.088 87.0496L102.909 88.9955C102.885 89.2641 102.613 89.5312 102.303 89.5919L100.057 90.0315C99.7472 90.0922 99.5159 89.9236 99.5406 89.6549L99.7197 87.709Z",
            fill: "#B3AAAA",
          }),
          (0, import_jsx_runtime.jsx)("path", {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M104.211 86.8298C104.236 86.5611 104.507 86.2941 104.817 86.2334L107.063 85.7938C107.373 85.7331 107.605 85.9017 107.58 86.1704L107.49 87.1433C107.416 87.9493 106.602 88.7504 105.672 88.9325L104.549 89.1523C104.239 89.213 104.007 89.0444 104.032 88.7757L104.211 86.8298Z",
            fill: "#B3AAAA",
          }),
          (0, import_jsx_runtime.jsx)("defs", {
            children: (0, import_jsx_runtime.jsxs)(
              "linearGradient",
              Object.assign(
                {
                  id: "paint0_linear_3_672",
                  x1: "-44.5195",
                  y1: "122.42",
                  x2: "263.357",
                  y2: "-8.65023",
                  gradientUnits: "userSpaceOnUse",
                },
                {
                  children: [
                    (0, import_jsx_runtime.jsx)("stop", {
                      offset: "0.110697",
                      stopColor: "#232323",
                    }),
                    (0, import_jsx_runtime.jsx)("stop", {
                      offset: "1",
                      stopColor: "#3D3D3D",
                    }),
                  ],
                }
              )
            ),
          }),
        ],
      }
    )
  );
};
var UpArrowIcon = () => {
  return (0, import_jsx_runtime.jsx)(
    "svg",
    Object.assign(
      {
        width: "10",
        height: "7",
        viewBox: "0 0 10 7",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
      },
      {
        children: (0, import_jsx_runtime.jsx)("path", {
          d: "M9 5.4762L5 1.4762L1 5.4762",
          stroke: "#4F7CD1",
          strokeWidth: "1.5",
          strokeLinecap: "round",
          strokeLinejoin: "round",
        }),
      }
    )
  );
};
var DownArrowIcon = () => {
  return (0, import_jsx_runtime.jsx)(
    "svg",
    Object.assign(
      {
        width: "10",
        height: "7",
        viewBox: "0 0 10 7",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
      },
      {
        children: (0, import_jsx_runtime.jsx)("path", {
          d: "M1 1.52382L5 5.52382L9 1.52382",
          stroke: "#4F7CD1",
          strokeWidth: "1.5",
          strokeLinecap: "round",
          strokeLinejoin: "round",
        }),
      }
    )
  );
};
var DEFAULT_DERIVATION_PATH = "44'/397'/0'/0'/1'";
var DerivationPath = ({
  selector,
  options,
  onBack,
  onConnected,
  params,
  onError,
  onCloseModal,
}) => {
  const [route, setRoute] = (0, import_react.useState)("EnterDerivationPath");
  const [derivationPath, setDerivationPath] = (0, import_react.useState)(
    DEFAULT_DERIVATION_PATH
  );
  const [customDerivationPath, setCustomDerivationPath] = (0,
  import_react.useState)(1);
  const [accounts, setAccounts] = (0, import_react.useState)([]);
  const [selectedAccounts, setSelectedAccounts] = (0, import_react.useState)(
    []
  );
  const [hardwareWallet, setHardwareWallet] = (0, import_react.useState)();
  const [customAccountId, setCustomAccountId] = (0, import_react.useState)("");
  const [connecting, setConnecting] = (0, import_react.useState)(false);
  const initalHeaderTitle = translate("modal.ledger.connectWithLedger");
  const [headerTitle, setHeaderTitle] = (0, import_react.useState)(
    initalHeaderTitle
  );
  const getAccountIds = (publicKey) =>
    __awaiter$2(void 0, void 0, void 0, function* () {
      const response = yield fetch(
        `${selector.options.network.indexerUrl}/publicKey/ed25519:${publicKey}/accounts`
      );
      if (!response.ok) {
        throw new Error("Failed to get account id from public key");
      }
      const accountIds = yield response.json();
      if (!Array.isArray(accountIds) || !accountIds.length) {
        return [];
      }
      return accountIds;
    });
  const resolveAccounts = (wallet) =>
    __awaiter$2(void 0, void 0, void 0, function* () {
      const publicKey = yield wallet.getPublicKey(derivationPath);
      try {
        const accountIds = yield getAccountIds(publicKey);
        return accountIds.map((accountId, index) => {
          return {
            derivationPath,
            publicKey,
            accountId,
            selected: index === 0,
          };
        });
      } catch (e) {
        return null;
      }
    });
  const handleValidateAccount = () =>
    __awaiter$2(void 0, void 0, void 0, function* () {
      const wallet = yield selector.wallet(params.walletId);
      if (wallet.type !== "hardware") {
        return;
      }
      setConnecting(true);
      setHardwareWallet(wallet);
      try {
        const resolvedAccounts = yield resolveAccounts(wallet);
        if (!resolvedAccounts) {
          setRoute("AddCustomAccountId");
          return;
        }
        const noAccounts = resolvedAccounts.length === 0;
        const multipleAccounts = resolvedAccounts.length > 1;
        if (noAccounts) {
          setHeaderTitle(translate("modal.ledger.noAccountsFound"));
          setRoute("NoAccountsFound");
          return;
        }
        setAccounts(resolvedAccounts);
        if (!multipleAccounts) {
          setSelectedAccounts(resolvedAccounts);
          setRoute("OverviewAccounts");
        } else {
          setHeaderTitle(translate("modal.ledger.selectYourAccounts"));
          setRoute("ChooseAccount");
        }
      } catch (err) {
        setConnecting(false);
        const message =
          err instanceof Error ? err.message : "Something went wrong";
        onError(message, wallet);
      } finally {
        setConnecting(false);
      }
    });
  const handleAddCustomAccountId = () =>
    __awaiter$2(void 0, void 0, void 0, function* () {
      try {
        setConnecting(true);
        const publicKey = yield hardwareWallet.getPublicKey(derivationPath);
        const accountList = [
          {
            derivationPath,
            publicKey,
            accountId: customAccountId,
            selected: true,
          },
        ];
        setAccounts(accountList);
        setSelectedAccounts(accountList);
        setHeaderTitle(translate("modal.ledger.connecting1Account"));
        setRoute("OverviewAccounts");
      } catch (err) {
        setConnecting(false);
        const message =
          err instanceof Error ? err.message : "Something went wrong";
        onError(message, hardwareWallet);
      } finally {
        setConnecting(false);
      }
    });
  const handleSignIn = () => {
    const mapAccounts = selectedAccounts.map((account) => {
      return {
        derivationPath: account.derivationPath,
        publicKey: account.publicKey,
        accountId: account.accountId,
      };
    });
    return hardwareWallet
      .signIn({
        contractId: options.contractId,
        methodNames: options.methodNames,
        accounts: mapAccounts,
      })
      .then(() => onConnected())
      .catch((err) => {
        onError(`Error: ${err.message}`, hardwareWallet);
      });
  };
  const handleOnBackButtonClick = () => {
    if (
      route === "SpecifyHDPath" ||
      route === "NoAccountsFound" ||
      route === "ChooseAccount"
    ) {
      setHeaderTitle(translate("modal.ledger.connectWithLedger"));
      setRoute("EnterDerivationPath");
    }
    if (route === "OverviewAccounts") {
      setHeaderTitle(translate("modal.ledger.selectYourAccounts"));
      setRoute("ChooseAccount");
    }
  };
  if (connecting) {
    return (0, import_jsx_runtime.jsx)(
      "div",
      Object.assign(
        {
          className: "derivation-path-wrapper",
        },
        {
          children: (0, import_jsx_runtime.jsx)(WalletConnecting, {
            wallet: hardwareWallet,
            onBack: () => {
              setConnecting(false);
            },
            onCloseModal,
          }),
        }
      )
    );
  }
  return (0, import_jsx_runtime.jsxs)(import_react.Fragment, {
    children: [
      (0, import_jsx_runtime.jsxs)(
        "div",
        Object.assign(
          {
            className: "nws-modal-header-wrapper",
          },
          {
            children: [
              (route === "SpecifyHDPath" ||
                route === "NoAccountsFound" ||
                route === "ChooseAccount" ||
                route === "OverviewAccounts") &&
                (0, import_jsx_runtime.jsx)(BackArrow, {
                  onClick: handleOnBackButtonClick,
                }),
              (0, import_jsx_runtime.jsx)(ModalHeader, {
                title: headerTitle,
                onCloseModal,
              }),
            ],
          }
        )
      ),
      (0, import_jsx_runtime.jsxs)(
        "div",
        Object.assign(
          {
            className: "derivation-path-wrapper",
          },
          {
            children: [
              route === "EnterDerivationPath" &&
                (0, import_jsx_runtime.jsxs)(
                  "div",
                  Object.assign(
                    {
                      className: "enter-derivation-path",
                    },
                    {
                      children: [
                        (0, import_jsx_runtime.jsx)(
                          "div",
                          Object.assign(
                            {
                              className: "ledger-image",
                            },
                            {
                              children: (0, import_jsx_runtime.jsx)(
                                LedgerDeviceIcon,
                                {}
                              ),
                            }
                          )
                        ),
                        (0, import_jsx_runtime.jsxs)(
                          "div",
                          Object.assign(
                            {
                              className: "ledger-description",
                            },
                            {
                              children: [
                                (0, import_jsx_runtime.jsx)("p", {
                                  children: translate(
                                    "modal.ledger.makeSureYourLedger"
                                  ),
                                }),
                                (0, import_jsx_runtime.jsx)(
                                  "p",
                                  Object.assign(
                                    {
                                      className: "specify-path",
                                      onClick: () => {
                                        setHeaderTitle(
                                          translate(
                                            "modal.ledger.specifyHDPath"
                                          )
                                        );
                                        setRoute("SpecifyHDPath");
                                      },
                                    },
                                    {
                                      children: translate(
                                        "modal.ledger.specifyHDPath"
                                      ),
                                    }
                                  )
                                ),
                              ],
                            }
                          )
                        ),
                        (0, import_jsx_runtime.jsx)(
                          "div",
                          Object.assign(
                            {
                              className: "action-buttons",
                            },
                            {
                              children: (0, import_jsx_runtime.jsx)(
                                "button",
                                Object.assign(
                                  {
                                    className: "middleButton",
                                    onClick: handleValidateAccount,
                                  },
                                  {
                                    children: translate(
                                      "modal.ledger.continue"
                                    ),
                                  }
                                )
                              ),
                            }
                          )
                        ),
                      ],
                    }
                  )
                ),
              route === "SpecifyHDPath" &&
                (0, import_jsx_runtime.jsxs)(
                  "div",
                  Object.assign(
                    {
                      className: "specify-path-wrapper",
                    },
                    {
                      children: [
                        (0, import_jsx_runtime.jsxs)(
                          "div",
                          Object.assign(
                            {
                              className: "change-path-wrapper",
                            },
                            {
                              children: [
                                (0, import_jsx_runtime.jsx)(
                                  "div",
                                  Object.assign(
                                    {
                                      className: "display-path",
                                    },
                                    {
                                      children: (0, import_jsx_runtime.jsx)(
                                        "span",
                                        {
                                          children: derivationPath.slice(0, -2),
                                        }
                                      ),
                                    }
                                  )
                                ),
                                (0, import_jsx_runtime.jsxs)(
                                  "div",
                                  Object.assign(
                                    {
                                      className: "change-path",
                                    },
                                    {
                                      children: [
                                        (0, import_jsx_runtime.jsx)(
                                          "div",
                                          Object.assign(
                                            {
                                              className: "path-value",
                                            },
                                            {
                                              children: (0,
                                              import_jsx_runtime.jsx)("span", {
                                                children: customDerivationPath,
                                              }),
                                            }
                                          )
                                        ),
                                        (0, import_jsx_runtime.jsxs)(
                                          "div",
                                          Object.assign(
                                            {
                                              className: "buttons-wrapper",
                                            },
                                            {
                                              children: [
                                                (0, import_jsx_runtime.jsx)(
                                                  "button",
                                                  Object.assign(
                                                    {
                                                      onClick: () => {
                                                        const newValue =
                                                          customDerivationPath +
                                                          1;
                                                        const path =
                                                          derivationPath.slice(
                                                            0,
                                                            -2
                                                          );
                                                        setDerivationPath(
                                                          `${path}${newValue}'`
                                                        );
                                                        setCustomDerivationPath(
                                                          newValue
                                                        );
                                                      },
                                                    },
                                                    {
                                                      children: (0,
                                                      import_jsx_runtime.jsx)(
                                                        UpArrowIcon,
                                                        {}
                                                      ),
                                                    }
                                                  )
                                                ),
                                                (0, import_jsx_runtime.jsx)(
                                                  "button",
                                                  Object.assign(
                                                    {
                                                      onClick: () => {
                                                        const newValue =
                                                          customDerivationPath -
                                                          1;
                                                        if (newValue < 0) {
                                                          return;
                                                        }
                                                        const path =
                                                          derivationPath.slice(
                                                            0,
                                                            -2
                                                          );
                                                        setDerivationPath(
                                                          `${path}${newValue}'`
                                                        );
                                                        setCustomDerivationPath(
                                                          newValue
                                                        );
                                                      },
                                                    },
                                                    {
                                                      children: (0,
                                                      import_jsx_runtime.jsx)(
                                                        DownArrowIcon,
                                                        {}
                                                      ),
                                                    }
                                                  )
                                                ),
                                              ],
                                            }
                                          )
                                        ),
                                      ],
                                    }
                                  )
                                ),
                              ],
                            }
                          )
                        ),
                        (0, import_jsx_runtime.jsx)(
                          "p",
                          Object.assign(
                            {
                              className: "path-description",
                            },
                            {
                              children: translate(
                                "modal.ledger.enterYourPreferredHDPath"
                              ),
                            }
                          )
                        ),
                        (0, import_jsx_runtime.jsx)(
                          "p",
                          Object.assign(
                            {
                              className: "what-link",
                            },
                            {
                              children: (0, import_jsx_runtime.jsx)(
                                "a",
                                Object.assign(
                                  {
                                    href: "https://www.ledger.com/academy/crypto/what-are-hierarchical-deterministic-hd-wallets",
                                    target: "_blank",
                                  },
                                  {
                                    children: "What's this?",
                                  }
                                )
                              ),
                            }
                          )
                        ),
                        (0, import_jsx_runtime.jsx)(
                          "div",
                          Object.assign(
                            {
                              className: "action-buttons",
                            },
                            {
                              children: (0, import_jsx_runtime.jsx)(
                                "button",
                                Object.assign(
                                  {
                                    className: "middleButton",
                                    onClick: handleValidateAccount,
                                  },
                                  {
                                    children: translate("modal.ledger.scan"),
                                  }
                                )
                              ),
                            }
                          )
                        ),
                      ],
                    }
                  )
                ),
              route === "NoAccountsFound" &&
                (0, import_jsx_runtime.jsx)(
                  "div",
                  Object.assign(
                    {
                      className: "no-accounts-found-wrapper",
                    },
                    {
                      children: (0, import_jsx_runtime.jsxs)("p", {
                        children: [
                          translate("modal.ledger.cantFindAnyAccount"),
                          " ",
                          (0, import_jsx_runtime.jsx)(
                            "a",
                            Object.assign(
                              {
                                href: `https://${
                                  selector.options.network.networkId ===
                                  "testnet"
                                    ? "testnet"
                                    : "app"
                                }.mynearwallet.com/create`,
                                target: "_blank",
                              },
                              {
                                children: "MyNearWallet",
                              }
                            )
                          ),
                          " ",
                          translate("modal.ledger.orConnectAnAnotherLedger"),
                        ],
                      }),
                    }
                  )
                ),
              route === "ChooseAccount" &&
                (0, import_jsx_runtime.jsx)(HardwareWalletAccountsForm, {
                  accounts,
                  onSelectedChanged: (index, selected) => {
                    setAccounts((prevAccounts) => {
                      const updateAccounts = prevAccounts.map(
                        (account, idx) => {
                          const selectedValue =
                            index === idx ? selected : account.selected;
                          return Object.assign(Object.assign({}, account), {
                            selected: selectedValue,
                          });
                        }
                      );
                      return [...updateAccounts];
                    });
                  },
                  onSubmit: (acc, e) => {
                    e.preventDefault();
                    const selectedAcc = acc.filter(
                      (account) => account.selected
                    );
                    setSelectedAccounts(selectedAcc);
                    const numberOfAccounts = selectedAcc.length;
                    setHeaderTitle(
                      `${translate(
                        "modal.ledger.connecting"
                      )} ${numberOfAccounts} ${translate(
                        "modal.ledger.ofAccounts"
                      )}`
                    );
                    setRoute("OverviewAccounts");
                  },
                  onChangeRoute: (newRoute) => {
                    if (newRoute === "SpecifyHDPath") {
                      setHeaderTitle(translate("modal.ledger.specifyHDPath"));
                    }
                    setRoute(newRoute);
                  },
                }),
              route === "AddCustomAccountId" &&
                (0, import_jsx_runtime.jsxs)(
                  "div",
                  Object.assign(
                    {
                      className: "enter-custom-account",
                    },
                    {
                      children: [
                        (0, import_jsx_runtime.jsx)("p", {
                          children: translate(
                            "modal.ledger.failedToAutomatically"
                          ),
                        }),
                        (0, import_jsx_runtime.jsx)(
                          "div",
                          Object.assign(
                            {
                              className: "input-wrapper",
                            },
                            {
                              children: (0, import_jsx_runtime.jsx)("input", {
                                type: "text",
                                placeholder: "Account ID",
                                value: customAccountId,
                                onChange: (e) => {
                                  setCustomAccountId(e.target.value);
                                },
                              }),
                            }
                          )
                        ),
                        (0, import_jsx_runtime.jsx)(
                          "div",
                          Object.assign(
                            {
                              className: "action-buttons",
                            },
                            {
                              children: (0, import_jsx_runtime.jsx)(
                                "button",
                                Object.assign(
                                  {
                                    className: "middleButton",
                                    onClick: handleAddCustomAccountId,
                                  },
                                  {
                                    children: translate("ledger.Continue"),
                                  }
                                )
                              ),
                            }
                          )
                        ),
                      ],
                    }
                  )
                ),
              route === "OverviewAccounts" &&
                (0, import_jsx_runtime.jsxs)(
                  "div",
                  Object.assign(
                    {
                      className: "overview-wrapper",
                    },
                    {
                      children: [
                        (0, import_jsx_runtime.jsx)("p", {
                          children: translate(
                            "modal.ledger.overviewTheListOfAuthorized"
                          ),
                        }),
                        (0, import_jsx_runtime.jsx)(
                          "div",
                          Object.assign(
                            {
                              className: "accounts",
                            },
                            {
                              children: selectedAccounts.map((account, index) =>
                                (0, import_jsx_runtime.jsx)(
                                  "div",
                                  {
                                    children: (0, import_jsx_runtime.jsx)(
                                      "div",
                                      Object.assign(
                                        {
                                          className: "account",
                                        },
                                        {
                                          children: (0, import_jsx_runtime.jsx)(
                                            "span",
                                            {
                                              children: account.accountId,
                                            }
                                          ),
                                        }
                                      )
                                    ),
                                  },
                                  account.accountId
                                )
                              ),
                            }
                          )
                        ),
                        (0, import_jsx_runtime.jsx)(
                          "div",
                          Object.assign(
                            {
                              className: "action-buttons",
                            },
                            {
                              children: (0, import_jsx_runtime.jsx)(
                                "button",
                                Object.assign(
                                  {
                                    className: "middleButton",
                                    onClick: handleSignIn,
                                    disabled: accounts.length === 0,
                                  },
                                  {
                                    children: translate("modal.ledger.finish"),
                                  }
                                )
                              ),
                            }
                          )
                        ),
                      ],
                    }
                  )
                ),
            ],
          }
        )
      ),
    ],
  });
};
var WalletNotInstalled = ({ module, onBack, onCloseModal }) => {
  return (0, import_jsx_runtime.jsxs)(import_react.Fragment, {
    children: [
      (0, import_jsx_runtime.jsxs)(
        "div",
        Object.assign(
          {
            className: "nws-modal-header-wrapper",
          },
          {
            children: [
              (0, import_jsx_runtime.jsx)(BackArrow, {
                onClick: onBack,
              }),
              (0, import_jsx_runtime.jsx)(ModalHeader, {
                title: "",
                onCloseModal,
              }),
            ],
          }
        )
      ),
      (0, import_jsx_runtime.jsxs)(
        "div",
        Object.assign(
          {
            className: "wallet-not-installed-wrapper",
          },
          {
            children: [
              (0, import_jsx_runtime.jsxs)(
                "div",
                Object.assign(
                  {
                    className: "wallet-data",
                  },
                  {
                    children: [
                      (0, import_jsx_runtime.jsx)(
                        "div",
                        Object.assign(
                          {
                            className: `wallet-icon-box ${module.id}`,
                          },
                          {
                            children: (0, import_jsx_runtime.jsx)("img", {
                              src: module.metadata.iconUrl,
                              alt: module.metadata.name,
                            }),
                          }
                        )
                      ),
                      (0, import_jsx_runtime.jsx)("p", {
                        children: module.metadata.name,
                      }),
                    ],
                  }
                )
              ),
              (0, import_jsx_runtime.jsxs)("p", {
                children: [
                  translate("modal.install.youllNeedToInstall"),
                  " ",
                  module.metadata.name,
                  " ",
                  translate("modal.install.toContinueAfterInstalling"),
                  (0, import_jsx_runtime.jsxs)(
                    "span",
                    Object.assign(
                      {
                        className: "refresh-link",
                        onClick: () => window.location.reload(),
                      },
                      {
                        children: [
                          " ",
                          translate("modal.install.refreshThePage"),
                        ],
                      }
                    )
                  ),
                ],
              }),
              (0, import_jsx_runtime.jsx)(
                "div",
                Object.assign(
                  {
                    className: "action-buttons",
                  },
                  {
                    children: (0, import_jsx_runtime.jsxs)(
                      "button",
                      Object.assign(
                        {
                          className: "middleButton",
                          onClick: () => {
                            if (module.type !== "injected") {
                              return;
                            }
                            window.open(module.metadata.downloadUrl, "_blank");
                          },
                        },
                        {
                          children: [
                            translate("modal.install.open"),
                            " ",
                            module.metadata.name,
                          ],
                        }
                      )
                    ),
                  }
                )
              ),
            ],
          }
        )
      ),
    ],
  });
};
var QRIcon = () =>
  (0, import_jsx_runtime.jsxs)(
    "svg",
    Object.assign(
      {
        width: "18",
        height: "16",
        viewBox: "0 0 18 16",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
      },
      {
        children: [
          (0, import_jsx_runtime.jsx)("path", {
            d: "M7.22224 1.33334H1.44446V6.66668H7.22224V1.33334Z",
            stroke: "currentColor",
            strokeLinecap: "round",
            strokeLinejoin: "round",
          }),
          (0, import_jsx_runtime.jsx)("path", {
            d: "M15.8889 1.33334H10.1111V6.66668H15.8889V1.33334Z",
            stroke: "currentColor",
            strokeLinecap: "round",
            strokeLinejoin: "round",
          }),
          (0, import_jsx_runtime.jsx)("path", {
            d: "M7.22224 9.33334H1.44446V14.6667H7.22224V9.33334Z",
            stroke: "currentColor",
            strokeLinecap: "round",
            strokeLinejoin: "round",
          }),
          (0, import_jsx_runtime.jsx)("path", {
            d: "M10.1111 13.1429V14.6667H15.8889M10.1111 9.33334V10.8572H12.5873V9.33334H15.8889V12.381",
            stroke: "#4C5155",
            strokeLinecap: "round",
            strokeLinejoin: "round",
          }),
          (0, import_jsx_runtime.jsx)("rect", {
            x: "3.61108",
            y: "3.33334",
            width: "1.44444",
            height: "1.33333",
            fill: "#4C5155",
          }),
          (0, import_jsx_runtime.jsx)("rect", {
            x: "3.61108",
            y: "11.3333",
            width: "1.44444",
            height: "1.33333",
            fill: "#4C5155",
          }),
          (0, import_jsx_runtime.jsx)("rect", {
            x: "12.2778",
            y: "3.33334",
            width: "1.44445",
            height: "1.33333",
            fill: "#4C5155",
          }),
        ],
      }
    )
  );
var LinkIcon = () =>
  (0, import_jsx_runtime.jsxs)(
    "svg",
    Object.assign(
      {
        width: "18",
        height: "16",
        viewBox: "0 0 18 16",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
      },
      {
        children: [
          (0, import_jsx_runtime.jsx)("path", {
            d: "M13 8.66667V12.6667C13 13.0203 12.8478 13.3594 12.577 13.6095C12.3061 13.8595 11.9387 14 11.5556 14H3.61113C3.22804 14 2.86064 13.8595 2.58975 13.6095C2.31887 13.3594 2.16669 13.0203 2.16669 12.6667V5.33333C2.16669 4.97971 2.31887 4.64057 2.58975 4.39052C2.86064 4.14048 3.22804 4 3.61113 4H7.94447",
            stroke: "currentColor",
            strokeLinecap: "round",
            strokeLinejoin: "round",
          }),
          (0, import_jsx_runtime.jsx)("path", {
            d: "M10.8333 2H15.1666V6",
            stroke: "currentColor",
            strokeLinecap: "round",
            strokeLinejoin: "round",
          }),
          (0, import_jsx_runtime.jsx)("path", {
            d: "M7.22223 9.33333L15.1667 2",
            stroke: "currentColor",
            strokeLinecap: "round",
            strokeLinejoin: "round",
          }),
        ],
      }
    )
  );
var KeyIcon = () =>
  (0, import_jsx_runtime.jsx)(
    "svg",
    Object.assign(
      {
        width: "40",
        height: "40",
        viewBox: "0 0 40 40",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
      },
      {
        children: (0, import_jsx_runtime.jsx)("path", {
          d: "M33.5 1.83325L30.1666 5.16658M17.4818 17.8514C19.1406 19.5103 20.1666 21.8019 20.1666 24.3333C20.1666 29.3959 16.0626 33.4999 11 33.4999C5.93735 33.4999 1.8333 29.3959 1.8333 24.3333C1.8333 19.2706 5.93735 15.1666 11 15.1666C13.5313 15.1666 15.8229 16.1926 17.4818 17.8514ZM17.4818 17.8514L24.3333 10.9999M24.3333 10.9999L29.3333 15.9999L35.1666 10.1666L30.1666 5.16658M24.3333 10.9999L30.1666 5.16658",
          stroke: "currentColor",
          strokeWidth: "3",
          strokeLinecap: "round",
          strokeLinejoin: "round",
        }),
      }
    )
  );
var FolderIcon = () =>
  (0, import_jsx_runtime.jsxs)(
    "svg",
    Object.assign(
      {
        width: "40",
        height: "41",
        viewBox: "0 0 40 41",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
      },
      {
        children: [
          (0, import_jsx_runtime.jsx)("circle", {
            cx: "28.3333",
            cy: "23.8333",
            r: "1.66667",
            fill: "currentColor",
          }),
          (0, import_jsx_runtime.jsx)("path", {
            d: "M35 12.1667H7C5.89543 12.1667 5 11.2712 5 10.1667V7.5C5 6.39543 5.89543 5.5 7 5.5H31.6667",
            stroke: "currentColor",
            strokeWidth: "3",
            strokeLinecap: "round",
            strokeLinejoin: "round",
          }),
          (0, import_jsx_runtime.jsx)("path", {
            d: "M35 12.1667V35.5H7C5.89543 35.5 5 34.6046 5 33.5V8.83334",
            stroke: "currentColor",
            strokeWidth: "3",
            strokeLinecap: "round",
            strokeLinejoin: "round",
          }),
        ],
      }
    )
  );
var WalletHome = ({ selector, onCloseModal }) => {
  const [modules, setModules] = (0, import_react.useState)([]);
  const [route, setRoute] = (0, import_react.useState)("WalletInfo");
  (0, import_react.useEffect)(() => {
    const subscription = selector.store.observable.subscribe((state) => {
      const filterByType = (item) => {
        return (
          item.type !== "bridge" &&
          item.type !== "hardware" &&
          item.type !== "instant-link"
        );
      };
      const filteredModules = state.modules.filter(filterByType);
      setModules(filteredModules);
    });
    return () => subscription.unsubscribe();
  }, []);
  const getWalletUrl = (module) => {
    let url = "";
    if (module.type === "injected") {
      url = module.metadata.downloadUrl;
    }
    if (module.type === "browser") {
      url = module.metadata.walletUrl;
    }
    return url;
  };
  return (0, import_jsx_runtime.jsxs)(
    "div",
    Object.assign(
      {
        className: "wallet-home-wrapper",
      },
      {
        children: [
          (0, import_jsx_runtime.jsxs)(
            "div",
            Object.assign(
              {
                className: "nws-modal-header-wrapper",
              },
              {
                children: [
                  route === "GetWallets" &&
                    (0, import_jsx_runtime.jsx)(BackArrow, {
                      onClick: () => {
                        setRoute("WalletInfo");
                      },
                    }),
                  (0, import_jsx_runtime.jsx)(ModalHeader, {
                    title:
                      route === "GetWallets"
                        ? translate("modal.wallet.getAWallet")
                        : translate("modal.wallet.whatIsAWallet"),
                    onCloseModal,
                  }),
                ],
              }
            )
          ),
          route === "GetWallets" &&
            (0, import_jsx_runtime.jsx)(
              "div",
              Object.assign(
                {
                  className: "get-wallet-wrapper",
                },
                {
                  children: modules.map((module) => {
                    const { iconUrl, name } = module.metadata;
                    const qrIcon = ["nearfi", "here-wallet"].includes(
                      module.id
                    );
                    const hereWalletType =
                      module.id === "here-wallet" ? "mobile" : "";
                    const walletUrl = getWalletUrl(module);
                    return (0, import_jsx_runtime.jsxs)(
                      "div",
                      Object.assign(
                        {
                          tabIndex: 0,
                          className: `single-wallet-get ${module.id}`,
                          onClick: () => {
                            if (walletUrl) {
                              window.open(walletUrl, "_blank");
                            }
                          },
                        },
                        {
                          children: [
                            (0, import_jsx_runtime.jsxs)(
                              "div",
                              Object.assign(
                                {
                                  className: "small-icon",
                                },
                                {
                                  children: [
                                    qrIcon &&
                                      walletUrl &&
                                      (0, import_jsx_runtime.jsx)(QRIcon, {}),
                                    !qrIcon &&
                                      walletUrl &&
                                      (0, import_jsx_runtime.jsx)(LinkIcon, {}),
                                  ],
                                }
                              )
                            ),
                            (0, import_jsx_runtime.jsx)(
                              "div",
                              Object.assign(
                                {
                                  className: "icon",
                                },
                                {
                                  children: (0, import_jsx_runtime.jsx)("img", {
                                    src: iconUrl,
                                    alt: name,
                                  }),
                                }
                              )
                            ),
                            (0, import_jsx_runtime.jsxs)(
                              "div",
                              Object.assign(
                                {
                                  className: "content",
                                },
                                {
                                  children: [
                                    (0, import_jsx_runtime.jsx)(
                                      "div",
                                      Object.assign(
                                        {
                                          className: "title",
                                        },
                                        {
                                          children: name,
                                        }
                                      )
                                    ),
                                    (0, import_jsx_runtime.jsx)(
                                      "div",
                                      Object.assign(
                                        {
                                          className: "type",
                                        },
                                        {
                                          children: translate(
                                            `modal.walletTypes.${
                                              hereWalletType || module.type
                                            }`
                                          ),
                                        }
                                      )
                                    ),
                                  ],
                                }
                              )
                            ),
                          ],
                        }
                      ),
                      module.id
                    );
                  }),
                }
              )
            ),
          route === "WalletInfo" &&
            (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, {
              children: [
                (0, import_jsx_runtime.jsxs)(
                  "div",
                  Object.assign(
                    {
                      className: "wallet-info-wrapper what-wallet-hide",
                    },
                    {
                      children: [
                        (0, import_jsx_runtime.jsxs)(
                          "div",
                          Object.assign(
                            {
                              className: "wallet-what",
                            },
                            {
                              children: [
                                (0, import_jsx_runtime.jsx)(
                                  "div",
                                  Object.assign(
                                    {
                                      className: "icon-side",
                                    },
                                    {
                                      children: (0, import_jsx_runtime.jsx)(
                                        KeyIcon,
                                        {}
                                      ),
                                    }
                                  )
                                ),
                                (0, import_jsx_runtime.jsxs)(
                                  "div",
                                  Object.assign(
                                    {
                                      className: "content-side",
                                    },
                                    {
                                      children: [
                                        (0, import_jsx_runtime.jsx)("h3", {
                                          children: translate(
                                            "modal.wallet.secureAndManage"
                                          ),
                                        }),
                                        (0, import_jsx_runtime.jsx)("p", {
                                          children: translate(
                                            "modal.wallet.safelyStore"
                                          ),
                                        }),
                                      ],
                                    }
                                  )
                                ),
                              ],
                            }
                          )
                        ),
                        (0, import_jsx_runtime.jsxs)(
                          "div",
                          Object.assign(
                            {
                              className: "wallet-what",
                            },
                            {
                              children: [
                                (0, import_jsx_runtime.jsx)(
                                  "div",
                                  Object.assign(
                                    {
                                      className: "icon-side",
                                    },
                                    {
                                      children: (0, import_jsx_runtime.jsx)(
                                        FolderIcon,
                                        {}
                                      ),
                                    }
                                  )
                                ),
                                (0, import_jsx_runtime.jsxs)(
                                  "div",
                                  Object.assign(
                                    {
                                      className: "content-side",
                                    },
                                    {
                                      children: [
                                        (0, import_jsx_runtime.jsx)("h3", {
                                          children: translate(
                                            "modal.wallet.logInToAny"
                                          ),
                                        }),
                                        (0, import_jsx_runtime.jsx)("p", {
                                          children: translate(
                                            "modal.wallet.noNeedToCreate"
                                          ),
                                        }),
                                      ],
                                    }
                                  )
                                ),
                              ],
                            }
                          )
                        ),
                        (0, import_jsx_runtime.jsx)("div", {
                          className: "button-spacing",
                        }),
                        (0, import_jsx_runtime.jsx)(
                          "button",
                          Object.assign(
                            {
                              className: "middleButton",
                              onClick: () => {
                                setRoute("GetWallets");
                              },
                            },
                            {
                              children: translate("modal.wallet.getAWallet"),
                            }
                          )
                        ),
                      ],
                    }
                  )
                ),
                (0, import_jsx_runtime.jsxs)(
                  "div",
                  Object.assign(
                    {
                      className: "what-wallet-mobile",
                    },
                    {
                      children: [
                        (0, import_jsx_runtime.jsx)("p", {
                          children: translate("modal.wallet.useAWallet"),
                        }),
                        (0, import_jsx_runtime.jsx)(
                          "button",
                          Object.assign(
                            {
                              className: "middleButton",
                              onClick: () => {
                                setRoute("GetWallets");
                              },
                            },
                            {
                              children: translate("modal.wallet.getAWallet"),
                            }
                          )
                        ),
                      ],
                    }
                  )
                ),
                (0, import_jsx_runtime.jsx)(
                  "div",
                  Object.assign(
                    {
                      className: "lang-selector-wrapper",
                    },
                    {
                      children: (0, import_jsx_runtime.jsxs)(
                        "select",
                        Object.assign(
                          {
                            className: "lang-selector",
                            name: "lang",
                          },
                          {
                            children: [
                              (0, import_jsx_runtime.jsx)(
                                "option",
                                Object.assign(
                                  {
                                    value: "en",
                                  },
                                  {
                                    children: "English",
                                  }
                                )
                              ),
                              (0, import_jsx_runtime.jsx)(
                                "option",
                                Object.assign(
                                  {
                                    value: "es",
                                  },
                                  {
                                    children: "Spanish",
                                  }
                                )
                              ),
                            ],
                          }
                        )
                      ),
                    }
                  )
                ),
              ],
            }),
        ],
      }
    )
  );
};
var WalletConnected = ({ module, onCloseModal }) => {
  return (0, import_jsx_runtime.jsxs)(import_react.Fragment, {
    children: [
      (0, import_jsx_runtime.jsxs)(
        "div",
        Object.assign(
          {
            className: "nws-modal-header",
          },
          {
            children: [
              (0, import_jsx_runtime.jsx)(
                "h3",
                Object.assign(
                  {
                    className: "middleTitle",
                  },
                  {
                    children: ``,
                  }
                )
              ),
              (0, import_jsx_runtime.jsx)(CloseButton, {
                onClick: onCloseModal,
              }),
            ],
          }
        )
      ),
      (0, import_jsx_runtime.jsx)(
        "div",
        Object.assign(
          {
            className: "connecting-wrapper",
          },
          {
            children: (0, import_jsx_runtime.jsxs)(
              "div",
              Object.assign(
                {
                  className: "content",
                },
                {
                  children: [
                    (0, import_jsx_runtime.jsxs)(
                      "div",
                      Object.assign(
                        {
                          className: "icon",
                        },
                        {
                          children: [
                            (0, import_jsx_runtime.jsx)("div", {
                              className: "green-dot",
                            }),
                            (0, import_jsx_runtime.jsx)("img", {
                              src:
                                module === null || module === void 0
                                  ? void 0
                                  : module.metadata.iconUrl,
                              alt:
                                module === null || module === void 0
                                  ? void 0
                                  : module.metadata.name,
                            }),
                          ],
                        }
                      )
                    ),
                    (0, import_jsx_runtime.jsx)(
                      "h3",
                      Object.assign(
                        {
                          className: "connecting-name",
                        },
                        {
                          children:
                            module === null || module === void 0
                              ? void 0
                              : module.metadata.name,
                        }
                      )
                    ),
                    (0, import_jsx_runtime.jsxs)(
                      "div",
                      Object.assign(
                        {
                          className: "wallet-connected-success",
                        },
                        {
                          children: [
                            (0, import_jsx_runtime.jsx)(
                              ConnectionSuccessIcon,
                              {}
                            ),
                            (0, import_jsx_runtime.jsx)("span", {
                              children: translate(
                                "modal.wallet.connectionSuccessful"
                              ),
                            }),
                          ],
                        }
                      )
                    ),
                  ],
                }
              )
            ),
          }
        )
      ),
    ],
  });
};
var anObject$1$2 = anObject$c$1;
var regexpFlags$1 = function () {
  var that = anObject$1$2(this);
  var result = "";
  if (that.hasIndices) result += "d";
  if (that.global) result += "g";
  if (that.ignoreCase) result += "i";
  if (that.multiline) result += "m";
  if (that.dotAll) result += "s";
  if (that.unicode) result += "u";
  if (that.unicodeSets) result += "v";
  if (that.sticky) result += "y";
  return result;
};
var call$g = functionCall$2;
var hasOwn2$2 = hasOwnProperty_1$2;
var isPrototypeOf$5 = objectIsPrototypeOf$2;
var regExpFlags$1 = regexpFlags$1;
var RegExpPrototype$1$1 = RegExp.prototype;
var regexpGetFlags$1 = function (R) {
  var flags = R.flags;
  return flags === void 0 &&
    !("flags" in RegExpPrototype$1$1) &&
    !hasOwn2$2(R, "flags") &&
    isPrototypeOf$5(RegExpPrototype$1$1, R)
    ? call$g(regExpFlags$1, R)
    : flags;
};
var PROPER_FUNCTION_NAME$2 = functionName$2.PROPER;
var defineBuiltIn$8 = defineBuiltIn$6$1;
var anObject$e = anObject$c$1;
var $toString$1 = toString$3;
var fails$i = fails$h;
var getRegExpFlags$1 = regexpGetFlags$1;
var TO_STRING$1 = "toString";
var RegExpPrototype$2 = RegExp.prototype;
var n$ToString$1 = RegExpPrototype$2[TO_STRING$1];
var NOT_GENERIC$1 = fails$i(function () {
  return n$ToString$1.call({ source: "a", flags: "b" }) != "/a/b";
});
var INCORRECT_NAME$1 =
  PROPER_FUNCTION_NAME$2 && n$ToString$1.name != TO_STRING$1;
if (NOT_GENERIC$1 || INCORRECT_NAME$1) {
  defineBuiltIn$8(
    RegExp.prototype,
    TO_STRING$1,
    function toString3() {
      var R = anObject$e(this);
      var pattern = $toString$1(R.source);
      var flags = $toString$1(getRegExpFlags$1(R));
      return "/" + pattern + "/" + flags;
    },
    { unsafe: true }
  );
}
var CopyIcon = () =>
  (0, import_jsx_runtime.jsxs)(
    "svg",
    Object.assign(
      {
        width: 24,
        height: 24,
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
      },
      {
        children: [
          (0, import_jsx_runtime.jsx)("path", {
            d: "M6.5 15.25a1.75 1.75 0 0 1-1.75-1.75V6.75a2 2 0 0 1 2-2h6.75c.966 0 1.75.784 1.75 1.75",
            stroke: "#4F7CD1",
            strokeWidth: 1.5,
            strokeLinecap: "round",
            strokeLinejoin: "round",
          }),
          (0, import_jsx_runtime.jsx)("path", {
            d: "M8.75 10.75a2 2 0 0 1 2-2h6.5a2 2 0 0 1 2 2v6.5a2 2 0 0 1-2 2h-6.5a2 2 0 0 1-2-2v-6.5Z",
            stroke: "#4F7CD1",
            strokeWidth: 1.5,
            strokeLinecap: "round",
            strokeLinejoin: "round",
          }),
        ],
      }
    )
  );
function formatQRCodeImage(data2) {
  return __awaiter$2(this, void 0, void 0, function* () {
    return yield import_qrcode.default.toString(data2, {
      margin: 0,
      type: "svg",
    });
  });
}
var ScanQRCode = ({ wallet, uri, onCloseModal, handleOpenDefaultModal }) => {
  const [notification, setNotification] = import_react.default.useState("");
  const [svg, setSvg] = import_react.default.useState("");
  const copyToClipboard = () => {
    if (!uri) {
      return;
    }
    const success = (0, import_copy_to_clipboard.default)(uri);
    if (success) {
      setNotification(translate("modal.qr.copiedToClipboard"));
      setTimeout(() => setNotification(""), 1200);
    } else {
      setNotification(translate("modal.qr.failedToCopy"));
      setTimeout(() => setNotification(""), 1200);
    }
  };
  import_react.default.useEffect(() => {
    (() =>
      __awaiter$2(void 0, void 0, void 0, function* () {
        if (uri) {
          setSvg(yield formatQRCodeImage(uri));
        }
      }))();
  }, [uri]);
  return (0, import_jsx_runtime.jsxs)(
    "section",
    Object.assign(
      {
        className: "scan-qr-code",
      },
      {
        children: [
          (0, import_jsx_runtime.jsx)(ModalHeader, {
            title: translate("modal.qr.scanWithYourMobile"),
            onCloseModal,
          }),
          (0, import_jsx_runtime.jsxs)(
            "section",
            Object.assign(
              {
                className: "qr-code",
              },
              {
                children: [
                  (0, import_jsx_runtime.jsx)("div", {
                    dangerouslySetInnerHTML: {
                      __html: svg,
                    },
                  }),
                  notification
                    ? (0, import_jsx_runtime.jsx)(
                        "div",
                        Object.assign(
                          {
                            className: "notification",
                          },
                          {
                            children: notification,
                          }
                        )
                      )
                    : (0, import_jsx_runtime.jsxs)(
                        "div",
                        Object.assign(
                          {
                            className: "copy-btn",
                            onClick: copyToClipboard,
                          },
                          {
                            children: [
                              (0, import_jsx_runtime.jsx)(CopyIcon, {}),
                              translate("modal.qr.copyToClipboard"),
                            ],
                          }
                        )
                      ),
                ],
              }
            )
          ),
          (0, import_jsx_runtime.jsxs)(
            "footer",
            Object.assign(
              {
                className: "footer",
              },
              {
                children: [
                  (0, import_jsx_runtime.jsxs)("p", {
                    children: [
                      translate("modal.qr.preferTheOfficial"),
                      " ",
                      wallet.metadata.name,
                      "?",
                    ],
                  }),
                  (0, import_jsx_runtime.jsx)(
                    "button",
                    Object.assign(
                      {
                        className: "btn",
                        onClick: handleOpenDefaultModal,
                      },
                      {
                        children: translate("modal.qr.open"),
                      }
                    )
                  ),
                ],
              }
            )
          ),
        ],
      }
    )
  );
};
var getThemeClass = (theme) => {
  switch (theme) {
    case "dark":
      return "dark-theme";
    case "light":
      return "light-theme";
    default:
      return "";
  }
};
var Modal = ({ selector, options, visible, hide, emitter }) => {
  var _a, _b, _c;
  const [route, setRoute] = (0, import_react.useState)({
    name: "WalletHome",
  });
  const [alertMessage, setAlertMessage] = (0, import_react.useState)(null);
  const [selectedWallet, setSelectedWallet] = (0, import_react.useState)();
  const [bridgeWalletUri, setBridgeWalletUri] = (0, import_react.useState)();
  (0, import_react.useEffect)(() => {
    setRoute({
      name: "WalletHome",
    });
    allowOnlyLanguage(selector.options.languageCode);
    const { selectedWalletId, modules } = selector.store.getState();
    if (selectedWalletId) {
      const module = modules.find((m) => m.id === selectedWalletId);
      setSelectedWallet(module);
      setRoute({
        name: "WalletConnected",
        params: {
          module,
        },
      });
    }
    setBridgeWalletUri("");
  }, [visible]);
  (0, import_react.useEffect)(() => {
    const subscription = selector.on("networkChanged", ({ networkId }) => {
      if (networkId === selector.options.network.networkId) {
        return handleDismissClick({});
      }
      setRoute({
        name: "WalletNetworkChanged",
      });
    });
    return () => subscription.remove();
  }, []);
  const handleDismissClick = (0, import_react.useCallback)(
    ({ hideReason }) => {
      setAlertMessage(null);
      setRoute({
        name: "WalletHome",
      });
      if (hideReason === "user-triggered") {
        emitter.emit("onHide", {
          hideReason,
        });
      }
      if (hideReason === "wallet-navigation") {
        emitter.emit("onHide", {
          hideReason,
        });
      }
      hide();
    },
    [hide, emitter]
  );
  (0, import_react.useEffect)(() => {
    const close = (e) => {
      if (e.key === "Escape") {
        handleDismissClick({
          hideReason: "user-triggered",
        });
      }
    };
    window.addEventListener("keydown", close);
    return () => window.removeEventListener("keydown", close);
  }, [handleDismissClick]);
  const handleWalletClick = (module, qrCodeModal) =>
    __awaiter$2(void 0, void 0, void 0, function* () {
      setSelectedWallet(module);
      const { selectedWalletId } = selector.store.getState();
      if (selectedWalletId === module.id) {
        setRoute({
          name: "WalletConnected",
          params: {
            module,
          },
        });
        return;
      }
      try {
        const { deprecated, available } = module.metadata;
        if (module.type === "injected" && !available) {
          setRoute({
            name: "WalletNotInstalled",
            params: {
              module,
            },
          });
          return;
        }
        const wallet = yield module.wallet();
        if (deprecated) {
          setAlertMessage(
            `${module.metadata.name} is deprecated. Please select another wallet.`
          );
          setRoute({
            name: "AlertMessage",
            params: {
              module,
            },
          });
          return;
        }
        if (wallet.type === "hardware") {
          setRoute({
            name: "DerivationPath",
            params: {
              walletId: wallet.id || "ledger",
            },
          });
          return;
        }
        setRoute({
          name: "WalletConnecting",
          params: {
            wallet,
          },
        });
        if (wallet.type === "bridge") {
          const subscription = selector.on("uriChanged", ({ uri }) => {
            setBridgeWalletUri(uri);
            setRoute({
              name: "ScanQRCode",
              params: {
                uri,
                wallet,
              },
            });
          });
          yield wallet.signIn({
            contractId: options.contractId,
            methodNames: options.methodNames,
            qrCodeModal,
          });
          subscription.remove();
          handleDismissClick({
            hideReason: "wallet-navigation",
          });
          return;
        }
        if (wallet.type === "browser") {
          yield wallet.signIn({
            contractId: options.contractId,
            methodNames: options.methodNames,
            successUrl: wallet.metadata.successUrl,
            failureUrl: wallet.metadata.failureUrl,
          });
          handleDismissClick({
            hideReason: "wallet-navigation",
          });
          return;
        }
        yield wallet.signIn({
          contractId: options.contractId,
          methodNames: options.methodNames,
        });
        handleDismissClick({
          hideReason: "wallet-navigation",
        });
      } catch (err) {
        const { name } = module.metadata;
        const message =
          err instanceof Error ? err.message : "Something went wrong";
        setAlertMessage(`Failed to sign in with ${name}: ${message}`);
        setRoute({
          name: "AlertMessage",
          params: {
            module,
          },
        });
      }
    });
  if (!visible) {
    return null;
  }
  return (0, import_jsx_runtime.jsxs)(
    "div",
    Object.assign(
      {
        className: `nws-modal-wrapper ${getThemeClass(
          options === null || options === void 0 ? void 0 : options.theme
        )} ${visible ? "open" : ""}`,
      },
      {
        children: [
          (0, import_jsx_runtime.jsx)("div", {
            className: "nws-modal-overlay",
            onClick: () => {
              handleDismissClick({
                hideReason: "user-triggered",
              });
            },
          }),
          (0, import_jsx_runtime.jsxs)(
            "div",
            Object.assign(
              {
                className: "nws-modal",
              },
              {
                children: [
                  (0, import_jsx_runtime.jsxs)(
                    "div",
                    Object.assign(
                      {
                        className: "modal-left",
                      },
                      {
                        children: [
                          (0, import_jsx_runtime.jsx)(
                            "div",
                            Object.assign(
                              {
                                className: "modal-left-title",
                              },
                              {
                                children: (0, import_jsx_runtime.jsx)("h2", {
                                  children: translate(
                                    "modal.wallet.connectYourWallet"
                                  ),
                                }),
                              }
                            )
                          ),
                          (0, import_jsx_runtime.jsx)(WalletOptions, {
                            handleWalletClick: (module) => {
                              handleWalletClick(module, false);
                            },
                            selector,
                          }),
                        ],
                      }
                    )
                  ),
                  (0, import_jsx_runtime.jsx)(
                    "div",
                    Object.assign(
                      {
                        className: "modal-right",
                      },
                      {
                        children: (0, import_jsx_runtime.jsxs)(
                          "div",
                          Object.assign(
                            {
                              className: "nws-modal-body",
                            },
                            {
                              children: [
                                route.name === "AlertMessage" &&
                                  alertMessage &&
                                  (0, import_jsx_runtime.jsx)(AlertMessage, {
                                    message: alertMessage,
                                    module:
                                      (_a = route.params) === null ||
                                      _a === void 0
                                        ? void 0
                                        : _a.module,
                                    onBack: (retry) => {
                                      if (retry) {
                                        handleWalletClick(
                                          selectedWallet,
                                          false
                                        );
                                      }
                                      setAlertMessage(null);
                                      setRoute({
                                        name: "WalletHome",
                                      });
                                    },
                                    onCloseModal: () =>
                                      handleDismissClick({
                                        hideReason: "user-triggered",
                                      }),
                                  }),
                                route.name === "DerivationPath" &&
                                  (0, import_jsx_runtime.jsx)(DerivationPath, {
                                    selector,
                                    options,
                                    onConnected: () => {
                                      handleDismissClick({
                                        hideReason: "wallet-navigation",
                                      });
                                    },
                                    params: route.params,
                                    onBack: () =>
                                      setRoute({
                                        name: "WalletHome",
                                      }),
                                    onError: (message, wallet) => {
                                      const { modules } =
                                        selector.store.getState();
                                      const findModule = modules.find(
                                        (module) => module.id === wallet.id
                                      );
                                      setAlertMessage(message);
                                      setRoute({
                                        name: "AlertMessage",
                                        params: {
                                          module: findModule,
                                        },
                                      });
                                    },
                                    onCloseModal: () =>
                                      handleDismissClick({
                                        hideReason: "user-triggered",
                                      }),
                                  }),
                                route.name === "WalletNetworkChanged" &&
                                  (0, import_jsx_runtime.jsx)(
                                    WalletNetworkChanged,
                                    {
                                      selector,
                                      onBack: () =>
                                        setRoute({
                                          name: "WalletHome",
                                        }),
                                      onCloseModal: () =>
                                        handleDismissClick({
                                          hideReason: "user-triggered",
                                        }),
                                    }
                                  ),
                                route.name === "WalletNotInstalled" &&
                                  (0, import_jsx_runtime.jsx)(
                                    WalletNotInstalled,
                                    {
                                      module:
                                        (_b = route.params) === null ||
                                        _b === void 0
                                          ? void 0
                                          : _b.module,
                                      onBack: () => {
                                        setRoute({
                                          name: "WalletHome",
                                        });
                                      },
                                      onCloseModal: () =>
                                        handleDismissClick({
                                          hideReason: "user-triggered",
                                        }),
                                    }
                                  ),
                                route.name === "WalletConnecting" &&
                                  (0, import_jsx_runtime.jsx)(
                                    WalletConnecting,
                                    {
                                      wallet:
                                        (_c = route.params) === null ||
                                        _c === void 0
                                          ? void 0
                                          : _c.wallet,
                                      onBack: () => {
                                        setRoute({
                                          name: "WalletHome",
                                        });
                                      },
                                      onCloseModal: () =>
                                        handleDismissClick({
                                          hideReason: "user-triggered",
                                        }),
                                    }
                                  ),
                                route.name === "WalletHome" &&
                                  (0, import_jsx_runtime.jsx)(WalletHome, {
                                    selector,
                                    onCloseModal: () =>
                                      handleDismissClick({
                                        hideReason: "user-triggered",
                                      }),
                                  }),
                                route.name === "WalletConnected" &&
                                  (0, import_jsx_runtime.jsx)(WalletConnected, {
                                    module: selectedWallet,
                                    onCloseModal: () =>
                                      handleDismissClick({
                                        hideReason: "user-triggered",
                                      }),
                                  }),
                                route.name === "ScanQRCode" &&
                                  (0, import_jsx_runtime.jsx)(ScanQRCode, {
                                    handleOpenDefaultModal: () => {
                                      handleWalletClick(selectedWallet, true);
                                    },
                                    onCloseModal: () =>
                                      handleDismissClick({
                                        hideReason: "user-triggered",
                                      }),
                                    uri: bridgeWalletUri,
                                    wallet: selectedWallet,
                                  }),
                              ],
                            }
                          )
                        ),
                      }
                    )
                  ),
                ],
              }
            )
          ),
        ],
      }
    )
  );
};
var MODAL_ELEMENT_ID = "near-wallet-selector-modal";
var modalInstance = null;
var setupModal = (selector, options) => {
  const el = document.createElement("div");
  el.id = MODAL_ELEMENT_ID;
  if (!document.getElementById(MODAL_ELEMENT_ID)) {
    document.body.appendChild(el);
  }
  const container = document.getElementById(MODAL_ELEMENT_ID);
  const root = (0, import_client.createRoot)(container);
  const emitter = new EventEmitter();
  const render = (visible = false) => {
    root.render(
      (0, import_jsx_runtime.jsx)(Modal, {
        selector,
        options,
        visible,
        hide: () => render(false),
        emitter,
      })
    );
  };
  if (!modalInstance) {
    modalInstance = {
      show: () => {
        render(true);
      },
      hide: () => {
        render(false);
      },
      on: (eventName, callback) => {
        return emitter.on(eventName, callback);
      },
      off: (eventName, callback) => {
        emitter.off(eventName, callback);
      },
    };
  }
  return modalInstance;
};
/*! Bundled license information:

react/cjs/react.production.min.js:
  (**
   * @license React
   * react.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react/cjs/react.development.js:
  (**
   * @license React
   * react.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react/cjs/react-jsx-runtime.production.min.js:
  (**
   * @license React
   * react-jsx-runtime.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react/cjs/react-jsx-runtime.development.js:
  (**
   * @license React
   * react-jsx-runtime.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

scheduler/cjs/scheduler.production.min.js:
  (**
   * @license React
   * scheduler.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

scheduler/cjs/scheduler.development.js:
  (**
   * @license React
   * scheduler.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom.production.min.js:
  (**
   * @license React
   * react-dom.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom.development.js:
  (**
   * @license React
   * react-dom.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
  (**
   * Checks if an event is supported in the current execution environment.
   *
   * NOTE: This will not work correctly for non-generic events such as `change`,
   * `reset`, `load`, `error`, and `select`.
   *
   * Borrows from Modernizr.
   *
   * @param {string} eventNameSuffix Event name, e.g. "click".
   * @return {boolean} True if the event is supported.
   * @internal
   * @license Modernizr 3.0.0pre (Custom Build) | MIT
   *)
*/

// node_modules/@near-wallet-selector/my-near-wallet/index.js
var nearAPI2 = __toESM(require_browser_index2());

// node_modules/@near-wallet-selector/wallet-utils/index.js
var import_bn = __toESM(require_bn());
var nearAPI = __toESM(require_browser_index2());
var { transactions: transactions2, utils: utils2 } = nearAPI;
var getAccessKey = (permission) => {
  if (permission === "FullAccess") {
    return transactions2.fullAccessKey();
  }
  const { receiverId, methodNames = [] } = permission;
  const allowance = permission.allowance
    ? new import_bn.BN(permission.allowance)
    : void 0;
  return transactions2.functionCallAccessKey(
    receiverId,
    methodNames,
    allowance
  );
};
var createAction = (action) => {
  switch (action.type) {
    case "CreateAccount":
      return transactions2.createAccount();
    case "DeployContract": {
      const { code } = action.params;
      return transactions2.deployContract(code);
    }
    case "FunctionCall": {
      const { methodName, args, gas, deposit } = action.params;
      return transactions2.functionCall(
        methodName,
        args,
        new import_bn.BN(gas),
        new import_bn.BN(deposit)
      );
    }
    case "Transfer": {
      const { deposit } = action.params;
      return transactions2.transfer(new import_bn.BN(deposit));
    }
    case "Stake": {
      const { stake, publicKey } = action.params;
      return transactions2.stake(
        new import_bn.BN(stake),
        utils2.PublicKey.from(publicKey)
      );
    }
    case "AddKey": {
      const { publicKey, accessKey } = action.params;
      return transactions2.addKey(
        utils2.PublicKey.from(publicKey),
        // TODO: Use accessKey.nonce? near-api-js seems to think 0 is fine?
        getAccessKey(accessKey.permission)
      );
    }
    case "DeleteKey": {
      const { publicKey } = action.params;
      return transactions2.deleteKey(utils2.PublicKey.from(publicKey));
    }
    case "DeleteAccount": {
      const { beneficiaryId } = action.params;
      return transactions2.deleteAccount(beneficiaryId);
    }
    default:
      throw new Error("Invalid action type");
  }
};
var commonjsGlobal$1 =
  typeof globalThis !== "undefined"
    ? globalThis
    : typeof window !== "undefined"
    ? window
    : typeof global !== "undefined"
    ? global
    : typeof self !== "undefined"
    ? self
    : {};
var fails$d = function (exec3) {
  try {
    return !!exec3();
  } catch (error) {
    return true;
  }
};
var fails$c = fails$d;
var functionBindNative$1 = !fails$c(function () {
  var test3 = function () {}.bind();
  return typeof test3 != "function" || test3.hasOwnProperty("prototype");
});
var NATIVE_BIND$3 = functionBindNative$1;
var FunctionPrototype$2 = Function.prototype;
var bind$5 = FunctionPrototype$2.bind;
var call$e = FunctionPrototype$2.call;
var uncurryThis$d = NATIVE_BIND$3 && bind$5.bind(call$e, call$e);
var functionUncurryThis$1 = NATIVE_BIND$3
  ? function (fn) {
      return fn && uncurryThis$d(fn);
    }
  : function (fn) {
      return (
        fn &&
        function () {
          return call$e.apply(fn, arguments);
        }
      );
    };
var uncurryThis$c = functionUncurryThis$1;
var toString$2 = uncurryThis$c({}.toString);
var stringSlice$1 = uncurryThis$c("".slice);
var classofRaw$1 = function (it) {
  return stringSlice$1(toString$2(it), 8, -1);
};
var uncurryThis$b = functionUncurryThis$1;
var fails$b = fails$d;
var classof$5 = classofRaw$1;
var $Object$4 = Object;
var split$1 = uncurryThis$b("".split);
var indexedObject$1 = fails$b(function () {
  return !$Object$4("z").propertyIsEnumerable(0);
})
  ? function (it) {
      return classof$5(it) == "String" ? split$1(it, "") : $Object$4(it);
    }
  : $Object$4;
var $TypeError$b = TypeError;
var requireObjectCoercible$2$1 = function (it) {
  if (it == void 0) throw $TypeError$b("Can't call method on " + it);
  return it;
};
var IndexedObject$2 = indexedObject$1;
var requireObjectCoercible$1$1 = requireObjectCoercible$2$1;
var toIndexedObject$5 = function (it) {
  return IndexedObject$2(requireObjectCoercible$1$1(it));
};
var check$1 = function (it) {
  return it && it.Math == Math && it;
};
var global$j =
  // eslint-disable-next-line es-x/no-global-this -- safe
  check$1(typeof globalThis == "object" && globalThis) ||
  check$1(typeof window == "object" && window) || // eslint-disable-next-line no-restricted-globals -- safe
  check$1(typeof self == "object" && self) ||
  check$1(typeof commonjsGlobal$1 == "object" && commonjsGlobal$1) || // eslint-disable-next-line no-new-func -- fallback
  (function () {
    return this;
  })() ||
  Function("return this")();
var shared$3$1 = { exports: {} };
var global$i = global$j;
var defineProperty$4 = Object.defineProperty;
var defineGlobalProperty$3$1 = function (key, value) {
  try {
    defineProperty$4(global$i, key, {
      value,
      configurable: true,
      writable: true,
    });
  } catch (error) {
    global$i[key] = value;
  }
  return value;
};
var global$h = global$j;
var defineGlobalProperty$2$1 = defineGlobalProperty$3$1;
var SHARED$1 = "__core-js_shared__";
var store$3$1 = global$h[SHARED$1] || defineGlobalProperty$2$1(SHARED$1, {});
var sharedStore$1 = store$3$1;
var store$2$1 = sharedStore$1;
(shared$3$1.exports = function (key, value) {
  return store$2$1[key] || (store$2$1[key] = value !== void 0 ? value : {});
})("versions", []).push({
  version: "3.23.3",
  mode: "global",
  copyright: " 2014-2022 Denis Pushkarev (zloirock.ru)",
  license: "https://github.com/zloirock/core-js/blob/v3.23.3/LICENSE",
  source: "https://github.com/zloirock/core-js",
});
var requireObjectCoercible$3 = requireObjectCoercible$2$1;
var $Object$3 = Object;
var toObject$2$1 = function (argument) {
  return $Object$3(requireObjectCoercible$3(argument));
};
var uncurryThis$a$1 = functionUncurryThis$1;
var toObject$1$1 = toObject$2$1;
var hasOwnProperty$1 = uncurryThis$a$1({}.hasOwnProperty);
var hasOwnProperty_1$1 =
  Object.hasOwn ||
  function hasOwn(it, key) {
    return hasOwnProperty$1(toObject$1$1(it), key);
  };
var uncurryThis$9$1 = functionUncurryThis$1;
var id$1 = 0;
var postfix$1 = Math.random();
var toString$1$1 = uncurryThis$9$1((1).toString);
var uid$2$1 = function (key) {
  return (
    "Symbol(" +
    (key === void 0 ? "" : key) +
    ")_" +
    toString$1$1(++id$1 + postfix$1, 36)
  );
};
var isCallable$k = function (argument) {
  return typeof argument == "function";
};
var global$g = global$j;
var isCallable$j = isCallable$k;
var aFunction$1 = function (argument) {
  return isCallable$j(argument) ? argument : void 0;
};
var getBuiltIn$8 = function (namespace, method) {
  return arguments.length < 2
    ? aFunction$1(global$g[namespace])
    : global$g[namespace] && global$g[namespace][method];
};
var getBuiltIn$7 = getBuiltIn$8;
var engineUserAgent$1 = getBuiltIn$7("navigator", "userAgent") || "";
var global$f = global$j;
var userAgent$3 = engineUserAgent$1;
var process$3 = global$f.process;
var Deno$1$1 = global$f.Deno;
var versions$1 =
  (process$3 && process$3.versions) || (Deno$1$1 && Deno$1$1.version);
var v8$1 = versions$1 && versions$1.v8;
var match$1;
var version$1;
if (v8$1) {
  match$1 = v8$1.split(".");
  version$1 = match$1[0] > 0 && match$1[0] < 4 ? 1 : +(match$1[0] + match$1[1]);
}
if (!version$1 && userAgent$3) {
  match$1 = userAgent$3.match(/Edge\/(\d+)/);
  if (!match$1 || match$1[1] >= 74) {
    match$1 = userAgent$3.match(/Chrome\/(\d+)/);
    if (match$1) version$1 = +match$1[1];
  }
}
var engineV8Version$1 = version$1;
var V8_VERSION$1 = engineV8Version$1;
var fails$a = fails$d;
var nativeSymbol$1 =
  !!Object.getOwnPropertySymbols &&
  !fails$a(function () {
    var symbol = Symbol();
    return (
      !String(symbol) ||
      !(Object(symbol) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
      (!Symbol.sham && V8_VERSION$1 && V8_VERSION$1 < 41)
    );
  });
var NATIVE_SYMBOL$1$1 = nativeSymbol$1;
var useSymbolAsUid$1 =
  NATIVE_SYMBOL$1$1 && !Symbol.sham && typeof Symbol.iterator == "symbol";
var global$e = global$j;
var shared$2$1 = shared$3$1.exports;
var hasOwn$a = hasOwnProperty_1$1;
var uid$1$1 = uid$2$1;
var NATIVE_SYMBOL$2 = nativeSymbol$1;
var USE_SYMBOL_AS_UID$1$1 = useSymbolAsUid$1;
var WellKnownSymbolsStore$1 = shared$2$1("wks");
var Symbol$1$1 = global$e.Symbol;
var symbolFor$1 = Symbol$1$1 && Symbol$1$1["for"];
var createWellKnownSymbol$1 = USE_SYMBOL_AS_UID$1$1
  ? Symbol$1$1
  : (Symbol$1$1 && Symbol$1$1.withoutSetter) || uid$1$1;
var wellKnownSymbol$e = function (name) {
  if (
    !hasOwn$a(WellKnownSymbolsStore$1, name) ||
    !(NATIVE_SYMBOL$2 || typeof WellKnownSymbolsStore$1[name] == "string")
  ) {
    var description = "Symbol." + name;
    if (NATIVE_SYMBOL$2 && hasOwn$a(Symbol$1$1, name)) {
      WellKnownSymbolsStore$1[name] = Symbol$1$1[name];
    } else if (USE_SYMBOL_AS_UID$1$1 && symbolFor$1) {
      WellKnownSymbolsStore$1[name] = symbolFor$1(description);
    } else {
      WellKnownSymbolsStore$1[name] = createWellKnownSymbol$1(description);
    }
  }
  return WellKnownSymbolsStore$1[name];
};
var isCallable$i = isCallable$k;
var isObject$7 = function (it) {
  return typeof it == "object" ? it !== null : isCallable$i(it);
};
var isObject$6 = isObject$7;
var $String$3 = String;
var $TypeError$a = TypeError;
var anObject$c = function (argument) {
  if (isObject$6(argument)) return argument;
  throw $TypeError$a($String$3(argument) + " is not an object");
};
var objectDefineProperties = {};
var fails$9$1 = fails$d;
var descriptors$1 = !fails$9$1(function () {
  return (
    Object.defineProperty({}, 1, {
      get: function () {
        return 7;
      },
    })[1] != 7
  );
});
var DESCRIPTORS$9 = descriptors$1;
var fails$8$1 = fails$d;
var v8PrototypeDefineBug$1 =
  DESCRIPTORS$9 &&
  fails$8$1(function () {
    return (
      Object.defineProperty(function () {}, "prototype", {
        value: 42,
        writable: false,
      }).prototype != 42
    );
  });
var objectDefineProperty$1 = {};
var global$d = global$j;
var isObject$5$1 = isObject$7;
var document$3 = global$d.document;
var EXISTS$1$1 =
  isObject$5$1(document$3) && isObject$5$1(document$3.createElement);
var documentCreateElement$2 = function (it) {
  return EXISTS$1$1 ? document$3.createElement(it) : {};
};
var DESCRIPTORS$8 = descriptors$1;
var fails$7$1 = fails$d;
var createElement$1 = documentCreateElement$2;
var ie8DomDefine$1 =
  !DESCRIPTORS$8 &&
  !fails$7$1(function () {
    return (
      Object.defineProperty(createElement$1("div"), "a", {
        get: function () {
          return 7;
        },
      }).a != 7
    );
  });
var NATIVE_BIND$2 = functionBindNative$1;
var call$d = Function.prototype.call;
var functionCall$1 = NATIVE_BIND$2
  ? call$d.bind(call$d)
  : function () {
      return call$d.apply(call$d, arguments);
    };
var uncurryThis$8$1 = functionUncurryThis$1;
var objectIsPrototypeOf$1 = uncurryThis$8$1({}.isPrototypeOf);
var getBuiltIn$6 = getBuiltIn$8;
var isCallable$h = isCallable$k;
var isPrototypeOf$3 = objectIsPrototypeOf$1;
var USE_SYMBOL_AS_UID$2 = useSymbolAsUid$1;
var $Object$2$1 = Object;
var isSymbol$2$1 = USE_SYMBOL_AS_UID$2
  ? function (it) {
      return typeof it == "symbol";
    }
  : function (it) {
      var $Symbol = getBuiltIn$6("Symbol");
      return (
        isCallable$h($Symbol) &&
        isPrototypeOf$3($Symbol.prototype, $Object$2$1(it))
      );
    };
var $String$2 = String;
var tryToString$4 = function (argument) {
  try {
    return $String$2(argument);
  } catch (error) {
    return "Object";
  }
};
var isCallable$g = isCallable$k;
var tryToString$3 = tryToString$4;
var $TypeError$9 = TypeError;
var aCallable$7 = function (argument) {
  if (isCallable$g(argument)) return argument;
  throw $TypeError$9(tryToString$3(argument) + " is not a function");
};
var aCallable$6 = aCallable$7;
var getMethod$3 = function (V, P) {
  var func = V[P];
  return func == null ? void 0 : aCallable$6(func);
};
var call$c = functionCall$1;
var isCallable$f = isCallable$k;
var isObject$4$1 = isObject$7;
var $TypeError$8 = TypeError;
var ordinaryToPrimitive$1$1 = function (input, pref) {
  var fn, val;
  if (
    pref === "string" &&
    isCallable$f((fn = input.toString)) &&
    !isObject$4$1((val = call$c(fn, input)))
  )
    return val;
  if (
    isCallable$f((fn = input.valueOf)) &&
    !isObject$4$1((val = call$c(fn, input)))
  )
    return val;
  if (
    pref !== "string" &&
    isCallable$f((fn = input.toString)) &&
    !isObject$4$1((val = call$c(fn, input)))
  )
    return val;
  throw $TypeError$8("Can't convert object to primitive value");
};
var call$b = functionCall$1;
var isObject$3$1 = isObject$7;
var isSymbol$1$1 = isSymbol$2$1;
var getMethod$2 = getMethod$3;
var ordinaryToPrimitive$2 = ordinaryToPrimitive$1$1;
var wellKnownSymbol$d = wellKnownSymbol$e;
var $TypeError$7 = TypeError;
var TO_PRIMITIVE$1 = wellKnownSymbol$d("toPrimitive");
var toPrimitive$1$1 = function (input, pref) {
  if (!isObject$3$1(input) || isSymbol$1$1(input)) return input;
  var exoticToPrim = getMethod$2(input, TO_PRIMITIVE$1);
  var result;
  if (exoticToPrim) {
    if (pref === void 0) pref = "default";
    result = call$b(exoticToPrim, input, pref);
    if (!isObject$3$1(result) || isSymbol$1$1(result)) return result;
    throw $TypeError$7("Can't convert object to primitive value");
  }
  if (pref === void 0) pref = "number";
  return ordinaryToPrimitive$2(input, pref);
};
var toPrimitive$2 = toPrimitive$1$1;
var isSymbol$3 = isSymbol$2$1;
var toPropertyKey$2$1 = function (argument) {
  var key = toPrimitive$2(argument, "string");
  return isSymbol$3(key) ? key : key + "";
};
var DESCRIPTORS$7$1 = descriptors$1;
var IE8_DOM_DEFINE$1$1 = ie8DomDefine$1;
var V8_PROTOTYPE_DEFINE_BUG$1 = v8PrototypeDefineBug$1;
var anObject$b = anObject$c;
var toPropertyKey$1$1 = toPropertyKey$2$1;
var $TypeError$6 = TypeError;
var $defineProperty$1 = Object.defineProperty;
var $getOwnPropertyDescriptor$1$1 = Object.getOwnPropertyDescriptor;
var ENUMERABLE$1 = "enumerable";
var CONFIGURABLE$1$1 = "configurable";
var WRITABLE$1 = "writable";
objectDefineProperty$1.f = DESCRIPTORS$7$1
  ? V8_PROTOTYPE_DEFINE_BUG$1
    ? function defineProperty(O, P, Attributes) {
        anObject$b(O);
        P = toPropertyKey$1$1(P);
        anObject$b(Attributes);
        if (
          typeof O === "function" &&
          P === "prototype" &&
          "value" in Attributes &&
          WRITABLE$1 in Attributes &&
          !Attributes[WRITABLE$1]
        ) {
          var current = $getOwnPropertyDescriptor$1$1(O, P);
          if (current && current[WRITABLE$1]) {
            O[P] = Attributes.value;
            Attributes = {
              configurable:
                CONFIGURABLE$1$1 in Attributes
                  ? Attributes[CONFIGURABLE$1$1]
                  : current[CONFIGURABLE$1$1],
              enumerable:
                ENUMERABLE$1 in Attributes
                  ? Attributes[ENUMERABLE$1]
                  : current[ENUMERABLE$1],
              writable: false,
            };
          }
        }
        return $defineProperty$1(O, P, Attributes);
      }
    : $defineProperty$1
  : function defineProperty2(O, P, Attributes) {
      anObject$b(O);
      P = toPropertyKey$1$1(P);
      anObject$b(Attributes);
      if (IE8_DOM_DEFINE$1$1)
        try {
          return $defineProperty$1(O, P, Attributes);
        } catch (error) {}
      if ("get" in Attributes || "set" in Attributes)
        throw $TypeError$6("Accessors not supported");
      if ("value" in Attributes) O[P] = Attributes.value;
      return O;
    };
var ceil$1 = Math.ceil;
var floor$1 = Math.floor;
var mathTrunc$1 =
  Math.trunc ||
  function trunc(x) {
    var n = +x;
    return (n > 0 ? floor$1 : ceil$1)(n);
  };
var trunc2$1 = mathTrunc$1;
var toIntegerOrInfinity$2$1 = function (argument) {
  var number = +argument;
  return number !== number || number === 0 ? 0 : trunc2$1(number);
};
var toIntegerOrInfinity$1$1 = toIntegerOrInfinity$2$1;
var max$1 = Math.max;
var min$1$1 = Math.min;
var toAbsoluteIndex$1$1 = function (index, length) {
  var integer = toIntegerOrInfinity$1$1(index);
  return integer < 0 ? max$1(integer + length, 0) : min$1$1(integer, length);
};
var toIntegerOrInfinity$3 = toIntegerOrInfinity$2$1;
var min$2 = Math.min;
var toLength$1$1 = function (argument) {
  return argument > 0
    ? min$2(toIntegerOrInfinity$3(argument), 9007199254740991)
    : 0;
};
var toLength$2 = toLength$1$1;
var lengthOfArrayLike$2 = function (obj) {
  return toLength$2(obj.length);
};
var toIndexedObject$4 = toIndexedObject$5;
var toAbsoluteIndex$2 = toAbsoluteIndex$1$1;
var lengthOfArrayLike$1$1 = lengthOfArrayLike$2;
var createMethod$1 = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIndexedObject$4($this);
    var length = lengthOfArrayLike$1$1(O);
    var index = toAbsoluteIndex$2(fromIndex, length);
    var value;
    if (IS_INCLUDES && el != el)
      while (length > index) {
        value = O[index++];
        if (value != value) return true;
      }
    else
      for (; length > index; index++) {
        if ((IS_INCLUDES || index in O) && O[index] === el)
          return IS_INCLUDES || index || 0;
      }
    return !IS_INCLUDES && -1;
  };
};
var arrayIncludes$1 = {
  // `Array.prototype.includes` method
  // https://tc39.es/ecma262/#sec-array.prototype.includes
  includes: createMethod$1(true),
  // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof
  indexOf: createMethod$1(false),
};
var hiddenKeys$4 = {};
var uncurryThis$7$1 = functionUncurryThis$1;
var hasOwn$9 = hasOwnProperty_1$1;
var toIndexedObject$3$1 = toIndexedObject$5;
var indexOf$1 = arrayIncludes$1.indexOf;
var hiddenKeys$3$1 = hiddenKeys$4;
var push$1 = uncurryThis$7$1([].push);
var objectKeysInternal$1 = function (object, names) {
  var O = toIndexedObject$3$1(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O)
    !hasOwn$9(hiddenKeys$3$1, key) && hasOwn$9(O, key) && push$1(result, key);
  while (names.length > i)
    if (hasOwn$9(O, (key = names[i++]))) {
      ~indexOf$1(result, key) || push$1(result, key);
    }
  return result;
};
var enumBugKeys$3 = [
  "constructor",
  "hasOwnProperty",
  "isPrototypeOf",
  "propertyIsEnumerable",
  "toLocaleString",
  "toString",
  "valueOf",
];
var internalObjectKeys$1$1 = objectKeysInternal$1;
var enumBugKeys$2$1 = enumBugKeys$3;
var objectKeys$1$1 =
  Object.keys ||
  function keys(O) {
    return internalObjectKeys$1$1(O, enumBugKeys$2$1);
  };
var DESCRIPTORS$6$1 = descriptors$1;
var V8_PROTOTYPE_DEFINE_BUG$2 = v8PrototypeDefineBug$1;
var definePropertyModule$4 = objectDefineProperty$1;
var anObject$a = anObject$c;
var toIndexedObject$2$1 = toIndexedObject$5;
var objectKeys$2 = objectKeys$1$1;
objectDefineProperties.f =
  DESCRIPTORS$6$1 && !V8_PROTOTYPE_DEFINE_BUG$2
    ? Object.defineProperties
    : function defineProperties(O, Properties) {
        anObject$a(O);
        var props = toIndexedObject$2$1(Properties);
        var keys5 = objectKeys$2(Properties);
        var length = keys5.length;
        var index = 0;
        var key;
        while (length > index)
          definePropertyModule$4.f(O, (key = keys5[index++]), props[key]);
        return O;
      };
var getBuiltIn$5 = getBuiltIn$8;
var html$2 = getBuiltIn$5("document", "documentElement");
var shared$1$1 = shared$3$1.exports;
var uid$3 = uid$2$1;
var keys2 = shared$1$1("keys");
var sharedKey$3 = function (key) {
  return keys2[key] || (keys2[key] = uid$3(key));
};
var anObject$9 = anObject$c;
var definePropertiesModule = objectDefineProperties;
var enumBugKeys$1$1 = enumBugKeys$3;
var hiddenKeys$2$1 = hiddenKeys$4;
var html$1 = html$2;
var documentCreateElement$1 = documentCreateElement$2;
var sharedKey$2 = sharedKey$3;
var GT = ">";
var LT = "<";
var PROTOTYPE = "prototype";
var SCRIPT = "script";
var IE_PROTO$1 = sharedKey$2("IE_PROTO");
var EmptyConstructor = function () {};
var scriptTag = function (content) {
  return LT + SCRIPT + GT + content + LT + "/" + SCRIPT + GT;
};
var NullProtoObjectViaActiveX = function (activeXDocument3) {
  activeXDocument3.write(scriptTag(""));
  activeXDocument3.close();
  var temp = activeXDocument3.parentWindow.Object;
  activeXDocument3 = null;
  return temp;
};
var NullProtoObjectViaIFrame = function () {
  var iframe = documentCreateElement$1("iframe");
  var JS = "java" + SCRIPT + ":";
  var iframeDocument;
  iframe.style.display = "none";
  html$1.appendChild(iframe);
  iframe.src = String(JS);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(scriptTag("document.F=Object"));
  iframeDocument.close();
  return iframeDocument.F;
};
var activeXDocument;
var NullProtoObject = function () {
  try {
    activeXDocument = new ActiveXObject("htmlfile");
  } catch (error) {}
  NullProtoObject =
    typeof document != "undefined"
      ? document.domain && activeXDocument
        ? NullProtoObjectViaActiveX(activeXDocument)
        : NullProtoObjectViaIFrame()
      : NullProtoObjectViaActiveX(activeXDocument);
  var length = enumBugKeys$1$1.length;
  while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys$1$1[length]];
  return NullProtoObject();
};
hiddenKeys$2$1[IE_PROTO$1] = true;
var objectCreate =
  Object.create ||
  function create(O, Properties) {
    var result;
    if (O !== null) {
      EmptyConstructor[PROTOTYPE] = anObject$9(O);
      result = new EmptyConstructor();
      EmptyConstructor[PROTOTYPE] = null;
      result[IE_PROTO$1] = O;
    } else result = NullProtoObject();
    return Properties === void 0
      ? result
      : definePropertiesModule.f(result, Properties);
  };
var wellKnownSymbol$c = wellKnownSymbol$e;
var create$1 = objectCreate;
var defineProperty$3 = objectDefineProperty$1.f;
var UNSCOPABLES = wellKnownSymbol$c("unscopables");
var ArrayPrototype$1 = Array.prototype;
if (ArrayPrototype$1[UNSCOPABLES] == void 0) {
  defineProperty$3(ArrayPrototype$1, UNSCOPABLES, {
    configurable: true,
    value: create$1(null),
  });
}
var addToUnscopables$1 = function (key) {
  ArrayPrototype$1[UNSCOPABLES][key] = true;
};
var iterators = {};
var uncurryThis$6$1 = functionUncurryThis$1;
var isCallable$e = isCallable$k;
var store$1$1 = sharedStore$1;
var functionToString$1 = uncurryThis$6$1(Function.toString);
if (!isCallable$e(store$1$1.inspectSource)) {
  store$1$1.inspectSource = function (it) {
    return functionToString$1(it);
  };
}
var inspectSource$4 = store$1$1.inspectSource;
var global$c = global$j;
var isCallable$d = isCallable$k;
var inspectSource$3 = inspectSource$4;
var WeakMap$1$1 = global$c.WeakMap;
var nativeWeakMap$1 =
  isCallable$d(WeakMap$1$1) && /native code/.test(inspectSource$3(WeakMap$1$1));
var createPropertyDescriptor$3 = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value,
  };
};
var DESCRIPTORS$5$1 = descriptors$1;
var definePropertyModule$3 = objectDefineProperty$1;
var createPropertyDescriptor$2$1 = createPropertyDescriptor$3;
var createNonEnumerableProperty$4 = DESCRIPTORS$5$1
  ? function (object, key, value) {
      return definePropertyModule$3.f(
        object,
        key,
        createPropertyDescriptor$2$1(1, value)
      );
    }
  : function (object, key, value) {
      object[key] = value;
      return object;
    };
var NATIVE_WEAK_MAP$1 = nativeWeakMap$1;
var global$b = global$j;
var uncurryThis$5$1 = functionUncurryThis$1;
var isObject$2$1 = isObject$7;
var createNonEnumerableProperty$3 = createNonEnumerableProperty$4;
var hasOwn$8 = hasOwnProperty_1$1;
var shared$4 = sharedStore$1;
var sharedKey$1$1 = sharedKey$3;
var hiddenKeys$1$1 = hiddenKeys$4;
var OBJECT_ALREADY_INITIALIZED$1 = "Object already initialized";
var TypeError$2 = global$b.TypeError;
var WeakMap$3 = global$b.WeakMap;
var set$1;
var get$1;
var has$1;
var enforce$1 = function (it) {
  return has$1(it) ? get$1(it) : set$1(it, {});
};
var getterFor$1 = function (TYPE) {
  return function (it) {
    var state;
    if (!isObject$2$1(it) || (state = get$1(it)).type !== TYPE) {
      throw TypeError$2("Incompatible receiver, " + TYPE + " required");
    }
    return state;
  };
};
if (NATIVE_WEAK_MAP$1 || shared$4.state) {
  store$4 = shared$4.state || (shared$4.state = new WeakMap$3());
  wmget$1 = uncurryThis$5$1(store$4.get);
  wmhas$1 = uncurryThis$5$1(store$4.has);
  wmset$1 = uncurryThis$5$1(store$4.set);
  set$1 = function (it, metadata) {
    if (wmhas$1(store$4, it))
      throw new TypeError$2(OBJECT_ALREADY_INITIALIZED$1);
    metadata.facade = it;
    wmset$1(store$4, it, metadata);
    return metadata;
  };
  get$1 = function (it) {
    return wmget$1(store$4, it) || {};
  };
  has$1 = function (it) {
    return wmhas$1(store$4, it);
  };
} else {
  STATE$1 = sharedKey$1$1("state");
  hiddenKeys$1$1[STATE$1] = true;
  set$1 = function (it, metadata) {
    if (hasOwn$8(it, STATE$1))
      throw new TypeError$2(OBJECT_ALREADY_INITIALIZED$1);
    metadata.facade = it;
    createNonEnumerableProperty$3(it, STATE$1, metadata);
    return metadata;
  };
  get$1 = function (it) {
    return hasOwn$8(it, STATE$1) ? it[STATE$1] : {};
  };
  has$1 = function (it) {
    return hasOwn$8(it, STATE$1);
  };
}
var store$4;
var wmget$1;
var wmhas$1;
var wmset$1;
var STATE$1;
var internalState$1 = {
  set: set$1,
  get: get$1,
  has: has$1,
  enforce: enforce$1,
  getterFor: getterFor$1,
};
var objectGetOwnPropertyDescriptor$1 = {};
var objectPropertyIsEnumerable$1 = {};
var $propertyIsEnumerable$1 = {}.propertyIsEnumerable;
var getOwnPropertyDescriptor$2 = Object.getOwnPropertyDescriptor;
var NASHORN_BUG$1 =
  getOwnPropertyDescriptor$2 && !$propertyIsEnumerable$1.call({ 1: 2 }, 1);
objectPropertyIsEnumerable$1.f = NASHORN_BUG$1
  ? function propertyIsEnumerable(V) {
      var descriptor = getOwnPropertyDescriptor$2(this, V);
      return !!descriptor && descriptor.enumerable;
    }
  : $propertyIsEnumerable$1;
var DESCRIPTORS$4$1 = descriptors$1;
var call$a = functionCall$1;
var propertyIsEnumerableModule$2 = objectPropertyIsEnumerable$1;
var createPropertyDescriptor$1$1 = createPropertyDescriptor$3;
var toIndexedObject$1$1 = toIndexedObject$5;
var toPropertyKey$3 = toPropertyKey$2$1;
var hasOwn$7 = hasOwnProperty_1$1;
var IE8_DOM_DEFINE$2 = ie8DomDefine$1;
var $getOwnPropertyDescriptor$2 = Object.getOwnPropertyDescriptor;
objectGetOwnPropertyDescriptor$1.f = DESCRIPTORS$4$1
  ? $getOwnPropertyDescriptor$2
  : function getOwnPropertyDescriptor(O, P) {
      O = toIndexedObject$1$1(O);
      P = toPropertyKey$3(P);
      if (IE8_DOM_DEFINE$2)
        try {
          return $getOwnPropertyDescriptor$2(O, P);
        } catch (error) {}
      if (hasOwn$7(O, P))
        return createPropertyDescriptor$1$1(
          !call$a(propertyIsEnumerableModule$2.f, O, P),
          O[P]
        );
    };
var makeBuiltIn$2$1 = { exports: {} };
var DESCRIPTORS$3$1 = descriptors$1;
var hasOwn$6$1 = hasOwnProperty_1$1;
var FunctionPrototype$1$1 = Function.prototype;
var getDescriptor$1 = DESCRIPTORS$3$1 && Object.getOwnPropertyDescriptor;
var EXISTS$2 = hasOwn$6$1(FunctionPrototype$1$1, "name");
var PROPER$1 = EXISTS$2 && function something() {}.name === "something";
var CONFIGURABLE$2 =
  EXISTS$2 &&
  (!DESCRIPTORS$3$1 ||
    (DESCRIPTORS$3$1 &&
      getDescriptor$1(FunctionPrototype$1$1, "name").configurable));
var functionName$1 = {
  EXISTS: EXISTS$2,
  PROPER: PROPER$1,
  CONFIGURABLE: CONFIGURABLE$2,
};
var fails$6$1 = fails$d;
var isCallable$c = isCallable$k;
var hasOwn$5$1 = hasOwnProperty_1$1;
var DESCRIPTORS$2$1 = descriptors$1;
var CONFIGURABLE_FUNCTION_NAME$1 = functionName$1.CONFIGURABLE;
var inspectSource$2$1 = inspectSource$4;
var InternalStateModule$2 = internalState$1;
var enforceInternalState$1 = InternalStateModule$2.enforce;
var getInternalState$1 = InternalStateModule$2.get;
var defineProperty$2$1 = Object.defineProperty;
var CONFIGURABLE_LENGTH$1 =
  DESCRIPTORS$2$1 &&
  !fails$6$1(function () {
    return (
      defineProperty$2$1(function () {}, "length", { value: 8 }).length !== 8
    );
  });
var TEMPLATE$1 = String(String).split("String");
var makeBuiltIn$1$1 = (makeBuiltIn$2$1.exports = function (
  value,
  name,
  options
) {
  if (String(name).slice(0, 7) === "Symbol(") {
    name = "[" + String(name).replace(/^Symbol\(([^)]*)\)/, "$1") + "]";
  }
  if (options && options.getter) name = "get " + name;
  if (options && options.setter) name = "set " + name;
  if (
    !hasOwn$5$1(value, "name") ||
    (CONFIGURABLE_FUNCTION_NAME$1 && value.name !== name)
  ) {
    if (DESCRIPTORS$2$1)
      defineProperty$2$1(value, "name", { value: name, configurable: true });
    else value.name = name;
  }
  if (
    CONFIGURABLE_LENGTH$1 &&
    options &&
    hasOwn$5$1(options, "arity") &&
    value.length !== options.arity
  ) {
    defineProperty$2$1(value, "length", { value: options.arity });
  }
  try {
    if (options && hasOwn$5$1(options, "constructor") && options.constructor) {
      if (DESCRIPTORS$2$1)
        defineProperty$2$1(value, "prototype", { writable: false });
    } else if (value.prototype) value.prototype = void 0;
  } catch (error) {}
  var state = enforceInternalState$1(value);
  if (!hasOwn$5$1(state, "source")) {
    state.source = TEMPLATE$1.join(typeof name == "string" ? name : "");
  }
  return value;
});
Function.prototype.toString = makeBuiltIn$1$1(function toString() {
  return (
    (isCallable$c(this) && getInternalState$1(this).source) ||
    inspectSource$2$1(this)
  );
}, "toString");
var isCallable$b = isCallable$k;
var definePropertyModule$2$1 = objectDefineProperty$1;
var makeBuiltIn$3 = makeBuiltIn$2$1.exports;
var defineGlobalProperty$1$1 = defineGlobalProperty$3$1;
var defineBuiltIn$6 = function (O, key, value, options) {
  if (!options) options = {};
  var simple = options.enumerable;
  var name = options.name !== void 0 ? options.name : key;
  if (isCallable$b(value)) makeBuiltIn$3(value, name, options);
  if (options.global) {
    if (simple) O[key] = value;
    else defineGlobalProperty$1$1(key, value);
  } else {
    try {
      if (!options.unsafe) delete O[key];
      else if (O[key]) simple = true;
    } catch (error) {}
    if (simple) O[key] = value;
    else
      definePropertyModule$2$1.f(O, key, {
        value,
        enumerable: false,
        configurable: !options.nonConfigurable,
        writable: !options.nonWritable,
      });
  }
  return O;
};
var objectGetOwnPropertyNames$1 = {};
var internalObjectKeys$2 = objectKeysInternal$1;
var enumBugKeys$4 = enumBugKeys$3;
var hiddenKeys$5 = enumBugKeys$4.concat("length", "prototype");
objectGetOwnPropertyNames$1.f =
  Object.getOwnPropertyNames ||
  function getOwnPropertyNames(O) {
    return internalObjectKeys$2(O, hiddenKeys$5);
  };
var objectGetOwnPropertySymbols$1 = {};
objectGetOwnPropertySymbols$1.f = Object.getOwnPropertySymbols;
var getBuiltIn$4 = getBuiltIn$8;
var uncurryThis$4$1 = functionUncurryThis$1;
var getOwnPropertyNamesModule$1 = objectGetOwnPropertyNames$1;
var getOwnPropertySymbolsModule$2 = objectGetOwnPropertySymbols$1;
var anObject$8 = anObject$c;
var concat$2 = uncurryThis$4$1([].concat);
var ownKeys$1$1 =
  getBuiltIn$4("Reflect", "ownKeys") ||
  function ownKeys(it) {
    var keys5 = getOwnPropertyNamesModule$1.f(anObject$8(it));
    var getOwnPropertySymbols = getOwnPropertySymbolsModule$2.f;
    return getOwnPropertySymbols
      ? concat$2(keys5, getOwnPropertySymbols(it))
      : keys5;
  };
var hasOwn$4$1 = hasOwnProperty_1$1;
var ownKeys2$1 = ownKeys$1$1;
var getOwnPropertyDescriptorModule$1 = objectGetOwnPropertyDescriptor$1;
var definePropertyModule$1$1 = objectDefineProperty$1;
var copyConstructorProperties$1$1 = function (target, source, exceptions) {
  var keys5 = ownKeys2$1(source);
  var defineProperty7 = definePropertyModule$1$1.f;
  var getOwnPropertyDescriptor5 = getOwnPropertyDescriptorModule$1.f;
  for (var i = 0; i < keys5.length; i++) {
    var key = keys5[i];
    if (
      !hasOwn$4$1(target, key) &&
      !(exceptions && hasOwn$4$1(exceptions, key))
    ) {
      defineProperty7(target, key, getOwnPropertyDescriptor5(source, key));
    }
  }
};
var fails$5$1 = fails$d;
var isCallable$a$1 = isCallable$k;
var replacement$1 = /#|\.prototype\./;
var isForced$2 = function (feature, detection) {
  var value = data$1[normalize$1(feature)];
  return value == POLYFILL$1
    ? true
    : value == NATIVE$1
    ? false
    : isCallable$a$1(detection)
    ? fails$5$1(detection)
    : !!detection;
};
var normalize$1 = (isForced$2.normalize = function (string) {
  return String(string).replace(replacement$1, ".").toLowerCase();
});
var data$1 = (isForced$2.data = {});
var NATIVE$1 = (isForced$2.NATIVE = "N");
var POLYFILL$1 = (isForced$2.POLYFILL = "P");
var isForced_1$1 = isForced$2;
var global$a$1 = global$j;
var getOwnPropertyDescriptor$1$1 = objectGetOwnPropertyDescriptor$1.f;
var createNonEnumerableProperty$2$1 = createNonEnumerableProperty$4;
var defineBuiltIn$5 = defineBuiltIn$6;
var defineGlobalProperty$4 = defineGlobalProperty$3$1;
var copyConstructorProperties$2 = copyConstructorProperties$1$1;
var isForced$1$1 = isForced_1$1;
var _export$1 = function (options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var FORCED, target, key, targetProperty, sourceProperty, descriptor;
  if (GLOBAL) {
    target = global$a$1;
  } else if (STATIC) {
    target = global$a$1[TARGET] || defineGlobalProperty$4(TARGET, {});
  } else {
    target = (global$a$1[TARGET] || {}).prototype;
  }
  if (target)
    for (key in source) {
      sourceProperty = source[key];
      if (options.dontCallGetSet) {
        descriptor = getOwnPropertyDescriptor$1$1(target, key);
        targetProperty = descriptor && descriptor.value;
      } else targetProperty = target[key];
      FORCED = isForced$1$1(
        GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key,
        options.forced
      );
      if (!FORCED && targetProperty !== void 0) {
        if (typeof sourceProperty == typeof targetProperty) continue;
        copyConstructorProperties$2(sourceProperty, targetProperty);
      }
      if (options.sham || (targetProperty && targetProperty.sham)) {
        createNonEnumerableProperty$2$1(sourceProperty, "sham", true);
      }
      defineBuiltIn$5(target, key, sourceProperty, options);
    }
};
var fails$4$1 = fails$d;
var correctPrototypeGetter = !fails$4$1(function () {
  function F() {}
  F.prototype.constructor = null;
  return Object.getPrototypeOf(new F()) !== F.prototype;
});
var hasOwn$3$1 = hasOwnProperty_1$1;
var isCallable$9$1 = isCallable$k;
var toObject$3 = toObject$2$1;
var sharedKey$4 = sharedKey$3;
var CORRECT_PROTOTYPE_GETTER = correctPrototypeGetter;
var IE_PROTO = sharedKey$4("IE_PROTO");
var $Object$1$1 = Object;
var ObjectPrototype = $Object$1$1.prototype;
var objectGetPrototypeOf = CORRECT_PROTOTYPE_GETTER
  ? $Object$1$1.getPrototypeOf
  : function (O) {
      var object = toObject$3(O);
      if (hasOwn$3$1(object, IE_PROTO)) return object[IE_PROTO];
      var constructor = object.constructor;
      if (isCallable$9$1(constructor) && object instanceof constructor) {
        return constructor.prototype;
      }
      return object instanceof $Object$1$1 ? ObjectPrototype : null;
    };
var fails$3$1 = fails$d;
var isCallable$8$1 = isCallable$k;
var getPrototypeOf$1 = objectGetPrototypeOf;
var defineBuiltIn$4 = defineBuiltIn$6;
var wellKnownSymbol$b = wellKnownSymbol$e;
var ITERATOR$5 = wellKnownSymbol$b("iterator");
var BUGGY_SAFARI_ITERATORS$1 = false;
var IteratorPrototype$2;
var PrototypeOfArrayIteratorPrototype;
var arrayIterator;
if ([].keys) {
  arrayIterator = [].keys();
  if (!("next" in arrayIterator)) BUGGY_SAFARI_ITERATORS$1 = true;
  else {
    PrototypeOfArrayIteratorPrototype = getPrototypeOf$1(
      getPrototypeOf$1(arrayIterator)
    );
    if (PrototypeOfArrayIteratorPrototype !== Object.prototype)
      IteratorPrototype$2 = PrototypeOfArrayIteratorPrototype;
  }
}
var NEW_ITERATOR_PROTOTYPE =
  IteratorPrototype$2 == void 0 ||
  fails$3$1(function () {
    var test3 = {};
    return IteratorPrototype$2[ITERATOR$5].call(test3) !== test3;
  });
if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype$2 = {};
if (!isCallable$8$1(IteratorPrototype$2[ITERATOR$5])) {
  defineBuiltIn$4(IteratorPrototype$2, ITERATOR$5, function () {
    return this;
  });
}
var iteratorsCore = {
  IteratorPrototype: IteratorPrototype$2,
  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS$1,
};
var defineProperty$1$1 = objectDefineProperty$1.f;
var hasOwn$2$1 = hasOwnProperty_1$1;
var wellKnownSymbol$a = wellKnownSymbol$e;
var TO_STRING_TAG$3 = wellKnownSymbol$a("toStringTag");
var setToStringTag$3 = function (target, TAG, STATIC) {
  if (target && !STATIC) target = target.prototype;
  if (target && !hasOwn$2$1(target, TO_STRING_TAG$3)) {
    defineProperty$1$1(target, TO_STRING_TAG$3, {
      configurable: true,
      value: TAG,
    });
  }
};
var IteratorPrototype$1 = iteratorsCore.IteratorPrototype;
var create2 = objectCreate;
var createPropertyDescriptor$4 = createPropertyDescriptor$3;
var setToStringTag$2 = setToStringTag$3;
var Iterators$4 = iterators;
var returnThis$1 = function () {
  return this;
};
var createIteratorConstructor$1 = function (
  IteratorConstructor,
  NAME,
  next,
  ENUMERABLE_NEXT
) {
  var TO_STRING_TAG3 = NAME + " Iterator";
  IteratorConstructor.prototype = create2(IteratorPrototype$1, {
    next: createPropertyDescriptor$4(+!ENUMERABLE_NEXT, next),
  });
  setToStringTag$2(IteratorConstructor, TO_STRING_TAG3, false);
  Iterators$4[TO_STRING_TAG3] = returnThis$1;
  return IteratorConstructor;
};
var isCallable$7$1 = isCallable$k;
var $String$1$1 = String;
var $TypeError$5$1 = TypeError;
var aPossiblePrototype$1 = function (argument) {
  if (typeof argument == "object" || isCallable$7$1(argument)) return argument;
  throw $TypeError$5$1(
    "Can't set " + $String$1$1(argument) + " as a prototype"
  );
};
var uncurryThis$3$1 = functionUncurryThis$1;
var anObject$7 = anObject$c;
var aPossiblePrototype = aPossiblePrototype$1;
var objectSetPrototypeOf =
  Object.setPrototypeOf ||
  ("__proto__" in {}
    ? (function () {
        var CORRECT_SETTER = false;
        var test3 = {};
        var setter;
        try {
          setter = uncurryThis$3$1(
            Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set
          );
          setter(test3, []);
          CORRECT_SETTER = test3 instanceof Array;
        } catch (error) {}
        return function setPrototypeOf3(O, proto) {
          anObject$7(O);
          aPossiblePrototype(proto);
          if (CORRECT_SETTER) setter(O, proto);
          else O.__proto__ = proto;
          return O;
        };
      })()
    : void 0);
var $$6 = _export$1;
var call$9 = functionCall$1;
var FunctionName = functionName$1;
var isCallable$6$1 = isCallable$k;
var createIteratorConstructor = createIteratorConstructor$1;
var getPrototypeOf = objectGetPrototypeOf;
var setPrototypeOf$1 = objectSetPrototypeOf;
var setToStringTag$1 = setToStringTag$3;
var createNonEnumerableProperty$1$1 = createNonEnumerableProperty$4;
var defineBuiltIn$3 = defineBuiltIn$6;
var wellKnownSymbol$9 = wellKnownSymbol$e;
var Iterators$3 = iterators;
var IteratorsCore = iteratorsCore;
var PROPER_FUNCTION_NAME$1 = FunctionName.PROPER;
var CONFIGURABLE_FUNCTION_NAME$2 = FunctionName.CONFIGURABLE;
var IteratorPrototype = IteratorsCore.IteratorPrototype;
var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
var ITERATOR$4 = wellKnownSymbol$9("iterator");
var KEYS = "keys";
var VALUES = "values";
var ENTRIES = "entries";
var returnThis = function () {
  return this;
};
var defineIterator$1 = function (
  Iterable,
  NAME,
  IteratorConstructor,
  next,
  DEFAULT,
  IS_SET,
  FORCED
) {
  createIteratorConstructor(IteratorConstructor, NAME, next);
  var getIterationMethod = function (KIND) {
    if (KIND === DEFAULT && defaultIterator) return defaultIterator;
    if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype)
      return IterablePrototype[KIND];
    switch (KIND) {
      case KEYS:
        return function keys5() {
          return new IteratorConstructor(this, KIND);
        };
      case VALUES:
        return function values3() {
          return new IteratorConstructor(this, KIND);
        };
      case ENTRIES:
        return function entries() {
          return new IteratorConstructor(this, KIND);
        };
    }
    return function () {
      return new IteratorConstructor(this);
    };
  };
  var TO_STRING_TAG3 = NAME + " Iterator";
  var INCORRECT_VALUES_NAME = false;
  var IterablePrototype = Iterable.prototype;
  var nativeIterator =
    IterablePrototype[ITERATOR$4] ||
    IterablePrototype["@@iterator"] ||
    (DEFAULT && IterablePrototype[DEFAULT]);
  var defaultIterator =
    (!BUGGY_SAFARI_ITERATORS && nativeIterator) || getIterationMethod(DEFAULT);
  var anyNativeIterator =
    NAME == "Array"
      ? IterablePrototype.entries || nativeIterator
      : nativeIterator;
  var CurrentIteratorPrototype, methods, KEY;
  if (anyNativeIterator) {
    CurrentIteratorPrototype = getPrototypeOf(
      anyNativeIterator.call(new Iterable())
    );
    if (
      CurrentIteratorPrototype !== Object.prototype &&
      CurrentIteratorPrototype.next
    ) {
      if (getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
        if (setPrototypeOf$1) {
          setPrototypeOf$1(CurrentIteratorPrototype, IteratorPrototype);
        } else if (!isCallable$6$1(CurrentIteratorPrototype[ITERATOR$4])) {
          defineBuiltIn$3(CurrentIteratorPrototype, ITERATOR$4, returnThis);
        }
      }
      setToStringTag$1(CurrentIteratorPrototype, TO_STRING_TAG3, true);
    }
  }
  if (
    PROPER_FUNCTION_NAME$1 &&
    DEFAULT == VALUES &&
    nativeIterator &&
    nativeIterator.name !== VALUES
  ) {
    if (CONFIGURABLE_FUNCTION_NAME$2) {
      createNonEnumerableProperty$1$1(IterablePrototype, "name", VALUES);
    } else {
      INCORRECT_VALUES_NAME = true;
      defaultIterator = function values3() {
        return call$9(nativeIterator, this);
      };
    }
  }
  if (DEFAULT) {
    methods = {
      values: getIterationMethod(VALUES),
      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
      entries: getIterationMethod(ENTRIES),
    };
    if (FORCED)
      for (KEY in methods) {
        if (
          BUGGY_SAFARI_ITERATORS ||
          INCORRECT_VALUES_NAME ||
          !(KEY in IterablePrototype)
        ) {
          defineBuiltIn$3(IterablePrototype, KEY, methods[KEY]);
        }
      }
    else
      $$6(
        {
          target: NAME,
          proto: true,
          forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME,
        },
        methods
      );
  }
  if (IterablePrototype[ITERATOR$4] !== defaultIterator) {
    defineBuiltIn$3(IterablePrototype, ITERATOR$4, defaultIterator, {
      name: DEFAULT,
    });
  }
  Iterators$3[NAME] = defaultIterator;
  return methods;
};
var toIndexedObject$6 = toIndexedObject$5;
var addToUnscopables = addToUnscopables$1;
var Iterators$2 = iterators;
var InternalStateModule$1 = internalState$1;
var defineProperty3$1 = objectDefineProperty$1.f;
var defineIterator = defineIterator$1;
var DESCRIPTORS$1$1 = descriptors$1;
var ARRAY_ITERATOR = "Array Iterator";
var setInternalState$1 = InternalStateModule$1.set;
var getInternalState$2 = InternalStateModule$1.getterFor(ARRAY_ITERATOR);
var es_array_iterator = defineIterator(
  Array,
  "Array",
  function (iterated, kind) {
    setInternalState$1(this, {
      type: ARRAY_ITERATOR,
      target: toIndexedObject$6(iterated),
      // target
      index: 0,
      // next index
      kind,
      // kind
    });
  },
  function () {
    var state = getInternalState$2(this);
    var target = state.target;
    var kind = state.kind;
    var index = state.index++;
    if (!target || index >= target.length) {
      state.target = void 0;
      return { value: void 0, done: true };
    }
    if (kind == "keys") return { value: index, done: false };
    if (kind == "values") return { value: target[index], done: false };
    return { value: [index, target[index]], done: false };
  },
  "values"
);
var values = (Iterators$2.Arguments = Iterators$2.Array);
addToUnscopables("keys");
addToUnscopables("values");
addToUnscopables("entries");
if (DESCRIPTORS$1$1 && values.name !== "values")
  try {
    defineProperty3$1(values, "name", { value: "values" });
  } catch (error) {}
var domIterables = {
  CSSRuleList: 0,
  CSSStyleDeclaration: 0,
  CSSValueList: 0,
  ClientRectList: 0,
  DOMRectList: 0,
  DOMStringList: 0,
  DOMTokenList: 1,
  DataTransferItemList: 0,
  FileList: 0,
  HTMLAllCollection: 0,
  HTMLCollection: 0,
  HTMLFormElement: 0,
  HTMLSelectElement: 0,
  MediaList: 0,
  MimeTypeArray: 0,
  NamedNodeMap: 0,
  NodeList: 1,
  PaintRequestList: 0,
  Plugin: 0,
  PluginArray: 0,
  SVGLengthList: 0,
  SVGNumberList: 0,
  SVGPathSegList: 0,
  SVGPointList: 0,
  SVGStringList: 0,
  SVGTransformList: 0,
  SourceBufferList: 0,
  StyleSheetList: 0,
  TextTrackCueList: 0,
  TextTrackList: 0,
  TouchList: 0,
};
var documentCreateElement$3 = documentCreateElement$2;
var classList = documentCreateElement$3("span").classList;
var DOMTokenListPrototype$1 =
  classList && classList.constructor && classList.constructor.prototype;
var domTokenListPrototype =
  DOMTokenListPrototype$1 === Object.prototype
    ? void 0
    : DOMTokenListPrototype$1;
var global$9$1 = global$j;
var DOMIterables = domIterables;
var DOMTokenListPrototype = domTokenListPrototype;
var ArrayIteratorMethods = es_array_iterator;
var createNonEnumerableProperty$5 = createNonEnumerableProperty$4;
var wellKnownSymbol$8 = wellKnownSymbol$e;
var ITERATOR$3 = wellKnownSymbol$8("iterator");
var TO_STRING_TAG$2 = wellKnownSymbol$8("toStringTag");
var ArrayValues = ArrayIteratorMethods.values;
var handlePrototype = function (CollectionPrototype, COLLECTION_NAME) {
  if (CollectionPrototype) {
    if (CollectionPrototype[ITERATOR$3] !== ArrayValues)
      try {
        createNonEnumerableProperty$5(
          CollectionPrototype,
          ITERATOR$3,
          ArrayValues
        );
      } catch (error) {
        CollectionPrototype[ITERATOR$3] = ArrayValues;
      }
    if (!CollectionPrototype[TO_STRING_TAG$2]) {
      createNonEnumerableProperty$5(
        CollectionPrototype,
        TO_STRING_TAG$2,
        COLLECTION_NAME
      );
    }
    if (DOMIterables[COLLECTION_NAME])
      for (var METHOD_NAME in ArrayIteratorMethods) {
        if (
          CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME]
        )
          try {
            createNonEnumerableProperty$5(
              CollectionPrototype,
              METHOD_NAME,
              ArrayIteratorMethods[METHOD_NAME]
            );
          } catch (error) {
            CollectionPrototype[METHOD_NAME] =
              ArrayIteratorMethods[METHOD_NAME];
          }
      }
  }
};
for (COLLECTION_NAME in DOMIterables) {
  handlePrototype(
    global$9$1[COLLECTION_NAME] && global$9$1[COLLECTION_NAME].prototype,
    COLLECTION_NAME
  );
}
var COLLECTION_NAME;
handlePrototype(DOMTokenListPrototype, "DOMTokenList");
var classof$4 = classofRaw$1;
var global$8$1 = global$j;
var engineIsNode = classof$4(global$8$1.process) == "process";
var getBuiltIn$3$1 = getBuiltIn$8;
var definePropertyModule$5 = objectDefineProperty$1;
var wellKnownSymbol$7 = wellKnownSymbol$e;
var DESCRIPTORS$a = descriptors$1;
var SPECIES$2 = wellKnownSymbol$7("species");
var setSpecies$1 = function (CONSTRUCTOR_NAME) {
  var Constructor = getBuiltIn$3$1(CONSTRUCTOR_NAME);
  var defineProperty7 = definePropertyModule$5.f;
  if (DESCRIPTORS$a && Constructor && !Constructor[SPECIES$2]) {
    defineProperty7(Constructor, SPECIES$2, {
      configurable: true,
      get: function () {
        return this;
      },
    });
  }
};
var isPrototypeOf$2 = objectIsPrototypeOf$1;
var $TypeError$4$1 = TypeError;
var anInstance$1 = function (it, Prototype) {
  if (isPrototypeOf$2(Prototype, it)) return it;
  throw $TypeError$4$1("Incorrect invocation");
};
var wellKnownSymbol$6 = wellKnownSymbol$e;
var TO_STRING_TAG$1 = wellKnownSymbol$6("toStringTag");
var test = {};
test[TO_STRING_TAG$1] = "z";
var toStringTagSupport = String(test) === "[object z]";
var TO_STRING_TAG_SUPPORT = toStringTagSupport;
var isCallable$5$1 = isCallable$k;
var classofRaw$2 = classofRaw$1;
var wellKnownSymbol$5 = wellKnownSymbol$e;
var TO_STRING_TAG = wellKnownSymbol$5("toStringTag");
var $Object$5 = Object;
var CORRECT_ARGUMENTS =
  classofRaw$2(
    (function () {
      return arguments;
    })()
  ) == "Arguments";
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (error) {}
};
var classof$3 = TO_STRING_TAG_SUPPORT
  ? classofRaw$2
  : function (it) {
      var O, tag, result;
      return it === void 0
        ? "Undefined"
        : it === null
        ? "Null"
        : typeof (tag = tryGet((O = $Object$5(it)), TO_STRING_TAG)) == "string"
        ? tag
        : CORRECT_ARGUMENTS
        ? classofRaw$2(O)
        : (result = classofRaw$2(O)) == "Object" && isCallable$5$1(O.callee)
        ? "Arguments"
        : result;
    };
var uncurryThis$2$1 = functionUncurryThis$1;
var fails$2$1 = fails$d;
var isCallable$4$1 = isCallable$k;
var classof$2 = classof$3;
var getBuiltIn$2$1 = getBuiltIn$8;
var inspectSource$1$1 = inspectSource$4;
var noop = function () {};
var empty = [];
var construct = getBuiltIn$2$1("Reflect", "construct");
var constructorRegExp = /^\s*(?:class|function)\b/;
var exec = uncurryThis$2$1(constructorRegExp.exec);
var INCORRECT_TO_STRING = !constructorRegExp.exec(noop);
var isConstructorModern = function isConstructor(argument) {
  if (!isCallable$4$1(argument)) return false;
  try {
    construct(noop, empty, argument);
    return true;
  } catch (error) {
    return false;
  }
};
var isConstructorLegacy = function isConstructor2(argument) {
  if (!isCallable$4$1(argument)) return false;
  switch (classof$2(argument)) {
    case "AsyncFunction":
    case "GeneratorFunction":
    case "AsyncGeneratorFunction":
      return false;
  }
  try {
    return (
      INCORRECT_TO_STRING ||
      !!exec(constructorRegExp, inspectSource$1$1(argument))
    );
  } catch (error) {
    return true;
  }
};
isConstructorLegacy.sham = true;
var isConstructor$1 =
  !construct ||
  fails$2$1(function () {
    var called;
    return (
      isConstructorModern(isConstructorModern.call) ||
      !isConstructorModern(Object) ||
      !isConstructorModern(function () {
        called = true;
      }) ||
      called
    );
  })
    ? isConstructorLegacy
    : isConstructorModern;
var isConstructor3 = isConstructor$1;
var tryToString$2 = tryToString$4;
var $TypeError$3$1 = TypeError;
var aConstructor$1 = function (argument) {
  if (isConstructor3(argument)) return argument;
  throw $TypeError$3$1(tryToString$2(argument) + " is not a constructor");
};
var anObject$6 = anObject$c;
var aConstructor = aConstructor$1;
var wellKnownSymbol$4 = wellKnownSymbol$e;
var SPECIES$1 = wellKnownSymbol$4("species");
var speciesConstructor$1 = function (O, defaultConstructor) {
  var C = anObject$6(O).constructor;
  var S;
  return C === void 0 || (S = anObject$6(C)[SPECIES$1]) == void 0
    ? defaultConstructor
    : aConstructor(S);
};
var NATIVE_BIND$1$1 = functionBindNative$1;
var FunctionPrototype$3 = Function.prototype;
var apply$1 = FunctionPrototype$3.apply;
var call$8 = FunctionPrototype$3.call;
var functionApply =
  (typeof Reflect == "object" && Reflect.apply) ||
  (NATIVE_BIND$1$1
    ? call$8.bind(apply$1)
    : function () {
        return call$8.apply(apply$1, arguments);
      });
var uncurryThis$1$1 = functionUncurryThis$1;
var aCallable$5 = aCallable$7;
var NATIVE_BIND$4 = functionBindNative$1;
var bind$4 = uncurryThis$1$1(uncurryThis$1$1.bind);
var functionBindContext = function (fn, that) {
  aCallable$5(fn);
  return that === void 0
    ? fn
    : NATIVE_BIND$4
    ? bind$4(fn, that)
    : function () {
        return fn.apply(that, arguments);
      };
};
var uncurryThis$e = functionUncurryThis$1;
var arraySlice$1 = uncurryThis$e([].slice);
var $TypeError$2$1 = TypeError;
var validateArgumentsLength$1 = function (passed, required) {
  if (passed < required) throw $TypeError$2$1("Not enough arguments");
  return passed;
};
var userAgent$2 = engineUserAgent$1;
var engineIsIos = /(?:ipad|iphone|ipod).*applewebkit/i.test(userAgent$2);
var global$7$1 = global$j;
var apply = functionApply;
var bind$3 = functionBindContext;
var isCallable$3$1 = isCallable$k;
var hasOwn$1$1 = hasOwnProperty_1$1;
var fails$1$1 = fails$d;
var html = html$2;
var arraySlice = arraySlice$1;
var createElement$2 = documentCreateElement$2;
var validateArgumentsLength = validateArgumentsLength$1;
var IS_IOS$1 = engineIsIos;
var IS_NODE$2 = engineIsNode;
var set$2 = global$7$1.setImmediate;
var clear = global$7$1.clearImmediate;
var process$2 = global$7$1.process;
var Dispatch = global$7$1.Dispatch;
var Function$1 = global$7$1.Function;
var MessageChannel$1 = global$7$1.MessageChannel;
var String$1 = global$7$1.String;
var counter = 0;
var queue$1 = {};
var ONREADYSTATECHANGE = "onreadystatechange";
var location$1;
var defer;
var channel;
var port;
try {
  location$1 = global$7$1.location;
} catch (error) {}
var run = function (id3) {
  if (hasOwn$1$1(queue$1, id3)) {
    var fn = queue$1[id3];
    delete queue$1[id3];
    fn();
  }
};
var runner = function (id3) {
  return function () {
    run(id3);
  };
};
var listener = function (event) {
  run(event.data);
};
var post = function (id3) {
  global$7$1.postMessage(
    String$1(id3),
    location$1.protocol + "//" + location$1.host
  );
};
if (!set$2 || !clear) {
  set$2 = function setImmediate(handler) {
    validateArgumentsLength(arguments.length, 1);
    var fn = isCallable$3$1(handler) ? handler : Function$1(handler);
    var args = arraySlice(arguments, 1);
    queue$1[++counter] = function () {
      apply(fn, void 0, args);
    };
    defer(counter);
    return counter;
  };
  clear = function clearImmediate(id3) {
    delete queue$1[id3];
  };
  if (IS_NODE$2) {
    defer = function (id3) {
      process$2.nextTick(runner(id3));
    };
  } else if (Dispatch && Dispatch.now) {
    defer = function (id3) {
      Dispatch.now(runner(id3));
    };
  } else if (MessageChannel$1 && !IS_IOS$1) {
    channel = new MessageChannel$1();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = bind$3(port.postMessage, port);
  } else if (
    global$7$1.addEventListener &&
    isCallable$3$1(global$7$1.postMessage) &&
    !global$7$1.importScripts &&
    location$1 &&
    location$1.protocol !== "file:" &&
    !fails$1$1(post)
  ) {
    defer = post;
    global$7$1.addEventListener("message", listener, false);
  } else if (ONREADYSTATECHANGE in createElement$2("script")) {
    defer = function (id3) {
      html.appendChild(createElement$2("script"))[ONREADYSTATECHANGE] =
        function () {
          html.removeChild(this);
          run(id3);
        };
    };
  } else {
    defer = function (id3) {
      setTimeout(runner(id3), 0);
    };
  }
}
var task$1 = {
  set: set$2,
  clear,
};
var userAgent$1 = engineUserAgent$1;
var global$6$1 = global$j;
var engineIsIosPebble =
  /ipad|iphone|ipod/i.test(userAgent$1) && global$6$1.Pebble !== void 0;
var userAgent$4 = engineUserAgent$1;
var engineIsWebosWebkit = /web0s(?!.*chrome)/i.test(userAgent$4);
var global$5$1 = global$j;
var bind$2 = functionBindContext;
var getOwnPropertyDescriptor2$1 = objectGetOwnPropertyDescriptor$1.f;
var macrotask = task$1.set;
var IS_IOS = engineIsIos;
var IS_IOS_PEBBLE = engineIsIosPebble;
var IS_WEBOS_WEBKIT = engineIsWebosWebkit;
var IS_NODE$1 = engineIsNode;
var MutationObserver$1 =
  global$5$1.MutationObserver || global$5$1.WebKitMutationObserver;
var document$2 = global$5$1.document;
var process$1$1 = global$5$1.process;
var Promise$1 = global$5$1.Promise;
var queueMicrotaskDescriptor = getOwnPropertyDescriptor2$1(
  global$5$1,
  "queueMicrotask"
);
var queueMicrotask$1 =
  queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;
var flush;
var head;
var last;
var notify$1;
var toggle;
var node;
var promise;
var then;
if (!queueMicrotask$1) {
  flush = function () {
    var parent, fn;
    if (IS_NODE$1 && (parent = process$1$1.domain)) parent.exit();
    while (head) {
      fn = head.fn;
      head = head.next;
      try {
        fn();
      } catch (error) {
        if (head) notify$1();
        else last = void 0;
        throw error;
      }
    }
    last = void 0;
    if (parent) parent.enter();
  };
  if (
    !IS_IOS &&
    !IS_NODE$1 &&
    !IS_WEBOS_WEBKIT &&
    MutationObserver$1 &&
    document$2
  ) {
    toggle = true;
    node = document$2.createTextNode("");
    new MutationObserver$1(flush).observe(node, { characterData: true });
    notify$1 = function () {
      node.data = toggle = !toggle;
    };
  } else if (!IS_IOS_PEBBLE && Promise$1 && Promise$1.resolve) {
    promise = Promise$1.resolve(void 0);
    promise.constructor = Promise$1;
    then = bind$2(promise.then, promise);
    notify$1 = function () {
      then(flush);
    };
  } else if (IS_NODE$1) {
    notify$1 = function () {
      process$1$1.nextTick(flush);
    };
  } else {
    macrotask = bind$2(macrotask, global$5$1);
    notify$1 = function () {
      macrotask(flush);
    };
  }
}
var microtask$1 =
  queueMicrotask$1 ||
  function (fn) {
    var task3 = { fn, next: void 0 };
    if (last) last.next = task3;
    if (!head) {
      head = task3;
      notify$1();
    }
    last = task3;
  };
var global$4$1 = global$j;
var hostReportErrors$1 = function (a, b) {
  var console = global$4$1.console;
  if (console && console.error) {
    arguments.length == 1 ? console.error(a) : console.error(a, b);
  }
};
var perform$3 = function (exec3) {
  try {
    return { error: false, value: exec3() };
  } catch (error) {
    return { error: true, value: error };
  }
};
var Queue$1 = function () {
  this.head = null;
  this.tail = null;
};
Queue$1.prototype = {
  add: function (item) {
    var entry = { item, next: null };
    if (this.head) this.tail.next = entry;
    else this.head = entry;
    this.tail = entry;
  },
  get: function () {
    var entry = this.head;
    if (entry) {
      this.head = entry.next;
      if (this.tail === entry) this.tail = null;
      return entry.item;
    }
  },
};
var queue = Queue$1;
var global$3$1 = global$j;
var promiseNativeConstructor = global$3$1.Promise;
var engineIsBrowser = typeof window == "object" && typeof Deno != "object";
var global$2$1 = global$j;
var NativePromiseConstructor$3 = promiseNativeConstructor;
var isCallable$2$1 = isCallable$k;
var isForced$3 = isForced_1$1;
var inspectSource$5 = inspectSource$4;
var wellKnownSymbol$3 = wellKnownSymbol$e;
var IS_BROWSER = engineIsBrowser;
var V8_VERSION$2 = engineV8Version$1;
NativePromiseConstructor$3 && NativePromiseConstructor$3.prototype;
var SPECIES = wellKnownSymbol$3("species");
var SUBCLASSING = false;
var NATIVE_PROMISE_REJECTION_EVENT$1 = isCallable$2$1(
  global$2$1.PromiseRejectionEvent
);
var FORCED_PROMISE_CONSTRUCTOR$5 = isForced$3("Promise", function () {
  var PROMISE_CONSTRUCTOR_SOURCE = inspectSource$5(NativePromiseConstructor$3);
  var GLOBAL_CORE_JS_PROMISE =
    PROMISE_CONSTRUCTOR_SOURCE !== String(NativePromiseConstructor$3);
  if (!GLOBAL_CORE_JS_PROMISE && V8_VERSION$2 === 66) return true;
  if (V8_VERSION$2 >= 51 && /native code/.test(PROMISE_CONSTRUCTOR_SOURCE))
    return false;
  var promise3 = new NativePromiseConstructor$3(function (resolve3) {
    resolve3(1);
  });
  var FakePromise = function (exec3) {
    exec3(
      function () {},
      function () {}
    );
  };
  var constructor = (promise3.constructor = {});
  constructor[SPECIES] = FakePromise;
  SUBCLASSING = promise3.then(function () {}) instanceof FakePromise;
  if (!SUBCLASSING) return true;
  return (
    !GLOBAL_CORE_JS_PROMISE && IS_BROWSER && !NATIVE_PROMISE_REJECTION_EVENT$1
  );
});
var promiseConstructorDetection = {
  CONSTRUCTOR: FORCED_PROMISE_CONSTRUCTOR$5,
  REJECTION_EVENT: NATIVE_PROMISE_REJECTION_EVENT$1,
  SUBCLASSING,
};
var newPromiseCapability$2 = {};
var aCallable$4 = aCallable$7;
var PromiseCapability = function (C) {
  var resolve3, reject3;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve3 !== void 0 || reject3 !== void 0)
      throw TypeError("Bad Promise constructor");
    resolve3 = $$resolve;
    reject3 = $$reject;
  });
  this.resolve = aCallable$4(resolve3);
  this.reject = aCallable$4(reject3);
};
newPromiseCapability$2.f = function (C) {
  return new PromiseCapability(C);
};
var $$5 = _export$1;
var IS_NODE = engineIsNode;
var global$1$1 = global$j;
var call$7 = functionCall$1;
var defineBuiltIn$2 = defineBuiltIn$6;
var setPrototypeOf = objectSetPrototypeOf;
var setToStringTag = setToStringTag$3;
var setSpecies = setSpecies$1;
var aCallable$3 = aCallable$7;
var isCallable$1$1 = isCallable$k;
var isObject$1$1 = isObject$7;
var anInstance = anInstance$1;
var speciesConstructor = speciesConstructor$1;
var task = task$1.set;
var microtask = microtask$1;
var hostReportErrors = hostReportErrors$1;
var perform$2 = perform$3;
var Queue = queue;
var InternalStateModule$3 = internalState$1;
var NativePromiseConstructor$2 = promiseNativeConstructor;
var PromiseConstructorDetection = promiseConstructorDetection;
var newPromiseCapabilityModule$3 = newPromiseCapability$2;
var PROMISE = "Promise";
var FORCED_PROMISE_CONSTRUCTOR$4 = PromiseConstructorDetection.CONSTRUCTOR;
var NATIVE_PROMISE_REJECTION_EVENT =
  PromiseConstructorDetection.REJECTION_EVENT;
var NATIVE_PROMISE_SUBCLASSING = PromiseConstructorDetection.SUBCLASSING;
var getInternalPromiseState = InternalStateModule$3.getterFor(PROMISE);
var setInternalState = InternalStateModule$3.set;
var NativePromisePrototype$1 =
  NativePromiseConstructor$2 && NativePromiseConstructor$2.prototype;
var PromiseConstructor = NativePromiseConstructor$2;
var PromisePrototype = NativePromisePrototype$1;
var TypeError$1$1 = global$1$1.TypeError;
var document$1$1 = global$1$1.document;
var process$4 = global$1$1.process;
var newPromiseCapability$1 = newPromiseCapabilityModule$3.f;
var newGenericPromiseCapability = newPromiseCapability$1;
var DISPATCH_EVENT = !!(
  document$1$1 &&
  document$1$1.createEvent &&
  global$1$1.dispatchEvent
);
var UNHANDLED_REJECTION = "unhandledrejection";
var REJECTION_HANDLED = "rejectionhandled";
var PENDING = 0;
var FULFILLED = 1;
var REJECTED = 2;
var HANDLED = 1;
var UNHANDLED = 2;
var Internal;
var OwnPromiseCapability;
var PromiseWrapper;
var nativeThen;
var isThenable = function (it) {
  var then3;
  return isObject$1$1(it) && isCallable$1$1((then3 = it.then)) ? then3 : false;
};
var callReaction = function (reaction, state) {
  var value = state.value;
  var ok = state.state == FULFILLED;
  var handler = ok ? reaction.ok : reaction.fail;
  var resolve3 = reaction.resolve;
  var reject3 = reaction.reject;
  var domain = reaction.domain;
  var result, then3, exited;
  try {
    if (handler) {
      if (!ok) {
        if (state.rejection === UNHANDLED) onHandleUnhandled(state);
        state.rejection = HANDLED;
      }
      if (handler === true) result = value;
      else {
        if (domain) domain.enter();
        result = handler(value);
        if (domain) {
          domain.exit();
          exited = true;
        }
      }
      if (result === reaction.promise) {
        reject3(TypeError$1$1("Promise-chain cycle"));
      } else if ((then3 = isThenable(result))) {
        call$7(then3, result, resolve3, reject3);
      } else resolve3(result);
    } else reject3(value);
  } catch (error) {
    if (domain && !exited) domain.exit();
    reject3(error);
  }
};
var notify = function (state, isReject) {
  if (state.notified) return;
  state.notified = true;
  microtask(function () {
    var reactions = state.reactions;
    var reaction;
    while ((reaction = reactions.get())) {
      callReaction(reaction, state);
    }
    state.notified = false;
    if (isReject && !state.rejection) onUnhandled(state);
  });
};
var dispatchEvent = function (name, promise3, reason) {
  var event, handler;
  if (DISPATCH_EVENT) {
    event = document$1$1.createEvent("Event");
    event.promise = promise3;
    event.reason = reason;
    event.initEvent(name, false, true);
    global$1$1.dispatchEvent(event);
  } else event = { promise: promise3, reason };
  if (!NATIVE_PROMISE_REJECTION_EVENT && (handler = global$1$1["on" + name]))
    handler(event);
  else if (name === UNHANDLED_REJECTION)
    hostReportErrors("Unhandled promise rejection", reason);
};
var onUnhandled = function (state) {
  call$7(task, global$1$1, function () {
    var promise3 = state.facade;
    var value = state.value;
    var IS_UNHANDLED = isUnhandled(state);
    var result;
    if (IS_UNHANDLED) {
      result = perform$2(function () {
        if (IS_NODE) {
          process$4.emit("unhandledRejection", value, promise3);
        } else dispatchEvent(UNHANDLED_REJECTION, promise3, value);
      });
      state.rejection = IS_NODE || isUnhandled(state) ? UNHANDLED : HANDLED;
      if (result.error) throw result.value;
    }
  });
};
var isUnhandled = function (state) {
  return state.rejection !== HANDLED && !state.parent;
};
var onHandleUnhandled = function (state) {
  call$7(task, global$1$1, function () {
    var promise3 = state.facade;
    if (IS_NODE) {
      process$4.emit("rejectionHandled", promise3);
    } else dispatchEvent(REJECTION_HANDLED, promise3, state.value);
  });
};
var bind$1 = function (fn, state, unwrap) {
  return function (value) {
    fn(state, value, unwrap);
  };
};
var internalReject = function (state, value, unwrap) {
  if (state.done) return;
  state.done = true;
  if (unwrap) state = unwrap;
  state.value = value;
  state.state = REJECTED;
  notify(state, true);
};
var internalResolve = function (state, value, unwrap) {
  if (state.done) return;
  state.done = true;
  if (unwrap) state = unwrap;
  try {
    if (state.facade === value)
      throw TypeError$1$1("Promise can't be resolved itself");
    var then3 = isThenable(value);
    if (then3) {
      microtask(function () {
        var wrapper = { done: false };
        try {
          call$7(
            then3,
            value,
            bind$1(internalResolve, wrapper, state),
            bind$1(internalReject, wrapper, state)
          );
        } catch (error) {
          internalReject(wrapper, error, state);
        }
      });
    } else {
      state.value = value;
      state.state = FULFILLED;
      notify(state, false);
    }
  } catch (error) {
    internalReject({ done: false }, error, state);
  }
};
if (FORCED_PROMISE_CONSTRUCTOR$4) {
  PromiseConstructor = function Promise2(executor) {
    anInstance(this, PromisePrototype);
    aCallable$3(executor);
    call$7(Internal, this);
    var state = getInternalPromiseState(this);
    try {
      executor(bind$1(internalResolve, state), bind$1(internalReject, state));
    } catch (error) {
      internalReject(state, error);
    }
  };
  PromisePrototype = PromiseConstructor.prototype;
  Internal = function Promise2(executor) {
    setInternalState(this, {
      type: PROMISE,
      done: false,
      notified: false,
      parent: false,
      reactions: new Queue(),
      rejection: false,
      state: PENDING,
      value: void 0,
    });
  };
  Internal.prototype = defineBuiltIn$2(
    PromisePrototype,
    "then",
    function then3(onFulfilled, onRejected) {
      var state = getInternalPromiseState(this);
      var reaction = newPromiseCapability$1(
        speciesConstructor(this, PromiseConstructor)
      );
      state.parent = true;
      reaction.ok = isCallable$1$1(onFulfilled) ? onFulfilled : true;
      reaction.fail = isCallable$1$1(onRejected) && onRejected;
      reaction.domain = IS_NODE ? process$4.domain : void 0;
      if (state.state == PENDING) state.reactions.add(reaction);
      else
        microtask(function () {
          callReaction(reaction, state);
        });
      return reaction.promise;
    }
  );
  OwnPromiseCapability = function () {
    var promise3 = new Internal();
    var state = getInternalPromiseState(promise3);
    this.promise = promise3;
    this.resolve = bind$1(internalResolve, state);
    this.reject = bind$1(internalReject, state);
  };
  newPromiseCapabilityModule$3.f = newPromiseCapability$1 = function (C) {
    return C === PromiseConstructor || C === PromiseWrapper
      ? new OwnPromiseCapability(C)
      : newGenericPromiseCapability(C);
  };
  if (
    isCallable$1$1(NativePromiseConstructor$2) &&
    NativePromisePrototype$1 !== Object.prototype
  ) {
    nativeThen = NativePromisePrototype$1.then;
    if (!NATIVE_PROMISE_SUBCLASSING) {
      defineBuiltIn$2(
        NativePromisePrototype$1,
        "then",
        function then3(onFulfilled, onRejected) {
          var that = this;
          return new PromiseConstructor(function (resolve3, reject3) {
            call$7(nativeThen, that, resolve3, reject3);
          }).then(onFulfilled, onRejected);
        },
        { unsafe: true }
      );
    }
    try {
      delete NativePromisePrototype$1.constructor;
    } catch (error) {}
    if (setPrototypeOf) {
      setPrototypeOf(NativePromisePrototype$1, PromisePrototype);
    }
  }
}
$$5(
  {
    global: true,
    constructor: true,
    wrap: true,
    forced: FORCED_PROMISE_CONSTRUCTOR$4,
  },
  {
    Promise: PromiseConstructor,
  }
);
setToStringTag(PromiseConstructor, PROMISE, false);
setSpecies(PROMISE);
var wellKnownSymbol$2 = wellKnownSymbol$e;
var Iterators$1 = iterators;
var ITERATOR$2 = wellKnownSymbol$2("iterator");
var ArrayPrototype = Array.prototype;
var isArrayIteratorMethod$1 = function (it) {
  return (
    it !== void 0 &&
    (Iterators$1.Array === it || ArrayPrototype[ITERATOR$2] === it)
  );
};
var classof$1 = classof$3;
var getMethod$1$1 = getMethod$3;
var Iterators = iterators;
var wellKnownSymbol$1$1 = wellKnownSymbol$e;
var ITERATOR$1 = wellKnownSymbol$1$1("iterator");
var getIteratorMethod$2 = function (it) {
  if (it != void 0)
    return (
      getMethod$1$1(it, ITERATOR$1) ||
      getMethod$1$1(it, "@@iterator") ||
      Iterators[classof$1(it)]
    );
};
var call$6 = functionCall$1;
var aCallable$2 = aCallable$7;
var anObject$5 = anObject$c;
var tryToString$1$1 = tryToString$4;
var getIteratorMethod$1 = getIteratorMethod$2;
var $TypeError$1$1 = TypeError;
var getIterator$1 = function (argument, usingIterator) {
  var iteratorMethod =
    arguments.length < 2 ? getIteratorMethod$1(argument) : usingIterator;
  if (aCallable$2(iteratorMethod))
    return anObject$5(call$6(iteratorMethod, argument));
  throw $TypeError$1$1(tryToString$1$1(argument) + " is not iterable");
};
var call$5$1 = functionCall$1;
var anObject$4 = anObject$c;
var getMethod$4 = getMethod$3;
var iteratorClose$1 = function (iterator, kind, value) {
  var innerResult, innerError;
  anObject$4(iterator);
  try {
    innerResult = getMethod$4(iterator, "return");
    if (!innerResult) {
      if (kind === "throw") throw value;
      return value;
    }
    innerResult = call$5$1(innerResult, iterator);
  } catch (error) {
    innerError = true;
    innerResult = error;
  }
  if (kind === "throw") throw value;
  if (innerError) throw innerResult;
  anObject$4(innerResult);
  return value;
};
var bind$6 = functionBindContext;
var call$4$1 = functionCall$1;
var anObject$3 = anObject$c;
var tryToString$5 = tryToString$4;
var isArrayIteratorMethod = isArrayIteratorMethod$1;
var lengthOfArrayLike$3 = lengthOfArrayLike$2;
var isPrototypeOf$1 = objectIsPrototypeOf$1;
var getIterator = getIterator$1;
var getIteratorMethod = getIteratorMethod$2;
var iteratorClose = iteratorClose$1;
var $TypeError$c = TypeError;
var Result = function (stopped, result) {
  this.stopped = stopped;
  this.result = result;
};
var ResultPrototype = Result.prototype;
var iterate$2 = function (iterable, unboundFunction, options) {
  var that = options && options.that;
  var AS_ENTRIES = !!(options && options.AS_ENTRIES);
  var IS_ITERATOR = !!(options && options.IS_ITERATOR);
  var INTERRUPTED = !!(options && options.INTERRUPTED);
  var fn = bind$6(unboundFunction, that);
  var iterator, iterFn, index, length, result, next, step;
  var stop = function (condition) {
    if (iterator) iteratorClose(iterator, "normal", condition);
    return new Result(true, condition);
  };
  var callFn = function (value) {
    if (AS_ENTRIES) {
      anObject$3(value);
      return INTERRUPTED
        ? fn(value[0], value[1], stop)
        : fn(value[0], value[1]);
    }
    return INTERRUPTED ? fn(value, stop) : fn(value);
  };
  if (IS_ITERATOR) {
    iterator = iterable;
  } else {
    iterFn = getIteratorMethod(iterable);
    if (!iterFn)
      throw $TypeError$c(tryToString$5(iterable) + " is not iterable");
    if (isArrayIteratorMethod(iterFn)) {
      for (
        index = 0, length = lengthOfArrayLike$3(iterable);
        length > index;
        index++
      ) {
        result = callFn(iterable[index]);
        if (result && isPrototypeOf$1(ResultPrototype, result)) return result;
      }
      return new Result(false);
    }
    iterator = getIterator(iterable, iterFn);
  }
  next = iterator.next;
  while (!(step = call$4$1(next, iterator)).done) {
    try {
      result = callFn(step.value);
    } catch (error) {
      iteratorClose(iterator, "throw", error);
    }
    if (
      typeof result == "object" &&
      result &&
      isPrototypeOf$1(ResultPrototype, result)
    )
      return result;
  }
  return new Result(false);
};
var wellKnownSymbol$f = wellKnownSymbol$e;
var ITERATOR = wellKnownSymbol$f("iterator");
var SAFE_CLOSING = false;
try {
  called = 0;
  iteratorWithReturn = {
    next: function () {
      return { done: !!called++ };
    },
    return: function () {
      SAFE_CLOSING = true;
    },
  };
  iteratorWithReturn[ITERATOR] = function () {
    return this;
  };
  Array.from(iteratorWithReturn, function () {
    throw 2;
  });
} catch (error) {}
var called;
var iteratorWithReturn;
var checkCorrectnessOfIteration$1 = function (exec3, SKIP_CLOSING) {
  if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
  var ITERATION_SUPPORT = false;
  try {
    var object = {};
    object[ITERATOR] = function () {
      return {
        next: function () {
          return { done: (ITERATION_SUPPORT = true) };
        },
      };
    };
    exec3(object);
  } catch (error) {}
  return ITERATION_SUPPORT;
};
var NativePromiseConstructor$1 = promiseNativeConstructor;
var checkCorrectnessOfIteration = checkCorrectnessOfIteration$1;
var FORCED_PROMISE_CONSTRUCTOR$3 = promiseConstructorDetection.CONSTRUCTOR;
var promiseStaticsIncorrectIteration =
  FORCED_PROMISE_CONSTRUCTOR$3 ||
  !checkCorrectnessOfIteration(function (iterable) {
    NativePromiseConstructor$1.all(iterable).then(void 0, function () {});
  });
var $$4 = _export$1;
var call$3$1 = functionCall$1;
var aCallable$1$1 = aCallable$7;
var newPromiseCapabilityModule$2 = newPromiseCapability$2;
var perform$1 = perform$3;
var iterate$1 = iterate$2;
var PROMISE_STATICS_INCORRECT_ITERATION$1 = promiseStaticsIncorrectIteration;
$$4(
  {
    target: "Promise",
    stat: true,
    forced: PROMISE_STATICS_INCORRECT_ITERATION$1,
  },
  {
    all: function all(iterable) {
      var C = this;
      var capability = newPromiseCapabilityModule$2.f(C);
      var resolve3 = capability.resolve;
      var reject3 = capability.reject;
      var result = perform$1(function () {
        var $promiseResolve = aCallable$1$1(C.resolve);
        var values3 = [];
        var counter3 = 0;
        var remaining = 1;
        iterate$1(iterable, function (promise3) {
          var index = counter3++;
          var alreadyCalled = false;
          remaining++;
          call$3$1($promiseResolve, C, promise3).then(function (value) {
            if (alreadyCalled) return;
            alreadyCalled = true;
            values3[index] = value;
            --remaining || resolve3(values3);
          }, reject3);
        });
        --remaining || resolve3(values3);
      });
      if (result.error) reject3(result.value);
      return capability.promise;
    },
  }
);
var $$3 = _export$1;
var FORCED_PROMISE_CONSTRUCTOR$2 = promiseConstructorDetection.CONSTRUCTOR;
var NativePromiseConstructor = promiseNativeConstructor;
var getBuiltIn$1$1 = getBuiltIn$8;
var isCallable$l = isCallable$k;
var defineBuiltIn$1$1 = defineBuiltIn$6;
var NativePromisePrototype =
  NativePromiseConstructor && NativePromiseConstructor.prototype;
$$3(
  {
    target: "Promise",
    proto: true,
    forced: FORCED_PROMISE_CONSTRUCTOR$2,
    real: true,
  },
  {
    catch: function (onRejected) {
      return this.then(void 0, onRejected);
    },
  }
);
if (isCallable$l(NativePromiseConstructor)) {
  method = getBuiltIn$1$1("Promise").prototype["catch"];
  if (NativePromisePrototype["catch"] !== method) {
    defineBuiltIn$1$1(NativePromisePrototype, "catch", method, {
      unsafe: true,
    });
  }
}
var method;
var $$2 = _export$1;
var call$2$1 = functionCall$1;
var aCallable$8 = aCallable$7;
var newPromiseCapabilityModule$1 = newPromiseCapability$2;
var perform = perform$3;
var iterate = iterate$2;
var PROMISE_STATICS_INCORRECT_ITERATION = promiseStaticsIncorrectIteration;
$$2(
  {
    target: "Promise",
    stat: true,
    forced: PROMISE_STATICS_INCORRECT_ITERATION,
  },
  {
    race: function race(iterable) {
      var C = this;
      var capability = newPromiseCapabilityModule$1.f(C);
      var reject3 = capability.reject;
      var result = perform(function () {
        var $promiseResolve = aCallable$8(C.resolve);
        iterate(iterable, function (promise3) {
          call$2$1($promiseResolve, C, promise3).then(
            capability.resolve,
            reject3
          );
        });
      });
      if (result.error) reject3(result.value);
      return capability.promise;
    },
  }
);
var $$1 = _export$1;
var call$1$1 = functionCall$1;
var newPromiseCapabilityModule = newPromiseCapability$2;
var FORCED_PROMISE_CONSTRUCTOR$1 = promiseConstructorDetection.CONSTRUCTOR;
$$1(
  { target: "Promise", stat: true, forced: FORCED_PROMISE_CONSTRUCTOR$1 },
  {
    reject: function reject(r) {
      var capability = newPromiseCapabilityModule.f(this);
      call$1$1(capability.reject, void 0, r);
      return capability.promise;
    },
  }
);
var anObject$2$1 = anObject$c;
var isObject$8 = isObject$7;
var newPromiseCapability = newPromiseCapability$2;
var promiseResolve$1 = function (C, x) {
  anObject$2$1(C);
  if (isObject$8(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve3 = promiseCapability.resolve;
  resolve3(x);
  return promiseCapability.promise;
};
var $$7 = _export$1;
var getBuiltIn$9 = getBuiltIn$8;
var FORCED_PROMISE_CONSTRUCTOR = promiseConstructorDetection.CONSTRUCTOR;
var promiseResolve = promiseResolve$1;
getBuiltIn$9("Promise");
$$7(
  { target: "Promise", stat: true, forced: FORCED_PROMISE_CONSTRUCTOR },
  {
    resolve: function resolve(x) {
      return promiseResolve(this, x);
    },
  }
);
var classof$6 = classof$3;
var $String$4 = String;
var toString2 = function (argument) {
  if (classof$6(argument) === "Symbol")
    throw TypeError("Cannot convert a Symbol value to a string");
  return $String$4(argument);
};
var anObject$1$1 = anObject$c;
var regexpFlags = function () {
  var that = anObject$1$1(this);
  var result = "";
  if (that.hasIndices) result += "d";
  if (that.global) result += "g";
  if (that.ignoreCase) result += "i";
  if (that.multiline) result += "m";
  if (that.dotAll) result += "s";
  if (that.unicode) result += "u";
  if (that.unicodeSets) result += "v";
  if (that.sticky) result += "y";
  return result;
};
var call$f = functionCall$1;
var hasOwn2$1 = hasOwnProperty_1$1;
var isPrototypeOf$4 = objectIsPrototypeOf$1;
var regExpFlags = regexpFlags;
var RegExpPrototype$1 = RegExp.prototype;
var regexpGetFlags = function (R) {
  var flags = R.flags;
  return flags === void 0 &&
    !("flags" in RegExpPrototype$1) &&
    !hasOwn2$1(R, "flags") &&
    isPrototypeOf$4(RegExpPrototype$1, R)
    ? call$f(regExpFlags, R)
    : flags;
};
var PROPER_FUNCTION_NAME = functionName$1.PROPER;
var defineBuiltIn$7 = defineBuiltIn$6;
var anObject$d = anObject$c;
var $toString = toString2;
var fails$e = fails$d;
var getRegExpFlags = regexpGetFlags;
var TO_STRING = "toString";
var RegExpPrototype = RegExp.prototype;
var n$ToString = RegExpPrototype[TO_STRING];
var NOT_GENERIC = fails$e(function () {
  return n$ToString.call({ source: "a", flags: "b" }) != "/a/b";
});
var INCORRECT_NAME = PROPER_FUNCTION_NAME && n$ToString.name != TO_STRING;
if (NOT_GENERIC || INCORRECT_NAME) {
  defineBuiltIn$7(
    RegExp.prototype,
    TO_STRING,
    function toString5() {
      var R = anObject$d(this);
      var pattern = $toString(R.source);
      var flags = $toString(getRegExpFlags(R));
      return "/" + pattern + "/" + flags;
    },
    { unsafe: true }
  );
}

// node_modules/@near-wallet-selector/my-near-wallet/index.js
var commonjsGlobal2 =
  typeof globalThis !== "undefined"
    ? globalThis
    : typeof window !== "undefined"
    ? window
    : typeof global !== "undefined"
    ? global
    : typeof self !== "undefined"
    ? self
    : {};
var check2 = function (it) {
  return it && it.Math == Math && it;
};
var global$j2 =
  // eslint-disable-next-line es-x/no-global-this -- safe
  check2(typeof globalThis == "object" && globalThis) ||
  check2(typeof window == "object" && window) || // eslint-disable-next-line no-restricted-globals -- safe
  check2(typeof self == "object" && self) ||
  check2(typeof commonjsGlobal2 == "object" && commonjsGlobal2) || // eslint-disable-next-line no-new-func -- fallback
  (function () {
    return this;
  })() ||
  Function("return this")();
var objectGetOwnPropertyDescriptor2 = {};
var fails$e$1 = function (exec3) {
  try {
    return !!exec3();
  } catch (error) {
    return true;
  }
};
var fails$d2 = fails$e$1;
var descriptors2 = !fails$d2(function () {
  return (
    Object.defineProperty({}, 1, {
      get: function () {
        return 7;
      },
    })[1] != 7
  );
});
var fails$c2 = fails$e$1;
var functionBindNative2 = !fails$c2(function () {
  var test3 = function () {}.bind();
  return typeof test3 != "function" || test3.hasOwnProperty("prototype");
});
var NATIVE_BIND$32 = functionBindNative2;
var call$f$1 = Function.prototype.call;
var functionCall2 = NATIVE_BIND$32
  ? call$f$1.bind(call$f$1)
  : function () {
      return call$f$1.apply(call$f$1, arguments);
    };
var objectPropertyIsEnumerable2 = {};
var $propertyIsEnumerable2 = {}.propertyIsEnumerable;
var getOwnPropertyDescriptor$22 = Object.getOwnPropertyDescriptor;
var NASHORN_BUG2 =
  getOwnPropertyDescriptor$22 && !$propertyIsEnumerable2.call({ 1: 2 }, 1);
objectPropertyIsEnumerable2.f = NASHORN_BUG2
  ? function propertyIsEnumerable2(V) {
      var descriptor = getOwnPropertyDescriptor$22(this, V);
      return !!descriptor && descriptor.enumerable;
    }
  : $propertyIsEnumerable2;
var createPropertyDescriptor$32 = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value,
  };
};
var NATIVE_BIND$22 = functionBindNative2;
var FunctionPrototype$22 = Function.prototype;
var bind$52 = FunctionPrototype$22.bind;
var call$e2 = FunctionPrototype$22.call;
var uncurryThis$e$1 = NATIVE_BIND$22 && bind$52.bind(call$e2, call$e2);
var functionUncurryThis2 = NATIVE_BIND$22
  ? function (fn) {
      return fn && uncurryThis$e$1(fn);
    }
  : function (fn) {
      return (
        fn &&
        function () {
          return call$e2.apply(fn, arguments);
        }
      );
    };
var uncurryThis$d2 = functionUncurryThis2;
var toString$22 = uncurryThis$d2({}.toString);
var stringSlice2 = uncurryThis$d2("".slice);
var classofRaw$12 = function (it) {
  return stringSlice2(toString$22(it), 8, -1);
};
var uncurryThis$c2 = functionUncurryThis2;
var fails$b2 = fails$e$1;
var classof$52 = classofRaw$12;
var $Object$42 = Object;
var split2 = uncurryThis$c2("".split);
var indexedObject2 = fails$b2(function () {
  return !$Object$42("z").propertyIsEnumerable(0);
})
  ? function (it) {
      return classof$52(it) == "String" ? split2(it, "") : $Object$42(it);
    }
  : $Object$42;
var $TypeError$b2 = TypeError;
var requireObjectCoercible$22 = function (it) {
  if (it == void 0) throw $TypeError$b2("Can't call method on " + it);
  return it;
};
var IndexedObject$1$1 = indexedObject2;
var requireObjectCoercible$12 = requireObjectCoercible$22;
var toIndexedObject$52 = function (it) {
  return IndexedObject$1$1(requireObjectCoercible$12(it));
};
var isCallable$k2 = function (argument) {
  return typeof argument == "function";
};
var isCallable$j2 = isCallable$k2;
var isObject$72 = function (it) {
  return typeof it == "object" ? it !== null : isCallable$j2(it);
};
var global$i2 = global$j2;
var isCallable$i2 = isCallable$k2;
var aFunction2 = function (argument) {
  return isCallable$i2(argument) ? argument : void 0;
};
var getBuiltIn$82 = function (namespace, method) {
  return arguments.length < 2
    ? aFunction2(global$i2[namespace])
    : global$i2[namespace] && global$i2[namespace][method];
};
var uncurryThis$b2 = functionUncurryThis2;
var objectIsPrototypeOf2 = uncurryThis$b2({}.isPrototypeOf);
var getBuiltIn$72 = getBuiltIn$82;
var engineUserAgent2 = getBuiltIn$72("navigator", "userAgent") || "";
var global$h2 = global$j2;
var userAgent$32 = engineUserAgent2;
var process$32 = global$h2.process;
var Deno$12 = global$h2.Deno;
var versions2 =
  (process$32 && process$32.versions) || (Deno$12 && Deno$12.version);
var v82 = versions2 && versions2.v8;
var match2;
var version2;
if (v82) {
  match2 = v82.split(".");
  version2 = match2[0] > 0 && match2[0] < 4 ? 1 : +(match2[0] + match2[1]);
}
if (!version2 && userAgent$32) {
  match2 = userAgent$32.match(/Edge\/(\d+)/);
  if (!match2 || match2[1] >= 74) {
    match2 = userAgent$32.match(/Chrome\/(\d+)/);
    if (match2) version2 = +match2[1];
  }
}
var engineV8Version2 = version2;
var V8_VERSION$12 = engineV8Version2;
var fails$a2 = fails$e$1;
var nativeSymbol2 =
  !!Object.getOwnPropertySymbols &&
  !fails$a2(function () {
    var symbol = Symbol();
    return (
      !String(symbol) ||
      !(Object(symbol) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
      (!Symbol.sham && V8_VERSION$12 && V8_VERSION$12 < 41)
    );
  });
var NATIVE_SYMBOL$12 = nativeSymbol2;
var useSymbolAsUid2 =
  NATIVE_SYMBOL$12 && !Symbol.sham && typeof Symbol.iterator == "symbol";
var getBuiltIn$62 = getBuiltIn$82;
var isCallable$h2 = isCallable$k2;
var isPrototypeOf$32 = objectIsPrototypeOf2;
var USE_SYMBOL_AS_UID$12 = useSymbolAsUid2;
var $Object$32 = Object;
var isSymbol$22 = USE_SYMBOL_AS_UID$12
  ? function (it) {
      return typeof it == "symbol";
    }
  : function (it) {
      var $Symbol = getBuiltIn$62("Symbol");
      return (
        isCallable$h2($Symbol) &&
        isPrototypeOf$32($Symbol.prototype, $Object$32(it))
      );
    };
var $String$32 = String;
var tryToString$42 = function (argument) {
  try {
    return $String$32(argument);
  } catch (error) {
    return "Object";
  }
};
var isCallable$g2 = isCallable$k2;
var tryToString$32 = tryToString$42;
var $TypeError$a2 = TypeError;
var aCallable$72 = function (argument) {
  if (isCallable$g2(argument)) return argument;
  throw $TypeError$a2(tryToString$32(argument) + " is not a function");
};
var aCallable$62 = aCallable$72;
var getMethod$32 = function (V, P) {
  var func = V[P];
  return func == null ? void 0 : aCallable$62(func);
};
var call$d2 = functionCall2;
var isCallable$f2 = isCallable$k2;
var isObject$62 = isObject$72;
var $TypeError$92 = TypeError;
var ordinaryToPrimitive$12 = function (input, pref) {
  var fn, val;
  if (
    pref === "string" &&
    isCallable$f2((fn = input.toString)) &&
    !isObject$62((val = call$d2(fn, input)))
  )
    return val;
  if (
    isCallable$f2((fn = input.valueOf)) &&
    !isObject$62((val = call$d2(fn, input)))
  )
    return val;
  if (
    pref !== "string" &&
    isCallable$f2((fn = input.toString)) &&
    !isObject$62((val = call$d2(fn, input)))
  )
    return val;
  throw $TypeError$92("Can't convert object to primitive value");
};
var shared$32 = { exports: {} };
var global$g2 = global$j2;
var defineProperty$5 = Object.defineProperty;
var defineGlobalProperty$32 = function (key, value) {
  try {
    defineProperty$5(global$g2, key, {
      value,
      configurable: true,
      writable: true,
    });
  } catch (error) {
    global$g2[key] = value;
  }
  return value;
};
var global$f2 = global$j2;
var defineGlobalProperty$22 = defineGlobalProperty$32;
var SHARED2 = "__core-js_shared__";
var store$32 = global$f2[SHARED2] || defineGlobalProperty$22(SHARED2, {});
var sharedStore2 = store$32;
var store$22 = sharedStore2;
(shared$32.exports = function (key, value) {
  return store$22[key] || (store$22[key] = value !== void 0 ? value : {});
})("versions", []).push({
  version: "3.23.3",
  mode: "global",
  copyright: " 2014-2022 Denis Pushkarev (zloirock.ru)",
  license: "https://github.com/zloirock/core-js/blob/v3.23.3/LICENSE",
  source: "https://github.com/zloirock/core-js",
});
var requireObjectCoercible2 = requireObjectCoercible$22;
var $Object$22 = Object;
var toObject$3$1 = function (argument) {
  return $Object$22(requireObjectCoercible2(argument));
};
var uncurryThis$a2 = functionUncurryThis2;
var toObject$22 = toObject$3$1;
var hasOwnProperty2 = uncurryThis$a2({}.hasOwnProperty);
var hasOwnProperty_12 =
  Object.hasOwn ||
  function hasOwn3(it, key) {
    return hasOwnProperty2(toObject$22(it), key);
  };
var uncurryThis$92 = functionUncurryThis2;
var id2 = 0;
var postfix2 = Math.random();
var toString$12 = uncurryThis$92((1).toString);
var uid$22 = function (key) {
  return (
    "Symbol(" +
    (key === void 0 ? "" : key) +
    ")_" +
    toString$12(++id2 + postfix2, 36)
  );
};
var global$e2 = global$j2;
var shared$22 = shared$32.exports;
var hasOwn$a2 = hasOwnProperty_12;
var uid$12 = uid$22;
var NATIVE_SYMBOL2 = nativeSymbol2;
var USE_SYMBOL_AS_UID2 = useSymbolAsUid2;
var WellKnownSymbolsStore2 = shared$22("wks");
var Symbol$12 = global$e2.Symbol;
var symbolFor2 = Symbol$12 && Symbol$12["for"];
var createWellKnownSymbol2 = USE_SYMBOL_AS_UID2
  ? Symbol$12
  : (Symbol$12 && Symbol$12.withoutSetter) || uid$12;
var wellKnownSymbol$e2 = function (name) {
  if (
    !hasOwn$a2(WellKnownSymbolsStore2, name) ||
    !(NATIVE_SYMBOL2 || typeof WellKnownSymbolsStore2[name] == "string")
  ) {
    var description = "Symbol." + name;
    if (NATIVE_SYMBOL2 && hasOwn$a2(Symbol$12, name)) {
      WellKnownSymbolsStore2[name] = Symbol$12[name];
    } else if (USE_SYMBOL_AS_UID2 && symbolFor2) {
      WellKnownSymbolsStore2[name] = symbolFor2(description);
    } else {
      WellKnownSymbolsStore2[name] = createWellKnownSymbol2(description);
    }
  }
  return WellKnownSymbolsStore2[name];
};
var call$c2 = functionCall2;
var isObject$52 = isObject$72;
var isSymbol$12 = isSymbol$22;
var getMethod$22 = getMethod$32;
var ordinaryToPrimitive2 = ordinaryToPrimitive$12;
var wellKnownSymbol$d2 = wellKnownSymbol$e2;
var $TypeError$82 = TypeError;
var TO_PRIMITIVE2 = wellKnownSymbol$d2("toPrimitive");
var toPrimitive$12 = function (input, pref) {
  if (!isObject$52(input) || isSymbol$12(input)) return input;
  var exoticToPrim = getMethod$22(input, TO_PRIMITIVE2);
  var result;
  if (exoticToPrim) {
    if (pref === void 0) pref = "default";
    result = call$c2(exoticToPrim, input, pref);
    if (!isObject$52(result) || isSymbol$12(result)) return result;
    throw $TypeError$82("Can't convert object to primitive value");
  }
  if (pref === void 0) pref = "number";
  return ordinaryToPrimitive2(input, pref);
};
var toPrimitive2 = toPrimitive$12;
var isSymbol2 = isSymbol$22;
var toPropertyKey$22 = function (argument) {
  var key = toPrimitive2(argument, "string");
  return isSymbol2(key) ? key : key + "";
};
var global$d2 = global$j2;
var isObject$42 = isObject$72;
var document$32 = global$d2.document;
var EXISTS$12 =
  isObject$42(document$32) && isObject$42(document$32.createElement);
var documentCreateElement$22 = function (it) {
  return EXISTS$12 ? document$32.createElement(it) : {};
};
var DESCRIPTORS$a$1 = descriptors2;
var fails$92 = fails$e$1;
var createElement$12 = documentCreateElement$22;
var ie8DomDefine2 =
  !DESCRIPTORS$a$1 &&
  !fails$92(function () {
    return (
      Object.defineProperty(createElement$12("div"), "a", {
        get: function () {
          return 7;
        },
      }).a != 7
    );
  });
var DESCRIPTORS$92 = descriptors2;
var call$b2 = functionCall2;
var propertyIsEnumerableModule$1$1 = objectPropertyIsEnumerable2;
var createPropertyDescriptor$22 = createPropertyDescriptor$32;
var toIndexedObject$42 = toIndexedObject$52;
var toPropertyKey$12 = toPropertyKey$22;
var hasOwn$92 = hasOwnProperty_12;
var IE8_DOM_DEFINE$12 = ie8DomDefine2;
var $getOwnPropertyDescriptor$12 = Object.getOwnPropertyDescriptor;
objectGetOwnPropertyDescriptor2.f = DESCRIPTORS$92
  ? $getOwnPropertyDescriptor$12
  : function getOwnPropertyDescriptor3(O, P) {
      O = toIndexedObject$42(O);
      P = toPropertyKey$12(P);
      if (IE8_DOM_DEFINE$12)
        try {
          return $getOwnPropertyDescriptor$12(O, P);
        } catch (error) {}
      if (hasOwn$92(O, P))
        return createPropertyDescriptor$22(
          !call$b2(propertyIsEnumerableModule$1$1.f, O, P),
          O[P]
        );
    };
var objectDefineProperty2 = {};
var DESCRIPTORS$82 = descriptors2;
var fails$82 = fails$e$1;
var v8PrototypeDefineBug2 =
  DESCRIPTORS$82 &&
  fails$82(function () {
    return (
      Object.defineProperty(function () {}, "prototype", {
        value: 42,
        writable: false,
      }).prototype != 42
    );
  });
var isObject$32 = isObject$72;
var $String$22 = String;
var $TypeError$72 = TypeError;
var anObject$c2 = function (argument) {
  if (isObject$32(argument)) return argument;
  throw $TypeError$72($String$22(argument) + " is not an object");
};
var DESCRIPTORS$72 = descriptors2;
var IE8_DOM_DEFINE2 = ie8DomDefine2;
var V8_PROTOTYPE_DEFINE_BUG$12 = v8PrototypeDefineBug2;
var anObject$b2 = anObject$c2;
var toPropertyKey2 = toPropertyKey$22;
var $TypeError$62 = TypeError;
var $defineProperty2 = Object.defineProperty;
var $getOwnPropertyDescriptor2 = Object.getOwnPropertyDescriptor;
var ENUMERABLE2 = "enumerable";
var CONFIGURABLE$12 = "configurable";
var WRITABLE2 = "writable";
objectDefineProperty2.f = DESCRIPTORS$72
  ? V8_PROTOTYPE_DEFINE_BUG$12
    ? function defineProperty4(O, P, Attributes) {
        anObject$b2(O);
        P = toPropertyKey2(P);
        anObject$b2(Attributes);
        if (
          typeof O === "function" &&
          P === "prototype" &&
          "value" in Attributes &&
          WRITABLE2 in Attributes &&
          !Attributes[WRITABLE2]
        ) {
          var current = $getOwnPropertyDescriptor2(O, P);
          if (current && current[WRITABLE2]) {
            O[P] = Attributes.value;
            Attributes = {
              configurable:
                CONFIGURABLE$12 in Attributes
                  ? Attributes[CONFIGURABLE$12]
                  : current[CONFIGURABLE$12],
              enumerable:
                ENUMERABLE2 in Attributes
                  ? Attributes[ENUMERABLE2]
                  : current[ENUMERABLE2],
              writable: false,
            };
          }
        }
        return $defineProperty2(O, P, Attributes);
      }
    : $defineProperty2
  : function defineProperty5(O, P, Attributes) {
      anObject$b2(O);
      P = toPropertyKey2(P);
      anObject$b2(Attributes);
      if (IE8_DOM_DEFINE2)
        try {
          return $defineProperty2(O, P, Attributes);
        } catch (error) {}
      if ("get" in Attributes || "set" in Attributes)
        throw $TypeError$62("Accessors not supported");
      if ("value" in Attributes) O[P] = Attributes.value;
      return O;
    };
var DESCRIPTORS$62 = descriptors2;
var definePropertyModule$42 = objectDefineProperty2;
var createPropertyDescriptor$12 = createPropertyDescriptor$32;
var createNonEnumerableProperty$42 = DESCRIPTORS$62
  ? function (object, key, value) {
      return definePropertyModule$42.f(
        object,
        key,
        createPropertyDescriptor$12(1, value)
      );
    }
  : function (object, key, value) {
      object[key] = value;
      return object;
    };
var makeBuiltIn$22 = { exports: {} };
var DESCRIPTORS$52 = descriptors2;
var hasOwn$82 = hasOwnProperty_12;
var FunctionPrototype$12 = Function.prototype;
var getDescriptor2 = DESCRIPTORS$52 && Object.getOwnPropertyDescriptor;
var EXISTS2 = hasOwn$82(FunctionPrototype$12, "name");
var PROPER2 = EXISTS2 && function something2() {}.name === "something";
var CONFIGURABLE2 =
  EXISTS2 &&
  (!DESCRIPTORS$52 ||
    (DESCRIPTORS$52 &&
      getDescriptor2(FunctionPrototype$12, "name").configurable));
var functionName2 = {
  EXISTS: EXISTS2,
  PROPER: PROPER2,
  CONFIGURABLE: CONFIGURABLE2,
};
var uncurryThis$82 = functionUncurryThis2;
var isCallable$e2 = isCallable$k2;
var store$12 = sharedStore2;
var functionToString2 = uncurryThis$82(Function.toString);
if (!isCallable$e2(store$12.inspectSource)) {
  store$12.inspectSource = function (it) {
    return functionToString2(it);
  };
}
var inspectSource$42 = store$12.inspectSource;
var global$c2 = global$j2;
var isCallable$d2 = isCallable$k2;
var inspectSource$32 = inspectSource$42;
var WeakMap$12 = global$c2.WeakMap;
var nativeWeakMap2 =
  isCallable$d2(WeakMap$12) && /native code/.test(inspectSource$32(WeakMap$12));
var shared$12 = shared$32.exports;
var uid2 = uid$22;
var keys3 = shared$12("keys");
var sharedKey$32 = function (key) {
  return keys3[key] || (keys3[key] = uid2(key));
};
var hiddenKeys$42 = {};
var NATIVE_WEAK_MAP2 = nativeWeakMap2;
var global$b2 = global$j2;
var uncurryThis$72 = functionUncurryThis2;
var isObject$22 = isObject$72;
var createNonEnumerableProperty$32 = createNonEnumerableProperty$42;
var hasOwn$72 = hasOwnProperty_12;
var shared2 = sharedStore2;
var sharedKey$22 = sharedKey$32;
var hiddenKeys$32 = hiddenKeys$42;
var OBJECT_ALREADY_INITIALIZED2 = "Object already initialized";
var TypeError$22 = global$b2.TypeError;
var WeakMap2 = global$b2.WeakMap;
var set$12;
var get2;
var has2;
var enforce2 = function (it) {
  return has2(it) ? get2(it) : set$12(it, {});
};
var getterFor2 = function (TYPE) {
  return function (it) {
    var state;
    if (!isObject$22(it) || (state = get2(it)).type !== TYPE) {
      throw TypeError$22("Incompatible receiver, " + TYPE + " required");
    }
    return state;
  };
};
if (NATIVE_WEAK_MAP2 || shared2.state) {
  store$4 = shared2.state || (shared2.state = new WeakMap2());
  wmget$1 = uncurryThis$72(store$4.get);
  wmhas$1 = uncurryThis$72(store$4.has);
  wmset$1 = uncurryThis$72(store$4.set);
  set$12 = function (it, metadata) {
    if (wmhas$1(store$4, it))
      throw new TypeError$22(OBJECT_ALREADY_INITIALIZED2);
    metadata.facade = it;
    wmset$1(store$4, it, metadata);
    return metadata;
  };
  get2 = function (it) {
    return wmget$1(store$4, it) || {};
  };
  has2 = function (it) {
    return wmhas$1(store$4, it);
  };
} else {
  STATE$1 = sharedKey$22("state");
  hiddenKeys$32[STATE$1] = true;
  set$12 = function (it, metadata) {
    if (hasOwn$72(it, STATE$1))
      throw new TypeError$22(OBJECT_ALREADY_INITIALIZED2);
    metadata.facade = it;
    createNonEnumerableProperty$32(it, STATE$1, metadata);
    return metadata;
  };
  get2 = function (it) {
    return hasOwn$72(it, STATE$1) ? it[STATE$1] : {};
  };
  has2 = function (it) {
    return hasOwn$72(it, STATE$1);
  };
}
var store$4;
var wmget$1;
var wmhas$1;
var wmset$1;
var STATE$1;
var internalState2 = {
  set: set$12,
  get: get2,
  has: has2,
  enforce: enforce2,
  getterFor: getterFor2,
};
var fails$72 = fails$e$1;
var isCallable$c2 = isCallable$k2;
var hasOwn$62 = hasOwnProperty_12;
var DESCRIPTORS$42 = descriptors2;
var CONFIGURABLE_FUNCTION_NAME$12 = functionName2.CONFIGURABLE;
var inspectSource$22 = inspectSource$42;
var InternalStateModule$22 = internalState2;
var enforceInternalState2 = InternalStateModule$22.enforce;
var getInternalState$12 = InternalStateModule$22.get;
var defineProperty$42 = Object.defineProperty;
var CONFIGURABLE_LENGTH2 =
  DESCRIPTORS$42 &&
  !fails$72(function () {
    return (
      defineProperty$42(function () {}, "length", { value: 8 }).length !== 8
    );
  });
var TEMPLATE2 = String(String).split("String");
var makeBuiltIn$12 = (makeBuiltIn$22.exports = function (value, name, options) {
  if (String(name).slice(0, 7) === "Symbol(") {
    name = "[" + String(name).replace(/^Symbol\(([^)]*)\)/, "$1") + "]";
  }
  if (options && options.getter) name = "get " + name;
  if (options && options.setter) name = "set " + name;
  if (
    !hasOwn$62(value, "name") ||
    (CONFIGURABLE_FUNCTION_NAME$12 && value.name !== name)
  ) {
    if (DESCRIPTORS$42)
      defineProperty$42(value, "name", { value: name, configurable: true });
    else value.name = name;
  }
  if (
    CONFIGURABLE_LENGTH2 &&
    options &&
    hasOwn$62(options, "arity") &&
    value.length !== options.arity
  ) {
    defineProperty$42(value, "length", { value: options.arity });
  }
  try {
    if (options && hasOwn$62(options, "constructor") && options.constructor) {
      if (DESCRIPTORS$42)
        defineProperty$42(value, "prototype", { writable: false });
    } else if (value.prototype) value.prototype = void 0;
  } catch (error) {}
  var state = enforceInternalState2(value);
  if (!hasOwn$62(state, "source")) {
    state.source = TEMPLATE2.join(typeof name == "string" ? name : "");
  }
  return value;
});
Function.prototype.toString = makeBuiltIn$12(function toString3() {
  return (
    (isCallable$c2(this) && getInternalState$12(this).source) ||
    inspectSource$22(this)
  );
}, "toString");
var isCallable$b2 = isCallable$k2;
var definePropertyModule$32 = objectDefineProperty2;
var makeBuiltIn2 = makeBuiltIn$22.exports;
var defineGlobalProperty$12 = defineGlobalProperty$32;
var defineBuiltIn$62 = function (O, key, value, options) {
  if (!options) options = {};
  var simple = options.enumerable;
  var name = options.name !== void 0 ? options.name : key;
  if (isCallable$b2(value)) makeBuiltIn2(value, name, options);
  if (options.global) {
    if (simple) O[key] = value;
    else defineGlobalProperty$12(key, value);
  } else {
    try {
      if (!options.unsafe) delete O[key];
      else if (O[key]) simple = true;
    } catch (error) {}
    if (simple) O[key] = value;
    else
      definePropertyModule$32.f(O, key, {
        value,
        enumerable: false,
        configurable: !options.nonConfigurable,
        writable: !options.nonWritable,
      });
  }
  return O;
};
var objectGetOwnPropertyNames2 = {};
var ceil2 = Math.ceil;
var floor2 = Math.floor;
var mathTrunc2 =
  Math.trunc ||
  function trunc3(x) {
    var n = +x;
    return (n > 0 ? floor2 : ceil2)(n);
  };
var trunc4 = mathTrunc2;
var toIntegerOrInfinity$22 = function (argument) {
  var number = +argument;
  return number !== number || number === 0 ? 0 : trunc4(number);
};
var toIntegerOrInfinity$12 = toIntegerOrInfinity$22;
var max2 = Math.max;
var min$12 = Math.min;
var toAbsoluteIndex$12 = function (index, length) {
  var integer = toIntegerOrInfinity$12(index);
  return integer < 0 ? max2(integer + length, 0) : min$12(integer, length);
};
var toIntegerOrInfinity2 = toIntegerOrInfinity$22;
var min2 = Math.min;
var toLength$12 = function (argument) {
  return argument > 0
    ? min2(toIntegerOrInfinity2(argument), 9007199254740991)
    : 0;
};
var toLength2 = toLength$12;
var lengthOfArrayLike$22 = function (obj) {
  return toLength2(obj.length);
};
var toIndexedObject$32 = toIndexedObject$52;
var toAbsoluteIndex2 = toAbsoluteIndex$12;
var lengthOfArrayLike$12 = lengthOfArrayLike$22;
var createMethod2 = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIndexedObject$32($this);
    var length = lengthOfArrayLike$12(O);
    var index = toAbsoluteIndex2(fromIndex, length);
    var value;
    if (IS_INCLUDES && el != el)
      while (length > index) {
        value = O[index++];
        if (value != value) return true;
      }
    else
      for (; length > index; index++) {
        if ((IS_INCLUDES || index in O) && O[index] === el)
          return IS_INCLUDES || index || 0;
      }
    return !IS_INCLUDES && -1;
  };
};
var arrayIncludes2 = {
  // `Array.prototype.includes` method
  // https://tc39.es/ecma262/#sec-array.prototype.includes
  includes: createMethod2(true),
  // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof
  indexOf: createMethod2(false),
};
var uncurryThis$62 = functionUncurryThis2;
var hasOwn$52 = hasOwnProperty_12;
var toIndexedObject$22 = toIndexedObject$52;
var indexOf2 = arrayIncludes2.indexOf;
var hiddenKeys$22 = hiddenKeys$42;
var push2 = uncurryThis$62([].push);
var objectKeysInternal2 = function (object, names) {
  var O = toIndexedObject$22(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O)
    !hasOwn$52(hiddenKeys$22, key) && hasOwn$52(O, key) && push2(result, key);
  while (names.length > i)
    if (hasOwn$52(O, (key = names[i++]))) {
      ~indexOf2(result, key) || push2(result, key);
    }
  return result;
};
var enumBugKeys$32 = [
  "constructor",
  "hasOwnProperty",
  "isPrototypeOf",
  "propertyIsEnumerable",
  "toLocaleString",
  "toString",
  "valueOf",
];
var internalObjectKeys$12 = objectKeysInternal2;
var enumBugKeys$22 = enumBugKeys$32;
var hiddenKeys$12 = enumBugKeys$22.concat("length", "prototype");
objectGetOwnPropertyNames2.f =
  Object.getOwnPropertyNames ||
  function getOwnPropertyNames2(O) {
    return internalObjectKeys$12(O, hiddenKeys$12);
  };
var objectGetOwnPropertySymbols2 = {};
objectGetOwnPropertySymbols2.f = Object.getOwnPropertySymbols;
var getBuiltIn$52 = getBuiltIn$82;
var uncurryThis$52 = functionUncurryThis2;
var getOwnPropertyNamesModule2 = objectGetOwnPropertyNames2;
var getOwnPropertySymbolsModule$1$1 = objectGetOwnPropertySymbols2;
var anObject$a2 = anObject$c2;
var concat$1$1 = uncurryThis$52([].concat);
var ownKeys$12 =
  getBuiltIn$52("Reflect", "ownKeys") ||
  function ownKeys3(it) {
    var keys5 = getOwnPropertyNamesModule2.f(anObject$a2(it));
    var getOwnPropertySymbols = getOwnPropertySymbolsModule$1$1.f;
    return getOwnPropertySymbols
      ? concat$1$1(keys5, getOwnPropertySymbols(it))
      : keys5;
  };
var hasOwn$42 = hasOwnProperty_12;
var ownKeys4 = ownKeys$12;
var getOwnPropertyDescriptorModule2 = objectGetOwnPropertyDescriptor2;
var definePropertyModule$22 = objectDefineProperty2;
var copyConstructorProperties$12 = function (target, source, exceptions) {
  var keys5 = ownKeys4(source);
  var defineProperty7 = definePropertyModule$22.f;
  var getOwnPropertyDescriptor5 = getOwnPropertyDescriptorModule2.f;
  for (var i = 0; i < keys5.length; i++) {
    var key = keys5[i];
    if (
      !hasOwn$42(target, key) &&
      !(exceptions && hasOwn$42(exceptions, key))
    ) {
      defineProperty7(target, key, getOwnPropertyDescriptor5(source, key));
    }
  }
};
var fails$62 = fails$e$1;
var isCallable$a2 = isCallable$k2;
var replacement2 = /#|\.prototype\./;
var isForced$22 = function (feature, detection) {
  var value = data2[normalize2(feature)];
  return value == POLYFILL2
    ? true
    : value == NATIVE2
    ? false
    : isCallable$a2(detection)
    ? fails$62(detection)
    : !!detection;
};
var normalize2 = (isForced$22.normalize = function (string) {
  return String(string).replace(replacement2, ".").toLowerCase();
});
var data2 = (isForced$22.data = {});
var NATIVE2 = (isForced$22.NATIVE = "N");
var POLYFILL2 = (isForced$22.POLYFILL = "P");
var isForced_12 = isForced$22;
var global$a2 = global$j2;
var getOwnPropertyDescriptor$12 = objectGetOwnPropertyDescriptor2.f;
var createNonEnumerableProperty$22 = createNonEnumerableProperty$42;
var defineBuiltIn$52 = defineBuiltIn$62;
var defineGlobalProperty2 = defineGlobalProperty$32;
var copyConstructorProperties2 = copyConstructorProperties$12;
var isForced$12 = isForced_12;
var _export2 = function (options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var FORCED, target, key, targetProperty, sourceProperty, descriptor;
  if (GLOBAL) {
    target = global$a2;
  } else if (STATIC) {
    target = global$a2[TARGET] || defineGlobalProperty2(TARGET, {});
  } else {
    target = (global$a2[TARGET] || {}).prototype;
  }
  if (target)
    for (key in source) {
      sourceProperty = source[key];
      if (options.dontCallGetSet) {
        descriptor = getOwnPropertyDescriptor$12(target, key);
        targetProperty = descriptor && descriptor.value;
      } else targetProperty = target[key];
      FORCED = isForced$12(
        GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key,
        options.forced
      );
      if (!FORCED && targetProperty !== void 0) {
        if (typeof sourceProperty == typeof targetProperty) continue;
        copyConstructorProperties2(sourceProperty, targetProperty);
      }
      if (options.sham || (targetProperty && targetProperty.sham)) {
        createNonEnumerableProperty$22(sourceProperty, "sham", true);
      }
      defineBuiltIn$52(target, key, sourceProperty, options);
    }
};
var internalObjectKeys2 = objectKeysInternal2;
var enumBugKeys$12 = enumBugKeys$32;
var objectKeys$2$1 =
  Object.keys ||
  function keys4(O) {
    return internalObjectKeys2(O, enumBugKeys$12);
  };
var DESCRIPTORS$32 = descriptors2;
var uncurryThis$42 = functionUncurryThis2;
var call$a2 = functionCall2;
var fails$52 = fails$e$1;
var objectKeys$12 = objectKeys$2$1;
var getOwnPropertySymbolsModule2 = objectGetOwnPropertySymbols2;
var propertyIsEnumerableModule2 = objectPropertyIsEnumerable2;
var toObject$12 = toObject$3$1;
var IndexedObject2 = indexedObject2;
var $assign$1 = Object.assign;
var defineProperty$32 = Object.defineProperty;
var concat2 = uncurryThis$42([].concat);
var objectAssign$1 =
  !$assign$1 ||
  fails$52(function () {
    if (
      DESCRIPTORS$32 &&
      $assign$1(
        { b: 1 },
        $assign$1(
          defineProperty$32({}, "a", {
            enumerable: true,
            get: function () {
              defineProperty$32(this, "b", {
                value: 3,
                enumerable: false,
              });
            },
          }),
          { b: 2 }
        )
      ).b !== 1
    )
      return true;
    var A = {};
    var B = {};
    var symbol = Symbol();
    var alphabet = "abcdefghijklmnopqrst";
    A[symbol] = 7;
    alphabet.split("").forEach(function (chr) {
      B[chr] = chr;
    });
    return (
      $assign$1({}, A)[symbol] != 7 ||
      objectKeys$12($assign$1({}, B)).join("") != alphabet
    );
  })
    ? function assign(target, source) {
        var T = toObject$12(target);
        var argumentsLength = arguments.length;
        var index = 1;
        var getOwnPropertySymbols = getOwnPropertySymbolsModule2.f;
        var propertyIsEnumerable3 = propertyIsEnumerableModule2.f;
        while (argumentsLength > index) {
          var S = IndexedObject2(arguments[index++]);
          var keys5 = getOwnPropertySymbols
            ? concat2(objectKeys$12(S), getOwnPropertySymbols(S))
            : objectKeys$12(S);
          var length = keys5.length;
          var j = 0;
          var key;
          while (length > j) {
            key = keys5[j++];
            if (!DESCRIPTORS$32 || call$a2(propertyIsEnumerable3, S, key))
              T[key] = S[key];
          }
        }
        return T;
      }
    : $assign$1;
var $$7$1 = _export2;
var assign2$1 = objectAssign$1;
$$7$1(
  {
    target: "Object",
    stat: true,
    arity: 2,
    forced: Object.assign !== assign2$1,
  },
  {
    assign: assign2$1,
  }
);
var wellKnownSymbol$c2 = wellKnownSymbol$e2;
var TO_STRING_TAG$32 = wellKnownSymbol$c2("toStringTag");
var test2 = {};
test2[TO_STRING_TAG$32] = "z";
var toStringTagSupport2 = String(test2) === "[object z]";
var TO_STRING_TAG_SUPPORT2 = toStringTagSupport2;
var isCallable$92 = isCallable$k2;
var classofRaw2 = classofRaw$12;
var wellKnownSymbol$b2 = wellKnownSymbol$e2;
var TO_STRING_TAG$22 = wellKnownSymbol$b2("toStringTag");
var $Object$12 = Object;
var CORRECT_ARGUMENTS2 =
  classofRaw2(
    (function () {
      return arguments;
    })()
  ) == "Arguments";
var tryGet2 = function (it, key) {
  try {
    return it[key];
  } catch (error) {}
};
var classof$42 = TO_STRING_TAG_SUPPORT2
  ? classofRaw2
  : function (it) {
      var O, tag, result;
      return it === void 0
        ? "Undefined"
        : it === null
        ? "Null"
        : typeof (tag = tryGet2((O = $Object$12(it)), TO_STRING_TAG$22)) ==
          "string"
        ? tag
        : CORRECT_ARGUMENTS2
        ? classofRaw2(O)
        : (result = classofRaw2(O)) == "Object" && isCallable$92(O.callee)
        ? "Arguments"
        : result;
    };
var classof$32 = classof$42;
var $String$12 = String;
var toString4 = function (argument) {
  if (classof$32(argument) === "Symbol")
    throw TypeError("Cannot convert a Symbol value to a string");
  return $String$12(argument);
};
var anObject$92 = anObject$c2;
var regexpFlags2 = function () {
  var that = anObject$92(this);
  var result = "";
  if (that.hasIndices) result += "d";
  if (that.global) result += "g";
  if (that.ignoreCase) result += "i";
  if (that.multiline) result += "m";
  if (that.dotAll) result += "s";
  if (that.unicode) result += "u";
  if (that.unicodeSets) result += "v";
  if (that.sticky) result += "y";
  return result;
};
var call$92 = functionCall2;
var hasOwn$32 = hasOwnProperty_12;
var isPrototypeOf$22 = objectIsPrototypeOf2;
var regExpFlags2 = regexpFlags2;
var RegExpPrototype$12 = RegExp.prototype;
var regexpGetFlags2 = function (R) {
  var flags = R.flags;
  return flags === void 0 &&
    !("flags" in RegExpPrototype$12) &&
    !hasOwn$32(R, "flags") &&
    isPrototypeOf$22(RegExpPrototype$12, R)
    ? call$92(regExpFlags2, R)
    : flags;
};
var PROPER_FUNCTION_NAME$12 = functionName2.PROPER;
var defineBuiltIn$42 = defineBuiltIn$62;
var anObject$82 = anObject$c2;
var $toString2 = toString4;
var fails$42 = fails$e$1;
var getRegExpFlags2 = regexpGetFlags2;
var TO_STRING2 = "toString";
var RegExpPrototype2 = RegExp.prototype;
var n$ToString2 = RegExpPrototype2[TO_STRING2];
var NOT_GENERIC2 = fails$42(function () {
  return n$ToString2.call({ source: "a", flags: "b" }) != "/a/b";
});
var INCORRECT_NAME2 = PROPER_FUNCTION_NAME$12 && n$ToString2.name != TO_STRING2;
if (NOT_GENERIC2 || INCORRECT_NAME2) {
  defineBuiltIn$42(
    RegExp.prototype,
    TO_STRING2,
    function toString5() {
      var R = anObject$82(this);
      var pattern = $toString2(R.source);
      var flags = $toString2(getRegExpFlags2(R));
      return "/" + pattern + "/" + flags;
    },
    { unsafe: true }
  );
}
var objectDefineProperties2 = {};
var DESCRIPTORS$22 = descriptors2;
var V8_PROTOTYPE_DEFINE_BUG2 = v8PrototypeDefineBug2;
var definePropertyModule$12 = objectDefineProperty2;
var anObject$72 = anObject$c2;
var toIndexedObject$12 = toIndexedObject$52;
var objectKeys2 = objectKeys$2$1;
objectDefineProperties2.f =
  DESCRIPTORS$22 && !V8_PROTOTYPE_DEFINE_BUG2
    ? Object.defineProperties
    : function defineProperties2(O, Properties) {
        anObject$72(O);
        var props = toIndexedObject$12(Properties);
        var keys5 = objectKeys2(Properties);
        var length = keys5.length;
        var index = 0;
        var key;
        while (length > index)
          definePropertyModule$12.f(O, (key = keys5[index++]), props[key]);
        return O;
      };
var getBuiltIn$42 = getBuiltIn$82;
var html$22 = getBuiltIn$42("document", "documentElement");
var anObject$62 = anObject$c2;
var definePropertiesModule2 = objectDefineProperties2;
var enumBugKeys2 = enumBugKeys$32;
var hiddenKeys2 = hiddenKeys$42;
var html$12 = html$22;
var documentCreateElement$12 = documentCreateElement$22;
var sharedKey$12 = sharedKey$32;
var GT2 = ">";
var LT2 = "<";
var PROTOTYPE2 = "prototype";
var SCRIPT2 = "script";
var IE_PROTO$12 = sharedKey$12("IE_PROTO");
var EmptyConstructor2 = function () {};
var scriptTag2 = function (content) {
  return LT2 + SCRIPT2 + GT2 + content + LT2 + "/" + SCRIPT2 + GT2;
};
var NullProtoObjectViaActiveX2 = function (activeXDocument3) {
  activeXDocument3.write(scriptTag2(""));
  activeXDocument3.close();
  var temp = activeXDocument3.parentWindow.Object;
  activeXDocument3 = null;
  return temp;
};
var NullProtoObjectViaIFrame2 = function () {
  var iframe = documentCreateElement$12("iframe");
  var JS = "java" + SCRIPT2 + ":";
  var iframeDocument;
  iframe.style.display = "none";
  html$12.appendChild(iframe);
  iframe.src = String(JS);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(scriptTag2("document.F=Object"));
  iframeDocument.close();
  return iframeDocument.F;
};
var activeXDocument2;
var NullProtoObject2 = function () {
  try {
    activeXDocument2 = new ActiveXObject("htmlfile");
  } catch (error) {}
  NullProtoObject2 =
    typeof document != "undefined"
      ? document.domain && activeXDocument2
        ? NullProtoObjectViaActiveX2(activeXDocument2)
        : NullProtoObjectViaIFrame2()
      : NullProtoObjectViaActiveX2(activeXDocument2);
  var length = enumBugKeys2.length;
  while (length--) delete NullProtoObject2[PROTOTYPE2][enumBugKeys2[length]];
  return NullProtoObject2();
};
hiddenKeys2[IE_PROTO$12] = true;
var objectCreate2 =
  Object.create ||
  function create3(O, Properties) {
    var result;
    if (O !== null) {
      EmptyConstructor2[PROTOTYPE2] = anObject$62(O);
      result = new EmptyConstructor2();
      EmptyConstructor2[PROTOTYPE2] = null;
      result[IE_PROTO$12] = O;
    } else result = NullProtoObject2();
    return Properties === void 0
      ? result
      : definePropertiesModule2.f(result, Properties);
  };
var wellKnownSymbol$a2 = wellKnownSymbol$e2;
var create$12 = objectCreate2;
var defineProperty$22 = objectDefineProperty2.f;
var UNSCOPABLES2 = wellKnownSymbol$a2("unscopables");
var ArrayPrototype$12 = Array.prototype;
if (ArrayPrototype$12[UNSCOPABLES2] == void 0) {
  defineProperty$22(ArrayPrototype$12, UNSCOPABLES2, {
    configurable: true,
    value: create$12(null),
  });
}
var addToUnscopables$12 = function (key) {
  ArrayPrototype$12[UNSCOPABLES2][key] = true;
};
var iterators2 = {};
var fails$32 = fails$e$1;
var correctPrototypeGetter2 = !fails$32(function () {
  function F() {}
  F.prototype.constructor = null;
  return Object.getPrototypeOf(new F()) !== F.prototype;
});
var hasOwn$22 = hasOwnProperty_12;
var isCallable$82 = isCallable$k2;
var toObject2 = toObject$3$1;
var sharedKey2 = sharedKey$32;
var CORRECT_PROTOTYPE_GETTER2 = correctPrototypeGetter2;
var IE_PROTO2 = sharedKey2("IE_PROTO");
var $Object2 = Object;
var ObjectPrototype2 = $Object2.prototype;
var objectGetPrototypeOf2 = CORRECT_PROTOTYPE_GETTER2
  ? $Object2.getPrototypeOf
  : function (O) {
      var object = toObject2(O);
      if (hasOwn$22(object, IE_PROTO2)) return object[IE_PROTO2];
      var constructor = object.constructor;
      if (isCallable$82(constructor) && object instanceof constructor) {
        return constructor.prototype;
      }
      return object instanceof $Object2 ? ObjectPrototype2 : null;
    };
var fails$22 = fails$e$1;
var isCallable$72 = isCallable$k2;
var getPrototypeOf$12 = objectGetPrototypeOf2;
var defineBuiltIn$32 = defineBuiltIn$62;
var wellKnownSymbol$92 = wellKnownSymbol$e2;
var ITERATOR$52 = wellKnownSymbol$92("iterator");
var BUGGY_SAFARI_ITERATORS$12 = false;
var IteratorPrototype$22;
var PrototypeOfArrayIteratorPrototype2;
var arrayIterator2;
if ([].keys) {
  arrayIterator2 = [].keys();
  if (!("next" in arrayIterator2)) BUGGY_SAFARI_ITERATORS$12 = true;
  else {
    PrototypeOfArrayIteratorPrototype2 = getPrototypeOf$12(
      getPrototypeOf$12(arrayIterator2)
    );
    if (PrototypeOfArrayIteratorPrototype2 !== Object.prototype)
      IteratorPrototype$22 = PrototypeOfArrayIteratorPrototype2;
  }
}
var NEW_ITERATOR_PROTOTYPE2 =
  IteratorPrototype$22 == void 0 ||
  fails$22(function () {
    var test3 = {};
    return IteratorPrototype$22[ITERATOR$52].call(test3) !== test3;
  });
if (NEW_ITERATOR_PROTOTYPE2) IteratorPrototype$22 = {};
if (!isCallable$72(IteratorPrototype$22[ITERATOR$52])) {
  defineBuiltIn$32(IteratorPrototype$22, ITERATOR$52, function () {
    return this;
  });
}
var iteratorsCore2 = {
  IteratorPrototype: IteratorPrototype$22,
  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS$12,
};
var defineProperty$12 = objectDefineProperty2.f;
var hasOwn$12 = hasOwnProperty_12;
var wellKnownSymbol$82 = wellKnownSymbol$e2;
var TO_STRING_TAG$12 = wellKnownSymbol$82("toStringTag");
var setToStringTag$32 = function (target, TAG, STATIC) {
  if (target && !STATIC) target = target.prototype;
  if (target && !hasOwn$12(target, TO_STRING_TAG$12)) {
    defineProperty$12(target, TO_STRING_TAG$12, {
      configurable: true,
      value: TAG,
    });
  }
};
var IteratorPrototype$12 = iteratorsCore2.IteratorPrototype;
var create4 = objectCreate2;
var createPropertyDescriptor2 = createPropertyDescriptor$32;
var setToStringTag$22 = setToStringTag$32;
var Iterators$42 = iterators2;
var returnThis$12 = function () {
  return this;
};
var createIteratorConstructor$12 = function (
  IteratorConstructor,
  NAME,
  next,
  ENUMERABLE_NEXT
) {
  var TO_STRING_TAG3 = NAME + " Iterator";
  IteratorConstructor.prototype = create4(IteratorPrototype$12, {
    next: createPropertyDescriptor2(+!ENUMERABLE_NEXT, next),
  });
  setToStringTag$22(IteratorConstructor, TO_STRING_TAG3, false);
  Iterators$42[TO_STRING_TAG3] = returnThis$12;
  return IteratorConstructor;
};
var isCallable$62 = isCallable$k2;
var $String2 = String;
var $TypeError$52 = TypeError;
var aPossiblePrototype$12 = function (argument) {
  if (typeof argument == "object" || isCallable$62(argument)) return argument;
  throw $TypeError$52("Can't set " + $String2(argument) + " as a prototype");
};
var uncurryThis$32 = functionUncurryThis2;
var anObject$52 = anObject$c2;
var aPossiblePrototype2 = aPossiblePrototype$12;
var objectSetPrototypeOf2 =
  Object.setPrototypeOf ||
  ("__proto__" in {}
    ? (function () {
        var CORRECT_SETTER = false;
        var test3 = {};
        var setter;
        try {
          setter = uncurryThis$32(
            Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set
          );
          setter(test3, []);
          CORRECT_SETTER = test3 instanceof Array;
        } catch (error) {}
        return function setPrototypeOf3(O, proto) {
          anObject$52(O);
          aPossiblePrototype2(proto);
          if (CORRECT_SETTER) setter(O, proto);
          else O.__proto__ = proto;
          return O;
        };
      })()
    : void 0);
var $$62 = _export2;
var call$82 = functionCall2;
var FunctionName2 = functionName2;
var isCallable$52 = isCallable$k2;
var createIteratorConstructor2 = createIteratorConstructor$12;
var getPrototypeOf2 = objectGetPrototypeOf2;
var setPrototypeOf$12 = objectSetPrototypeOf2;
var setToStringTag$12 = setToStringTag$32;
var createNonEnumerableProperty$12 = createNonEnumerableProperty$42;
var defineBuiltIn$22 = defineBuiltIn$62;
var wellKnownSymbol$72 = wellKnownSymbol$e2;
var Iterators$32 = iterators2;
var IteratorsCore2 = iteratorsCore2;
var PROPER_FUNCTION_NAME2 = FunctionName2.PROPER;
var CONFIGURABLE_FUNCTION_NAME2 = FunctionName2.CONFIGURABLE;
var IteratorPrototype2 = IteratorsCore2.IteratorPrototype;
var BUGGY_SAFARI_ITERATORS2 = IteratorsCore2.BUGGY_SAFARI_ITERATORS;
var ITERATOR$42 = wellKnownSymbol$72("iterator");
var KEYS2 = "keys";
var VALUES2 = "values";
var ENTRIES2 = "entries";
var returnThis2 = function () {
  return this;
};
var defineIterator$12 = function (
  Iterable,
  NAME,
  IteratorConstructor,
  next,
  DEFAULT,
  IS_SET,
  FORCED
) {
  createIteratorConstructor2(IteratorConstructor, NAME, next);
  var getIterationMethod = function (KIND) {
    if (KIND === DEFAULT && defaultIterator) return defaultIterator;
    if (!BUGGY_SAFARI_ITERATORS2 && KIND in IterablePrototype)
      return IterablePrototype[KIND];
    switch (KIND) {
      case KEYS2:
        return function keys5() {
          return new IteratorConstructor(this, KIND);
        };
      case VALUES2:
        return function values3() {
          return new IteratorConstructor(this, KIND);
        };
      case ENTRIES2:
        return function entries() {
          return new IteratorConstructor(this, KIND);
        };
    }
    return function () {
      return new IteratorConstructor(this);
    };
  };
  var TO_STRING_TAG3 = NAME + " Iterator";
  var INCORRECT_VALUES_NAME = false;
  var IterablePrototype = Iterable.prototype;
  var nativeIterator =
    IterablePrototype[ITERATOR$42] ||
    IterablePrototype["@@iterator"] ||
    (DEFAULT && IterablePrototype[DEFAULT]);
  var defaultIterator =
    (!BUGGY_SAFARI_ITERATORS2 && nativeIterator) || getIterationMethod(DEFAULT);
  var anyNativeIterator =
    NAME == "Array"
      ? IterablePrototype.entries || nativeIterator
      : nativeIterator;
  var CurrentIteratorPrototype, methods, KEY;
  if (anyNativeIterator) {
    CurrentIteratorPrototype = getPrototypeOf2(
      anyNativeIterator.call(new Iterable())
    );
    if (
      CurrentIteratorPrototype !== Object.prototype &&
      CurrentIteratorPrototype.next
    ) {
      if (getPrototypeOf2(CurrentIteratorPrototype) !== IteratorPrototype2) {
        if (setPrototypeOf$12) {
          setPrototypeOf$12(CurrentIteratorPrototype, IteratorPrototype2);
        } else if (!isCallable$52(CurrentIteratorPrototype[ITERATOR$42])) {
          defineBuiltIn$22(CurrentIteratorPrototype, ITERATOR$42, returnThis2);
        }
      }
      setToStringTag$12(CurrentIteratorPrototype, TO_STRING_TAG3, true);
    }
  }
  if (
    PROPER_FUNCTION_NAME2 &&
    DEFAULT == VALUES2 &&
    nativeIterator &&
    nativeIterator.name !== VALUES2
  ) {
    if (CONFIGURABLE_FUNCTION_NAME2) {
      createNonEnumerableProperty$12(IterablePrototype, "name", VALUES2);
    } else {
      INCORRECT_VALUES_NAME = true;
      defaultIterator = function values3() {
        return call$82(nativeIterator, this);
      };
    }
  }
  if (DEFAULT) {
    methods = {
      values: getIterationMethod(VALUES2),
      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS2),
      entries: getIterationMethod(ENTRIES2),
    };
    if (FORCED)
      for (KEY in methods) {
        if (
          BUGGY_SAFARI_ITERATORS2 ||
          INCORRECT_VALUES_NAME ||
          !(KEY in IterablePrototype)
        ) {
          defineBuiltIn$22(IterablePrototype, KEY, methods[KEY]);
        }
      }
    else
      $$62(
        {
          target: NAME,
          proto: true,
          forced: BUGGY_SAFARI_ITERATORS2 || INCORRECT_VALUES_NAME,
        },
        methods
      );
  }
  if (IterablePrototype[ITERATOR$42] !== defaultIterator) {
    defineBuiltIn$22(IterablePrototype, ITERATOR$42, defaultIterator, {
      name: DEFAULT,
    });
  }
  Iterators$32[NAME] = defaultIterator;
  return methods;
};
var toIndexedObject2 = toIndexedObject$52;
var addToUnscopables2 = addToUnscopables$12;
var Iterators$22 = iterators2;
var InternalStateModule$12 = internalState2;
var defineProperty6 = objectDefineProperty2.f;
var defineIterator2 = defineIterator$12;
var DESCRIPTORS$12 = descriptors2;
var ARRAY_ITERATOR2 = "Array Iterator";
var setInternalState$12 = InternalStateModule$12.set;
var getInternalState2 = InternalStateModule$12.getterFor(ARRAY_ITERATOR2);
var es_array_iterator2 = defineIterator2(
  Array,
  "Array",
  function (iterated, kind) {
    setInternalState$12(this, {
      type: ARRAY_ITERATOR2,
      target: toIndexedObject2(iterated),
      // target
      index: 0,
      // next index
      kind,
      // kind
    });
  },
  function () {
    var state = getInternalState2(this);
    var target = state.target;
    var kind = state.kind;
    var index = state.index++;
    if (!target || index >= target.length) {
      state.target = void 0;
      return { value: void 0, done: true };
    }
    if (kind == "keys") return { value: index, done: false };
    if (kind == "values") return { value: target[index], done: false };
    return { value: [index, target[index]], done: false };
  },
  "values"
);
var values2 = (Iterators$22.Arguments = Iterators$22.Array);
addToUnscopables2("keys");
addToUnscopables2("values");
addToUnscopables2("entries");
if (DESCRIPTORS$12 && values2.name !== "values")
  try {
    defineProperty6(values2, "name", { value: "values" });
  } catch (error) {}
var classof$22 = classofRaw$12;
var global$92 = global$j2;
var engineIsNode2 = classof$22(global$92.process) == "process";
var getBuiltIn$32 = getBuiltIn$82;
var definePropertyModule2 = objectDefineProperty2;
var wellKnownSymbol$62 = wellKnownSymbol$e2;
var DESCRIPTORS2 = descriptors2;
var SPECIES$22 = wellKnownSymbol$62("species");
var setSpecies$12 = function (CONSTRUCTOR_NAME) {
  var Constructor = getBuiltIn$32(CONSTRUCTOR_NAME);
  var defineProperty7 = definePropertyModule2.f;
  if (DESCRIPTORS2 && Constructor && !Constructor[SPECIES$22]) {
    defineProperty7(Constructor, SPECIES$22, {
      configurable: true,
      get: function () {
        return this;
      },
    });
  }
};
var isPrototypeOf$12 = objectIsPrototypeOf2;
var $TypeError$42 = TypeError;
var anInstance$12 = function (it, Prototype) {
  if (isPrototypeOf$12(Prototype, it)) return it;
  throw $TypeError$42("Incorrect invocation");
};
var uncurryThis$22 = functionUncurryThis2;
var fails$12 = fails$e$1;
var isCallable$42 = isCallable$k2;
var classof$12 = classof$42;
var getBuiltIn$22 = getBuiltIn$82;
var inspectSource$12 = inspectSource$42;
var noop2 = function () {};
var empty2 = [];
var construct2 = getBuiltIn$22("Reflect", "construct");
var constructorRegExp2 = /^\s*(?:class|function)\b/;
var exec2 = uncurryThis$22(constructorRegExp2.exec);
var INCORRECT_TO_STRING2 = !constructorRegExp2.exec(noop2);
var isConstructorModern2 = function isConstructor4(argument) {
  if (!isCallable$42(argument)) return false;
  try {
    construct2(noop2, empty2, argument);
    return true;
  } catch (error) {
    return false;
  }
};
var isConstructorLegacy2 = function isConstructor5(argument) {
  if (!isCallable$42(argument)) return false;
  switch (classof$12(argument)) {
    case "AsyncFunction":
    case "GeneratorFunction":
    case "AsyncGeneratorFunction":
      return false;
  }
  try {
    return (
      INCORRECT_TO_STRING2 ||
      !!exec2(constructorRegExp2, inspectSource$12(argument))
    );
  } catch (error) {
    return true;
  }
};
isConstructorLegacy2.sham = true;
var isConstructor$12 =
  !construct2 ||
  fails$12(function () {
    var called;
    return (
      isConstructorModern2(isConstructorModern2.call) ||
      !isConstructorModern2(Object) ||
      !isConstructorModern2(function () {
        called = true;
      }) ||
      called
    );
  })
    ? isConstructorLegacy2
    : isConstructorModern2;
var isConstructor6 = isConstructor$12;
var tryToString$22 = tryToString$42;
var $TypeError$32 = TypeError;
var aConstructor$12 = function (argument) {
  if (isConstructor6(argument)) return argument;
  throw $TypeError$32(tryToString$22(argument) + " is not a constructor");
};
var anObject$42 = anObject$c2;
var aConstructor2 = aConstructor$12;
var wellKnownSymbol$52 = wellKnownSymbol$e2;
var SPECIES$12 = wellKnownSymbol$52("species");
var speciesConstructor$12 = function (O, defaultConstructor) {
  var C = anObject$42(O).constructor;
  var S;
  return C === void 0 || (S = anObject$42(C)[SPECIES$12]) == void 0
    ? defaultConstructor
    : aConstructor2(S);
};
var NATIVE_BIND$12 = functionBindNative2;
var FunctionPrototype2 = Function.prototype;
var apply$12 = FunctionPrototype2.apply;
var call$72 = FunctionPrototype2.call;
var functionApply2 =
  (typeof Reflect == "object" && Reflect.apply) ||
  (NATIVE_BIND$12
    ? call$72.bind(apply$12)
    : function () {
        return call$72.apply(apply$12, arguments);
      });
var uncurryThis$12 = functionUncurryThis2;
var aCallable$52 = aCallable$72;
var NATIVE_BIND2 = functionBindNative2;
var bind$42 = uncurryThis$12(uncurryThis$12.bind);
var functionBindContext2 = function (fn, that) {
  aCallable$52(fn);
  return that === void 0
    ? fn
    : NATIVE_BIND2
    ? bind$42(fn, that)
    : function () {
        return fn.apply(that, arguments);
      };
};
var uncurryThis2 = functionUncurryThis2;
var arraySlice$12 = uncurryThis2([].slice);
var $TypeError$22 = TypeError;
var validateArgumentsLength$12 = function (passed, required) {
  if (passed < required) throw $TypeError$22("Not enough arguments");
  return passed;
};
var userAgent$22 = engineUserAgent2;
var engineIsIos2 = /(?:ipad|iphone|ipod).*applewebkit/i.test(userAgent$22);
var global$82 = global$j2;
var apply2 = functionApply2;
var bind$32 = functionBindContext2;
var isCallable$32 = isCallable$k2;
var hasOwn4 = hasOwnProperty_12;
var fails2 = fails$e$1;
var html2 = html$22;
var arraySlice2 = arraySlice$12;
var createElement2 = documentCreateElement$22;
var validateArgumentsLength2 = validateArgumentsLength$12;
var IS_IOS$12 = engineIsIos2;
var IS_NODE$22 = engineIsNode2;
var set2 = global$82.setImmediate;
var clear2 = global$82.clearImmediate;
var process$22 = global$82.process;
var Dispatch2 = global$82.Dispatch;
var Function$12 = global$82.Function;
var MessageChannel2 = global$82.MessageChannel;
var String$12 = global$82.String;
var counter2 = 0;
var queue$12 = {};
var ONREADYSTATECHANGE2 = "onreadystatechange";
var location2;
var defer2;
var channel2;
var port2;
try {
  location2 = global$82.location;
} catch (error) {}
var run2 = function (id3) {
  if (hasOwn4(queue$12, id3)) {
    var fn = queue$12[id3];
    delete queue$12[id3];
    fn();
  }
};
var runner2 = function (id3) {
  return function () {
    run2(id3);
  };
};
var listener2 = function (event) {
  run2(event.data);
};
var post2 = function (id3) {
  global$82.postMessage(
    String$12(id3),
    location2.protocol + "//" + location2.host
  );
};
if (!set2 || !clear2) {
  set2 = function setImmediate(handler) {
    validateArgumentsLength2(arguments.length, 1);
    var fn = isCallable$32(handler) ? handler : Function$12(handler);
    var args = arraySlice2(arguments, 1);
    queue$12[++counter2] = function () {
      apply2(fn, void 0, args);
    };
    defer2(counter2);
    return counter2;
  };
  clear2 = function clearImmediate(id3) {
    delete queue$12[id3];
  };
  if (IS_NODE$22) {
    defer2 = function (id3) {
      process$22.nextTick(runner2(id3));
    };
  } else if (Dispatch2 && Dispatch2.now) {
    defer2 = function (id3) {
      Dispatch2.now(runner2(id3));
    };
  } else if (MessageChannel2 && !IS_IOS$12) {
    channel2 = new MessageChannel2();
    port2 = channel2.port2;
    channel2.port1.onmessage = listener2;
    defer2 = bind$32(port2.postMessage, port2);
  } else if (
    global$82.addEventListener &&
    isCallable$32(global$82.postMessage) &&
    !global$82.importScripts &&
    location2 &&
    location2.protocol !== "file:" &&
    !fails2(post2)
  ) {
    defer2 = post2;
    global$82.addEventListener("message", listener2, false);
  } else if (ONREADYSTATECHANGE2 in createElement2("script")) {
    defer2 = function (id3) {
      html2.appendChild(createElement2("script"))[ONREADYSTATECHANGE2] =
        function () {
          html2.removeChild(this);
          run2(id3);
        };
    };
  } else {
    defer2 = function (id3) {
      setTimeout(runner2(id3), 0);
    };
  }
}
var task$12 = {
  set: set2,
  clear: clear2,
};
var userAgent$12 = engineUserAgent2;
var global$72 = global$j2;
var engineIsIosPebble2 =
  /ipad|iphone|ipod/i.test(userAgent$12) && global$72.Pebble !== void 0;
var userAgent2 = engineUserAgent2;
var engineIsWebosWebkit2 = /web0s(?!.*chrome)/i.test(userAgent2);
var global$62 = global$j2;
var bind$22 = functionBindContext2;
var getOwnPropertyDescriptor4 = objectGetOwnPropertyDescriptor2.f;
var macrotask2 = task$12.set;
var IS_IOS2 = engineIsIos2;
var IS_IOS_PEBBLE2 = engineIsIosPebble2;
var IS_WEBOS_WEBKIT2 = engineIsWebosWebkit2;
var IS_NODE$12 = engineIsNode2;
var MutationObserver2 =
  global$62.MutationObserver || global$62.WebKitMutationObserver;
var document$22 = global$62.document;
var process$12 = global$62.process;
var Promise$12 = global$62.Promise;
var queueMicrotaskDescriptor2 = getOwnPropertyDescriptor4(
  global$62,
  "queueMicrotask"
);
var queueMicrotask2 =
  queueMicrotaskDescriptor2 && queueMicrotaskDescriptor2.value;
var flush2;
var head2;
var last2;
var notify$12;
var toggle2;
var node2;
var promise2;
var then2;
if (!queueMicrotask2) {
  flush2 = function () {
    var parent, fn;
    if (IS_NODE$12 && (parent = process$12.domain)) parent.exit();
    while (head2) {
      fn = head2.fn;
      head2 = head2.next;
      try {
        fn();
      } catch (error) {
        if (head2) notify$12();
        else last2 = void 0;
        throw error;
      }
    }
    last2 = void 0;
    if (parent) parent.enter();
  };
  if (
    !IS_IOS2 &&
    !IS_NODE$12 &&
    !IS_WEBOS_WEBKIT2 &&
    MutationObserver2 &&
    document$22
  ) {
    toggle2 = true;
    node2 = document$22.createTextNode("");
    new MutationObserver2(flush2).observe(node2, { characterData: true });
    notify$12 = function () {
      node2.data = toggle2 = !toggle2;
    };
  } else if (!IS_IOS_PEBBLE2 && Promise$12 && Promise$12.resolve) {
    promise2 = Promise$12.resolve(void 0);
    promise2.constructor = Promise$12;
    then2 = bind$22(promise2.then, promise2);
    notify$12 = function () {
      then2(flush2);
    };
  } else if (IS_NODE$12) {
    notify$12 = function () {
      process$12.nextTick(flush2);
    };
  } else {
    macrotask2 = bind$22(macrotask2, global$62);
    notify$12 = function () {
      macrotask2(flush2);
    };
  }
}
var microtask$12 =
  queueMicrotask2 ||
  function (fn) {
    var task3 = { fn, next: void 0 };
    if (last2) last2.next = task3;
    if (!head2) {
      head2 = task3;
      notify$12();
    }
    last2 = task3;
  };
var global$52 = global$j2;
var hostReportErrors$12 = function (a, b) {
  var console = global$52.console;
  if (console && console.error) {
    arguments.length == 1 ? console.error(a) : console.error(a, b);
  }
};
var perform$32 = function (exec3) {
  try {
    return { error: false, value: exec3() };
  } catch (error) {
    return { error: true, value: error };
  }
};
var Queue$12 = function () {
  this.head = null;
  this.tail = null;
};
Queue$12.prototype = {
  add: function (item) {
    var entry = { item, next: null };
    if (this.head) this.tail.next = entry;
    else this.head = entry;
    this.tail = entry;
  },
  get: function () {
    var entry = this.head;
    if (entry) {
      this.head = entry.next;
      if (this.tail === entry) this.tail = null;
      return entry.item;
    }
  },
};
var queue2 = Queue$12;
var global$42 = global$j2;
var promiseNativeConstructor2 = global$42.Promise;
var engineIsBrowser2 = typeof window == "object" && typeof Deno != "object";
var global$32 = global$j2;
var NativePromiseConstructor$32 = promiseNativeConstructor2;
var isCallable$22 = isCallable$k2;
var isForced2 = isForced_12;
var inspectSource2 = inspectSource$42;
var wellKnownSymbol$42 = wellKnownSymbol$e2;
var IS_BROWSER2 = engineIsBrowser2;
var V8_VERSION2 = engineV8Version2;
NativePromiseConstructor$32 && NativePromiseConstructor$32.prototype;
var SPECIES2 = wellKnownSymbol$42("species");
var SUBCLASSING2 = false;
var NATIVE_PROMISE_REJECTION_EVENT$12 = isCallable$22(
  global$32.PromiseRejectionEvent
);
var FORCED_PROMISE_CONSTRUCTOR$52 = isForced2("Promise", function () {
  var PROMISE_CONSTRUCTOR_SOURCE = inspectSource2(NativePromiseConstructor$32);
  var GLOBAL_CORE_JS_PROMISE =
    PROMISE_CONSTRUCTOR_SOURCE !== String(NativePromiseConstructor$32);
  if (!GLOBAL_CORE_JS_PROMISE && V8_VERSION2 === 66) return true;
  if (V8_VERSION2 >= 51 && /native code/.test(PROMISE_CONSTRUCTOR_SOURCE))
    return false;
  var promise3 = new NativePromiseConstructor$32(function (resolve3) {
    resolve3(1);
  });
  var FakePromise = function (exec3) {
    exec3(
      function () {},
      function () {}
    );
  };
  var constructor = (promise3.constructor = {});
  constructor[SPECIES2] = FakePromise;
  SUBCLASSING2 = promise3.then(function () {}) instanceof FakePromise;
  if (!SUBCLASSING2) return true;
  return (
    !GLOBAL_CORE_JS_PROMISE && IS_BROWSER2 && !NATIVE_PROMISE_REJECTION_EVENT$12
  );
});
var promiseConstructorDetection2 = {
  CONSTRUCTOR: FORCED_PROMISE_CONSTRUCTOR$52,
  REJECTION_EVENT: NATIVE_PROMISE_REJECTION_EVENT$12,
  SUBCLASSING: SUBCLASSING2,
};
var newPromiseCapability$22 = {};
var aCallable$42 = aCallable$72;
var PromiseCapability2 = function (C) {
  var resolve3, reject3;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve3 !== void 0 || reject3 !== void 0)
      throw TypeError("Bad Promise constructor");
    resolve3 = $$resolve;
    reject3 = $$reject;
  });
  this.resolve = aCallable$42(resolve3);
  this.reject = aCallable$42(reject3);
};
newPromiseCapability$22.f = function (C) {
  return new PromiseCapability2(C);
};
var $$52 = _export2;
var IS_NODE2 = engineIsNode2;
var global$22 = global$j2;
var call$62 = functionCall2;
var defineBuiltIn$12 = defineBuiltIn$62;
var setPrototypeOf2 = objectSetPrototypeOf2;
var setToStringTag2 = setToStringTag$32;
var setSpecies2 = setSpecies$12;
var aCallable$32 = aCallable$72;
var isCallable$12 = isCallable$k2;
var isObject$12 = isObject$72;
var anInstance2 = anInstance$12;
var speciesConstructor2 = speciesConstructor$12;
var task2 = task$12.set;
var microtask2 = microtask$12;
var hostReportErrors2 = hostReportErrors$12;
var perform$22 = perform$32;
var Queue2 = queue2;
var InternalStateModule2 = internalState2;
var NativePromiseConstructor$22 = promiseNativeConstructor2;
var PromiseConstructorDetection2 = promiseConstructorDetection2;
var newPromiseCapabilityModule$32 = newPromiseCapability$22;
var PROMISE2 = "Promise";
var FORCED_PROMISE_CONSTRUCTOR$42 = PromiseConstructorDetection2.CONSTRUCTOR;
var NATIVE_PROMISE_REJECTION_EVENT2 =
  PromiseConstructorDetection2.REJECTION_EVENT;
var NATIVE_PROMISE_SUBCLASSING2 = PromiseConstructorDetection2.SUBCLASSING;
var getInternalPromiseState2 = InternalStateModule2.getterFor(PROMISE2);
var setInternalState2 = InternalStateModule2.set;
var NativePromisePrototype$12 =
  NativePromiseConstructor$22 && NativePromiseConstructor$22.prototype;
var PromiseConstructor2 = NativePromiseConstructor$22;
var PromisePrototype2 = NativePromisePrototype$12;
var TypeError$12 = global$22.TypeError;
var document$12 = global$22.document;
var process2 = global$22.process;
var newPromiseCapability$12 = newPromiseCapabilityModule$32.f;
var newGenericPromiseCapability2 = newPromiseCapability$12;
var DISPATCH_EVENT2 = !!(
  document$12 &&
  document$12.createEvent &&
  global$22.dispatchEvent
);
var UNHANDLED_REJECTION2 = "unhandledrejection";
var REJECTION_HANDLED2 = "rejectionhandled";
var PENDING2 = 0;
var FULFILLED2 = 1;
var REJECTED2 = 2;
var HANDLED2 = 1;
var UNHANDLED2 = 2;
var Internal2;
var OwnPromiseCapability2;
var PromiseWrapper2;
var nativeThen2;
var isThenable2 = function (it) {
  var then3;
  return isObject$12(it) && isCallable$12((then3 = it.then)) ? then3 : false;
};
var callReaction2 = function (reaction, state) {
  var value = state.value;
  var ok = state.state == FULFILLED2;
  var handler = ok ? reaction.ok : reaction.fail;
  var resolve3 = reaction.resolve;
  var reject3 = reaction.reject;
  var domain = reaction.domain;
  var result, then3, exited;
  try {
    if (handler) {
      if (!ok) {
        if (state.rejection === UNHANDLED2) onHandleUnhandled2(state);
        state.rejection = HANDLED2;
      }
      if (handler === true) result = value;
      else {
        if (domain) domain.enter();
        result = handler(value);
        if (domain) {
          domain.exit();
          exited = true;
        }
      }
      if (result === reaction.promise) {
        reject3(TypeError$12("Promise-chain cycle"));
      } else if ((then3 = isThenable2(result))) {
        call$62(then3, result, resolve3, reject3);
      } else resolve3(result);
    } else reject3(value);
  } catch (error) {
    if (domain && !exited) domain.exit();
    reject3(error);
  }
};
var notify2 = function (state, isReject) {
  if (state.notified) return;
  state.notified = true;
  microtask2(function () {
    var reactions = state.reactions;
    var reaction;
    while ((reaction = reactions.get())) {
      callReaction2(reaction, state);
    }
    state.notified = false;
    if (isReject && !state.rejection) onUnhandled2(state);
  });
};
var dispatchEvent2 = function (name, promise3, reason) {
  var event, handler;
  if (DISPATCH_EVENT2) {
    event = document$12.createEvent("Event");
    event.promise = promise3;
    event.reason = reason;
    event.initEvent(name, false, true);
    global$22.dispatchEvent(event);
  } else event = { promise: promise3, reason };
  if (!NATIVE_PROMISE_REJECTION_EVENT2 && (handler = global$22["on" + name]))
    handler(event);
  else if (name === UNHANDLED_REJECTION2)
    hostReportErrors2("Unhandled promise rejection", reason);
};
var onUnhandled2 = function (state) {
  call$62(task2, global$22, function () {
    var promise3 = state.facade;
    var value = state.value;
    var IS_UNHANDLED = isUnhandled2(state);
    var result;
    if (IS_UNHANDLED) {
      result = perform$22(function () {
        if (IS_NODE2) {
          process2.emit("unhandledRejection", value, promise3);
        } else dispatchEvent2(UNHANDLED_REJECTION2, promise3, value);
      });
      state.rejection = IS_NODE2 || isUnhandled2(state) ? UNHANDLED2 : HANDLED2;
      if (result.error) throw result.value;
    }
  });
};
var isUnhandled2 = function (state) {
  return state.rejection !== HANDLED2 && !state.parent;
};
var onHandleUnhandled2 = function (state) {
  call$62(task2, global$22, function () {
    var promise3 = state.facade;
    if (IS_NODE2) {
      process2.emit("rejectionHandled", promise3);
    } else dispatchEvent2(REJECTION_HANDLED2, promise3, state.value);
  });
};
var bind$12 = function (fn, state, unwrap) {
  return function (value) {
    fn(state, value, unwrap);
  };
};
var internalReject2 = function (state, value, unwrap) {
  if (state.done) return;
  state.done = true;
  if (unwrap) state = unwrap;
  state.value = value;
  state.state = REJECTED2;
  notify2(state, true);
};
var internalResolve2 = function (state, value, unwrap) {
  if (state.done) return;
  state.done = true;
  if (unwrap) state = unwrap;
  try {
    if (state.facade === value)
      throw TypeError$12("Promise can't be resolved itself");
    var then3 = isThenable2(value);
    if (then3) {
      microtask2(function () {
        var wrapper = { done: false };
        try {
          call$62(
            then3,
            value,
            bind$12(internalResolve2, wrapper, state),
            bind$12(internalReject2, wrapper, state)
          );
        } catch (error) {
          internalReject2(wrapper, error, state);
        }
      });
    } else {
      state.value = value;
      state.state = FULFILLED2;
      notify2(state, false);
    }
  } catch (error) {
    internalReject2({ done: false }, error, state);
  }
};
if (FORCED_PROMISE_CONSTRUCTOR$42) {
  PromiseConstructor2 = function Promise2(executor) {
    anInstance2(this, PromisePrototype2);
    aCallable$32(executor);
    call$62(Internal2, this);
    var state = getInternalPromiseState2(this);
    try {
      executor(
        bind$12(internalResolve2, state),
        bind$12(internalReject2, state)
      );
    } catch (error) {
      internalReject2(state, error);
    }
  };
  PromisePrototype2 = PromiseConstructor2.prototype;
  Internal2 = function Promise2(executor) {
    setInternalState2(this, {
      type: PROMISE2,
      done: false,
      notified: false,
      parent: false,
      reactions: new Queue2(),
      rejection: false,
      state: PENDING2,
      value: void 0,
    });
  };
  Internal2.prototype = defineBuiltIn$12(
    PromisePrototype2,
    "then",
    function then3(onFulfilled, onRejected) {
      var state = getInternalPromiseState2(this);
      var reaction = newPromiseCapability$12(
        speciesConstructor2(this, PromiseConstructor2)
      );
      state.parent = true;
      reaction.ok = isCallable$12(onFulfilled) ? onFulfilled : true;
      reaction.fail = isCallable$12(onRejected) && onRejected;
      reaction.domain = IS_NODE2 ? process2.domain : void 0;
      if (state.state == PENDING2) state.reactions.add(reaction);
      else
        microtask2(function () {
          callReaction2(reaction, state);
        });
      return reaction.promise;
    }
  );
  OwnPromiseCapability2 = function () {
    var promise3 = new Internal2();
    var state = getInternalPromiseState2(promise3);
    this.promise = promise3;
    this.resolve = bind$12(internalResolve2, state);
    this.reject = bind$12(internalReject2, state);
  };
  newPromiseCapabilityModule$32.f = newPromiseCapability$12 = function (C) {
    return C === PromiseConstructor2 || C === PromiseWrapper2
      ? new OwnPromiseCapability2(C)
      : newGenericPromiseCapability2(C);
  };
  if (
    isCallable$12(NativePromiseConstructor$22) &&
    NativePromisePrototype$12 !== Object.prototype
  ) {
    nativeThen2 = NativePromisePrototype$12.then;
    if (!NATIVE_PROMISE_SUBCLASSING2) {
      defineBuiltIn$12(
        NativePromisePrototype$12,
        "then",
        function then3(onFulfilled, onRejected) {
          var that = this;
          return new PromiseConstructor2(function (resolve3, reject3) {
            call$62(nativeThen2, that, resolve3, reject3);
          }).then(onFulfilled, onRejected);
        },
        { unsafe: true }
      );
    }
    try {
      delete NativePromisePrototype$12.constructor;
    } catch (error) {}
    if (setPrototypeOf2) {
      setPrototypeOf2(NativePromisePrototype$12, PromisePrototype2);
    }
  }
}
$$52(
  {
    global: true,
    constructor: true,
    wrap: true,
    forced: FORCED_PROMISE_CONSTRUCTOR$42,
  },
  {
    Promise: PromiseConstructor2,
  }
);
setToStringTag2(PromiseConstructor2, PROMISE2, false);
setSpecies2(PROMISE2);
var wellKnownSymbol$32 = wellKnownSymbol$e2;
var Iterators$12 = iterators2;
var ITERATOR$32 = wellKnownSymbol$32("iterator");
var ArrayPrototype2 = Array.prototype;
var isArrayIteratorMethod$12 = function (it) {
  return (
    it !== void 0 &&
    (Iterators$12.Array === it || ArrayPrototype2[ITERATOR$32] === it)
  );
};
var classof2 = classof$42;
var getMethod$12 = getMethod$32;
var Iterators2 = iterators2;
var wellKnownSymbol$22 = wellKnownSymbol$e2;
var ITERATOR$22 = wellKnownSymbol$22("iterator");
var getIteratorMethod$22 = function (it) {
  if (it != void 0)
    return (
      getMethod$12(it, ITERATOR$22) ||
      getMethod$12(it, "@@iterator") ||
      Iterators2[classof2(it)]
    );
};
var call$52 = functionCall2;
var aCallable$22 = aCallable$72;
var anObject$32 = anObject$c2;
var tryToString$12 = tryToString$42;
var getIteratorMethod$12 = getIteratorMethod$22;
var $TypeError$12 = TypeError;
var getIterator$12 = function (argument, usingIterator) {
  var iteratorMethod =
    arguments.length < 2 ? getIteratorMethod$12(argument) : usingIterator;
  if (aCallable$22(iteratorMethod))
    return anObject$32(call$52(iteratorMethod, argument));
  throw $TypeError$12(tryToString$12(argument) + " is not iterable");
};
var call$42 = functionCall2;
var anObject$22 = anObject$c2;
var getMethod2 = getMethod$32;
var iteratorClose$12 = function (iterator, kind, value) {
  var innerResult, innerError;
  anObject$22(iterator);
  try {
    innerResult = getMethod2(iterator, "return");
    if (!innerResult) {
      if (kind === "throw") throw value;
      return value;
    }
    innerResult = call$42(innerResult, iterator);
  } catch (error) {
    innerError = true;
    innerResult = error;
  }
  if (kind === "throw") throw value;
  if (innerError) throw innerResult;
  anObject$22(innerResult);
  return value;
};
var bind2 = functionBindContext2;
var call$32 = functionCall2;
var anObject$12 = anObject$c2;
var tryToString2 = tryToString$42;
var isArrayIteratorMethod2 = isArrayIteratorMethod$12;
var lengthOfArrayLike2 = lengthOfArrayLike$22;
var isPrototypeOf2 = objectIsPrototypeOf2;
var getIterator2 = getIterator$12;
var getIteratorMethod2 = getIteratorMethod$22;
var iteratorClose2 = iteratorClose$12;
var $TypeError2 = TypeError;
var Result2 = function (stopped, result) {
  this.stopped = stopped;
  this.result = result;
};
var ResultPrototype2 = Result2.prototype;
var iterate$22 = function (iterable, unboundFunction, options) {
  var that = options && options.that;
  var AS_ENTRIES = !!(options && options.AS_ENTRIES);
  var IS_ITERATOR = !!(options && options.IS_ITERATOR);
  var INTERRUPTED = !!(options && options.INTERRUPTED);
  var fn = bind2(unboundFunction, that);
  var iterator, iterFn, index, length, result, next, step;
  var stop = function (condition) {
    if (iterator) iteratorClose2(iterator, "normal", condition);
    return new Result2(true, condition);
  };
  var callFn = function (value) {
    if (AS_ENTRIES) {
      anObject$12(value);
      return INTERRUPTED
        ? fn(value[0], value[1], stop)
        : fn(value[0], value[1]);
    }
    return INTERRUPTED ? fn(value, stop) : fn(value);
  };
  if (IS_ITERATOR) {
    iterator = iterable;
  } else {
    iterFn = getIteratorMethod2(iterable);
    if (!iterFn) throw $TypeError2(tryToString2(iterable) + " is not iterable");
    if (isArrayIteratorMethod2(iterFn)) {
      for (
        index = 0, length = lengthOfArrayLike2(iterable);
        length > index;
        index++
      ) {
        result = callFn(iterable[index]);
        if (result && isPrototypeOf2(ResultPrototype2, result)) return result;
      }
      return new Result2(false);
    }
    iterator = getIterator2(iterable, iterFn);
  }
  next = iterator.next;
  while (!(step = call$32(next, iterator)).done) {
    try {
      result = callFn(step.value);
    } catch (error) {
      iteratorClose2(iterator, "throw", error);
    }
    if (
      typeof result == "object" &&
      result &&
      isPrototypeOf2(ResultPrototype2, result)
    )
      return result;
  }
  return new Result2(false);
};
var wellKnownSymbol$12 = wellKnownSymbol$e2;
var ITERATOR$12 = wellKnownSymbol$12("iterator");
var SAFE_CLOSING2 = false;
try {
  called = 0;
  iteratorWithReturn = {
    next: function () {
      return { done: !!called++ };
    },
    return: function () {
      SAFE_CLOSING2 = true;
    },
  };
  iteratorWithReturn[ITERATOR$12] = function () {
    return this;
  };
  Array.from(iteratorWithReturn, function () {
    throw 2;
  });
} catch (error) {}
var called;
var iteratorWithReturn;
var checkCorrectnessOfIteration$12 = function (exec3, SKIP_CLOSING) {
  if (!SKIP_CLOSING && !SAFE_CLOSING2) return false;
  var ITERATION_SUPPORT = false;
  try {
    var object = {};
    object[ITERATOR$12] = function () {
      return {
        next: function () {
          return { done: (ITERATION_SUPPORT = true) };
        },
      };
    };
    exec3(object);
  } catch (error) {}
  return ITERATION_SUPPORT;
};
var NativePromiseConstructor$12 = promiseNativeConstructor2;
var checkCorrectnessOfIteration2 = checkCorrectnessOfIteration$12;
var FORCED_PROMISE_CONSTRUCTOR$32 = promiseConstructorDetection2.CONSTRUCTOR;
var promiseStaticsIncorrectIteration2 =
  FORCED_PROMISE_CONSTRUCTOR$32 ||
  !checkCorrectnessOfIteration2(function (iterable) {
    NativePromiseConstructor$12.all(iterable).then(void 0, function () {});
  });
var $$42 = _export2;
var call$22 = functionCall2;
var aCallable$12 = aCallable$72;
var newPromiseCapabilityModule$22 = newPromiseCapability$22;
var perform$12 = perform$32;
var iterate$12 = iterate$22;
var PROMISE_STATICS_INCORRECT_ITERATION$12 = promiseStaticsIncorrectIteration2;
$$42(
  {
    target: "Promise",
    stat: true,
    forced: PROMISE_STATICS_INCORRECT_ITERATION$12,
  },
  {
    all: function all2(iterable) {
      var C = this;
      var capability = newPromiseCapabilityModule$22.f(C);
      var resolve3 = capability.resolve;
      var reject3 = capability.reject;
      var result = perform$12(function () {
        var $promiseResolve = aCallable$12(C.resolve);
        var values3 = [];
        var counter3 = 0;
        var remaining = 1;
        iterate$12(iterable, function (promise3) {
          var index = counter3++;
          var alreadyCalled = false;
          remaining++;
          call$22($promiseResolve, C, promise3).then(function (value) {
            if (alreadyCalled) return;
            alreadyCalled = true;
            values3[index] = value;
            --remaining || resolve3(values3);
          }, reject3);
        });
        --remaining || resolve3(values3);
      });
      if (result.error) reject3(result.value);
      return capability.promise;
    },
  }
);
var $$32 = _export2;
var FORCED_PROMISE_CONSTRUCTOR$22 = promiseConstructorDetection2.CONSTRUCTOR;
var NativePromiseConstructor2 = promiseNativeConstructor2;
var getBuiltIn$12 = getBuiltIn$82;
var isCallable2 = isCallable$k2;
var defineBuiltIn2 = defineBuiltIn$62;
var NativePromisePrototype2 =
  NativePromiseConstructor2 && NativePromiseConstructor2.prototype;
$$32(
  {
    target: "Promise",
    proto: true,
    forced: FORCED_PROMISE_CONSTRUCTOR$22,
    real: true,
  },
  {
    catch: function (onRejected) {
      return this.then(void 0, onRejected);
    },
  }
);
if (isCallable2(NativePromiseConstructor2)) {
  method = getBuiltIn$12("Promise").prototype["catch"];
  if (NativePromisePrototype2["catch"] !== method) {
    defineBuiltIn2(NativePromisePrototype2, "catch", method, { unsafe: true });
  }
}
var method;
var $$22 = _export2;
var call$12 = functionCall2;
var aCallable2 = aCallable$72;
var newPromiseCapabilityModule$12 = newPromiseCapability$22;
var perform2 = perform$32;
var iterate2 = iterate$22;
var PROMISE_STATICS_INCORRECT_ITERATION2 = promiseStaticsIncorrectIteration2;
$$22(
  {
    target: "Promise",
    stat: true,
    forced: PROMISE_STATICS_INCORRECT_ITERATION2,
  },
  {
    race: function race2(iterable) {
      var C = this;
      var capability = newPromiseCapabilityModule$12.f(C);
      var reject3 = capability.reject;
      var result = perform2(function () {
        var $promiseResolve = aCallable2(C.resolve);
        iterate2(iterable, function (promise3) {
          call$12($promiseResolve, C, promise3).then(
            capability.resolve,
            reject3
          );
        });
      });
      if (result.error) reject3(result.value);
      return capability.promise;
    },
  }
);
var $$12 = _export2;
var call2 = functionCall2;
var newPromiseCapabilityModule2 = newPromiseCapability$22;
var FORCED_PROMISE_CONSTRUCTOR$12 = promiseConstructorDetection2.CONSTRUCTOR;
$$12(
  { target: "Promise", stat: true, forced: FORCED_PROMISE_CONSTRUCTOR$12 },
  {
    reject: function reject2(r) {
      var capability = newPromiseCapabilityModule2.f(this);
      call2(capability.reject, void 0, r);
      return capability.promise;
    },
  }
);
var anObject2 = anObject$c2;
var isObject2 = isObject$72;
var newPromiseCapability2 = newPromiseCapability$22;
var promiseResolve$12 = function (C, x) {
  anObject2(C);
  if (isObject2(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability2.f(C);
  var resolve3 = promiseCapability.resolve;
  resolve3(x);
  return promiseCapability.promise;
};
var $2 = _export2;
var getBuiltIn2 = getBuiltIn$82;
var FORCED_PROMISE_CONSTRUCTOR2 = promiseConstructorDetection2.CONSTRUCTOR;
var promiseResolve2 = promiseResolve$12;
getBuiltIn2("Promise");
$2(
  { target: "Promise", stat: true, forced: FORCED_PROMISE_CONSTRUCTOR2 },
  {
    resolve: function resolve2(x) {
      return promiseResolve2(this, x);
    },
  }
);
var domIterables2 = {
  CSSRuleList: 0,
  CSSStyleDeclaration: 0,
  CSSValueList: 0,
  ClientRectList: 0,
  DOMRectList: 0,
  DOMStringList: 0,
  DOMTokenList: 1,
  DataTransferItemList: 0,
  FileList: 0,
  HTMLAllCollection: 0,
  HTMLCollection: 0,
  HTMLFormElement: 0,
  HTMLSelectElement: 0,
  MediaList: 0,
  MimeTypeArray: 0,
  NamedNodeMap: 0,
  NodeList: 1,
  PaintRequestList: 0,
  Plugin: 0,
  PluginArray: 0,
  SVGLengthList: 0,
  SVGNumberList: 0,
  SVGPathSegList: 0,
  SVGPointList: 0,
  SVGStringList: 0,
  SVGTransformList: 0,
  SourceBufferList: 0,
  StyleSheetList: 0,
  TextTrackCueList: 0,
  TextTrackList: 0,
  TouchList: 0,
};
var documentCreateElement2 = documentCreateElement$22;
var classList2 = documentCreateElement2("span").classList;
var DOMTokenListPrototype$12 =
  classList2 && classList2.constructor && classList2.constructor.prototype;
var domTokenListPrototype2 =
  DOMTokenListPrototype$12 === Object.prototype
    ? void 0
    : DOMTokenListPrototype$12;
var global$12 = global$j2;
var DOMIterables2 = domIterables2;
var DOMTokenListPrototype2 = domTokenListPrototype2;
var ArrayIteratorMethods2 = es_array_iterator2;
var createNonEnumerableProperty2 = createNonEnumerableProperty$42;
var wellKnownSymbol2 = wellKnownSymbol$e2;
var ITERATOR2 = wellKnownSymbol2("iterator");
var TO_STRING_TAG2 = wellKnownSymbol2("toStringTag");
var ArrayValues2 = ArrayIteratorMethods2.values;
var handlePrototype2 = function (CollectionPrototype, COLLECTION_NAME) {
  if (CollectionPrototype) {
    if (CollectionPrototype[ITERATOR2] !== ArrayValues2)
      try {
        createNonEnumerableProperty2(
          CollectionPrototype,
          ITERATOR2,
          ArrayValues2
        );
      } catch (error) {
        CollectionPrototype[ITERATOR2] = ArrayValues2;
      }
    if (!CollectionPrototype[TO_STRING_TAG2]) {
      createNonEnumerableProperty2(
        CollectionPrototype,
        TO_STRING_TAG2,
        COLLECTION_NAME
      );
    }
    if (DOMIterables2[COLLECTION_NAME])
      for (var METHOD_NAME in ArrayIteratorMethods2) {
        if (
          CollectionPrototype[METHOD_NAME] !==
          ArrayIteratorMethods2[METHOD_NAME]
        )
          try {
            createNonEnumerableProperty2(
              CollectionPrototype,
              METHOD_NAME,
              ArrayIteratorMethods2[METHOD_NAME]
            );
          } catch (error) {
            CollectionPrototype[METHOD_NAME] =
              ArrayIteratorMethods2[METHOD_NAME];
          }
      }
  }
};
for (COLLECTION_NAME in DOMIterables2) {
  handlePrototype2(
    global$12[COLLECTION_NAME] && global$12[COLLECTION_NAME].prototype,
    COLLECTION_NAME
  );
}
var COLLECTION_NAME;
handlePrototype2(DOMTokenListPrototype2, "DOMTokenList");
function __awaiter$1(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P
      ? value
      : new P(function (resolve3) {
          resolve3(value);
        });
  }
  return new (P || (P = Promise))(function (resolve3, reject3) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject3(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject3(e);
      }
    }
    function step(result) {
      result.done
        ? resolve3(result.value)
        : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
var icon$1 = `data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAD8UExURUdwTGx5rpLO8YOYx1Og0ly29X5ezR4mT0tiji4eWJ953KGn1Jxs7qB9xvfD/Us0gduu8yeh4HOq74dD647R91256eSz+j82cbvg/dSj/LuL79Wp6zCf24KN9xANGRANF59d/0W+/taa/8iN/3HL9uOn/z638Bil7l3G84TP+FHB8o5A/0i9/ZjU+47S+vq8/4Qy/S6w8O+x/5Rp/wyg7G2T/s+T/vO2/+qt/1qp/qDV/HyD/ki4+4R7/qnY/tyh/1Gx/ptU/76E/2bJ9Ld8/4t0/pxe+XvN9iOq7rB0/0i88aRk/6ps/z++/naL/mab/mGh/pVM/wub5mGd+fAEOhEAAAAgdFJOUwBEyWKA47EKJhnFluGA6l3H67Du6crdNOXs5q/I65rcQbfB9AAAIABJREFUeNrsnE9r4zoXxidOG9tNQqBvSrLKeKGF7WIz4J0WgSCuDc1s7vf/Mq/+S0d2p7Zkd7i0SsZJh3th+PGcR4+OpP748T3+4yNODofDKY2/SYxgdbhcfl4ul9M3rY9ZpZefbFwu6TeMD8dJwPp5Sb6l9eFIL5zW5TDoWrEc35wEjtOFDWPxjE2aJMkqWa3W6/WevuigPyVJ+tWngTg+HQ58PmSDQlqvt5Eax+jIBv2UY7umyL6u0JiMBK6DpETp4KqmL/ngX9hnwcEJYl8TGIV1EpzOEaNUCUBqFPwPfRX0W8GfFSPGgX255JCcTpwUByVY1WAU/FHwLxRWV3RdIYGtvhIvKqoVI0WriwoGK1CDvLi8JDouse5L8YqT08M2Op+vVFOYl54wJ+5PkppkJUkJZYlipN9RV1Ne69UXmCOT0zY6Xq+4Kip7GEYGmKZVyNF1ghj9whx//ZfltXQYTE/b8xnTUeFr1R82Lm7vwuPh6Cgz9jr+TVx8Mt+zcTgt0w6Ik310xIJVJXxdUaqgsIzH1w6tjlekxrVdpX/FSlb7zW63a+lrt3vazG8JFiqHVa2ewOQLlR70W1oX58XlhSiv7aerKz4xUvd7Rse9pWO32xxm/VfE6To64yt1KyEsgUt8ckT99GDsHUpL6oq9EaKT4+cWY5weNrvfbZtlNwqLfkpcM0o8XtFMhZlRUT7YYDLKEtmhsurQJNO6R0sEL0brk3FRWe3+ydpMDvblzpDtnvYz/SPihIYFzHRFYYE6xMazBnJWYTyrhsri4uqEfSESPX+WdcWnza7NbjemKyYpVob/Ml5Zu9vP0cmME1aBxZXDuSpdKWSGlK0qxUqteSxUphA7hLoOsednWVe8YiV4y34zTYkX9a4bhXejtbgJp8VQcVmJuDA4Gyp7d2K8TFn1oGnJWbEjqO5ywnLE5+iK8mGyEnbFlMV0dWO1GEyLmhWdA1kKrdiTG7y2duPvss3QWx1qVLVLSxZiJwRWdOQTxJXsd9qrGKvMHsznn4JocbNic6B5KWW5wlLMBmbDesjcOzN4KZLj0uKKD7tWcslcVIJgiLbi1fasSYk3p2WUJTsOdsqqHGVBw9I5q7BQcVp0XlxYXKdNa4Tlqkp8/uNNi0UrzupqawsLd8cYqqoXSkHOqu0ED5SF1AshQo1+tRyteM+F1RhGjXy0oiwZLU9txWwdKEhpTKIIjWv1pDUQHGpXW66uUGfTWi8WIk5Pd6Ao5VqNNDCGq7170WIx9IqFqq4iuXNUVyWr95RVDeYsSKqwPEvSkrgQLcXFhHW/STz8T2uqz9DKfHwrPVisMP/GSV0tZdkxvq6qgf6fzu+1hQsoC+mwRQd/Pi5kXOnmt+Jh53fH4mkG220m/gOSh0gpyuBSVVhhuNxRsbRfh+5sCH1LCqpjvNg39kHYrLiIcfEqZHwah5DzM8tbk2glbBbEVgHKqVANMxViJzvApWFd9wOWcng9FSrHQtLpaUJdgFa8euqHheExzeWptRuzMgqzgpaO8bClVVXuhoXSVT0kLCEtwUo+mG2hxwVoxetdNhYW09YkXUFQ3LIMJ1OJGPJyFoiqVVrD6K6VpSdCpS0xlqjEdD8a1hRa8fYs8DiuBUrRpSWF1e/+DbSzrCq0YpaaDjv2mJ9Wutll9w8xNWKGpLT242gl0fnDEsRDylKkqoF2Vu24FoxYcsGjypDQEa3npRVvRllWw8MXXWGPpJVE0bXvWCad2sLCfc9yZkSoqkI3suyljnQrrimOi+Q5mplWuhnp7zKqUm2lo6wQlqGqQygsteDBoAFfuWsdp1Oquu+82dBZyoKuRdhr3kqksMbSov8dja8jtZVsoyFlye6DrSwtLVxbydQA05hqW1qOZ1mrQ1GENGyxx7y0KKzbOFgNz6ajXT5xogO+2j0H4Fm2tNxeqZXgB5SF3JQFBnWtefPW2DJsVLRvR9KKk4GgpV1LSQv0HjDcwh8CpTfCQHPGWJampF1+zrw12rPElDghQXBa2PV3LFc9lrIwbCtbs2ExBMzOo9ZEqCtQUpLFmOfH59lW1emYAN+2rb1snEDrHWm56QE7uAZmQ1iInb3QkaTEgwhgiIgPNCetdNxqpzUmn4kexFhauOdbYDVtdwAr9zzb8JahyqSwCjtkS4vwwX/K82g7T38rnqgs9Rf30S5/xX9QlhO1avNyldVzeKejbKpQSosI46Jhi+Rzxa109DoajFs2ntYfpNWbEHstmrofsmQZFrD5Dk2LCJNnpkWBoXlMPh4Jq4ENG563vLTVC1qgDut+F75/5AiUIfR36er6Wy4URrp5bCsZBavpb2fcRva3+tqCMb7CTg+w6p8qfb8MkeblmpaweOZblFl5nKPRHHuW4fj+FshbeIgXPPBQgSNa8iwpnAjtIjTuToBpyaW0GvPYFlXWPYTWhDnRNJcx1rs8yrC0ZfWOO4CGA5gLkW1ZrJ2skAlBWQPl5CXctpiyfGG12ciVz0lWIjZLa6Osyj3XVtfvG5YmVViGZa11pGUREUpFepDSIjPYlqeyGtXfmpK3sNUAtGj1TmnB3p+7aWiON1jW3klJ6ToEwqKoaNp6iP8KrEa5/di8dbLnRNxrl1Z21JLLRJgd3MMzrrur7E6QeQBYpCRRMkPO8itDtbc4tmNzBgZvw3Kb8AM7PEJbmhXYMESgj0V0yDI1mHNplcdgafkbPKfF9hPHnA0cWPmArGV1acCJtt5+YQH9ynYsgvS6EDllSGnRKB/s8QEGb3Yxxs6Jg5YFtyyArApnbSjPdPcSKQLKUgbveFYe7vFB0WFKf6u3kYhB9wH2ljUrFUrroe1CI6qOGGERhFCfE/8IlVaYsqZ0bNTKB2OVIrBTifJy4cAR3HcWOhKYG0d7M+Fc0vJTlld/C86JIGrpJQ/olaqLTXVtoSqsRGpWOTC5m3DFKTFQ3LVCc7yXstp+f2vUno/JW043XsbSuhq4kDJ07hZurMJAOmBXiloZJi3fBN/CoyNsPzGdsPKxYZmzy8KvsK5F9WUok0LXIqCfbCJDrljlYpRh0krDytBaJ07RluNa8Jj3UV0if5b3pu2DpI6yYMAyjQYrMhD9CpVWHBwdVH/r9xRaIMTbTRoBar9aJWKs+H1XSqxn8JpVJ2dDiQrBKEqAsgKlFbaQhnlrdCVewTa+Vha/X89+iUMM/49EACsKc/IdwfMNBLRIkWtYufb5IGkxZbE7AtMXh9nAefnt6P1ErNfV8iYPxmd2QeKdS3txslpTXPJeU1cg5PRnUK/+BB9LVDNIi+0btu2f3Gg0vZFnbHQPomK3U0Qgra7nj26Is9s/xyOlUxRDZ9d0KLXjlealPCsnQdJK+CZrm80w2imVKLqB/HoKV9W7ooK4okJ1sxCMWUQld2QbFvArupbmrZpVgLL+xy6DZfdwUqzLNS1viWXO9Rptk1E7e1xdtAaVbSHU26oAwT03ZiWZlbQO/ZsPFNbrLbsNH7qd0gzU57fS8VmeX9SkFTj+kH+SbKNanGCTJ7E63vgjCEYsouZBRYm7OzP4kL4WhfXr9XYb3H+ePjfesmYCLd6Jv068bMPEpY/O2Cdm1E40sqrQrUTOy9/iGSxFqwlgpc9vNU9jK5HdAJ4kK3W++vkIt+w7qzmK+v0GC1Qelh44rF//3uTN6CbMuW6j89aPlHdsztH0y7rsArGqxM5q+BF3BW3lK0WLLRD9LV7Aotq6ZzJvNb7RwfS3Rs2JlBaNml7XRpLt8UiorApwykjHhtwOC4ZUKT/KR986lLAorYErdF7r63a0ttbedwOpcRHSdXCXAsYG1fIjDi/28K1DBYvTalvv4OD0t0ZpK/b/JRuMlrMJTdw8CrO7paz8JRSW0FZIx9Ta8hmprZBuCaWVy/1CGLGsuK54lcLdpbJy7zo0sLhvZd77Yg04NHJfntY2Mg1lgnrtPuDrSloS1+NzGgpLJoh7gLIm97dCGuLbI4E79o6/W7hIqVmVtAx969CG1U+nPnOizBC/F6e1itR2DhlY5pjuqO1ZUlovq3BYglbr5fONX38rpCW+juz9HOT0sGzLKqVxleLta1oQFvetW3Zv5+lBbBf+HQvUtuSBoj/VoPH4UqAqc+JnWg4sOSe2QctEfdBmwv1EP9uKOnUeC2gqH/YrSYo9/JKWC4vTus0grAnpNLAQYcJyls9lbmJDKQ2ePl7mgRWUt5yY2ixNK3k+8gPJTsCydSVQKUxSWW+PXhv5fVgib4V2A6f1t/yldRwMDU5TRvAy0aEs0cNMsGbpb8lfntE0y9JKoiM76O4IK7eDOzAshuqNKeshnQmWS6v1tq3x9xP9XYvYsKyOe8nempYsQEXMz+FF82+YVtuG2tZtcd+iyZRYW6nvKctQkuMlmUtZpr/VhvsWpbVdjla6PZZcWQ4qKCrbsdh4K70yvFbW68Cc6N+yUbm0bTit5bQVr6J8uN0ODMtW1hufDn0yPNvd+TWsLf9EqhY+7LNZ2OWTl37/2O7J6LhgAXsLgcVxvc6Yt8zvSWKLxmZJWunzsXRxldzaS9utchsVez94K+v11+uwbwVKq2kFrHY5WjRqlWYjh6jFoFw8A1BvFqvH5yBlDWnLt2Uj9qcbRqvhymr+T9vZtTaOZGG4m51O3M3AsDOEgaEDXhjsxr6JcXxh3AKLHQnFDk68/v//ZavOV51TVfKHpJRkxUl6LubhOW+dKtlO9VG0fGhFrajsxiihfqi8grPLUpphtbhV9lhH4wdN4fjA3Pr88PcPvcahXQZdgRoVserUaHEZiluGGd5P7BD0TqeyFq18xn8YrdHvf4fmXWJd1oNRg7Wj8z8P3WA9zcmsltwqO9JybQMdOD6oEu//lXRY0X6MTIEECi4dYc0F1DzfQdy8v+UJ4bnU4/FDaEGnlZglpH7sog6LaHWGRbjmuZiH/a36JqfGJbGKYDm3PuJDMSHhCdR/bRf6Q9XezuT7rpdZ8/ZK7HDHgutPToL17QNoueUhvxg5tA2zdDm4I2a7fmXIauV53XY/sQ51aMWq3OHduv8QWDOJLIXqh4703Uyfuy6LQzILec3T+TB7P7E+qxaQqmOriNcH0Bo9yEvVeB6cmbTaxcB2HVfSbBYAw2JM7bpyfwuLcImJtRwniQWX6tvQtD4/SNdOG6N6caP7djnc+PJ5gMxq706vuZ+4ZLeYVSSWgzW4W86szK6MXTdrWjt4dHk7nZg1n8/VtBhXI+xvjc/uby3JqmWmaSCxMLaGdotghbUg35UIMs0w1yned2jWfefM0p3pvGUP4qJZwoucGusCJFp+fBv0k/hGDz/0YtDs8dneKqCaDGKWZNdT4tbljrTWdbhMpkJmVT3+OiQtB2um7jnbxY0qQJ1YPcyai1y6i8j2W/t2qZYRqXEovzpYVQ3uFpo1i7YZQv3586cpQW9Wl92/XGaZ6DK5db4/LTmyIrGqcHwELc4sm+ncJESUhoL1FBqurFpP6t0F7QvCjFdwFlqsQWn5MkxWzrtMtyCgJu4yhFmm45onbpXnb1EsWxosa1WBtIaaEwFWvBZUC5uIFdLqDusYVaEqQusXvV7+TOfOk+BYNe2+XYi88mOolIeAT2/ghElwNrOoepnlWR3n84xhmQ6i9fVb3F2N064dkSmzCj8eB3Jr9CDNle7Wd7swD052P9GncBmoDMPM+DTP3/NJtmw8onKZmwi5Fw2kioqOohiGlocFbu1UtxDSPVSeOXqU4TFHLJv14FYN7xVe2i0stcixabXUNViwWJV3a4hKFLNmihdTwifCKDzpUYZHC0zahywtiK19VIDpRMiNu80rJZaj9fsAtBjWTjUMO92ua7Xw7BnwSOqYmpVu2+A6Mbzblxv3fIdly7CAMgxjiA4CYamJb5ZMfgGVXL/80sMsVqtlZmztIJZxgxUCq9LrQc0KcG38uRmgEo1ZyqbJ2aM7LMaVZpfs3cyztPCtFRmvKu5IbbqHCgRag1QiwFJTn2GlmanI6m+W+HWMaCVuHZlW3da5i1TWrFCDHtVmsxmAloMlQTWTXQWKp0kUVSHgf+kd8MfsnJj2XEfcCoTw2ktoRfvtUeMeEqsiq1wZAq1+f6uKzOJdPV2CkxSS59cPVnokXVfccdWv+HmS/iVY+2XYw4q2RTWqQoe7w7QZhhaYtTPrZQ3JcuJHH1hH/7DhdcxFl4w7/5dJa9pp2OdWg8s42yuNisXyoyctb1ayUtZJBXAmhItpdYSFlEItJlH/xIvroNcfd3/+dkevvvKvWEv3RdMaND0DmMW0Nr1oebNyLdXErnCi0RkWD7aLWJ1x64/fvn79fId/7HZZi1e1whRt91FYVRmzerpFZXi2X5jIV8bWDVZ9LAWUkMo1EtJ1Aaz7T/fOrVevVT3WVsUb7rJyjkixWQd39HILzTJNekBjrhOFqxesSK44up4ULoL16etvd/tXvPds072qkiosKqa1kcZBxPK4utNCWJNs/ck1HovesCDobXTlNm3mHhb8x86t2t7ICbcmosCy6b7hA8069KFFZsVa7VSq6yeTvmVYGrtEMNui6m1nMMv915/vKKdqulTSt5ttGdlpUGFlxDocDo933WiNHtKEujAWPc0qLau5jq9owRhgebd0uHupinQbWa8HqXUnXAcgBaxWh45uxbAmqldQeOiER68yLMsScSlk8zpdWwsyhgWViFpVyzTZk/WglKASC6rw4HF1oxVgtXQJA5tVloKq1Dmvp8fjXG1yCSxPqwpuKbVUMxol1maz4XTHqRBjyz2+dKE1ejgPCYyyhzs7wgJSZUlfkuyisrSGBVi+g6jiFWGVqEW0glgqsCCywK1OKe9gRY1CWnxcfwuB1xkWc4IncTWa3YgjNRAKFtGqlrl90ciqWCzMduAEo1NueViZOmOFBJvF1QXWCM2CzEJmx1SxOOafDCxPCzjV0GApXoXZdGepCh1X9GBYqw65hWYlrGwJmktvsxAXSEWtRGnnRtN6GVjgVpXZkpEVYdUa7oeN9srBWt2cWzmzJtqsuBi7Z9Y3gCU1SJXIlqXtRA4Wp3yyHoxQ8RZWCCsK9kDLfXcrLQ9rkYZ5kCgN+K5mMSxGFqqR7Kqj+IJLBAtzq1qmPYPdwrK9aJgHoQLJrMOtuQVmJYjgXOgiNN9MBoClHHOUyriz5+g6xrDAragOw3KwkPWNFCEtcgQVksLr6TZaZFb7KZR6Z5aDNfbv/ir5UqoqlGqsfYuq6jGBhbRyN1PNPFgYs6QAV+HwxG7LLQernU/4brHAi79O+phV+3Os1QpVidkPvKivd5cUVkRLbnpVIlZh58GDqkGsQjpXb7f18lSGhtWCSjBAmqjrortZY4+pRrESwUqFS6mVgWVpFYlaG7V8Pti8Ikj0ZXXjnAhmLfQ5YVDqqYDql1ke1jjQMry4Eo/Y53PY58yiDsJsM5gGy/buB91fHYhVGDek/Oi7AWN1khqkn6FYPc1CYgxprHDRUsi2qVlYwa1CZ9aGOyyn1SFaO4cGS+N6W51ucGv0fTGxXlnBFgttFz/vCsvfLGVa4NhYcCGyY62v3rA8rOBW6LA20jUUei3Im1hhKgyk4Pp29arawbJjop43Ot0n8rNFD1j0MVBAyrHSuPx3ZoKEamyBxbQKfTdHljgFpxUvni0qKcM3h8qN1ZX3qhWsiSq/JsKmYPpf/bsrrJI+6hftGktdcoJFRXlsNYtpFXaJYzZGD3bxvDJinUgsr9bpykqMzGqUPnSNqPkfTjrC2qcfkFyOpSxrnfiyOfFrGyykpefBTaEXz9E8uJJ+VInlI4vduoJWBGvSLK4ZA8ESZPi1DGVZcpNRtpoFtEzPYBpRnALtrowpQc4sxHX6ckUlOlgN+nQBk9arh1l7OrLAalWTXJXtZqFbUS9qbk4c1EYyLQkF1xtVIMXW++mKSiSzCFdDlwy5ZjCz8NPYWqjpyMce9gwscMvcdi4MqDiwbIPlig9JrQDW6XLKs1lGL/u0SdB1N2vvxhgeltWeQOFnO2F/AW7V58zCfqsw97z0grAt3FEsZPUORXg6gVsXaOnMaoSOMo1/1ah/1nSHxQcz4xPJ7eUznsSzs2ZRJRZF1LdT9W3OouLGwU2GDta7w3aJFpnVhPJrDJ7G/gwf/cxiu1gxOeGo4aAPfPefnHwelneL2lHdim7OspIqpHHy4/39Ii0d8E2sUfhBNAv0gIVA9qKXyMWo8M8QwMce+uMSLMotuxq02wwZrzwqYYW0PKwLtDwsB6KhSxNUEoKNqVP4TVdY2RFwuVHTQ8ZFWOBWYe7Qm3VzbpHDnTtOhG/vPNbvp3O0Rt+bhlGFcmzEpsY84cegsOzwRYiVCI8rYHm3HjniDxu7MarMsmqFxDoJqbW7nnOLYZFYGlljZsfmw8w6P66ABbSCVXb/KrCKpsFQgGTWybFar8/RElgtgkXNF3zpDOvV/c+/wtk2kl+91lfA8q+xeTQNVnTXK+MV8joRrTcQy7t1WrfT8rCm7rDEwhFCKyRZD1ivROsVTz7CU48Hjj3942vMgtx6DHtYuRoM+wzgFdegEwraBjDrtPZne245WFODa5EyW1hinc16JRpBL4WIkfkTBn7zch2sT/d/3lVKLLMzGtL9zezMYLxLuK9JrnWrW6Pv0ymgmvqvLQOLk89FH1ivTIUhAROtGP8S/+XrlbA+3VMl4vbVJocq6q5wInS03kLCr5lW9p1cDhZyimuxaTLJz5r1MUtXnsYkHMUtP16uhoW0HKeVeQVI3GCtQsC/265BxPIpn/3kCjZrinKdI7YI0HqZJVwUMEtIf3ctLKjEx41e56R3clCslXglWgGkdzrWbZUIsIDV9KJbIfS7wopNujxerof16SvQStbPqh19W0WstFlrMWvrjhwthBWAYX41TWt+NU0/WFcRen2h8+UWWOiWbbHS2xOrRKt3UYpTfutwZWgFWOQWxDxNkPkkW0y7wnrZnyUEpx9Myz/55wZYQCu8SkZe0hDFO+z5ua7hzXglgYVjkqHlYT1PY2DypSX3hzbrhVGFg8S6ySyitUn7dtW4UzNKvZUmpVk5uVJaDtYzY9K0zrLqCusl8QiBvITn8iMef90Ei93KRLtZ5mSLkONq61vTHK3R92ej1tRY1UiG6THtAYvNoZMtwrrjIlTjn9vMIlq5lbPak1G5rkgJLjdmp+02peVhAa7nJkn6WLJesO4BFvIJGW4jKgL18o87bjTLDaAVrQdDWtEsqHCZuNqiXOstDttvEayp8at5bkI3kavHHma9hHKTQE8oMSl33A4rdSvpGUJgSXvlzi2H1RaKMXWLyjCuxQSUUqyzWVJsJphSTMypo1mf7kdIK4DSeaXbqzWtCY1ZAsqPn5qWg/X8jLQI2rT5nyR+nldXs15UQOkyNJg0KT86wLK01B7y6i1e5di2fcsZvyW9ttv/83Z+PY3kWBSHpdkkZBtlHjYtQr9UlaCkliXUKGuIZClRKQ8QbQlU+f7fZe17/edel9MTXMlWMmmGHqTh1+ceHx9XB0FpASxnW7XV19uyb161TxTZBv9OEkHq2vLHFv7JejsnQ4t2ok5Ze8fKVDOfetEzjd+Ki8rL6pcR1urxMdCa/DSoGC+trC6o641RsmIbAovO3n8PiMqj0srKei8GT4tW7vuervYrlkYBlMe12uEgBm15ZcFLZ4B1b5yTw1UP8iyAlRBWwBNe6LXIfOMKoPXxYW9Y2//nY7+PhtDPn98PkhFU9lXpy7v85CfoarnUcqqJvKzfL98It8BsAKweKfvqTCpoatuYR45nMW3t9dOdOn+QLJrK7ZvVhrq7sayNMNrCBDH52SEqa/PE6Ol+0UsMX08Ea+ul5fhwVTX6uch+S5TxP6/hFhm8FQssa0+ncPUZzyCbQ60tYXBpYKq4/of53xgjLFRWR5TFokScU/NgbWOHsoMXJpCBgscAWCNDC6Koze57X7f7JOpZbbyugrLEBqdQCVGYe2xGZm+4tLyctpZ8FD2wN6+vXFhbMn3bSFRJVEOUhdr6cJEU7pQBTh9hCtnFSCnrWRqVVlZr1sTxj5+1QQW4nLaiWXzju+xBytoGUfE49Z4gBdcQWIbWB4mjENo/yAjS/TOCoroCezdjKIq2ba///e3bz87pCrVFvQscfslBwcdDYPUiQkpSICoANgjWhZtER2tF94Mstq+YtysrK41KGGKFxnV9ff2XhtWhtGqnrbAq8j2QP9sYMIY9Ub0fGsATKIvR6jUNn/EySMYQdWXsSr8abcH1WHeIy0qrphvr5VsoI2qyCcqHFRC9p43KU8KrWgx9g7Bvek2047fHzSAxrE/r7DwyWF2Z0CBUIdQv7VpFWxQaWW0Gsevq9CxaeXGvz4S15VuZ9yglbPkAGlTDYRlaRlQmv/ePU10rs+EJSxhXN7TEpoA5dNJq2zeqrc5vrP0vxMLsJObCOjx7yCpSVnUCZekEoWkZZe0/UVurz55fRbJyjmWEZUSlgRlVaZEhrSWZRKetlKgGKiusfO9pT2cj2FTVcFigLXunzH7fWwXjAssqC0htQFqgKGGYASzU1rKjq2LtaHmNLUM1mA8r7VV9XBWwak4Cy2gLItZ+7/srnq74MiiU3RQKq6y2LdzVIi3CqrZPjwsF9rY8jbKSsgJM20hWp/Asq61Pcwix/4zWwY2vGryyhN0/Y2wwBl+wy2srTlxdWBxJjljWA2AxaTV+DWxIDnWiAlwngWW0Ze/s49vBOLe7rgG2hPphrp0A14IRLITo06ptogdp9TY/g5WVSFXc1wOuxWney91M4iqxErLcDnvnYFdGWIBMGVYQTAtM823NJtE3gh1fGHE9PAmsHiSNaFv5+TulsqxvOVR7XvWtIllZUgBIuCn0w4jawry1rLl18YrLfmIgrKb/oFbVBFQng4W+FUh5Wa2ItVtZbUBROikQQu6DHX46sSZ6YFxay2GwGp4XmjgveGWdFhbSYstgcPcI6FJiAAASE0lEQVRQNIBZaWIGijP3yOJ3zuUJrM6VzXXweEttAKwmmr8tD1aoqSYM4uKEPwmG0Nq4jMWmUOAiuAFdCcQUxhA/2rXpNbGrvXeBdXVuHLNhNdtD80eiFVGWlCeEZXyLnTvTgAUrILRX2I3iI9JUAVtEKy3UVnShprrwSz0EVjKruxXQ6coP4UmVBdpiLXLQlYIO2ccrE0VVawaxcN6lGDNVJGjV4eiH9Db5sJreZpmJinECaZ0UltfWph+wbCVj94PWs4qIkGiDifV2PmRx7IysrMByYTmv2vZUZXn5LHoeWJggrFWtwrmzcr0oqqpVrfAzVxR9ajuBnU1bp/eJ/mCxyx9Db+69FFr5dEVRyZPDsrT4aWrQFZbIkBsEiiteCp2yIKQWpN86FCKWy2xYyW6hYcHKfSBPbvDBt1jZ/mjrmLAOqp6tk2URgykw1Z/6XdM1saN53hlYPqwmHkNnV02wdmlFBR/cXZ78x9AirfhAFVVlHZ0aFqyJ7Y6jcwkfsrzRFdv+kI4rX1l/RuUEFSZRympx+p9w7GgBscfQyeB2MK0sl0a9siyuVAfhZQXtc6ayFgcmkGwGvbSke9ydHtbI0lIrUrmbGVT+ZCINrGWDCKPo+61+5HLOlQVruqj6siKJoUFhyWBYAGt6clhWWyt+kANHXgJ9XbXUrLyiRG8Qd3rpJNpKKmwArMQEelQkZUmUl4F1hh9ib7QFth4OCKEYRc+yWaFVTFHCK4poS7TK561umR7GHFij74skqortcGSQlQEm5d3NGWBdXFxqWuSGBhhCJURR9MOooFGLwCpsM6hh/a5TsAYoa3T1r2jLTLbNTUDlE5a9ZuNzwLrw2jLhARq+X86wqDfxrNUzMnCuonD9Fjh6F81jFqzLBeHkHcuLSpIBNJqytMrZ5ehstADW4wZEFQ4Hv3IplyDImuiP+FFdWbB+zMLWpgp7G/2AkSNRFJFZXPOr88BC34JbioATFsi0wHJBVJiQJeKkhToT9ouifmuosi4AVt/VUVmNdJx8aLDXmUzL0wKbh+8bTijcrKVVJrCDUNGqyPstrqw8WOOblLHTnkHa5EAcS8r1mUwLaYGqrLebUewzOpRQhbctVFbc2HjHz4KFEb6i5UKvkeETKM86h4GWu5lB4bGXlY7oc1IJXm59DLT43qfOh1Vxw/Lbm/QMlrIszxNLKS17WI8nN2n9GMcSETIVBhG+OJxVW2SWWBas0XRBW74qLvuca+EQVo7WGefQ+ZaAATTDJBIxQdjaPSEx5feJqqDniR3ND3nKurzbVtGpoI+fvpIJU1jio6zm30dnpaVshSASXV+UT6nAqMUXzuxs3iJxq8tT1uWC1XxEYBVtsIhflRLm8P580gJaQrV2Z6iK/jYwlA5t6t9cA4Fx9rfb+Xh95SlLZwfaWjWVbLysnLhoHnXKktX5LN7Ran2PwDCFIot8NqjLHZbZSWT9lh/DPGXp7CCdR5HkwHVFUFla8szSsi4P37Ld8YiCHUf/IT8UeMBvx9in086ZVpc9hpPpXRXvnoOkYAL9QljapRCe5VmlBbR+qVan0h1fDnloJ5m+JTUgftIBM0YftYF5yhpdLXp6on0Mze0WF8Bay7vZOaUF+0TjW5jgRTJOaY8SCXIicHL7xIL3W5ljqB2+Cmc4TcTLSUwGwypRWmtZnnNBdLTghiIRO1PUv8M2sWDBwX+NzhgC/4bBG0mlmbAuftykMrskyyBPWGBZa7kuy7tzdQ+EljL3qhX+kEuIY7Y+9r4kP5IGF79/KxcWmJYvZWQ4wmH5ypKynoUKO7PHO1pws7vpinHLp0Xy94cXCXi+gxgwhmBatDqWdPtMAlYp0aykxEEsy/V6Pj0/LfNtKvVoJol2ovE+cRcXhIwV3lH5O/hWLqzLWWxU9JCQ0iq9sNC5jG1Nzktrgr7lTriCHSlCSdBKXvGzV8G0Ze8NzIZlkhbt2yUVVkwKJ3FtnuXaDOLsanTxf/EtkEbRMvOmdbP4w3F13G91+bDMCY+MhSXjUqaM10KYQzkfQGs0Gn3F5TFdujrB16RhZVQpz1dMWf4em1xYbA5lhAuAlfxhRLWG14chtEaX08sjaYW8hSIr4v1PwuEVKylYvzVAWaPxTcRKVgd0FeI7sCo1rTKX1uTqdn6c5QEtPIaAb3f3x9OK5G+LqA3MhgVzSJo+CwpRVSEyBFpISssLXvNojae3t0+3t8fS+qUK51voUja779KpQSSaU8heeJ44AJYO8bKJ+/aoRi5tYCDCkmvgZWh9H39Zzfe3T/o6ntaj/jYdrSMbeUFKVbelBnVpbWXD0uvhXcOPJ6SkrEpuWWYpRHWtgdZ6Ppt+7Qc4ji41q5enp5eX2+Mm0SQIE0ahaFbpLgvVJZzszG/6/yDut+p8WKMrHeJlQxJDf/ccRGWVVeIUmqt8mN9ffSFwjb/Pb180K8PreG35xKQOnYmlT1zdEPrLZPl8WBc/ZjJq26XXVhmCu9/nrO2KuMYLbP5ocenVd377+voE18vr8bR22G/tFHekHasf1CF7xzICnprWAFi4P/TZiuqqlL0toZtBMCyA9fCg4+n99yNwjUbjqZWV1hX88vQFl29dhEjeDn+wDPSoXK3fXufD0n/YMj4frDgrNolrqiszhlpb2rlmf4drNBlPjaxeYALx+fTyhUmENlCIg86+a/HgJ/xFDOHvfRC+5jJvzfJtwNt43Nw5s5L9ZZBpStplkPPS6jJGr4dxMjosqqv7+e0zyOn1+cldL1/xrfZw5dD7GwShq+f7b+N6Q2CZ6kGy4C57wd0qax1CVgRLPzUuPY3j3j5G72zGl05Uz0/P1t2f3CAeTcv0UiSR28r5byZyJ4IcbYgYAuticnMXWneuLRm1DTSUMlRw3Rle0++X4/FkMjLXZDIZj6+m9zON6vn55fnFXd6zvkgLd9M75TpRyKnh6HB3jIu1g2Bpacn+zTJS0sAQMkOIWLgYPoTnw8Prej6fGWT6mpqX2b3mdKvn75nCeqIm/3Kky0/ifmsnxIGB3P0psKpBsLRrrdlJDstYss/K03pAXERcmtfD66vOBHO87m7/197V9CaOBNGwBGEmCkJIOEKcMHK0QpbQ+GD3wVLfkfj/f2e7+rOqus0ANtFqEq82yaz2sPvy6vWrV9VG1OrPtcGqtlA9xq3efCti1SVRnn6LcFgZgjENnDrw8qNoBcUqUswCpEoQfKF/BpD0F8CKVKEVLf1DfTu3rudbUXtYRXcxBjNLqVZxOHCl8k0hyxu0d0d1iLCy3DLwCA0T/KFtMVwn83cg1l3cYvlWVbGCO/uUSx+HPqzp/N2xgcxS1MpTviF4d9cT0irUSAWsZCkMVsJ8hQJ030WoQouVF632PpVn+Rbuf7reKH5MZukDMZVgFThywNTCCi8tVE6yNECGX74EqcC3vgI9v+7QLZRv7aveCuzzYoOZpai1OjR8WcYNc5zJgkBZUktqqWXx0lhZ5QI2aVJ5yBy1Tr4K2xOqxdvRwvlWmE2fk1JvDD3ZxRnMrJc5dIimv4FqLIjAG+cOKZYsUljJcBKWZW2p5bEKAo+5RY7DO9H6VOrel2+lr9hhyl0Gg/Xy8Us2h4KOCaPD0Hc7xGVJxCwNmAh41eFAbJFsBY+FEbvHb/F8i3Gq613jGl6GEItvi0NTsAm0mxK63F2yXocB5cAKSAl7KCaYdWqxwt/rt+yQiwcQfA0Crwg6CIeDBc60cYYh2IUQY7kmOnCrRJJFkcJw+aclttSTCjGrvT2x+cT5VnrNpkfqx2AWRDUWLdoRNrglbJLdDvZYlFmWXbVxDgnNailcj+VbzKKfA6vQ6k3g2AhgvSzeVSFagMyiLUlmcPRexL5B4m4nwIUf5LSQuj+k8nG+db4i9mc8uR6FWVCIBW6g4fvBTVYbHzdwzZJMtIwjLSmzrH8P5gEz61G0XL7V4bvT1R9s1kjMgkIsDiwZtUVImRVpFrWk2DtY6yA8Wix3iAzE4/lWxUuyS1rVkZg1VydiOAllg6Y5wV/hxMEplkMMkaoMx6EXeSZaqKNmaL3d3Ccav/Vp7iCevfPq2FUxvBFRdaOABaPiLZpQSLcEQjxDiP1KKVO+oceUuk46xDRO3eNSvGNCdtH78tH+FtEwshzRVSOBNQfZKhBeZPZFAuUS5zOo16FFaMtQJJl1aoPTah9Ay+VbnX/9n4GrSvsHN3sci1latkjgwEK/okfc0VmITsOa+Cx2HBIbT587slOUL8f51vnCOFaNySzjH2B32zHLjSh46OfR4k10KYi8Y8B0qhXxqk0YiMfzra7q3ZZ3ujUeWDBzDWZUaxaqQ4nSGdwUBoUX1Gfh3tAUYU3L8JQowkH5Fr2+Eu1MjlmGGq28CdkM7gm5yXIpKZH4kjY7tBRRtOzrMMksjVZ2o251aLvvfGWSuB+dWeq3tcsLnMzwsU7BipD7d1KIdbI3JMRK2Yfb0YLOpwqJzYV2h1qviN8aOGRN7E9tnV41XNujrpCGMyU/CyOhJ3FpGwxEohJXt+9v0XyrZ4/SBPKqDKejvlsO0DJWq0li5aYU/iiUUatjoaprFjxQT4rz0rgS83s2knC+1XGnFe75jA2WQctcaYK/Ghl5Uq9WVxTLwcVki4wtyFgs5tZtl8+yK/lWdDRWY4Ol0dKGlJ6EEtt3pFgso4m8Q8JnOWaRyXQbNz43/W/xfOvaNjP4rMnLqM98sttawUo5UjoCI71OD7FSHv7PzFrduCQX51vn3rcDKrDGvkezALSkkXncQIc+Giv8NWax7rDFVovMpaMucXn7zTOSb/kbKuHlBej9LF21Gf3S0fzj11YSVkWtDmdW1BcGWmHNQvlf29sdAla7O27pxftbFdetyjFrfLBAt3JrSMNeJNOsMNyh1KJ4mWF+GzstNmltqV7t7tqCDvkW9aM8n7+MaeAjlZcS2Xgi8bKkXbRHill4wRKtOHlIlODy3ht62dTfT6zsx/LAzxcSCyr2/R5b3x1ab7kxWqV1EQVLsiQ17wnvQJvD1IEYpha2IFuzanp3rSi0rN+CzzGi40R/GVZht37SPcmP9xxEvpTR8gxay5LJmWHiLAzMYkENppVZE1lNH7jLaKav5h75J+SmlVuUtDmXNvlPqUI7el2Z7rDEK1ncOkhmSvt8ViJZpi7LbZk+eAHbvPUHADt3x+6otBzsRNiG1xH05mkXcOeLiTkUrbYXkkwqJG116lRvGKjV+jKkIk/j5Rbk6tFrW6DynXt3ML2/ad4fcpw99WUnH2+5kEVBAmW278fNQ8lNVp/Ae3lvUUiavz/+u9d+qzOvsKEpvN3jmq2ferN7nk1XW1WGDq2SRMpsN6ukDt5zq7cMww6g+bbMd4PegaDzLfPpMu4dbdU+vPPoMnvyGxbAzecNGYKVvdNV6uB9CYq0wLPFNh00ZIM/EfCoDddlb1/C5d6VpP7B+XnqjgeKK1AuvVnLh2DSrd5a8xAx69rw8GRFy9JquRuuKIvp5viphz1ddzzqt/8YAVN2dPaavTz/WUzeVtuyARfhFmeSAU3Zw6xoxBNymlNtLqm0Il8NpZX9b93M9r/trOe815+GCHVZzdbTr8DKwJWL0otWgdRd9galxGiJVAJ4EgYpEPa3yVjzvNfZWctWePa/j/+8ZvOXL3oWIPSluTTXo1oRs5KTQ8otDVXdKmEf8deeTdf6rrCWLv31c7b5KlqZX9j84321DPfAPKd6NatGTqsvATydhFDWapwKxEf4Zvbv0b5JdzbbrL+QVki6cjq5v+azBK5AMrIIkiXq8aEycE1e1xv9rF+nky+Hypw1Ci4U/PHWsExrVjzDd3CJZf4EqEwlLLJskmWJW31fVoyGXTJK30WsWXUqKiXMWj4Nqv/LA9oVtF57L5s3hHEYmRtquPQlHrvwoKklalV/Stb/ZqjMyaivptalbKRbCHGpgyDxn2hxCRrkNFLCkGrxt0NlqvFjqvGSOpZx8QxCy2+V+mtiUI3KqgOCLSA1yb4DUgSvrbYSNbpsWCYyeCCU8lOaW8Cpt+k3QsrhpW9AA2CWXLWguXJtL7IKW4MA1E5xavHdoPKGRhFspRADWkkMV+0WQ+D8g5vA6l97n35XoJCjmb7rS/Y5YMYaRGCTvpY/zb45UKQmgWQ7hRl5dj8wXaPZQr/PQeGTLfQLHn5A+Xl+np/n53nC8x/tAMljWkeBnAAAAABJRU5ErkJggg==`;
var resolveWalletUrl$1 = (network, walletUrl) => {
  if (walletUrl) {
    return walletUrl;
  }
  switch (network.networkId) {
    case "mainnet":
      return "https://app.mynearwallet.com";
    case "testnet":
      return "https://testnet.mynearwallet.com";
    default:
      throw new Error("Invalid wallet url");
  }
};
var setupWalletState = (params, network) =>
  __awaiter$1(void 0, void 0, void 0, function* () {
    const keyStore = new nearAPI2.keyStores.BrowserLocalStorageKeyStore();
    const near = yield nearAPI2.connect(
      Object.assign(
        Object.assign(
          {
            keyStore,
            walletUrl: params.walletUrl,
          },
          network
        ),
        {
          headers: {},
        }
      )
    );
    const wallet = new nearAPI2.WalletConnection(near, "near_app");
    return {
      wallet,
      keyStore,
    };
  });
var MyNearWallet = ({ metadata, options, store, params, logger }) =>
  __awaiter$1(void 0, void 0, void 0, function* () {
    const _state = yield setupWalletState(params, options.network);
    const getAccounts = () =>
      __awaiter$1(void 0, void 0, void 0, function* () {
        const accountId = _state.wallet.getAccountId();
        const account = _state.wallet.account();
        if (!accountId || !account) {
          return [];
        }
        const publicKey = yield account.connection.signer.getPublicKey(
          account.accountId,
          options.network.networkId
        );
        return [
          {
            accountId,
            publicKey: publicKey ? publicKey.toString() : "",
          },
        ];
      });
    const transformTransactions = (transactions4) =>
      __awaiter$1(void 0, void 0, void 0, function* () {
        const account = _state.wallet.account();
        const { networkId, signer, provider } = account.connection;
        const localKey = yield signer.getPublicKey(
          account.accountId,
          networkId
        );
        return Promise.all(
          transactions4.map((transaction, index) =>
            __awaiter$1(void 0, void 0, void 0, function* () {
              const actions = transaction.actions.map((action) =>
                createAction(action)
              );
              const accessKey = yield account.accessKeyForTransaction(
                transaction.receiverId,
                actions,
                localKey
              );
              if (!accessKey) {
                throw new Error(
                  `Failed to find matching key for transaction sent to ${transaction.receiverId}`
                );
              }
              const block = yield provider.block({
                finality: "final",
              });
              return nearAPI2.transactions.createTransaction(
                account.accountId,
                nearAPI2.utils.PublicKey.from(accessKey.public_key),
                transaction.receiverId,
                accessKey.access_key.nonce + index + 1,
                actions,
                nearAPI2.utils.serialize.base_decode(block.header.hash)
              );
            })
          )
        );
      });
    return {
      signIn({ contractId, methodNames, successUrl, failureUrl }) {
        return __awaiter$1(this, void 0, void 0, function* () {
          const existingAccounts = yield getAccounts();
          if (existingAccounts.length) {
            return existingAccounts;
          }
          yield _state.wallet.requestSignIn({
            contractId,
            methodNames,
            successUrl,
            failureUrl,
          });
          return getAccounts();
        });
      },
      signOut() {
        return __awaiter$1(this, void 0, void 0, function* () {
          if (_state.wallet.isSignedIn()) {
            _state.wallet.signOut();
          }
        });
      },
      getAccounts() {
        return __awaiter$1(this, void 0, void 0, function* () {
          return getAccounts();
        });
      },
      verifyOwner() {
        return __awaiter$1(this, void 0, void 0, function* () {
          throw new Error(`Method not supported by ${metadata.name}`);
        });
      },
      signAndSendTransaction({ signerId, receiverId, actions, callbackUrl }) {
        return __awaiter$1(this, void 0, void 0, function* () {
          logger.log("signAndSendTransaction", {
            signerId,
            receiverId,
            actions,
            callbackUrl,
          });
          const { contract } = store.getState();
          if (!_state.wallet.isSignedIn() || !contract) {
            throw new Error("Wallet not signed in");
          }
          const account = _state.wallet.account();
          return account["signAndSendTransaction"]({
            receiverId: receiverId || contract.contractId,
            actions: actions.map((action) => createAction(action)),
            walletCallbackUrl: callbackUrl,
          });
        });
      },
      signAndSendTransactions({ transactions: transactions4, callbackUrl }) {
        return __awaiter$1(this, void 0, void 0, function* () {
          logger.log("signAndSendTransactions", {
            transactions: transactions4,
            callbackUrl,
          });
          if (!_state.wallet.isSignedIn()) {
            throw new Error("Wallet not signed in");
          }
          return _state.wallet.requestSignTransactions({
            transactions: yield transformTransactions(transactions4),
            callbackUrl,
          });
        });
      },
      buildImportAccountsUrl() {
        return `${params.walletUrl}/batch-import`;
      },
    };
  });
function setupMyNearWallet({
  walletUrl,
  iconUrl = icon$1,
  deprecated = false,
  successUrl = "",
  failureUrl = "",
} = {}) {
  return (moduleOptions) =>
    __awaiter$1(this, void 0, void 0, function* () {
      return {
        id: "my-near-wallet",
        type: "browser",
        metadata: {
          name: "MyNearWallet",
          description:
            "NEAR wallet to store, buy, send and stake assets for DeFi.",
          iconUrl,
          deprecated,
          available: true,
          successUrl,
          failureUrl,
          walletUrl: resolveWalletUrl$1(
            moduleOptions.options.network,
            walletUrl
          ),
        },
        init: (options) => {
          return MyNearWallet(
            Object.assign(Object.assign({}, options), {
              params: {
                walletUrl: resolveWalletUrl$1(
                  options.options.network,
                  walletUrl
                ),
              },
            })
          );
        },
      };
    });
}

// node_modules/@near-wallet-selector/near-wallet/index.js
var commonjsGlobal =
  typeof globalThis !== "undefined"
    ? globalThis
    : typeof window !== "undefined"
    ? window
    : typeof global !== "undefined"
    ? global
    : typeof self !== "undefined"
    ? self
    : {};
var check = function (it) {
  return it && it.Math == Math && it;
};
var global$a =
  // eslint-disable-next-line es-x/no-global-this -- safe
  check(typeof globalThis == "object" && globalThis) ||
  check(typeof window == "object" && window) || // eslint-disable-next-line no-restricted-globals -- safe
  check(typeof self == "object" && self) ||
  check(typeof commonjsGlobal == "object" && commonjsGlobal) || // eslint-disable-next-line no-new-func -- fallback
  (function () {
    return this;
  })() ||
  Function("return this")();
var objectGetOwnPropertyDescriptor = {};
var fails$9 = function (exec) {
  try {
    return !!exec();
  } catch (error) {
    return true;
  }
};
var fails$8 = fails$9;
var descriptors = !fails$8(function () {
  return (
    Object.defineProperty({}, 1, {
      get: function () {
        return 7;
      },
    })[1] != 7
  );
});
var fails$7 = fails$9;
var functionBindNative = !fails$7(function () {
  var test = function () {}.bind();
  return typeof test != "function" || test.hasOwnProperty("prototype");
});
var NATIVE_BIND$1 = functionBindNative;
var call$5 = Function.prototype.call;
var functionCall = NATIVE_BIND$1
  ? call$5.bind(call$5)
  : function () {
      return call$5.apply(call$5, arguments);
    };
var objectPropertyIsEnumerable = {};
var $propertyIsEnumerable = {}.propertyIsEnumerable;
var getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;
var NASHORN_BUG =
  getOwnPropertyDescriptor$1 && !$propertyIsEnumerable.call({ 1: 2 }, 1);
objectPropertyIsEnumerable.f = NASHORN_BUG
  ? function propertyIsEnumerable(V) {
      var descriptor = getOwnPropertyDescriptor$1(this, V);
      return !!descriptor && descriptor.enumerable;
    }
  : $propertyIsEnumerable;
var createPropertyDescriptor$2 = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value,
  };
};
var NATIVE_BIND = functionBindNative;
var FunctionPrototype$1 = Function.prototype;
var bind = FunctionPrototype$1.bind;
var call$4 = FunctionPrototype$1.call;
var uncurryThis$a = NATIVE_BIND && bind.bind(call$4, call$4);
var functionUncurryThis = NATIVE_BIND
  ? function (fn) {
      return fn && uncurryThis$a(fn);
    }
  : function (fn) {
      return (
        fn &&
        function () {
          return call$4.apply(fn, arguments);
        }
      );
    };
var uncurryThis$9 = functionUncurryThis;
var toString$1 = uncurryThis$9({}.toString);
var stringSlice = uncurryThis$9("".slice);
var classofRaw = function (it) {
  return stringSlice(toString$1(it), 8, -1);
};
var uncurryThis$8 = functionUncurryThis;
var fails$6 = fails$9;
var classof = classofRaw;
var $Object$2 = Object;
var split = uncurryThis$8("".split);
var indexedObject = fails$6(function () {
  return !$Object$2("z").propertyIsEnumerable(0);
})
  ? function (it) {
      return classof(it) == "String" ? split(it, "") : $Object$2(it);
    }
  : $Object$2;
var $TypeError$5 = TypeError;
var requireObjectCoercible$2 = function (it) {
  if (it == void 0) throw $TypeError$5("Can't call method on " + it);
  return it;
};
var IndexedObject$1 = indexedObject;
var requireObjectCoercible$1 = requireObjectCoercible$2;
var toIndexedObject$3 = function (it) {
  return IndexedObject$1(requireObjectCoercible$1(it));
};
var isCallable$a = function (argument) {
  return typeof argument == "function";
};
var isCallable$9 = isCallable$a;
var isObject$5 = function (it) {
  return typeof it == "object" ? it !== null : isCallable$9(it);
};
var global$9 = global$a;
var isCallable$8 = isCallable$a;
var aFunction = function (argument) {
  return isCallable$8(argument) ? argument : void 0;
};
var getBuiltIn$3 = function (namespace, method) {
  return arguments.length < 2
    ? aFunction(global$9[namespace])
    : global$9[namespace] && global$9[namespace][method];
};
var uncurryThis$7 = functionUncurryThis;
var objectIsPrototypeOf = uncurryThis$7({}.isPrototypeOf);
var getBuiltIn$2 = getBuiltIn$3;
var engineUserAgent = getBuiltIn$2("navigator", "userAgent") || "";
var global$8 = global$a;
var userAgent = engineUserAgent;
var process$1 = global$8.process;
var Deno$1 = global$8.Deno;
var versions = (process$1 && process$1.versions) || (Deno$1 && Deno$1.version);
var v8 = versions && versions.v8;
var match;
var version;
if (v8) {
  match = v8.split(".");
  version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
}
if (!version && userAgent) {
  match = userAgent.match(/Edge\/(\d+)/);
  if (!match || match[1] >= 74) {
    match = userAgent.match(/Chrome\/(\d+)/);
    if (match) version = +match[1];
  }
}
var engineV8Version = version;
var V8_VERSION = engineV8Version;
var fails$5 = fails$9;
var nativeSymbol =
  !!Object.getOwnPropertySymbols &&
  !fails$5(function () {
    var symbol = Symbol();
    return (
      !String(symbol) ||
      !(Object(symbol) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
      (!Symbol.sham && V8_VERSION && V8_VERSION < 41)
    );
  });
var NATIVE_SYMBOL$1 = nativeSymbol;
var useSymbolAsUid =
  NATIVE_SYMBOL$1 && !Symbol.sham && typeof Symbol.iterator == "symbol";
var getBuiltIn$1 = getBuiltIn$3;
var isCallable$7 = isCallable$a;
var isPrototypeOf = objectIsPrototypeOf;
var USE_SYMBOL_AS_UID$1 = useSymbolAsUid;
var $Object$1 = Object;
var isSymbol$2 = USE_SYMBOL_AS_UID$1
  ? function (it) {
      return typeof it == "symbol";
    }
  : function (it) {
      var $Symbol = getBuiltIn$1("Symbol");
      return (
        isCallable$7($Symbol) && isPrototypeOf($Symbol.prototype, $Object$1(it))
      );
    };
var $String$1 = String;
var tryToString$1 = function (argument) {
  try {
    return $String$1(argument);
  } catch (error) {
    return "Object";
  }
};
var isCallable$6 = isCallable$a;
var tryToString = tryToString$1;
var $TypeError$4 = TypeError;
var aCallable$1 = function (argument) {
  if (isCallable$6(argument)) return argument;
  throw $TypeError$4(tryToString(argument) + " is not a function");
};
var aCallable = aCallable$1;
var getMethod$1 = function (V, P) {
  var func = V[P];
  return func == null ? void 0 : aCallable(func);
};
var call$3 = functionCall;
var isCallable$5 = isCallable$a;
var isObject$4 = isObject$5;
var $TypeError$3 = TypeError;
var ordinaryToPrimitive$1 = function (input, pref) {
  var fn, val;
  if (
    pref === "string" &&
    isCallable$5((fn = input.toString)) &&
    !isObject$4((val = call$3(fn, input)))
  )
    return val;
  if (
    isCallable$5((fn = input.valueOf)) &&
    !isObject$4((val = call$3(fn, input)))
  )
    return val;
  if (
    pref !== "string" &&
    isCallable$5((fn = input.toString)) &&
    !isObject$4((val = call$3(fn, input)))
  )
    return val;
  throw $TypeError$3("Can't convert object to primitive value");
};
var shared$3 = { exports: {} };
var global$7 = global$a;
var defineProperty$2 = Object.defineProperty;
var defineGlobalProperty$3 = function (key, value) {
  try {
    defineProperty$2(global$7, key, {
      value,
      configurable: true,
      writable: true,
    });
  } catch (error) {
    global$7[key] = value;
  }
  return value;
};
var global$6 = global$a;
var defineGlobalProperty$2 = defineGlobalProperty$3;
var SHARED = "__core-js_shared__";
var store$3 = global$6[SHARED] || defineGlobalProperty$2(SHARED, {});
var sharedStore = store$3;
var store$2 = sharedStore;
(shared$3.exports = function (key, value) {
  return store$2[key] || (store$2[key] = value !== void 0 ? value : {});
})("versions", []).push({
  version: "3.23.3",
  mode: "global",
  copyright: " 2014-2022 Denis Pushkarev (zloirock.ru)",
  license: "https://github.com/zloirock/core-js/blob/v3.23.3/LICENSE",
  source: "https://github.com/zloirock/core-js",
});
var requireObjectCoercible = requireObjectCoercible$2;
var $Object = Object;
var toObject$2 = function (argument) {
  return $Object(requireObjectCoercible(argument));
};
var uncurryThis$6 = functionUncurryThis;
var toObject$1 = toObject$2;
var hasOwnProperty = uncurryThis$6({}.hasOwnProperty);
var hasOwnProperty_1 =
  Object.hasOwn ||
  function hasOwn(it, key) {
    return hasOwnProperty(toObject$1(it), key);
  };
var uncurryThis$5 = functionUncurryThis;
var id = 0;
var postfix = Math.random();
var toString = uncurryThis$5((1).toString);
var uid$2 = function (key) {
  return (
    "Symbol(" +
    (key === void 0 ? "" : key) +
    ")_" +
    toString(++id + postfix, 36)
  );
};
var global$5 = global$a;
var shared$2 = shared$3.exports;
var hasOwn$6 = hasOwnProperty_1;
var uid$1 = uid$2;
var NATIVE_SYMBOL = nativeSymbol;
var USE_SYMBOL_AS_UID = useSymbolAsUid;
var WellKnownSymbolsStore = shared$2("wks");
var Symbol$1 = global$5.Symbol;
var symbolFor = Symbol$1 && Symbol$1["for"];
var createWellKnownSymbol = USE_SYMBOL_AS_UID
  ? Symbol$1
  : (Symbol$1 && Symbol$1.withoutSetter) || uid$1;
var wellKnownSymbol$1 = function (name) {
  if (
    !hasOwn$6(WellKnownSymbolsStore, name) ||
    !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == "string")
  ) {
    var description = "Symbol." + name;
    if (NATIVE_SYMBOL && hasOwn$6(Symbol$1, name)) {
      WellKnownSymbolsStore[name] = Symbol$1[name];
    } else if (USE_SYMBOL_AS_UID && symbolFor) {
      WellKnownSymbolsStore[name] = symbolFor(description);
    } else {
      WellKnownSymbolsStore[name] = createWellKnownSymbol(description);
    }
  }
  return WellKnownSymbolsStore[name];
};
var call$2 = functionCall;
var isObject$3 = isObject$5;
var isSymbol$1 = isSymbol$2;
var getMethod = getMethod$1;
var ordinaryToPrimitive = ordinaryToPrimitive$1;
var wellKnownSymbol = wellKnownSymbol$1;
var $TypeError$2 = TypeError;
var TO_PRIMITIVE = wellKnownSymbol("toPrimitive");
var toPrimitive$1 = function (input, pref) {
  if (!isObject$3(input) || isSymbol$1(input)) return input;
  var exoticToPrim = getMethod(input, TO_PRIMITIVE);
  var result;
  if (exoticToPrim) {
    if (pref === void 0) pref = "default";
    result = call$2(exoticToPrim, input, pref);
    if (!isObject$3(result) || isSymbol$1(result)) return result;
    throw $TypeError$2("Can't convert object to primitive value");
  }
  if (pref === void 0) pref = "number";
  return ordinaryToPrimitive(input, pref);
};
var toPrimitive = toPrimitive$1;
var isSymbol = isSymbol$2;
var toPropertyKey$2 = function (argument) {
  var key = toPrimitive(argument, "string");
  return isSymbol(key) ? key : key + "";
};
var global$4 = global$a;
var isObject$2 = isObject$5;
var document$1 = global$4.document;
var EXISTS$1 = isObject$2(document$1) && isObject$2(document$1.createElement);
var documentCreateElement = function (it) {
  return EXISTS$1 ? document$1.createElement(it) : {};
};
var DESCRIPTORS$7 = descriptors;
var fails$4 = fails$9;
var createElement = documentCreateElement;
var ie8DomDefine =
  !DESCRIPTORS$7 &&
  !fails$4(function () {
    return (
      Object.defineProperty(createElement("div"), "a", {
        get: function () {
          return 7;
        },
      }).a != 7
    );
  });
var DESCRIPTORS$6 = descriptors;
var call$1 = functionCall;
var propertyIsEnumerableModule$1 = objectPropertyIsEnumerable;
var createPropertyDescriptor$1 = createPropertyDescriptor$2;
var toIndexedObject$2 = toIndexedObject$3;
var toPropertyKey$1 = toPropertyKey$2;
var hasOwn$5 = hasOwnProperty_1;
var IE8_DOM_DEFINE$1 = ie8DomDefine;
var $getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;
objectGetOwnPropertyDescriptor.f = DESCRIPTORS$6
  ? $getOwnPropertyDescriptor$1
  : function getOwnPropertyDescriptor(O, P) {
      O = toIndexedObject$2(O);
      P = toPropertyKey$1(P);
      if (IE8_DOM_DEFINE$1)
        try {
          return $getOwnPropertyDescriptor$1(O, P);
        } catch (error) {}
      if (hasOwn$5(O, P))
        return createPropertyDescriptor$1(
          !call$1(propertyIsEnumerableModule$1.f, O, P),
          O[P]
        );
    };
var objectDefineProperty = {};
var DESCRIPTORS$5 = descriptors;
var fails$3 = fails$9;
var v8PrototypeDefineBug =
  DESCRIPTORS$5 &&
  fails$3(function () {
    return (
      Object.defineProperty(function () {}, "prototype", {
        value: 42,
        writable: false,
      }).prototype != 42
    );
  });
var isObject$1 = isObject$5;
var $String = String;
var $TypeError$1 = TypeError;
var anObject$2 = function (argument) {
  if (isObject$1(argument)) return argument;
  throw $TypeError$1($String(argument) + " is not an object");
};
var DESCRIPTORS$4 = descriptors;
var IE8_DOM_DEFINE = ie8DomDefine;
var V8_PROTOTYPE_DEFINE_BUG = v8PrototypeDefineBug;
var anObject$1 = anObject$2;
var toPropertyKey = toPropertyKey$2;
var $TypeError = TypeError;
var $defineProperty = Object.defineProperty;
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var ENUMERABLE = "enumerable";
var CONFIGURABLE$1 = "configurable";
var WRITABLE = "writable";
objectDefineProperty.f = DESCRIPTORS$4
  ? V8_PROTOTYPE_DEFINE_BUG
    ? function defineProperty(O, P, Attributes) {
        anObject$1(O);
        P = toPropertyKey(P);
        anObject$1(Attributes);
        if (
          typeof O === "function" &&
          P === "prototype" &&
          "value" in Attributes &&
          WRITABLE in Attributes &&
          !Attributes[WRITABLE]
        ) {
          var current = $getOwnPropertyDescriptor(O, P);
          if (current && current[WRITABLE]) {
            O[P] = Attributes.value;
            Attributes = {
              configurable:
                CONFIGURABLE$1 in Attributes
                  ? Attributes[CONFIGURABLE$1]
                  : current[CONFIGURABLE$1],
              enumerable:
                ENUMERABLE in Attributes
                  ? Attributes[ENUMERABLE]
                  : current[ENUMERABLE],
              writable: false,
            };
          }
        }
        return $defineProperty(O, P, Attributes);
      }
    : $defineProperty
  : function defineProperty2(O, P, Attributes) {
      anObject$1(O);
      P = toPropertyKey(P);
      anObject$1(Attributes);
      if (IE8_DOM_DEFINE)
        try {
          return $defineProperty(O, P, Attributes);
        } catch (error) {}
      if ("get" in Attributes || "set" in Attributes)
        throw $TypeError("Accessors not supported");
      if ("value" in Attributes) O[P] = Attributes.value;
      return O;
    };
var DESCRIPTORS$3 = descriptors;
var definePropertyModule$2 = objectDefineProperty;
var createPropertyDescriptor = createPropertyDescriptor$2;
var createNonEnumerableProperty$2 = DESCRIPTORS$3
  ? function (object, key, value) {
      return definePropertyModule$2.f(
        object,
        key,
        createPropertyDescriptor(1, value)
      );
    }
  : function (object, key, value) {
      object[key] = value;
      return object;
    };
var makeBuiltIn$2 = { exports: {} };
var DESCRIPTORS$2 = descriptors;
var hasOwn$4 = hasOwnProperty_1;
var FunctionPrototype = Function.prototype;
var getDescriptor = DESCRIPTORS$2 && Object.getOwnPropertyDescriptor;
var EXISTS = hasOwn$4(FunctionPrototype, "name");
var PROPER = EXISTS && function something() {}.name === "something";
var CONFIGURABLE =
  EXISTS &&
  (!DESCRIPTORS$2 ||
    (DESCRIPTORS$2 && getDescriptor(FunctionPrototype, "name").configurable));
var functionName = {
  EXISTS,
  PROPER,
  CONFIGURABLE,
};
var uncurryThis$4 = functionUncurryThis;
var isCallable$4 = isCallable$a;
var store$1 = sharedStore;
var functionToString = uncurryThis$4(Function.toString);
if (!isCallable$4(store$1.inspectSource)) {
  store$1.inspectSource = function (it) {
    return functionToString(it);
  };
}
var inspectSource$2 = store$1.inspectSource;
var global$3 = global$a;
var isCallable$3 = isCallable$a;
var inspectSource$1 = inspectSource$2;
var WeakMap$1 = global$3.WeakMap;
var nativeWeakMap =
  isCallable$3(WeakMap$1) && /native code/.test(inspectSource$1(WeakMap$1));
var shared$1 = shared$3.exports;
var uid = uid$2;
var keys = shared$1("keys");
var sharedKey$1 = function (key) {
  return keys[key] || (keys[key] = uid(key));
};
var hiddenKeys$3 = {};
var NATIVE_WEAK_MAP = nativeWeakMap;
var global$2 = global$a;
var uncurryThis$3 = functionUncurryThis;
var isObject = isObject$5;
var createNonEnumerableProperty$1 = createNonEnumerableProperty$2;
var hasOwn$3 = hasOwnProperty_1;
var shared = sharedStore;
var sharedKey = sharedKey$1;
var hiddenKeys$2 = hiddenKeys$3;
var OBJECT_ALREADY_INITIALIZED = "Object already initialized";
var TypeError$1 = global$2.TypeError;
var WeakMap$2 = global$2.WeakMap;
var set;
var get;
var has;
var enforce = function (it) {
  return has(it) ? get(it) : set(it, {});
};
var getterFor = function (TYPE) {
  return function (it) {
    var state;
    if (!isObject(it) || (state = get(it)).type !== TYPE) {
      throw TypeError$1("Incompatible receiver, " + TYPE + " required");
    }
    return state;
  };
};
if (NATIVE_WEAK_MAP || shared.state) {
  store = shared.state || (shared.state = new WeakMap$2());
  wmget = uncurryThis$3(store.get);
  wmhas = uncurryThis$3(store.has);
  wmset = uncurryThis$3(store.set);
  set = function (it, metadata) {
    if (wmhas(store, it)) throw new TypeError$1(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    wmset(store, it, metadata);
    return metadata;
  };
  get = function (it) {
    return wmget(store, it) || {};
  };
  has = function (it) {
    return wmhas(store, it);
  };
} else {
  STATE = sharedKey("state");
  hiddenKeys$2[STATE] = true;
  set = function (it, metadata) {
    if (hasOwn$3(it, STATE)) throw new TypeError$1(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    createNonEnumerableProperty$1(it, STATE, metadata);
    return metadata;
  };
  get = function (it) {
    return hasOwn$3(it, STATE) ? it[STATE] : {};
  };
  has = function (it) {
    return hasOwn$3(it, STATE);
  };
}
var store;
var wmget;
var wmhas;
var wmset;
var STATE;
var internalState = {
  set,
  get,
  has,
  enforce,
  getterFor,
};
var fails$2 = fails$9;
var isCallable$2 = isCallable$a;
var hasOwn$2 = hasOwnProperty_1;
var DESCRIPTORS$1 = descriptors;
var CONFIGURABLE_FUNCTION_NAME = functionName.CONFIGURABLE;
var inspectSource = inspectSource$2;
var InternalStateModule = internalState;
var enforceInternalState = InternalStateModule.enforce;
var getInternalState = InternalStateModule.get;
var defineProperty$1 = Object.defineProperty;
var CONFIGURABLE_LENGTH =
  DESCRIPTORS$1 &&
  !fails$2(function () {
    return (
      defineProperty$1(function () {}, "length", { value: 8 }).length !== 8
    );
  });
var TEMPLATE = String(String).split("String");
var makeBuiltIn$1 = (makeBuiltIn$2.exports = function (value, name, options) {
  if (String(name).slice(0, 7) === "Symbol(") {
    name = "[" + String(name).replace(/^Symbol\(([^)]*)\)/, "$1") + "]";
  }
  if (options && options.getter) name = "get " + name;
  if (options && options.setter) name = "set " + name;
  if (
    !hasOwn$2(value, "name") ||
    (CONFIGURABLE_FUNCTION_NAME && value.name !== name)
  ) {
    if (DESCRIPTORS$1)
      defineProperty$1(value, "name", { value: name, configurable: true });
    else value.name = name;
  }
  if (
    CONFIGURABLE_LENGTH &&
    options &&
    hasOwn$2(options, "arity") &&
    value.length !== options.arity
  ) {
    defineProperty$1(value, "length", { value: options.arity });
  }
  try {
    if (options && hasOwn$2(options, "constructor") && options.constructor) {
      if (DESCRIPTORS$1)
        defineProperty$1(value, "prototype", { writable: false });
    } else if (value.prototype) value.prototype = void 0;
  } catch (error) {}
  var state = enforceInternalState(value);
  if (!hasOwn$2(state, "source")) {
    state.source = TEMPLATE.join(typeof name == "string" ? name : "");
  }
  return value;
});
Function.prototype.toString = makeBuiltIn$1(function toString2() {
  return (
    (isCallable$2(this) && getInternalState(this).source) || inspectSource(this)
  );
}, "toString");
var isCallable$1 = isCallable$a;
var definePropertyModule$1 = objectDefineProperty;
var makeBuiltIn = makeBuiltIn$2.exports;
var defineGlobalProperty$1 = defineGlobalProperty$3;
var defineBuiltIn$1 = function (O, key, value, options) {
  if (!options) options = {};
  var simple = options.enumerable;
  var name = options.name !== void 0 ? options.name : key;
  if (isCallable$1(value)) makeBuiltIn(value, name, options);
  if (options.global) {
    if (simple) O[key] = value;
    else defineGlobalProperty$1(key, value);
  } else {
    try {
      if (!options.unsafe) delete O[key];
      else if (O[key]) simple = true;
    } catch (error) {}
    if (simple) O[key] = value;
    else
      definePropertyModule$1.f(O, key, {
        value,
        enumerable: false,
        configurable: !options.nonConfigurable,
        writable: !options.nonWritable,
      });
  }
  return O;
};
var objectGetOwnPropertyNames = {};
var ceil = Math.ceil;
var floor = Math.floor;
var mathTrunc =
  Math.trunc ||
  function trunc(x) {
    var n = +x;
    return (n > 0 ? floor : ceil)(n);
  };
var trunc2 = mathTrunc;
var toIntegerOrInfinity$2 = function (argument) {
  var number = +argument;
  return number !== number || number === 0 ? 0 : trunc2(number);
};
var toIntegerOrInfinity$1 = toIntegerOrInfinity$2;
var max = Math.max;
var min$1 = Math.min;
var toAbsoluteIndex$1 = function (index, length) {
  var integer = toIntegerOrInfinity$1(index);
  return integer < 0 ? max(integer + length, 0) : min$1(integer, length);
};
var toIntegerOrInfinity = toIntegerOrInfinity$2;
var min = Math.min;
var toLength$1 = function (argument) {
  return argument > 0
    ? min(toIntegerOrInfinity(argument), 9007199254740991)
    : 0;
};
var toLength = toLength$1;
var lengthOfArrayLike$1 = function (obj) {
  return toLength(obj.length);
};
var toIndexedObject$1 = toIndexedObject$3;
var toAbsoluteIndex = toAbsoluteIndex$1;
var lengthOfArrayLike = lengthOfArrayLike$1;
var createMethod = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIndexedObject$1($this);
    var length = lengthOfArrayLike(O);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    if (IS_INCLUDES && el != el)
      while (length > index) {
        value = O[index++];
        if (value != value) return true;
      }
    else
      for (; length > index; index++) {
        if ((IS_INCLUDES || index in O) && O[index] === el)
          return IS_INCLUDES || index || 0;
      }
    return !IS_INCLUDES && -1;
  };
};
var arrayIncludes = {
  // `Array.prototype.includes` method
  // https://tc39.es/ecma262/#sec-array.prototype.includes
  includes: createMethod(true),
  // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof
  indexOf: createMethod(false),
};
var uncurryThis$2 = functionUncurryThis;
var hasOwn$1 = hasOwnProperty_1;
var toIndexedObject = toIndexedObject$3;
var indexOf = arrayIncludes.indexOf;
var hiddenKeys$1 = hiddenKeys$3;
var push = uncurryThis$2([].push);
var objectKeysInternal = function (object, names) {
  var O = toIndexedObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O)
    !hasOwn$1(hiddenKeys$1, key) && hasOwn$1(O, key) && push(result, key);
  while (names.length > i)
    if (hasOwn$1(O, (key = names[i++]))) {
      ~indexOf(result, key) || push(result, key);
    }
  return result;
};
var enumBugKeys$2 = [
  "constructor",
  "hasOwnProperty",
  "isPrototypeOf",
  "propertyIsEnumerable",
  "toLocaleString",
  "toString",
  "valueOf",
];
var internalObjectKeys$1 = objectKeysInternal;
var enumBugKeys$1 = enumBugKeys$2;
var hiddenKeys = enumBugKeys$1.concat("length", "prototype");
objectGetOwnPropertyNames.f =
  Object.getOwnPropertyNames ||
  function getOwnPropertyNames(O) {
    return internalObjectKeys$1(O, hiddenKeys);
  };
var objectGetOwnPropertySymbols = {};
objectGetOwnPropertySymbols.f = Object.getOwnPropertySymbols;
var getBuiltIn = getBuiltIn$3;
var uncurryThis$1 = functionUncurryThis;
var getOwnPropertyNamesModule = objectGetOwnPropertyNames;
var getOwnPropertySymbolsModule$1 = objectGetOwnPropertySymbols;
var anObject = anObject$2;
var concat$1 = uncurryThis$1([].concat);
var ownKeys$1 =
  getBuiltIn("Reflect", "ownKeys") ||
  function ownKeys(it) {
    var keys3 = getOwnPropertyNamesModule.f(anObject(it));
    var getOwnPropertySymbols = getOwnPropertySymbolsModule$1.f;
    return getOwnPropertySymbols
      ? concat$1(keys3, getOwnPropertySymbols(it))
      : keys3;
  };
var hasOwn2 = hasOwnProperty_1;
var ownKeys2 = ownKeys$1;
var getOwnPropertyDescriptorModule = objectGetOwnPropertyDescriptor;
var definePropertyModule = objectDefineProperty;
var copyConstructorProperties$1 = function (target, source, exceptions) {
  var keys3 = ownKeys2(source);
  var defineProperty4 = definePropertyModule.f;
  var getOwnPropertyDescriptor3 = getOwnPropertyDescriptorModule.f;
  for (var i = 0; i < keys3.length; i++) {
    var key = keys3[i];
    if (!hasOwn2(target, key) && !(exceptions && hasOwn2(exceptions, key))) {
      defineProperty4(target, key, getOwnPropertyDescriptor3(source, key));
    }
  }
};
var fails$1 = fails$9;
var isCallable = isCallable$a;
var replacement = /#|\.prototype\./;
var isForced$1 = function (feature, detection) {
  var value = data[normalize(feature)];
  return value == POLYFILL
    ? true
    : value == NATIVE
    ? false
    : isCallable(detection)
    ? fails$1(detection)
    : !!detection;
};
var normalize = (isForced$1.normalize = function (string) {
  return String(string).replace(replacement, ".").toLowerCase();
});
var data = (isForced$1.data = {});
var NATIVE = (isForced$1.NATIVE = "N");
var POLYFILL = (isForced$1.POLYFILL = "P");
var isForced_1 = isForced$1;
var global$1 = global$a;
var getOwnPropertyDescriptor2 = objectGetOwnPropertyDescriptor.f;
var createNonEnumerableProperty = createNonEnumerableProperty$2;
var defineBuiltIn = defineBuiltIn$1;
var defineGlobalProperty = defineGlobalProperty$3;
var copyConstructorProperties = copyConstructorProperties$1;
var isForced = isForced_1;
var _export = function (options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var FORCED, target, key, targetProperty, sourceProperty, descriptor;
  if (GLOBAL) {
    target = global$1;
  } else if (STATIC) {
    target = global$1[TARGET] || defineGlobalProperty(TARGET, {});
  } else {
    target = (global$1[TARGET] || {}).prototype;
  }
  if (target)
    for (key in source) {
      sourceProperty = source[key];
      if (options.dontCallGetSet) {
        descriptor = getOwnPropertyDescriptor2(target, key);
        targetProperty = descriptor && descriptor.value;
      } else targetProperty = target[key];
      FORCED = isForced(
        GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key,
        options.forced
      );
      if (!FORCED && targetProperty !== void 0) {
        if (typeof sourceProperty == typeof targetProperty) continue;
        copyConstructorProperties(sourceProperty, targetProperty);
      }
      if (options.sham || (targetProperty && targetProperty.sham)) {
        createNonEnumerableProperty(sourceProperty, "sham", true);
      }
      defineBuiltIn(target, key, sourceProperty, options);
    }
};
var internalObjectKeys = objectKeysInternal;
var enumBugKeys = enumBugKeys$2;
var objectKeys$1 =
  Object.keys ||
  function keys2(O) {
    return internalObjectKeys(O, enumBugKeys);
  };
var DESCRIPTORS = descriptors;
var uncurryThis = functionUncurryThis;
var call = functionCall;
var fails = fails$9;
var objectKeys = objectKeys$1;
var getOwnPropertySymbolsModule = objectGetOwnPropertySymbols;
var propertyIsEnumerableModule = objectPropertyIsEnumerable;
var toObject = toObject$2;
var IndexedObject = indexedObject;
var $assign = Object.assign;
var defineProperty3 = Object.defineProperty;
var concat = uncurryThis([].concat);
var objectAssign =
  !$assign ||
  fails(function () {
    if (
      DESCRIPTORS &&
      $assign(
        { b: 1 },
        $assign(
          defineProperty3({}, "a", {
            enumerable: true,
            get: function () {
              defineProperty3(this, "b", {
                value: 3,
                enumerable: false,
              });
            },
          }),
          { b: 2 }
        )
      ).b !== 1
    )
      return true;
    var A = {};
    var B = {};
    var symbol = Symbol();
    var alphabet = "abcdefghijklmnopqrst";
    A[symbol] = 7;
    alphabet.split("").forEach(function (chr) {
      B[chr] = chr;
    });
    return (
      $assign({}, A)[symbol] != 7 ||
      objectKeys($assign({}, B)).join("") != alphabet
    );
  })
    ? function assign(target, source) {
        var T = toObject(target);
        var argumentsLength = arguments.length;
        var index = 1;
        var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
        var propertyIsEnumerable2 = propertyIsEnumerableModule.f;
        while (argumentsLength > index) {
          var S = IndexedObject(arguments[index++]);
          var keys3 = getOwnPropertySymbols
            ? concat(objectKeys(S), getOwnPropertySymbols(S))
            : objectKeys(S);
          var length = keys3.length;
          var j = 0;
          var key;
          while (length > j) {
            key = keys3[j++];
            if (!DESCRIPTORS || call(propertyIsEnumerable2, S, key))
              T[key] = S[key];
          }
        }
        return T;
      }
    : $assign;
var $ = _export;
var assign2 = objectAssign;
$(
  { target: "Object", stat: true, arity: 2, forced: Object.assign !== assign2 },
  {
    assign: assign2,
  }
);
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P
      ? value
      : new P(function (resolve) {
          resolve(value);
        });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done
        ? resolve(result.value)
        : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
var icon = `data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAQAAADTdEb+AAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAAmJLR0QA/4ePzL8AAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQfmCBYRIzjChBcFAAAabUlEQVR42u2deWBVxfXHPwlhSYCAsikiqCAYQJGqdSmCWrVotbVgUdzrhlWUHWQTRCkiCAEtFdywILRWkWoFd1CsIiJFlFX8sW9hTSCBJCTv90dEEsjLe/e+uefc7XP+S/LeOWfmm3vvzJ05k4Q1UmlMBq1pzqnUoQaVSSrz+0Jy2cMW1rKCFawn2+L3h+hQlVM4i5a0oDH1SKcKkM9+stjAar5nNVsptPKFSXH/ZRpncwWXkkF9UuP4XD57WMtC5rGYndrtFhKVNFrRgUtpyUmkkVzOXxSTy1a+41M+YzX5Jp035D4+YC8RG3aQJTzOOeWGHKLLqXTjffbE3Zc7eIuu1DXjvCF9WUaRLVEdta1Moq12O4aUogmDWUGx5Z4s5CseSFRcqdzBkgQlddS28AQNtdszBKjFgyxPoCeL+JzOVLHrvhUzyTcmqxJbxLUWnutCnOBi5nI44Z7M5SWaWXeeTBdWGxZVie1hCDW02zawVKM7W4315TKut+Y+lcFkOyKrkgvpVE7SbuFAUpdJhu9Bu+kd/y0xnYkUOiarEvsPTbRbOXA05i0HejKfp6kej/t0JtsYK1i39zhVu6UDxWm879gdaGLsh5tUJorIKkKEWaZmREJi0pA5DvZkEWOoWpH7ZAY7fhMsbZOopt3igSCd6Q73ZAH9Kxrt30SOoKwiFDAgnHxwnEo8IXAX2kfnaAG0Zo2orCJEyKardrv7nhuFLheryCjPfRqvi8sqQoSNtNdueV/TlO/F+nIGqccH8Cfjs+zx2hJaaLe+b6nMZMGezOeOYwNoxLdKsooQ4V3qa/eAT7mJXOGLxCllAxioKKsIESaXdxENSZCmfCfek/1LB9CYFcrCKmRQuGLLMFV4UaEnl5ee+O4uNika3XK4TbsnfMat5Cn0YzEPHQmgJvPVZRUhwmYu1+4LH9Fc7S40j5olIXRgv7qoSmxp+TMhIZapylS1XsyhPSQDV7pmfVQbxtNAOwhfcDM3q/muyZUA6S65ER6xF0jT7hXPk+HQIs34b4bp8Au2qYuptB1maDg+TIhUx185x7JttE2mDXW0W6IMlejP7dpBeJpb+aNyBHU4N5lzqazdEsdQg7/wa+0gPEtrHrW/f8YQlWmTzFnaLVEODRlPK+0gPEkaQ2iqHQSQkUxj7RjK5WzGhxsubHAHnbRDAKAx7FR/XI9mL8e3SD/kZ9rwf+q9VmJZcFA9iGh2mGFU0u4rD1GDN9T77IjlYWBPrHN2gD9p95aH6C66XyHWRUE9hIptG1dp95dH+AUb1HurtKkHEMu+52ztPvMANZmt3lNlzP1z3K0YH9aoick9XKcdwrGoazsOe9U1r8ndyQVsUu+jY009gHisiBHh+DAqtfiPeg95VFgRcrlXu/9cS9+E6y0GWFgRttNRuwddycUG610FUlgRVtBGuxddxwnMVe+Xcs39o8KjZJB57K61wPMAV2uHEA11bVuyaUcW6ocA7diu3iPRTD0Aa1bESFK0+9MlnMiH6v0R1bx0KwRIphd3awfhEh5y93JIdW1bth1cq91oLqADWeo9UZGpB2DHVgX+lIu6zFPvhQrNa7fCElqQGejSuEk8zGXaQcRCXds2bQbp2k2nxq/Zpd7+vrxiAdzMINftL5KhPsNctmWvHLwrrCR6BPL9YRI9uFQ7iHhQv2gmYDvdtwrJcX5j4XxBRUsiot1SCbGGW/hGOwhBTuZNLtYOIh68eyssoTmZLt0Z6QTJ9PKGrLwvLGjH09TSDkKIjtyvHUK8eF9Y0IXBgRgfnsIw7/wL+UFYSTxMN+0gHKcSffildhBWUB8/GLFd/F67IR3mdw4eTRqOCitgLbfwtXYQjnEqb3GedhBW8MOtsIRmZHKadhAOkUI/b8nKT8KCSxhDbe0gHOF33qth4SdhwY0MVa9mZ57TGOq9Dbv+EhY8xAPaIRimMv05VzsI6/jn4f0Ie7iXt7SDMEgX4wXoClgNNK/4FOfEUR+YGrcfudDZJhPkDJYZbp3tdKMudejt8IFzDnfyGl5hlvgMzJecrq0II1RhivH+OLJfINXhPT6OfvkXZAAp3Ct+Ws+bnKCtCgPcYvj8rq/KzN2/4F1hHXllmsxQ8ZKUmU4/QzjOmSw32iJzOLPM9zt7qK+DX13IDT8nkebw/8fxlk8vbWUkRFVeNtgaRUw97vgrXwgLGoiXr9hDZ211JMAdButZH+KpckoT+ERYkMFSYWmt88qyuOM4i1XGWmEfvcqdNvaNsOAyNgtLa5ErDgCxSjWmGWuBzXQlqVwvjgpLduZ9Po+yX9TjBTzj/q1Sx3GLsfO7VnIXM1GZBJe8YkEyg8TL3E/02PiwFT8YyvzzCksR+OhWCJDK88LCKqBvlJuBG0ljpqG8Z8eYJvaZsKA+7wpLay9dtPUSN/dTYCDjw0ymbgxPvhMWtGCJsLTW8yttxcTFOUbO78rj8ThO1vahsKA9G4WltfiYeWc3Up1/Gch0Nw/GVfXQl8KCruKvpt+OeXPQ5kEDA5sNcU8L+1RYSQww8jRhxf5KNW3tVEBb1iec4be0j9ufT4UF1ZgkLKwC+rt2fFiTWQnnN4/WFjz6VlhQl3eEpZVNV20FRaFHwus/XrdY5dDHwoIzWSwsrY2urC51foLndxXwrOUVaL4WFrQTPxn0G1po6+gY0nk7oYwOMNjG06PPhQU3sU9YWu9ST1tLZeiT0G0wi3tsHbrne2El0U98fPg8qdpq+pkL2ZJAJmu53qZf3wsLqvGssLAKGeiSPZW1mZNAHosTWHEWAGFBHfHDsrO5VVtTAAxI4BjL9xN6WgyEsKAZi4SltckFRfh/xTab0RczjZMT8h0QYcElrBOW1lLOUpXViXxgM/J8xiZ8gEJghAU3sldYWnOpryiswRTbijqbvgaKnwRIWNCbfGFpTYljgYkztGeHrYi3cruRF1OBElZVJggLq5AhKuPDunxsK95V/MZQBIESFpxo4GWsNdvP7QrCGm4r1i8NVvYLmLDgDBYKS2sLVwjL6gp22ojzHaOb2QInLLjIyAJdK7aMloKyqs+nliMs4kXDAw0f7SuMl4X0ZY+ox7MZz0lCvpJ4xMJyvBIO8RQ9yRJtkwRx4xULoAeHhK9aLxmunBeNq9htMbI9POzA2RsBvBUCVGGcsLAOM8zWKgFrnMTnFuPa5NDmtYAKC04wsmfFih3gLodllcxTFmP6jssdiiWwwoLT+EJYWlu50lFhXWPx3cJnnONYLAEWFlzAWmFpfWdpQ4I1GlqcSHmTJo7FEshR4VG+pg+7RT22JjPBVQPRqERvC/WcD/M37mODaO5GcfcVC6C7wdp28dkrjpwEcb2FLbq5POb4GtdA3woBKjPG5ioAu3aYx42PDxvxddz+d3K/wPg08MKCWvxTVFgRcrnHaCemWHi5vs5Yu4XCikkTy7M/idp2rjbYiX8gJ06/S8Tq4oTCAuA81ghLa7mxoX6TuMs2fUSGkKwCPio8yjf0YZeox5ZkcoqB76lM/wpLNh4hwkzuZKVojg7ilSsWwIPi48O/l1Mf3SqdOBCHpwLGC59RH94Kf6YyTwmPD4t4Mq4iZtFJZ14cfnIYIF6CNxRWmW6aISqsCLncl1DE7eJ4bN/OXQrLo8NnrFLkMIAFoh7TeJJrEvh8s5g30x+4m6kUi2blOF4TFmyiB6tFPdZnXAKH58aa6FzEbcwRzUcE7wkL/kdvdop6PItMGtn87AYOVvDbudzGItFchPCisGAOQyvsLvN0YLTNncfLWBXlN8W8yp/4QTQPMbwpLHiJTOGnkpsZaGt8mMVkDpfz83zG8DA7RHMQxVujwqPUZLrw+DCPB2xFmsak4yZJ9tLTgVXs1ginG6LQKK4ZIpOWxW9tRZrOCLJKfc8yOrugerOjwkps8k+XzfTkH6L1Yuoxjm0ssfy5HIbzDr+nLTXIYgGz2SgYtRLevWIBdGS78FXrMxrbjrYKaQLrrOIlnCCtgPcYQp6ox0sZbfudXgF5FIlGq4bXhQVTGSc8PryJQeoP3q7H+8I6zGimi3pM4hHu107b7XhfWHCAgXwi6rEaw20XwQ4IfhAWbKUnK0Q91mUc52un7Wb8ISz4jl5sF/XYjAmObif1OH4RFnzAYHJFPV7CGGprp+1W/CMseJWxwoP5GxlioHqxL/GTsIoYwzRRj0l0p5t22u7ET8KCXAbxkajHqgwX2l7qMfwlLNhGT74X9XgiY/mldtruw2/CguX0ZJuox6Zkcrp22m7Df8KCjxnIAVGPFzPG8sG5PsePwoLpjBEeH3bmsXB8WBp/CquIsUwV9vlnHtRO2034U1iQx2DeF/VYlcforJ22e/CrsGAHvVkm6vEExnCRdtpuwb/CghX0ZIuox9OZwBnaabsDPwsL5jGQ/aIef8kznKidthvwt7DgNUaXu6vPOW5gmHjdGBfid2EVM56XhX0+QHcXbO5Sxu/CgjyGMlfUYxWGcKN22tr4X1iQRW+WinqszRgu0U5blyAIC1bRk82iHpswgWbaaWsSDGHBpwwgR9Tj+TxDHe209QiKsGAmo4THh7/jcappp61FcIQVYQIvCvu8n4eDOj4MjrDgII/xrqjHygx26HRU1xMkYcFOetuoFZMItXiadtppaxAsYcEaegqXEGrMBJprpy1P0IQFCxhAtqjHXzCOetppSxM8YcE/GUmhqMff8rjjx1q6jCAKK8KzTBH2eR89gjU+DKKw4BDDeVvUYwoD6aqdtiTBFBbsog+LRT2mM5oO2mnLEVRhwVp6CJ8R34hM0VK8qgRXWPAF/dgn6vFcxlFfO20ZgiwseIMnKRD1eA1PBGN8GGxhRXiO54V93k3vILR6AFKskHweZ7aoxxQGcKt22s4TdGHBHvoKH+xWk1Fcrp2204TCgh/pwTpRj6eQSYZ22s4SCgtgIf3YK+rxHMbTQDttJwmFVcKbjBAeH/6GkaRpp+0cobCOMIlJwh7voo9/29+3iVmmgBG8KeqxEv25XTttpwiFdZS99GOhqMcajOLX2mk7Qyis0qyjB/8n6vFkMmmlnbYThMIqyyL6sEfUY2vGc7J22uYJhXUssxlOvqjHqxhJde20TRMK63gm8xwRUY930M9FR/oaIRTW8RTwJG+IeqxEX+7UTtssobDKYx/9+ELUY3VGcpV22iYJhVU+G+jBWlGPJ5HJ2dppmyMUVjQW04fdoh5bkklD7bRNEQorOm8zjEOiHq9gFDW00zZDKKyKmMJE4fHhbQwgRTttE4TCqohC/sLroh6T6c1d2mmbSSSkIrLpzwJRj2k8SUfttBMnFFYsNtKTNaIeGzCONtppJ0pQhFWVNNtz20vozU7RaDPIpJGoR+P4X1jJXMgoZjOXmXSnsa3veJdhHBSN+jJGUVPUo3EijlmhC47hrsUIskrFtIzOtqq+pDCKIgfb6ngrYqTD48PJjsbva2E15DWKj4lqj81dfem8JiqsCHl0c7R1QmHZJIMPy41rnc1XJ42YLyytLK51sH0cFZZ/n7HaMYMry/3NaTZnijbTk1WiOdRjHG1FPRrDr8LqxHTOjfrby22eKbiU3mSJ5tGCTE4V9WgIPworhQd5gSYV/EUD24dVzmUoeaLZtGc06aIejeA/YVXnMcbGEE4xxba//2XGJ/BpO9zMICqLejSA34RVj0wGxaxAtZFdtj0cZjSvieaURA/uFfVoAH8JqykvcW8cM+xzEjoJbD8DmSeaVzVGcL2oRwP4Z7rhAhbGFdf/bM6/l+YcVghPPazhPMPtFU43xMU1TOfCOP4ul5EGDj1ZRi92iOZ3JpkG/iEE8cMVK5m72B5nVM8Ze1FyD7nCV61/UMtgq4Uz7zGoxqPkxBnTNwb/6ysxQvj9YTFjDI4PQ2FVyAlMoCDOiHIMR1SDqaLCinCI7qGwJIR1Kv+0EFGm8f3GJ/ORsLR28ftQWE4L62zmWYhnkSOL51rzvbC0fuCCUFhOchnLLESzj+sciuNKtgpL6wtOc7uwvDvd0IW/W1r+8gJzHIrkIwaRK5r7xYyhtqhHG3jxilWZR9hjKZYvHd1jXIlhHBa+aj1DlQSjDm+Fx1CTURy0FMlexzdUVeclYWEdokcoLJOcxFTLs0ejBN6JnsQHwtLaTadQWKZozlzLcXwuVKq/paXBhAn7Ma6XWKGwYnIRX1uOYrdg3akr2CIsrYWc4U5heWlUeD3TOd/ypybxkViEnzCQA5JNwoUxFzWq4Y0rViXuK7M/MF6bTz3R1kxmCIXCV61MqtqKNbwVkspQDtiIYKfC8W1pTBEWVj69QmHZoQ6TbF0FihkmLiuABjYGGInZXm4MhWWV03jTpv+PqaMiLMhgqbC01nFxKCwrnMsCm953cKmSrAAuY5OwtBbR1E3Ccveo8Epm0M7WJyNMEC6YVpb5PMp+UY8X8IzaFbpc3HrFSuLWBGaF3ucE5XZNZpD4+PBZqlmIMJC3wir0Idu2521coiwrgFSeFxZWAX0tFGkKoLDSGUu+bb9F9NfW1E/U411hae2jSyisaDRk+nFVrazYuy5aq9SCJcLS2hD3U2nAhBWtqlW8tjmhF7Pmac9GYWkt5kx9YbltVBi9qlV8FDGOr7STKMNnDEhoQ791zuMZ6mqn7a4r1h9Yl6DPf7uw5E8SA+LeoGbK/hrH+DAgt8IU/syuBD1uNF7fwAzV+KuwsAoYEHN8GAhhVedx8hL294i2gqJSl7eFpZVN11BY9ZhiYDPCLFefnHUmi4WltZH2wRZWUyP/zesrqDnqDn7FemFpLaGFlrD0R4XnM91AUbFCRrNUO5UY/Jf+ZIt6bMs44YWOpdC9YnVktRFfr1NdqwEtkERf8fHh81ELZ/r2VpjMnWwz4ulHz5ymXJVnhYVVyKAom998KiwrVa0qtnzu09aLBeowW1haOdwWHGHVtlDVKpbNiFkl2V00ZZGwtDZzWTCEZa2qVcW2hpbaSrHMxQm/YbBqS8mQFZbGqLA1f7ewuKNi8hnFCoUcEuNL+rFP1GMbxgntB/8JeWF1YEa5F2Z7vM5M8QxM8AZPUCDqsSNPkibpUPZW2MXoIpKVFU4AupuqZArfDgsZUuZC4ptnLOtVrSq2g9yurY6EOJFZwtLazx3+E5b1qlax7CWbW8vdwxlxnqVhzrZwxU++U3jLq8IqKvWI3oBXDNdEX04zbV0Y4EJ+FJbWMs4DUujCbq8KK8KzP60Jas4cw9+cF3NRiFfo5HAHH28/MpVZRh9KxIWVzQjac6cDGwomJ1yB0z304JCwtCTMcQe5DpR9XZZAuTH3UYVx6jLwoLDM2wH+qK0Fw9TmX+qtatj012NZ51Vma4dgmH3040vtIMySREQ7BIss5QY2aAfhABcw03K9GBfjtSvWAUb4UlbwNX3YrR2EObwmrJd5RzsEx/g3wzmkHYQpvCWsxYzlsHYQDjKZ5zz3aBIV9fFD3JbtvZPcLVPL4Eq1cFQYJy86dn6Xe8imH59rB2EC74wKv6ITW7WDEOE8ZsZZL8bFeOWKtY8RAZEVfEMfdmkHkSheEdYU3tMOQZB3eMzr40NvCOsLxlOsHYQoLzLBMw8pUVAfP8S03Vyt3UgKpDNDveV9Pir8Gx9qh6BADgP4TDuIRFDXdgz7lPraTaRGW1apt79dUw+gYtv18xrtYHKtrcP0XGBuvxU+xyfaIagyh6Ec1A7CHurarsA+cUP1X2VSGGl4G4qMqQcQ3bLooN2rrqAm09T7wrK591YYYSKfagfhCvbzKPO1g7COuraj2AduPURbhTasUO8Ra6YeQPm2jV9p96XL6Mh29V6xYO68FRYzgf9qB+Ey3mMIedpBWEFd2+XYHBed3+UeUnjCQ+ND9QCOty1cpN2HLqUGr6r3jmeFVUQf7f5zMQ35WL2HPCqsd1x4fpebOJvl6n3kQWFt4nztnnM9Vxmqju+ouWtUWMRYFmsH4Xo+ZBC52kHERl3bpewtamo3hyeoxHAHaviYNRcFuJ622j3mGarzsnp/VWSHSfj4SVNWyEPaveUpTuYD9T6Lbnm4ZiHZvzxxfpebaMUy9V6LZlnJLqlwso4nvPBA6iqW04tt2kFEYVcyG7VjoOQYy2XaQXiQjxnIAe0gymVTMiu1YwDeZJp2CB5lGk9TpB1EOaxM5lsKlYNYy5Peem/vIop5hqnaQRxHIUuhrfI8bj53a7eDx2nAe+oP62VtG20hnfmqQUyjmnbPeJ4MlqqLqbTNIz2ZHBYoNslqRnq9/IULWEkvtmgHUYoF5AC0N3Q2s3U7WOY0qpBEuF2tF4+1HC4tCakm85RCeMXz53e5h2QGU6guqpIb4c9vfB+iWCGAFd6vW+cqUh0+gTA+K+bBoyGdqrB4LI9btHvCd9Q3fsqadVtOo9Ih9RcP4AUfnd/lHs7if8rC6l82oFOEA/rOT8d7uIr2bFKU1RJOOTagO8gXc5/LTdrt72NuIVtJVofKG+WnCpYmnBLeBh0kiUeVxoczSC0voAxWirhfwunabe9zUvmbgqxWkhEtoE7sc9z9jkCWqpWmHu8Iy2ofnaKHk0R/Chx1n0s37TYPCM1ZLCirAvr/dLB8FKoyxsH6AAUMIUW7xQPDJawVklURY2K/Q6nBRIekVcAT4SscUa5mg4isJlIjnnCqM9qBqYcDDA5lJc5V/OCwrPIZHf82mCr0YrdR99u4h0rarRxILuQrB2W1m15Wp46uM7i5aCGXa7dvgDmd6Q7Na33LdXYCasaL5CbsPJvMsq8lQ8SpTnfWGxZVLi/Zfy1XhU58nsCjfAEf0jG8BbqCc3jF2KueIj6nc6JvT+rSja9szG4d4lNup5Z2e4b8TGWu5HX2JiiqAr6im6mDHerSlVkWqvZuYQY3hKJyIVVpx0RW2Xzm2sEsusYnqqR4/giAKrSgA+05h4ZUL/cAzSIOsIWlzGcBazms3YYhUWnERVzB+ZxOLSrH/OtictnKMj7jU1ZTEJ+L+IVVQmUa0oJWnEUT6pFOVSCfHHawnlV8zxq2uXJnbsjx1KUpLWlJU06mNmnHPAsXk08OO9nAKpazmq3WNjb/PwtMam6w6l9KAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDIyLTA4LTIyVDE3OjM1OjQ4KzAwOjAwUOMNpQAAACV0RVh0ZGF0ZTptb2RpZnkAMjAyMi0wOC0yMlQxNzozNTo0OCswMDowMCG+tRkAAAAASUVORK5CYII=`;
var resolveWalletUrl = (network, walletUrl) => {
  if (walletUrl) {
    return walletUrl;
  }
  switch (network.networkId) {
    case "mainnet":
      return "https://wallet.near.org";
    case "testnet":
      return "https://wallet.testnet.near.org";
    default:
      throw new Error("Invalid wallet url");
  }
};
function setupNearWallet({
  walletUrl,
  iconUrl = icon,
  deprecated = false,
  successUrl = "",
  failureUrl = "",
} = {}) {
  return (options) =>
    __awaiter(this, void 0, void 0, function* () {
      const wallet = yield setupMyNearWallet({
        walletUrl: resolveWalletUrl(options.options.network, walletUrl),
        iconUrl,
        successUrl,
        failureUrl,
      })(options);
      if (!wallet) {
        return null;
      }
      return Object.assign(Object.assign({}, wallet), {
        id: "near-wallet",
        metadata: Object.assign(Object.assign({}, wallet.metadata), {
          name: "NEAR Wallet",
          description: "Web wallet for NEAR Protocol",
          iconUrl,
          deprecated,
          available: true,
        }),
      });
    });
}

const __vite__cjsImport7_buffer = require_buffer();

// 'use' prefix is idiomatic for Pinia stores.
// See https://pinia.vuejs.org/core-concepts/
const useAccounts = defineStore("accounts", {
  state: () => ({
    activeAccount: null,
    activeAccountId: "",
    authenticated: null,
    // isJobless: false,
  }),
  getters: {
    isActive() {
      return;
    },
  },
  actions: {
    setAccountId(accountId) {
      this.$patch({
        activeAccount: { accountId: accountId, active: true },
        activeAccountId: accountId,
      });
    },
    setKeyCloak(data) {
      this.$patch((state) => {
        state.authenticated = data;
      });
    },
    setAccount(acc) {
      this.$patch((state) => {
        state.activeAccount = acc;
        state.activeAccountId = acc.id;
        // state.hasChanged = true;
      });
    },

    deselectAccount() {
      this.$patch({
        activeAccount: null,
        activeAccountId: "",
      });
    },
  },
});

// 'use' prefix is idiomatic for Pinia stores.
// See https://pinia.vuejs.org/core-concepts/
const useWallets = defineStore("wallets", {
  state: () => ({
    selector: null,
    modal: null,
    accounts: [],
  }),
  getters: {
    getSelector() {
      return this.selector;
    },

    getModal() {
      return this.selector;
    },

    getAccounts() {
      return this.selector;
    },
  },
  actions: {
    setSelector(s) {
      this.$patch({ selector: s });
    },

    setModal(m) {
      this.$patch({ modal: m });
    },

    setAccounts(accs) {
      this.$patch({ accounts: accs });
    },
  },
});

const HeaderBarAction_vue_vue_type_style_index_0_scoped_6de8f6e2_lang = "";

const lo = __vite__cjsImport0_lodash.__esModule
  ? __vite__cjsImport0_lodash.default
  : __vite__cjsImport0_lodash;
const Buffer$1 = __vite__cjsImport7_buffer["Buffer"];

window.Buffer = Buffer$1;
window.global = window;

const selector = await setupWalletSelector({
  network: "testnet",
  debug: true,
  modules: [setupMyNearWallet(), setupNearWallet()],
});
const modal = setupModal(selector, {
  contractId: CONTRACT_ID,
});

const state = selector.store.getState();

const ITEMS = [
  { id: "connect_inferix_id", value: "Connect INFERIX ID" },
  { id: "top_up", value: "Top-up" },
  { id: "switch", value: "Switch Wallet" },
  { id: "logout", value: "Logout" },
];

const walletHTML = `<svg
      xmlns="http://www.w3.org/2000/svg"
      width="22"
      height="23"
      viewBox="0 0 22 23"
      fill="none"
    >
      <rect
        x="1"
        y="4.39999"
        width="20"
        height="17.6"
        rx="5"
        stroke="#AFCAFF"
        stroke-width="1.5"
      />
      <path
        d="M18 4.95V4.95C18 2.41367 15.6459 0.533124 13.1723 1.09334L4.89561 2.96776C2.61739 3.48371 1 5.50834 1 7.84427L1 12.1"
        stroke="#AFCAFF"
        stroke-width="1.5"
      />
      <path
        d="M5 17.05H11"
        stroke="#AFCAFF"
        stroke-width="1.5"
        stroke-linecap="round"
        stroke-linejoin="round"
      />
      <path
        d="M14 13.2C14 11.6812 15.2312 10.45 16.75 10.45H21V15.95H16.75C15.2312 15.95 14 14.7188 14 13.2V13.2Z"
        stroke="#AFCAFF"
        stroke-width="1.5"
      />
      <path
        d="M16.5 13.2H16.7"
        stroke="#AFCAFF"
        stroke-width="1.5"
        stroke-linecap="round"
        stroke-linejoin="round"
      />
    </svg>`;

const _sfc_main$1 = {
  name: "header-bar-action",
  components: { Dropdown },

  data: () => ({
    lo: lo,
    account: "",
    items: ITEMS,
    selectedItem: {},
    selector: null,
    modal: null,
    accounts: useAccounts(),
    wallets: useWallets(),
    isShowLogout: false,
    displaySize: {
      width: 0,
      height: 0,
    },
    walletHtml: walletHTML,
    userName: null,
  }),

  mounted() {
    if (lo.size(state.accounts) > 0)
      this.accounts.setAccount(lo.get(state, "accounts.0"));
    this.selector = selector;
    this.modal = modal;
    this.wallets.setSelector(selector);
    this.wallets.setModal(modal);
    this.wallets.setAccounts(state.accounts);
    this.resize();
    window.addEventListener("resize", this.resize);
  },

  unmounted() {
    window.removeEventListener("resize", this.resize);
  },

  methods: {
    resize() {
      let app = document.getElementById("app");
      this.displaySize = {
        width: app.offsetWidth,
        height: app.offsetHeight,
      };
    },

    chooseItem(item) {
      if (item.id == "switch") return this.modal.show();
      if (item.id == "logout") return this.handleSignOut();
      if (item.id == "connect_inferix_id") {
        this.$router.push({ path: "/connect-inferix" });
        this.emitter.emit("changeHeader", true);
        return;
      }
      if (item.id == "top_up") {
        this.$router.push({ path: "/top-up" });
        this.emitter.emit("changeHeader", true);
        return;
      }
    },
    onLogout() {
      localStorage.removeItem("authenticated");
      localStorage.removeItem("user-token");
      localStorage.removeItem("vue-refresh-token");
      this.userName = null;
      return;
    },
    onLogin() {
      return;
    },
    handleSignOut() {
      console.log("Signout!");
      return;
    },

    connectWallet() {
      this.modal.show();
    },
  },
};

const _withScopeId = (n) => (
  pushScopeId("data-v-6de8f6e2"), (n = n()), popScopeId(), n
);
const _hoisted_1$1 = { class: "action-item" };
const _hoisted_2$1 = {
  key: 0,
  class: "svg-icon",
  style: { height: "2em" },
  viewBox: "0 0 1024 1024",
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
};
const _hoisted_3$1 = /*#__PURE__*/ _withScopeId(() =>
  /*#__PURE__*/ createBaseVNode(
    "path",
    {
      d: "M512 625.778c-159.289 0-284.444-125.156-284.444-284.445S352.71 56.89 512 56.89s284.444 125.155 284.444 284.444S671.29 625.778 512 625.778z m0-56.89c125.156 0 227.556-102.4 227.556-227.555S637.156 113.778 512 113.778s-227.556 102.4-227.556 227.555S386.844 568.89 512 568.89z",
      fill: "#73777A",
    },
    null,
    -1
  )
);
const _hoisted_4$1 = /*#__PURE__*/ _withScopeId(() =>
  /*#__PURE__*/ createBaseVNode(
    "path",
    {
      d: "M56.889 1024c0-250.311 204.8-455.111 455.111-455.111S967.111 773.689 967.111 1024h-56.889c0-221.867-176.355-398.222-398.222-398.222S113.778 802.133 113.778 1024h-56.89z",
      fill: "#73777A",
    },
    null,
    -1
  )
);
const _hoisted_5$1 = [_hoisted_3$1, _hoisted_4$1];
const _hoisted_6$1 = {
  key: 1,
  xmlns: "http://www.w3.org/2000/svg",
  width: "23",
  height: "25",
  viewBox: "0 0 23 25",
  fill: "none",
};
const _hoisted_7$1 = /*#__PURE__*/ _withScopeId(() =>
  /*#__PURE__*/ createBaseVNode(
    "path",
    {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M12.5017 9.31818C12.5017 8.76589 12.054 8.31818 11.5017 8.31818C10.9494 8.31818 10.5017 8.76589 10.5017 9.31818V11.4563H8.36363C7.81135 11.4563 7.36363 11.904 7.36363 12.4563C7.36363 13.0086 7.81135 13.4563 8.36363 13.4563H10.5017V15.5944C10.5017 16.1467 10.9494 16.5944 11.5017 16.5944C12.054 16.5944 12.5017 16.1467 12.5017 15.5944V13.4563H14.6399C15.1921 13.4563 15.6399 13.0086 15.6399 12.4563C15.6399 11.904 15.1921 11.4563 14.6399 11.4563H12.5017V9.31818Z",
      fill: "#AFCAFF",
    },
    null,
    -1
  )
);
const _hoisted_8$1 = /*#__PURE__*/ _withScopeId(() =>
  /*#__PURE__*/ createBaseVNode(
    "rect",
    {
      x: "1",
      y: "1.95454",
      width: "21",
      height: "21",
      rx: "10.5",
      stroke: "#AFCAFF",
      "stroke-width": "2",
    },
    null,
    -1
  )
);
const _hoisted_9$1 = [_hoisted_7$1, _hoisted_8$1];
const _hoisted_10$1 = /*#__PURE__*/ _withScopeId(() =>
  /*#__PURE__*/ createBaseVNode(
    "div",
    { class: "action-item-text" },
    [
      /*#__PURE__*/ createBaseVNode(
        "a",
        { href: "https://h3d.me/ifxworkerwin" },
        "Node Register"
      ),
    ],
    -1
  )
);
const _hoisted_11$1 = /*#__PURE__*/ createStaticVNode(
  '<div class="lst-menu-child" data-v-6de8f6e2><div class="item-menu-child" data-v-6de8f6e2><svg class="svg-icon" style="width:1em;height:1em;vertical-align:middle;fill:currentColor;overflow:hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" data-v-6de8f6e2><path d="M173 873.3c-11 0-20-9-20-20V173.9c0-11 9-20 20-20h320.7c11 0 20-9 20-20v-15c0-11-9-20-20-20H153h-35c-11 0-20 9-20 20v809.3h395.7c11 0 20-9 20-20v-15c0-11-9-20-20-20H173z" fill="#2680F0" data-v-6de8f6e2></path><path d="M609.3 273.3c-7.8-7.8-7.8-20.5 0-28.3l10.6-10.6c7.8-7.8 20.5-7.8 28.3 0l264.9 264.9c7.8 7.8 7.8 20.5 0 28.3L648.4 792.8c-7.8 7.8-20.5 7.8-28.3 0l-10.6-10.6c-7.8-7.8-7.8-20.5 0-28.3l199-199c7.8-7.8 5.1-14.1-5.9-14.1H326.1c-11 0-20-9-20-20v-15c0-11 9-20 20-20h475.7c11 0 13.6-6.4 5.9-14.1L609.3 273.3z" fill="#2680F0" data-v-6de8f6e2></path></svg><span class="action-item-text" data-v-6de8f6e2>Logout</span></div></div>',
  1
);
const _hoisted_12$1 = [_hoisted_11$1];

function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
  return (
    openBlock(),
    createElementBlock(
      Fragment,
      null,
      [
        createBaseVNode("button", _hoisted_1$1, [
          _ctx.userName
            ? (openBlock(),
              createElementBlock("svg", _hoisted_2$1, _hoisted_5$1))
            : (openBlock(),
              createElementBlock("svg", _hoisted_6$1, _hoisted_9$1)),
          _hoisted_10$1,
        ]),
        createBaseVNode(
          "div",
          {
            class: normalizeClass([
              "box-menu-lv-child",
              { active: _ctx.isShowLogout },
            ]),
            onClick:
              _cache[0] ||
              (_cache[0] = (...args) =>
                $options.onLogout && $options.onLogout(...args)),
          },
          _hoisted_12$1,
          2
        ),
      ],
      64
    )
  );
}
const HeaderBarAction = /*#__PURE__*/ _export_sfc(_sfc_main$1, [
  ["render", _sfc_render$1],
  ["__scopeId", "data-v-6de8f6e2"],
]);

const styles = "";

const _imports_0 = "/assets/Inferix_explorer_logo-2664fe68.png";

const App_vue_vue_type_style_index_0_lang = "";

__vite__cjsImport0_lodash.__esModule
  ? __vite__cjsImport0_lodash.default
  : __vite__cjsImport0_lodash;

const DEFAULT_FLAMENCO_NAME = "Inferix.io";
const DEFAULT_FLAMENCO_VERSION = "unknown";
const TITLE = "Inferix Explorer";

const _sfc_main = {
  name: "App",
  components: {
    ApiSpinner,
    HeaderBarAction,
  },
  data: () => ({
    flamencoName: DEFAULT_FLAMENCO_NAME,
    flamencoVersion: DEFAULT_FLAMENCO_VERSION,
    backendURL: backendURL,
    isOpenMenu: false,
    headerIsChanged: false,
  }),
  mounted() {
    window.app = this;
    this.fetchManagerInfo();

    const sockStatus = useSocketStatus();
    this.$watch(
      () => sockStatus.isConnected,
      (isConnected) => {
        if (!isConnected) return;
        if (!sockStatus.wasEverDisconnected) return;
        this.socketIOReconnect();
      }
    );

    if (
      window.location.pathname == "/connect-inferix" ||
      window.location.pathname == "/top-up"
    )
      this.headerIsChanged = true;
    this.emitter.on("changeHeader", this.changeHeader);
  },

  beforeDestroy() {
    this.emitter.off("changeHeader", this.changeHeader);
  },
  methods: {
    linkToHome() {
      this.$router.push({ path: "workers" });
      this.headerIsChanged = false;
    },

    changeHeader(e) {
      this.headerIsChanged = e;
    },

    fetchManagerInfo() {
      const metaAPI = new MetaApi(getAPIClient());
      metaAPI.getVersion().then((version) => {
        this.flamencoName = version.name;
        this.flamencoVersion = version.version;
        document.title = TITLE;
      });
    },
    openMobileMenu() {
      this.isOpenMenu = true;
    },
    closeMobileMenu() {
      this.isOpenMenu = false;
    },
    buildLink(url) {
      this.$router.push(`/${url}`);
      this.closeMobileMenu();
    },
    socketIOReconnect() {
      const metaAPI = new MetaApi(getAPIClient());
      metaAPI.getVersion().then((version) => {
        if (
          version.name === this.flamencoName &&
          version.version == this.flamencoVersion
        )
          return;
        console.log(
          `Updated from ${this.flamencoVersion} to ${version.version}`
        );
        location.reload();
      });
    },
  },
};

const _hoisted_1 = { class: "app-header" };
const _hoisted_2 = /*#__PURE__*/ createBaseVNode(
  "img",
  {
    class: "h-[35px] max-sm:h-[30px]",
    src: _imports_0,
  },
  null,
  -1
);
const _hoisted_3 = { class: "flex basis-1/2 w-full" };
const _hoisted_4 = {
  key: 0,
  class: "w-full",
};
const _hoisted_5 = { class: "li-header-bar" };
const _hoisted_6 = /*#__PURE__*/ createBaseVNode(
  "div",
  { class: "border-active" },
  null,
  -1
);
const _hoisted_7 = /*#__PURE__*/ createBaseVNode(
  "div",
  { class: "header-item-content" },
  [/*#__PURE__*/ createBaseVNode("span", null, "MAP")],
  -1
);
const _hoisted_8 = { class: "li-header-bar" };
const _hoisted_9 = /*#__PURE__*/ createBaseVNode(
  "div",
  { class: "border-active" },
  null,
  -1
);
const _hoisted_10 = /*#__PURE__*/ createBaseVNode(
  "div",
  { class: "header-item-content" },
  [/*#__PURE__*/ createBaseVNode("span", null, "RUNNING JOBS")],
  -1
);
const _hoisted_11 = { class: "li-header-bar" };
const _hoisted_12 = /*#__PURE__*/ createBaseVNode(
  "div",
  { class: "border-active" },
  null,
  -1
);
const _hoisted_13 = /*#__PURE__*/ createBaseVNode(
  "div",
  { class: "header-item-content" },
  [/*#__PURE__*/ createBaseVNode("span", null, "LAST RENDERED")],
  -1
);
const _hoisted_14 = { key: 1 };
const _hoisted_15 = /*#__PURE__*/ createBaseVNode(
  "div",
  { class: "border-active" },
  null,
  -1
);
const _hoisted_16 = /*#__PURE__*/ createBaseVNode(
  "div",
  { class: "header-item-content" },
  [/*#__PURE__*/ createBaseVNode("span", null, "HOME")],
  -1
);
const _hoisted_17 = [_hoisted_15, _hoisted_16];
const _hoisted_18 = /*#__PURE__*/ createBaseVNode(
  "div",
  { class: "border-active" },
  null,
  -1
);
const _hoisted_19 = /*#__PURE__*/ createBaseVNode(
  "div",
  { class: "header-item-content" },
  [/*#__PURE__*/ createBaseVNode("span", null, "CONNECT INFERIX ID")],
  -1
);
const _hoisted_20 = /*#__PURE__*/ createBaseVNode(
  "div",
  { class: "border-active" },
  null,
  -1
);
const _hoisted_21 = /*#__PURE__*/ createBaseVNode(
  "div",
  { class: "header-item-content" },
  [/*#__PURE__*/ createBaseVNode("span", null, "TOP-UP")],
  -1
);
const _hoisted_22 = /*#__PURE__*/ createStaticVNode(
  '<span class="icon"><svg width="22" height="16" viewBox="0 0 22 16" fill="none" xmlns="http://www.w3.org/2000/svg"><rect width="22" height="2" rx="1" transform="matrix(1 0 0 -1 0 16)" fill="#414B5B"></rect><rect width="17" height="2" rx="1" transform="matrix(1 0 0 -1 5 9)" fill="#414B5B"></rect><rect width="13" height="2" rx="1" transform="matrix(1 0 0 -1 9 2)" fill="#414B5B"></rect></svg></span>',
  1
);
const _hoisted_23 = [_hoisted_22];
const _hoisted_24 = { class: "box-filter-admiss-mobile" };
const _hoisted_25 = { class: "layout-sidebar-filter-page" };
const _hoisted_26 = { class: "ct-block-filter block-filter-detail" };
const _hoisted_27 = { class: "lst-imt-filter-otp" };
const _hoisted_28 = /*#__PURE__*/ createBaseVNode(
  "div",
  { class: "title-item-filter" },
  [/*#__PURE__*/ createBaseVNode("h2", { class: "name-title" }, "MAP")],
  -1
);
const _hoisted_29 = [_hoisted_28];
const _hoisted_30 = /*#__PURE__*/ createBaseVNode(
  "div",
  { class: "title-item-filter" },
  [
    /*#__PURE__*/ createBaseVNode(
      "h2",
      { class: "name-title" },
      "RUNNING JOBS"
    ),
  ],
  -1
);
const _hoisted_31 = [_hoisted_30];
const _hoisted_32 = /*#__PURE__*/ createBaseVNode(
  "div",
  { class: "title-item-filter" },
  [
    /*#__PURE__*/ createBaseVNode(
      "h2",
      { class: "name-title" },
      "LAST RENDERED"
    ),
  ],
  -1
);
const _hoisted_33 = [_hoisted_32];
const _hoisted_34 = /*#__PURE__*/ createStaticVNode(
  '<svg width="16" height="17" viewBox="0 0 16 17" fill="none" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#clip0_100_26701)"><path d="M15.521 14.0628L9.95879 8.48931L15.4909 2.94624C15.942 2.49395 15.942 1.76079 15.4909 1.30875C15.0395 0.856718 14.308 0.856718 13.8566 1.30875L8.32456 6.85182L2.79273 1.30875C2.34135 0.856718 1.60989 0.856718 1.1585 1.30875C0.707116 1.76104 0.707116 2.4942 1.1585 2.94624L6.69032 8.48931L1.1276 14.0628C0.676216 14.5151 0.676216 15.248 1.1276 15.7003C1.35329 15.9265 1.64894 16.0394 1.94484 16.0394C2.24074 16.0394 2.53639 15.9265 2.76208 15.7003L8.32456 10.1268L13.8868 15.7003C14.1125 15.9265 14.4081 16.0394 14.704 16.0394C14.9999 16.0394 15.2956 15.9265 15.5213 15.7003C15.9722 15.2483 15.9722 14.5151 15.521 14.0628Z" fill="#868E96"></path></g><defs><clipPath id="clip0_100_26701"><rect width="15.07" height="15.07" fill="white" transform="translate(0.789062 0.969727)"></rect></clipPath></defs></svg>',
  1
);
const _hoisted_35 = [_hoisted_34];
const _hoisted_36 = /*#__PURE__*/ createBaseVNode(
  "div",
  { style: { flex: "1" } },
  null,
  -1
);

function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_router_link = resolveComponent("router-link");
  const _component_HeaderBarAction = resolveComponent("HeaderBarAction");
  const _component_api_spinner = resolveComponent("api-spinner");
  const _component_router_view = resolveComponent("router-view");

  return (
    openBlock(),
    createElementBlock(
      Fragment,
      null,
      [
        createBaseVNode("header", _hoisted_1, [
          createVNode(
            _component_router_link,
            {
              to: { name: "index" },
              class: "navbar-brand",
            },
            {
              default: withCtx(() => [_hoisted_2]),
              _: 1,
            }
          ),
          createBaseVNode("nav", _hoisted_3, [
            !_ctx.headerIsChanged
              ? (openBlock(),
                createElementBlock("ul", _hoisted_4, [
                  createBaseVNode("li", _hoisted_5, [
                    createVNode(
                      _component_router_link,
                      { to: { name: "workers" } },
                      {
                        default: withCtx(() => [_hoisted_6, _hoisted_7]),
                        _: 1,
                      }
                    ),
                  ]),
                  createBaseVNode("li", _hoisted_8, [
                    createVNode(
                      _component_router_link,
                      { to: { name: "jobs" } },
                      {
                        default: withCtx(() => [_hoisted_9, _hoisted_10]),
                        _: 1,
                      }
                    ),
                  ]),
                  createBaseVNode("li", _hoisted_11, [
                    createVNode(
                      _component_router_link,
                      { to: { name: "last-rendered" } },
                      {
                        default: withCtx(() => [_hoisted_12, _hoisted_13]),
                        _: 1,
                      }
                    ),
                  ]),
                ]))
              : (openBlock(),
                createElementBlock("ul", _hoisted_14, [
                  createBaseVNode("li", null, [
                    createBaseVNode(
                      "div",
                      {
                        onClick:
                          _cache[0] ||
                          (_cache[0] = (...args) =>
                            $options.linkToHome &&
                            $options.linkToHome(...args)),
                      },
                      _hoisted_17
                    ),
                  ]),
                  createBaseVNode("li", null, [
                    createVNode(
                      _component_router_link,
                      { to: { name: "connect-inferix-id" } },
                      {
                        default: withCtx(() => [_hoisted_18, _hoisted_19]),
                        _: 1,
                      }
                    ),
                  ]),
                  createBaseVNode("li", null, [
                    createVNode(
                      _component_router_link,
                      { to: { name: "top-up" } },
                      {
                        default: withCtx(() => [_hoisted_20, _hoisted_21]),
                        _: 1,
                      }
                    ),
                  ]),
                ])),
          ]),
          createBaseVNode(
            "div",
            {
              class: normalizeClass([
                "bg-menu-filter",
                {
                  active: _ctx.isOpenMenu,
                },
              ]),
              onClick:
                _cache[1] ||
                (_cache[1] = (...args) =>
                  $options.closeMobileMenu &&
                  $options.closeMobileMenu(...args)),
            },
            null,
            2
          ),
          createBaseVNode(
            "div",
            {
              class: "btn-menu-mb",
              onClick:
                _cache[2] ||
                (_cache[2] = (...args) =>
                  $options.openMobileMenu && $options.openMobileMenu(...args)),
            },
            _hoisted_23
          ),
          createBaseVNode("div", _hoisted_24, [
            createBaseVNode(
              "div",
              {
                class: normalizeClass([
                  "sidebar-filter-page",
                  {
                    "open-sidebar-filter": _ctx.isOpenMenu === true,
                  },
                ]),
              },
              [
                createBaseVNode("div", _hoisted_25, [
                  createBaseVNode("div", _hoisted_26, [
                    createBaseVNode("div", _hoisted_27, [
                      createBaseVNode(
                        "div",
                        {
                          class: "item-filter",
                          onClick:
                            _cache[3] ||
                            (_cache[3] = ($event) =>
                              $options.buildLink("workers")),
                        },
                        _hoisted_29
                      ),
                      createBaseVNode(
                        "div",
                        {
                          class: "item-filter",
                          onClick:
                            _cache[4] ||
                            (_cache[4] = ($event) =>
                              $options.buildLink("jobs")),
                        },
                        _hoisted_31
                      ),
                      createBaseVNode(
                        "div",
                        {
                          class: "item-filter",
                          onClick:
                            _cache[5] ||
                            (_cache[5] = ($event) =>
                              $options.buildLink("last-rendered")),
                        },
                        _hoisted_33
                      ),
                      createVNode(_component_HeaderBarAction),
                    ]),
                  ]),
                ]),
                _ctx.isOpenMenu
                  ? (openBlock(),
                    createElementBlock(
                      "div",
                      {
                        key: 0,
                        class: "close-box-fillter",
                        onClick:
                          _cache[6] ||
                          (_cache[6] = (...args) =>
                            $options.closeMobileMenu &&
                            $options.closeMobileMenu(...args)),
                      },
                      _hoisted_35
                    ))
                  : createCommentVNode("", true),
              ],
              2
            ),
          ]),
          createBaseVNode("nav", null, [
            _hoisted_36,
            createVNode(_component_api_spinner),
            createVNode(_component_HeaderBarAction),
          ]),
        ]),
        createVNode(_component_router_view, null, {
          default: withCtx(({ Component }) => [
            (openBlock(),
            createBlock(
              KeepAlive,
              { include: "WorkersView" },
              [
                (openBlock(),
                createBlock(
                  resolveDynamicComponent(Component),
                  { isOpenMenu: _ctx.isOpenMenu },
                  null,
                  8,
                  ["isOpenMenu"]
                )),
              ],
              1024
            )),
          ]),
          _: 1,
        }),
      ],
      64
    )
  );
}
const App = /*#__PURE__*/ _export_sfc(_sfc_main, [["render", _sfc_render]]);

const ToastPlugin = __vite__cjsImport10_vueToastNotification.__esModule
  ? __vite__cjsImport10_vueToastNotification.default
  : __vite__cjsImport10_vueToastNotification;
// Ensure Tabulator can find `luxon`, which it needs for sorting by
// date/time/datetime.
window.DateTime = DateTime;
// plain removes any Vue reactivity.
window.plain = (x) => JSON.parse(JSON.stringify(x));
// objectEmpty returns whether the object is empty or not.
window.objectEmpty = (o) => !o || Object.entries(o).length == 0;

// Automatically reload the window after a period of inactivity from the user.
autoreload();

const pinia = createPinia();

function normalMode() {
  const app = createApp(App);
  const emitter = mitt_default();
  app.use(pinia);
  app.use(router$1);
  app.use(ToastPlugin);
  app.use(module_default);
  app.use(vue_tippy_esm_browser_default);
  app.config.globalProperties.emitter = emitter;
  app.mount("#app");

  let instance = app.$toast.open("You did it!");
  instance.dismiss();
  app.$toast.clear();
}

function setupAssistantMode() {
  console.log("Flamenco Setup Assistant is starting");
  const app = createApp(SetupAssistant);
  app.use(pinia);
  app.use(router);
  app.use(module_default);
  app.use(vue_tippy_esm_browser_default);
  app.mount("#app");
}

/* This cannot use the client from '@/stores/api-query-count', as that would
 * require Pinia, which is unavailable until the app is actually started. And to
 * know which app to start, this API call needs to return data. */
const apiClient = newBareAPIClient();
const metaAPI = new MetaApi(apiClient);
metaAPI
  .getConfiguration()
  .then((config) => {
    if (config.isFirstRun) setupAssistantMode();
    else normalMode();
  })
  .catch((error) => {
    console.warn("Error getting Manager configuration:", error);
  });

export {
  WorkerTag as $,
  ApiSpinner as A,
  useAPIQueryCount as B,
  renderList as C,
  createStaticVNode as D,
  resolveComponent as E,
  Fragment as F,
  computed2 as G,
  withCtx as H,
  defineComponent as I,
  JobStatusChange as J,
  reactive as K,
  AvailableJobSettingVisibility as L,
  vShow as M,
  WorkerTagChangeRequest as N,
  vModelSelect as O,
  withModifiers as P,
  WorkerStatusChangeRequest as Q,
  DEFAULT_TASK_LOG as R,
  __commonJS as S,
  TaskStatusChange as T,
  DATA_NODE as U,
  MAP_BOX_STYLE as V,
  WorkerSleepSchedule as W,
  MAP_BOX_ACCESS_TOKEN as X,
  ApiClient as Y,
  Error$1 as Z,
  _export_sfc as _,
  openBlock as a,
  Worker as a0,
  WorkerTagList as a1,
  WorkerList as a2,
  __require as a3,
  DateTime as a4,
  JobDeletionInfo as a5,
  JobLastRenderedImageInfo as a6,
  Job as a7,
  JobBlocklistEntry as a8,
  JobTasksSummary as a9,
  Task as aa,
  TaskLogInfo as ab,
  AvailableJobType as ac,
  AvailableJobTypes as ad,
  JobsQueryResult as ae,
  useWallets as af,
  LOCAL_HOST_URL as ag,
  require_browser_index2 as ah,
  renderSlot as ai,
  MetaApi as aj,
  PathCheckInput as ak,
  SetupAssistantConfig as al,
  useCssVars as am,
  withKeys as an,
  vModelRadio as ao,
  useSocketStatus as ap,
  require_component_emitter as aq,
  SocketIOJobUpdate as ar,
  SocketIOLastRenderedUpdate as as,
  SocketIOTaskUpdate as at,
  SocketIOTaskLogUpdate as au,
  SocketIOWorkerUpdate as av,
  SocketIOSubscription as aw,
  ws as ax,
  onUnmounted$1 as b,
  createElementBlock as c,
  defineStore as d,
  createBaseVNode as e,
  createVNode as f,
  getAPIClient as g,
  createBlock as h,
  resolveDynamicComponent as i,
  unref as j,
  backendURL as k,
  api as l,
  popScopeId as m,
  normalizeClass as n,
  onMounted$1 as o,
  pushScopeId as p,
  createCommentVNode as q,
  ref as r,
  withDirectives as s,
  toDisplayString as t,
  useNotifs as u,
  vModelText as v,
  watch as w,
  resolveDirective as x,
  createTextVNode as y,
  __vite__cjsImport0_lodash as z,
};
